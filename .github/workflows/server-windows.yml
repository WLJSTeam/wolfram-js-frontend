name: Run server on Windows
on: workflow_dispatch

jobs:
  server-linux-x86:
    runs-on: ubuntu-latest
    container:
      image: wolframresearch/wolframengine:14.2
      options: --user root
    env:
      WOLFRAM_SYSTEM_ID: Linux-x86-64-v8
      WOLFRAMINIT: "-pwfile !cloudlm.wolfram.com -entitlement ${{ secrets.WOLFRAM_LICENSE_ENTITLEMENT_ID }}"
    timeout-minutes: 20
    steps:
      - name: Install tools in container
        run: |
          set -eux
          apt-get update -y
          apt-get install -y curl ca-certificates libuv1-dev

      - name: Check out repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_TOKEN }}

      - name: Download cloudflared (for public tunnel)
        env:
          CF_BIN: '${{ runner.temp }}/cloudflared'
        run: |
          set -eux
          curl -L "https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64" -o "${CF_BIN}"
          chmod +x "${CF_BIN}"
          echo "cloudflared at ${CF_BIN}"

      - name: Install nginx
        shell: bash
        run: |
          set -eux
          apt-get update -y
          apt-get install -y nginx

      - name: Configure nginx (proxy 3000 â†’ 4000, 4001, 4002)
        shell: bash
        run: |
          set -eux
    
      
          # common proxy settings (incl. websockets)
          cat >/etc/nginx/snippets/proxy.conf <<'EOF'
          # /etc/nginx/snippets/proxy.conf
          proxy_set_header Host $host;
          proxy_set_header X-Real-IP $remote_addr;
          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
          proxy_set_header X-Forwarded-Proto $scheme;
          
          proxy_http_version 1.1;
          
          # WebSocket upgrade
          map $http_upgrade $connection_upgrade {
            default upgrade;
            ''      close;
          }
          proxy_set_header Upgrade $http_upgrade;
          proxy_set_header Connection $connection_upgrade;
          
          # Forward WS-specific headers explicitly (some clients/frameworks are picky)
          proxy_set_header Sec-WebSocket-Version $http_sec_websocket_version;
          proxy_set_header Sec-WebSocket-Key $http_sec_websocket_key;
          proxy_set_header Sec-WebSocket-Protocol $http_sec_websocket_protocol;
          proxy_set_header Sec-WebSocket-Extensions $http_sec_websocket_extensions;
          proxy_set_header Origin $http_origin;
          
          # Timeouts + buffering
          proxy_read_timeout 3600s;
          proxy_send_timeout 3600s;
          proxy_connect_timeout 30s;
          proxy_buffering off;


          EOF
      
          # main server (listens on 3000)
          cat >/etc/nginx/sites-available/app.conf <<'EOF'
          server {
            listen 3000;

            location / {
              include snippets/proxy.conf;

              proxy_pass http://127.0.0.1:4000;
            }

            location /ws {
              include snippets/proxy.conf;

              proxy_pass http://127.0.0.1:4001;
            }

            location /ws2 {
              include snippets/proxy.conf;

              proxy_pass http://127.0.0.1:4002;
            }

          }
          EOF
      
          rm -f /etc/nginx/sites-enabled/default
          ln -sf /etc/nginx/sites-available/app.conf /etc/nginx/sites-enabled/app.conf
          nginx -t



      - name: Run server, expose 3000 via tunnel, and stream logs
        shell: bash
        env:
          CF_BIN: '${{ runner.temp }}/cloudflared'
        run: |
          set -eux
      
          # Start nginx in the background (no systemd in container)
          nginx
      
          # Versions (optional)
          wolframscript -version || true
          wolfram -version || true
      
          LOG_DIR="${RUNNER_TEMP}"
          LOG_OUT="${LOG_DIR}/cloudflared-3000.out.log"
          LOG_ERR="${LOG_DIR}/cloudflared-3000.err.log"
      
          # Tunnel to nginx (port 3000)
          nohup "${CF_BIN}" tunnel --url http://127.0.0.1:3000 >"${LOG_OUT}" 2>"${LOG_ERR}" &
          CF_PID=$!
      
          echo "==== Waiting for tunnel URLs... ===="
          sleep 4
          (tail -n +1 -F "${LOG_OUT}" & echo $! > "${LOG_DIR}/tail1.pid") &
          (tail -n +1 -F "${LOG_ERR}" & echo $! > "${LOG_DIR}/tail2.pid") &
      
          echo "==== Starting Wolfram server ===="
          # Your command (http on 4000, websockets on 4001 (/ws) and 4002 (/ws2)):
          wolframscript -f ./Scripts/start.wls host 0.0.0.0 http 4000 ws 4001 ws2 4002 wsprefix ws ws2prefix ws2 || EXIT_CODE=$? || true
          EXIT_CODE=${EXIT_CODE:-0}
          echo "==== Wolfram server exited with code ${EXIT_CODE} ===="
      
          # Cleanup
          kill "${CF_PID}" || true
          if [ -f "${LOG_DIR}/tail1.pid" ]; then kill "$(cat "${LOG_DIR}/tail1.pid")" || true; fi
          if [ -f "${LOG_DIR}/tail2.pid" ]; then kill "$(cat "${LOG_DIR}/tail2.pid")" || true; fi
      
          # Stop nginx gracefully
          nginx -s quit || true
      
          if [ "${EXIT_CODE}" -ne 0 ]; then
            echo "Wolfram server process exited with non-zero code: ${EXIT_CODE}" >&2
            exit "${EXIT_CODE}"
          fi
