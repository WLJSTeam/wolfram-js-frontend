name: Run server on Windows
on: workflow_dispatch

jobs:
  server-linux-x86:
    runs-on: ubuntu-latest
    container:
      image: wolframresearch/wolframengine:14.2
      options: --user root
    env:
      WOLFRAM_SYSTEM_ID: Linux-x86-64-v8
      WOLFRAMINIT: "-pwfile !cloudlm.wolfram.com -entitlement ${{ secrets.WOLFRAM_LICENSE_ENTITLEMENT_ID }}"
    timeout-minutes: 20
    steps:
      - name: Install tools in container
        run: |
          set -eux
          apt-get update -y
          apt-get install -y curl ca-certificates libuv1-dev

      - name: Check out repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_TOKEN }}

      - name: Download cloudflared (for public tunnel)
        env:
          CF_BIN: '${{ runner.temp }}/cloudflared'
        run: |
          set -eux
          curl -L "https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64" -o "${CF_BIN}"
          chmod +x "${CF_BIN}"
          echo "cloudflared at ${CF_BIN}"

      - name: Install nginx
        shell: bash
        run: |
          set -eux
          apt-get update -y
          apt-get install -y nginx

      - name: Configure nginx (proxy 3000 â†’ 4000, 4001, 4002)
        shell: bash
        run: |
          set -eux
      
          # global bits: logs + websocket upgrade helper
          cat >/etc/nginx/nginx.conf <<'EOF'
          user www-data;
          worker_processes auto;
          pid /run/nginx.pid;
          include /etc/nginx/modules-enabled/*.conf;
      
          events { worker_connections 1024; }
      
          http {
            sendfile on;
            tcp_nopush on;
            tcp_nodelay on;
            keepalive_timeout 65;
            types_hash_max_size 2048;
      
            include       /etc/nginx/mime.types;
            default_type  application/octet-stream;
      
            map $http_upgrade $connection_upgrade {
              default upgrade;
              ''      close;
            }
      
            log_format main '$remote_addr - $host [$time_local] '
                            '"$request" $status $body_bytes_sent '
                            '"$http_referer" "$http_user_agent" '
                            'upstream=$upstream_addr rt=$request_time urt=$upstream_response_time';
            access_log /var/log/nginx/access.log main;
            error_log  /var/log/nginx/error.log warn;
      
            gzip on;
            include /etc/nginx/sites-enabled/*;
          }
          EOF
      
          # common proxy settings (incl. websockets)
          cat >/etc/nginx/snippets/proxy.conf <<'EOF'
          ## Headers
          proxy_set_header Host $host;
          proxy_set_header X-Original-URL $scheme://$http_host$request_uri;
          proxy_set_header X-Forwarded-Proto $scheme;
          proxy_set_header X-Forwarded-Host $http_host;
          proxy_set_header X-Forwarded-Uri $request_uri;
          proxy_set_header X-Forwarded-Ssl on;
          proxy_set_header X-Forwarded-For $remote_addr;
          proxy_set_header X-Real-IP $remote_addr;
          
          # Custom; support wss
          proxy_set_header Upgrade $http_upgrade;
          proxy_set_header Connection "keep-alive, upgrade";
          
          # Proxy Configuration
          client_body_buffer_size 128k;
          proxy_next_upstream error timeout invalid_header http_500 http_502 http_503;
          proxy_redirect  http://  $scheme://;
          proxy_http_version 1.1;
          proxy_cache_bypass $cookie_session;
          proxy_no_cache $cookie_session;
          proxy_buffers 64 256k;
          
          send_timeout 5m;
          proxy_read_timeout 360;
          proxy_send_timeout 360;
          proxy_connect_timeout 360;

          EOF
      
          # main server (listens on 3000)
          cat >/etc/nginx/sites-available/app.conf <<'EOF'
          server {
            listen 3000;

            location / {
              include snippets/proxy.conf;

              proxy_pass http://127.0.0.1:4000;
            }

            location /ws {
              include snippets/proxy.conf;

              proxy_pass http://127.0.0.1:4001/;
            }

            location /ws2 {
              include snippets/proxy.conf;

              proxy_pass http://127.0.0.1:4002/;
            }

          }
          EOF
      
          rm -f /etc/nginx/sites-enabled/default
          ln -sf /etc/nginx/sites-available/app.conf /etc/nginx/sites-enabled/app.conf
          nginx -t



      - name: Run server, expose 3000 via tunnel, and stream logs
        shell: bash
        env:
          CF_BIN: '${{ runner.temp }}/cloudflared'
        run: |
          set -eux
      
          # Start nginx in the background (no systemd in container)
          nginx
      
          # Versions (optional)
          wolframscript -version || true
          wolfram -version || true
      
          LOG_DIR="${RUNNER_TEMP}"
          LOG_OUT="${LOG_DIR}/cloudflared-3000.out.log"
          LOG_ERR="${LOG_DIR}/cloudflared-3000.err.log"
      
          # Tunnel to nginx (port 3000)
          nohup "${CF_BIN}" tunnel --url http://127.0.0.1:3000 >"${LOG_OUT}" 2>"${LOG_ERR}" &
          CF_PID=$!
      
          echo "==== Waiting for tunnel URLs... ===="
          sleep 4
          (tail -n +1 -F "${LOG_OUT}" & echo $! > "${LOG_DIR}/tail1.pid") &
          (tail -n +1 -F "${LOG_ERR}" & echo $! > "${LOG_DIR}/tail2.pid") &
      
          echo "==== Starting Wolfram server ===="
          # Your command (http on 4000, websockets on 4001 (/ws) and 4002 (/ws2)):
          wolframscript -f ./Scripts/start.wls host 0.0.0.0 http 4000 ws 4001 ws2 4002 wsprefix ws ws2prefix ws2 || EXIT_CODE=$? || true
          EXIT_CODE=${EXIT_CODE:-0}
          echo "==== Wolfram server exited with code ${EXIT_CODE} ===="
      
          # Cleanup
          kill "${CF_PID}" || true
          if [ -f "${LOG_DIR}/tail1.pid" ]; then kill "$(cat "${LOG_DIR}/tail1.pid")" || true; fi
          if [ -f "${LOG_DIR}/tail2.pid" ]; then kill "$(cat "${LOG_DIR}/tail2.pid")" || true; fi
      
          # Stop nginx gracefully
          nginx -s quit || true
      
          if [ "${EXIT_CODE}" -ne 0 ]; then
            echo "Wolfram server process exited with non-zero code: ${EXIT_CODE}" >&2
            exit "${EXIT_CODE}"
          fi
