name: Run server on Windows

on:
  workflow_dispatch:

jobs:
  WindowsServer-x86:
    runs-on: windows-latest
    timeout-minutes: 60
    env:
      WOLFRAM_SYSTEM_ID: Windows-x86-64-v7
      WOLFRAMENGINE_INSTALL_MSI_DOWNLOAD_URL: https://files.wolframcdn.com/packages/winget/14.0.0.0/WolframEngine_14.0.0_WIN.msi
      WOLFRAMENGINE_CACHE_KEY: WolframEngine-U
      WOLFRAMENGINE_INSTALLATION_SUBDIRECTORY: WolframEngine

    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_TOKEN }}

      - name: Cache/restore Wolfram Engine install
        id: cache-restore
        uses: actions/cache@v4
        env:
          WOLFRAMENGINE_INSTALLATION_DIRECTORY: '${{ runner.temp }}\${{ env.WOLFRAMENGINE_INSTALLATION_SUBDIRECTORY }}'
        with:
          path: ${{ env.WOLFRAMENGINE_INSTALLATION_DIRECTORY }}
          key: wolframengine-${{ env.WOLFRAM_SYSTEM_ID }}-${{ env.WOLFRAMENGINE_CACHE_KEY }}

      - name: Download and install Wolfram Engine
        if: steps.cache-restore.outputs.cache-hit != 'true'
        env:
          WOLFRAMENGINE_INSTALLATION_DIRECTORY: '${{ runner.temp }}\${{ env.WOLFRAMENGINE_INSTALLATION_SUBDIRECTORY }}'
          WOLFRAMENGINE_INSTALL_MSI_PATH: '${{ runner.temp }}\WolframEngine-Install.msi'
          WOLFRAMENGINE_INSTALL_LOG_PATH: '${{ runner.temp }}\WolframEngine-Install.log'
        shell: pwsh
        run: |
          echo 'Downloading Wolfram Engine installer...'
          $msiFile = '${{ env.WOLFRAMENGINE_INSTALL_MSI_PATH }}'
          $logFile = '${{ env.WOLFRAMENGINE_INSTALL_LOG_PATH }}'
          Import-Module BitsTransfer
          Start-BitsTransfer '${{ env.WOLFRAMENGINE_INSTALL_MSI_DOWNLOAD_URL }}' $msiFile
          echo 'Installing Wolfram Engine...'
          $MSIArguments = @(
            "/i", ('"{0}"' -f $msiFile),
            'INSTALLLOCATION="${{ env.WOLFRAMENGINE_INSTALLATION_DIRECTORY }}"',
            "/qn", "/norestart", "/L*v", $logFile
          )
          Start-Process "msiexec.exe" -ArgumentList $MSIArguments -Wait -NoNewWindow
          echo 'Installed Wolfram Engine.'

      - name: Install Caddy (Chocolatey) and export path
        shell: pwsh
        run: |
          choco install caddy -y --no-progress
          $real = Join-Path $env:ProgramData "chocolatey\lib\caddy\tools\caddy.exe"
          if (-not (Test-Path $real)) {
            $real = Get-ChildItem -Path (Join-Path $env:ProgramData "chocolatey\lib\caddy\tools") -Recurse -Filter "caddy*.exe" |
                    Select-Object -ExpandProperty FullName -First 1
          }
          if (-not $real) { throw "Could not locate real caddy.exe under Chocolatey lib." }
          "CADDY_EXE=$real" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          Write-Host "Using Caddy at $real"

      - name: Download cloudflared (Quick Tunnel)
        shell: pwsh
        run: |
          $cf = Join-Path $env:RUNNER_TEMP "cloudflared.exe"
          Invoke-WebRequest -Uri "https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-windows-amd64.exe" -OutFile $cf
          Write-Host "cloudflared at $cf"

      - name: Run Caddy + Quick Tunnel + Wolfram (all-in-one)
        shell: pwsh
        env:
          WOLFRAMENGINE_INSTALLATION_DIRECTORY: '${{ runner.temp }}\${{ env.WOLFRAMENGINE_INSTALLATION_SUBDIRECTORY }}'
          WOLFRAMINIT: "-pwfile !cloudlm.wolfram.com -entitlement ${{ secrets.WOLFRAM_LICENSE_ENTITLEMENT_ID }}"
        run: |
          # --- Paths
          $caddy = $env:CADDY_EXE
          $caddyfile = Join-Path $env:RUNNER_TEMP "Caddyfile"
          $caddyOut = Join-Path $env:RUNNER_TEMP "caddy.out.log"
          $caddyErr = Join-Path $env:RUNNER_TEMP "caddy.err.log"
          $cf  = Join-Path $env:RUNNER_TEMP "cloudflared.exe"
          $cfOut = Join-Path $env:RUNNER_TEMP "cloudflared.out.log"
          $cfErr = Join-Path $env:RUNNER_TEMP "cloudflared.err.log"

          $lines = @(
            ':3000',
            '',
            '# Instant readiness endpoint (independent of backends)',
            'route /healthz* {',
            '  respond "ok" 200',
            '}',
            '',
            '# WebSocket service 1',
            'route /ws* {',
            '  reverse_proxy 127.0.0.1:4001 {',
            '    header_up Host {upstream_hostport}',
            '    header_up X-Forwarded-Host {host}',
            '    header_up X-Forwarded-Proto {scheme}',
            '    header_up X-Forwarded-For {remote}',
            '    transport http { dial_timeout 10s }',
            '  }',
            '}',
            '',
            '# WebSocket service 2',
            'route /ws2* {',
            '  reverse_proxy 127.0.0.1:4002 {',
            '    header_up Host {upstream_hostport}',
            '    header_up X-Forwarded-Host {host}',
            '    header_up X-Forwarded-Proto {scheme}',
            '    header_up X-Forwarded-For {remote}',
            '    transport http { dial_timeout 10s }',
            '  }',
            '}',
            '',
            '# Everything else to the HTTP app',
            'route /* {',
            '  reverse_proxy 127.0.0.1:4000 {',
            '    header_up Host {upstream_hostport}',
            '    header_up X-Forwarded-Host {host}',
            '    header_up X-Forwarded-Proto {scheme}',
            '    header_up X-Forwarded-For {remote}',
            '    transport http { dial_timeout 10s }',
            '  }',
            '}',
            '',
            '# Gracefully handle upstream errors (e.g., app not ready) instead of 502',
            'handle_errors {',
            '  @bad {',
            '    expression {http.error.status_code} >= 500 && {http.error.status_code} < 600',
            '  }',
            '  respond @bad "Service is starting — try again in a moment." 200',
            '}'
          )
          $cfg = $lines -join "`r`n"
          Set-Content -Path $caddyfile -Value $cfg -Encoding utf8


          # --- Start Caddy
          $caddyProc = Start-Process -FilePath $caddy -ArgumentList @("run","--config",$caddyfile) `
            -RedirectStandardOutput $caddyOut -RedirectStandardError $caddyErr -PassThru -WindowStyle Hidden

          # Wait until Caddy answers /healthz locally
          $okLocal = $false
          $deadlineLocal = (Get-Date).AddSeconds(20)
          while ((Get-Date) -lt $deadlineLocal -and -not $okLocal) {
            Start-Sleep -Seconds 1
            try {
              $resp = Invoke-WebRequest -Uri "http://127.0.0.1:3000/healthz" -TimeoutSec 5 -UseBasicParsing -ErrorAction Stop
              if ($resp.StatusCode -eq 200) { $okLocal = $true }
            } catch {}
          }
          if (-not $okLocal) {
            Write-Host "=== Caddy STDOUT (tail) ==="; if (Test-Path $caddyOut) { Get-Content $caddyOut -Tail 80 }
            Write-Host "=== Caddy STDERR (tail) ==="; if (Test-Path $caddyErr) { Get-Content $caddyErr -Tail 80 }
            throw "Caddy not responding on :3000"
          }
          Write-Host "Caddy responded 200 on /healthz"

          # --- Start Quick Tunnel
          $cfArgs = @("tunnel","--no-autoupdate","--edge-ip-version","4","--url","http://127.0.0.1:3000")
          $cfProc = Start-Process -FilePath $cf -ArgumentList $cfArgs `
            -RedirectStandardOutput $cfOut -RedirectStandardError $cfErr -PassThru -WindowStyle Hidden

          # Capture trycloudflare URL
          $url = $null
          $deadline = (Get-Date).AddSeconds(120)
          while ((Get-Date) -lt $deadline -and -not $url) {
            Start-Sleep -Seconds 1
            $content = ""
            if (Test-Path $cfOut) { $content += (Get-Content $cfOut -Raw -ErrorAction SilentlyContinue) }
            if (Test-Path $cfErr) { $content += "`n" + (Get-Content $cfErr -Raw -ErrorAction SilentlyContinue) }
            $m = [regex]::Match($content, 'https://[a-z0-9-]+\.trycloudflare\.com')
            if ($m.Success) { $url = $m.Value }
            elseif ($cfProc.HasExited) { break }
          }
          if (-not $url) {
            Write-Host "cloudflared logs (stdout tail):"; if (Test-Path $cfOut) { Get-Content $cfOut -Tail 120 }
            Write-Host "cloudflared logs (stderr tail):"; if (Test-Path $cfErr) { Get-Content $cfErr -Tail 120 }
            throw "Timed out waiting for trycloudflare URL."
          }
          Write-Host "✅ Quick Tunnel URL: $url"

          # Verify edge can reach /healthz
          $okEdge = $false
          $deadline2 = (Get-Date).AddSeconds(60)
          while ((Get-Date) -lt $deadline2 -and -not $okEdge) {
            Start-Sleep -Seconds 2
            try {
              $resp = Invoke-WebRequest -Uri ($url + "/healthz") -SkipHttpErrorCheck -TimeoutSec 10 -ErrorAction Stop
              if ($resp.StatusCode -ge 200 -and $resp.StatusCode -lt 600) { $okEdge = $true }
            } catch { $okEdge = $false }
          }
          if (-not $okEdge) {
            Write-Host "Edge cannot reach /healthz yet."
            Write-Host "==== cloudflared STDOUT (tail) ===="; if (Test-Path $cfOut) { Get-Content $cfOut -Tail 120 }
            Write-Host "==== cloudflared STDERR (tail) ===="; if (Test-Path $cfErr) { Get-Content $cfErr -Tail 120 }
            throw "Tunnel created but edge can’t reach origin (1033)."
          }

          # --- Tail logs in background (keep them visible during the app run)
          $tailJobs = @()
          $tailJobs += Start-Job -ScriptBlock { param($p,$tag) Get-Content -Path $p -Wait | ForEach-Object { Write-Host "[$tag] $_" } } -ArgumentList $caddyOut,"CADDY-OUT"
          $tailJobs += Start-Job -ScriptBlock { param($p,$tag) Get-Content -Path $p -Wait | ForEach-Object { Write-Host "[$tag] $_" } } -ArgumentList $caddyErr,"CADDY-ERR"
          $tailJobs += Start-Job -ScriptBlock { param($p,$tag) Get-Content -Path $p -Wait | ForEach-Object { Write-Host "[$tag] $_" } } -ArgumentList $cfOut,"CF-OUT"
          $tailJobs += Start-Job -ScriptBlock { param($p,$tag) Get-Content -Path $p -Wait | ForEach-Object { Write-Host "[$tag] $_" } } -ArgumentList $cfErr,"CF-ERR"

          # --- Run your app (starts 4000/4001/4002)
          $env:Path += ';' + (Join-Path $env:WOLFRAMENGINE_INSTALLATION_DIRECTORY '')
          Write-Host "==== Starting Wolfram server (console output below) ===="
          & wolframscript -f ./Scripts/start.wls http 4000 ws 4001 ws2 4002 wsprefix ws ws2prefix ws2
          $exitCode = $LASTEXITCODE
          Write-Host "==== Wolfram server exited with code $exitCode ===="

          # --- Cleanup
          foreach ($j in $tailJobs) {
            if ($j.State -eq 'Running') { Stop-Job $j -Force }
            Receive-Job $j -Keep | Out-Null
            Remove-Job $j -Force
          }
          foreach ($p in @($cfProc,$caddyProc)) {
            if ($p -and !$p.HasExited) { try { Stop-Process -Id $p.Id -Force -ErrorAction Stop } catch {} }
          }

          if ($exitCode -ne 0) { throw "Wolfram server process exited with non-zero code: $exitCode" }
