name: Run server on Windows

on:
  workflow_dispatch:

jobs:
  WindowsServer-x86:
    runs-on: windows-latest
    timeout-minutes: 60
    env:
      # Wolfram
      WOLFRAM_SYSTEM_ID: Windows-x86-64-v7
      WOLFRAMENGINE_INSTALL_MSI_DOWNLOAD_URL: https://files.wolframcdn.com/packages/winget/14.0.0.0/WolframEngine_14.0.0_WIN.msi
      WOLFRAMENGINE_CACHE_KEY: WolframEngine-U
      WOLFRAMENGINE_INSTALLATION_SUBDIRECTORY: WolframEngine

    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_TOKEN }}

      - name: Cache/restore Wolfram Engine install
        id: cache-restore
        uses: actions/cache@v4
        env:
          WOLFRAMENGINE_INSTALLATION_DIRECTORY: '${{ runner.temp }}\${{ env.WOLFRAMENGINE_INSTALLATION_SUBDIRECTORY }}'
        with:
          path: ${{ env.WOLFRAMENGINE_INSTALLATION_DIRECTORY }}
          key: wolframengine-${{ env.WOLFRAM_SYSTEM_ID }}-${{ env.WOLFRAMENGINE_CACHE_KEY }}

      - name: Download and install Wolfram Engine
        if: steps.cache-restore.outputs.cache-hit != 'true'
        env:
          WOLFRAMENGINE_INSTALLATION_DIRECTORY: '${{ runner.temp }}\${{ env.WOLFRAMENGINE_INSTALLATION_SUBDIRECTORY }}'
          WOLFRAMENGINE_INSTALL_MSI_PATH: '${{ runner.temp }}\WolframEngine-Install.msi'
          WOLFRAMENGINE_INSTALL_LOG_PATH: '${{ runner.temp }}\WolframEngine-Install.log'
        shell: pwsh
        run: |
          echo 'Downloading Wolfram Engine installer...'
          $msiFile = '${{ env.WOLFRAMENGINE_INSTALL_MSI_PATH }}'
          $logFile = '${{ env.WOLFRAMENGINE_INSTALL_LOG_PATH }}'
          Import-Module BitsTransfer
          Start-BitsTransfer '${{ env.WOLFRAMENGINE_INSTALL_MSI_DOWNLOAD_URL }}' $msiFile
          echo 'Installing Wolfram Engine...'
          $MSIArguments = @(
            "/i", ('"{0}"' -f $msiFile),
            'INSTALLLOCATION="${{ env.WOLFRAMENGINE_INSTALLATION_DIRECTORY }}"',
            "/qn", "/norestart", "/L*v", $logFile
          )
          Start-Process "msiexec.exe" -ArgumentList $MSIArguments -Wait -NoNewWindow
          echo 'Installed Wolfram Engine.'

      - name: Install Caddy (Chocolatey) and export path
        shell: pwsh
        run: |
          choco install caddy -y --no-progress
      
          $real = Join-Path $env:ProgramData "chocolatey\lib\caddy\tools\caddy.exe"
          if (-not (Test-Path $real)) {
            $real = Get-ChildItem -Path (Join-Path $env:ProgramData "chocolatey\lib\caddy\tools") -Recurse -Filter "caddy*.exe" |
                    Select-Object -ExpandProperty FullName -First 1
          }
          if (-not $real) { throw "Could not locate real caddy.exe under Chocolatey lib." }
      
          # Make it available to later steps
          "CADDY_EXE=$real" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          Write-Host "Using Caddy at $real"


      - name: Start local proxy (Caddy) on :3000
        shell: pwsh
        run: |
          $caddy = $env:CADDY_EXE
          $caddyfile = Join-Path $env:RUNNER_TEMP "Caddyfile"
      
          $lines = @(
            ':3000',
            '',
            '# WebSocket service 1',
            'route /ws* {',
            '  reverse_proxy 127.0.0.1:4001',
            '}',
            '',
            '# WebSocket service 2',
            'route /ws2* {',
            '  reverse_proxy 127.0.0.1:4002',
            '}',
            '',
            '# Everything else to the HTTP app',
            'route /* {',
            '  reverse_proxy 127.0.0.1:4000',
            '}'
          )
          $cfg = $lines -join "`r`n"
          Set-Content -Path $caddyfile -Value $cfg -Encoding utf8
      
          $caddyOut = Join-Path $env:RUNNER_TEMP "caddy.out.log"
          $caddyErr = Join-Path $env:RUNNER_TEMP "caddy.err.log"
      
          $proc = Start-Process -FilePath $caddy -ArgumentList @("run","--config",$caddyfile) `
            -RedirectStandardOutput $caddyOut -RedirectStandardError $caddyErr -PassThru -WindowStyle Hidden
          Set-Content -Path (Join-Path $env:RUNNER_TEMP "caddy.pid") -Value $proc.Id
      
          Start-Sleep -Seconds 1
          Write-Host "=== Caddy STDOUT (tail) ==="
          Get-Content $caddyOut -Tail 50
          Write-Host "=== Caddy STDERR (tail) ==="
          Get-Content $caddyErr -Tail 50

          # Wait up to 30s for port 3000 to be listening
          $deadline = (Get-Date).AddSeconds(30)
          $ready = $false
          while ((Get-Date) -lt $deadline -and -not $ready) {
            Start-Sleep -Seconds 1
            try {
              $nc = Test-NetConnection -ComputerName 127.0.0.1 -Port 3000 -WarningAction SilentlyContinue
              if ($nc.TcpTestSucceeded) { $ready = $true }
            } catch {}
          }
          if (-not $ready) {
            Write-Host "Caddy did not open :3000 in time. Recent logs:"
            Get-Content $caddyOut -Tail 60
            Get-Content $caddyErr -Tail 60
            throw "Caddy not ready on :3000"
          }
          Write-Host "Caddy is listening on :3000"

      - name: Download cloudflared (Quick Tunnel)
        shell: pwsh
        run: |
          $cf = Join-Path $env:RUNNER_TEMP "cloudflared.exe"
          Invoke-WebRequest -Uri "https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-windows-amd64.exe" -OutFile $cf
          Write-Host "cloudflared at $cf"

      - name: Start Quick Tunnel (→ http://127.0.0.1:3000), capture & verify URL
        id: quicktunnel
        shell: pwsh
        run: |
          $cf  = Join-Path $env:RUNNER_TEMP "cloudflared.exe"
          $out = Join-Path $env:RUNNER_TEMP "cloudflared.out.log"
          $err = Join-Path $env:RUNNER_TEMP "cloudflared.err.log"

          # Start cloudflared; prefer IPv4 and keep it quiet/stable
          $args = @("tunnel","--no-autoupdate","--edge-ip-version","4","--url","http://127.0.0.1:3000")
          $proc = Start-Process -FilePath $cf -ArgumentList $args -RedirectStandardOutput $out -RedirectStandardError $err -PassThru -WindowStyle Hidden
          Set-Content -Path (Join-Path $env:RUNNER_TEMP "cloudflared.pid") -Value $proc.Id

          # Wait up to 120s for the trycloudflare URL to appear
          $url = $null
          $deadline = (Get-Date).AddSeconds(120)
          while ((Get-Date) -lt $deadline -and -not $url) {
            Start-Sleep -Seconds 1
            $content = ""
            if (Test-Path $out) { $content += (Get-Content $out -Raw -ErrorAction SilentlyContinue) }
            if (Test-Path $err) { $content += "`n" + (Get-Content $err -Raw -ErrorAction SilentlyContinue) }
            $m = [regex]::Match($content, 'https://[a-z0-9-]+\.trycloudflare\.com')
            if ($m.Success) { $url = $m.Value }
            elseif ($proc.HasExited) { break }
          }
          if (-not $url) {
            Write-Host "cloudflared logs (stdout tail):"
            if (Test-Path $out) { Get-Content $out -Tail 120 }
            Write-Host "cloudflared logs (stderr tail):"
            if (Test-Path $err) { Get-Content $err -Tail 120 }
            throw "Timed out waiting for trycloudflare URL."
          }

          # Health-check the public URL (up to 60s) to avoid 1033
          $ok = $false
          $deadline2 = (Get-Date).AddSeconds(60)
          while ((Get-Date) -lt $deadline2 -and -not $ok) {
            Start-Sleep -Seconds 2
            try {
              # Treat ANY HTTP status (2xx–5xx) as success = edge can reach the tunnel
              $resp = Invoke-WebRequest -Uri $url -SkipHttpErrorCheck -TimeoutSec 10 -ErrorAction Stop
              if ($resp.StatusCode -ge 200 -and $resp.StatusCode -lt 600) { $ok = $true }
            } catch {
              # If we still failed (DNS/TLS/connect), keep trying
              $ok = $false
            }
          }
          if (-not $ok) {
            Write-Host "Could not reach $url yet. cloudflared logs:"
            if (Test-Path $out) { Get-Content $out -Tail 120 }
            if (Test-Path $err) { Get-Content $err -Tail 120 }
            throw "Tunnel up but not reachable from edge (1033). Check that cloudflared is still running and :3000 is open."
          }


          Write-Host "✅ Quick Tunnel URL: $url"
          "PUBLIC_URL=$url" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          "public_url=$url" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8

          # Show recent logs for context
          Write-Host "==== cloudflared STDOUT (tail) ===="
          Get-Content $out -Tail 80
          Write-Host "==== cloudflared STDERR (tail) ===="
          Get-Content $err -Tail 40



      - name: Start Wolfram server (your app)
        env:
          WOLFRAMENGINE_INSTALLATION_DIRECTORY: '${{ runner.temp }}\${{ env.WOLFRAMENGINE_INSTALLATION_SUBDIRECTORY }}'
          # If you use the entitlement secret, keep this line; otherwise remove it:
          WOLFRAMINIT: "-pwfile !cloudlm.wolfram.com -entitlement ${{ secrets.WOLFRAM_LICENSE_ENTITLEMENT_ID }}"
        shell: pwsh
        run: |
          # Put Wolfram on PATH
          $env:Path += ';' + (Join-Path $env:WOLFRAMENGINE_INSTALLATION_DIRECTORY '')

          Write-Host "==== Starting Wolfram server (console output below) ===="
          # Your script should start services on 4000/4001/4002 as needed.
          & wolframscript -f ./Scripts/start.wls http 4000 ws 4001 ws2 4002 wsprefix ws ws2prefix ws2
          $exitCode = $LASTEXITCODE
          Write-Host "==== Wolfram server exited with code $exitCode ===="
          
          if ($exitCode -ne 0) {
            throw "Wolfram server process exited with non-zero code: $exitCode"
          }

      - name: Cleanup (stop tunnel & proxy)
        if: always()
        shell: pwsh
        run: |
          # Stop cloudflared
          $cfPidFile = Join-Path $env:RUNNER_TEMP "cloudflared.pid"
          if (Test-Path $cfPidFile) {
            $pid = Get-Content $cfPidFile
            try { Stop-Process -Id $pid -Force -ErrorAction Stop } catch {}
            Remove-Item $cfPidFile -Force
          }
          # Stop Caddy
          $caddyPidFile = Join-Path $env:RUNNER_TEMP "caddy.pid"
          if (Test-Path $caddyPidFile) {
            $pid = Get-Content $caddyPidFile
            try { Stop-Process -Id $pid -Force -ErrorAction Stop } catch {}
            Remove-Item $caddyPidFile -Force
          }
          # Stop tail job
          $job = Get-Job -Name "tail-cloudflared" -ErrorAction SilentlyContinue
          if ($job -and $job.State -eq 'Running') { Stop-Job $job -Force }
          if ($job) { Receive-Job $job -Keep | Out-Null; Remove-Job $job -Force }
