name: Run server on Windows

on:
  workflow_dispatch:
    inputs:
      keep_alive_minutes:
        description: "Keep the tunnel alive for N minutes after startup (0=infinite until cancel)"
        required: false
        default: "120"

jobs:
  WindowsServer-x86:
    runs-on: windows-latest
    timeout-minutes: 60
    env:
      # Wolfram
      WOLFRAM_SYSTEM_ID: Windows-x86-64-v7
      WOLFRAMENGINE_INSTALL_MSI_DOWNLOAD_URL: https://files.wolframcdn.com/packages/winget/14.0.0.0/WolframEngine_14.0.0_WIN.msi
      WOLFRAMENGINE_CACHE_KEY: WolframEngine-U
      WOLFRAMENGINE_INSTALLATION_SUBDIRECTORY: WolframEngine

    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_TOKEN }}

      - name: Cache/restore Wolfram Engine install
        id: cache-restore
        uses: actions/cache@v4
        env:
          WOLFRAMENGINE_INSTALLATION_DIRECTORY: '${{ runner.temp }}\${{ env.WOLFRAMENGINE_INSTALLATION_SUBDIRECTORY }}'
        with:
          path: ${{ env.WOLFRAMENGINE_INSTALLATION_DIRECTORY }}
          key: wolframengine-${{ env.WOLFRAM_SYSTEM_ID }}-${{ env.WOLFRAMENGINE_CACHE_KEY }}

      - name: Download and install Wolfram Engine
        if: steps.cache-restore.outputs.cache-hit != 'true'
        env:
          WOLFRAMENGINE_INSTALLATION_DIRECTORY: '${{ runner.temp }}\${{ env.WOLFRAMENGINE_INSTALLATION_SUBDIRECTORY }}'
          WOLFRAMENGINE_INSTALL_MSI_PATH: '${{ runner.temp }}\WolframEngine-Install.msi'
          WOLFRAMENGINE_INSTALL_LOG_PATH: '${{ runner.temp }}\WolframEngine-Install.log'
        shell: pwsh
        run: |
          echo 'Downloading Wolfram Engine installer...'
          $msiFile = '${{ env.WOLFRAMENGINE_INSTALL_MSI_PATH }}'
          $logFile = '${{ env.WOLFRAMENGINE_INSTALL_LOG_PATH }}'
          Import-Module BitsTransfer
          Start-BitsTransfer '${{ env.WOLFRAMENGINE_INSTALL_MSI_DOWNLOAD_URL }}' $msiFile
          echo 'Installing Wolfram Engine...'
          $MSIArguments = @(
            "/i", ('"{0}"' -f $msiFile),
            'INSTALLLOCATION="${{ env.WOLFRAMENGINE_INSTALLATION_DIRECTORY }}"',
            "/qn", "/norestart", "/L*v", $logFile
          )
          Start-Process "msiexec.exe" -ArgumentList $MSIArguments -Wait -NoNewWindow
          echo 'Installed Wolfram Engine.'

      - name: Install Caddy (Chocolatey) and export path
        shell: pwsh
        run: |
          choco install caddy -y --no-progress
          $real = Join-Path $env:ProgramData "chocolatey\lib\caddy\tools\caddy.exe"
          if (-not (Test-Path $real)) {
            $real = Get-ChildItem -Path (Join-Path $env:ProgramData "chocolatey\lib\caddy\tools") -Recurse -Filter "caddy*.exe" |
                    Select-Object -ExpandProperty FullName -First 1
          }
          if (-not $real) { throw "Could not locate real caddy.exe under Chocolatey lib." }
          "CADDY_EXE=$real" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          Write-Host "Using Caddy at $real"

      - name: Download cloudflared (Quick Tunnel)
        shell: pwsh
        run: |
          $cf = Join-Path $env:RUNNER_TEMP "cloudflared.exe"
          Invoke-WebRequest -Uri "https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-windows-amd64.exe" -OutFile $cf
          Write-Host "cloudflared at $cf"

      - name: Run proxy + Quick Tunnel + app (kept alive)
        shell: pwsh
        env:
          WOLFRAMENGINE_INSTALLATION_DIRECTORY: '${{ runner.temp }}\${{ env.WOLFRAMENGINE_INSTALLATION_SUBDIRECTORY }}'
          WOLFRAMINIT: "-pwfile !cloudlm.wolfram.com -entitlement ${{ secrets.WOLFRAM_LICENSE_ENTITLEMENT_ID }}"
          KEEP_ALIVE_MINUTES: ${{ github.event.inputs.keep_alive_minutes || '120' }}
        run: |
          # --- Paths
          $caddy = $env:CADDY_EXE
          $caddyfile = Join-Path $env:RUNNER_TEMP "Caddyfile"
          $caddyOut = Join-Path $env:RUNNER_TEMP "caddy.out.log"
          $caddyErr = Join-Path $env:RUNNER_TEMP "caddy.err.log"
          $cf  = Join-Path $env:RUNNER_TEMP "cloudflared.exe"
          $cfOut = Join-Path $env:RUNNER_TEMP "cloudflared.out.log"
          $cfErr = Join-Path $env:RUNNER_TEMP "cloudflared.err.log"

          # --- Caddyfile: /healthz + path-based fanout
          $lines = @(
            ':3000',
            '',
            '# Instant readiness endpoint (independent of backends)',
            'route /healthz* {',
            '  respond "ok" 200',
            '}',
            '',
            '# WebSocket service 1',
            'route /ws* {',
            '  reverse_proxy 127.0.0.1:4001 {',
            '    header_up Host {upstream_hostport}',
            '    header_up X-Forwarded-Host {host}',
            '    header_up X-Forwarded-Proto {scheme}',
            '    header_up X-Forwarded-For {remote}',
            '  }',
            '}',
            '',
            '# WebSocket service 2',
            'route /ws2* {',
            '  reverse_proxy 127.0.0.1:4002 {',
            '    header_up Host {upstream_hostport}',
            '    header_up X-Forwarded-Host {host}',
            '    header_up X-Forwarded-Proto {scheme}',
            '    header_up X-Forwarded-For {remote}',
            '  }',
            '}',
            '',
            '# Everything else to the HTTP app',
            'route /* {',
            '  reverse_proxy 127.0.0.1:4000 {',
            '    header_up Host {upstream_hostport}',
            '    header_up X-Forwarded-Host {host}',
            '    header_up X-Forwarded-Proto {scheme}',
            '    header_up X-Forwarded-For {remote}',
            '  }',
            '}',
            '',
            '# Gracefully handle upstream 5xx during warm-up',
            'handle_errors {',
            '  @bad expression `{http.error.status_code} >= 500 && {http.error.status_code} < 600`',
            '  respond @bad "Service is starting — try again in a moment." 200',
            '}'
          )
          $cfg = $lines -join "`r`n"
          Set-Content -Path $caddyfile -Value $cfg -Encoding utf8

          # --- Start Caddy
          $caddyProc = Start-Process -FilePath $caddy -ArgumentList @("run","--config",$caddyfile) `
            -RedirectStandardOutput $caddyOut -RedirectStandardError $caddyErr -PassThru -WindowStyle Hidden

          # Wait until Caddy answers /healthz locally
          $okLocal = $false
          $deadlineLocal = (Get-Date).AddSeconds(20)
          while ((Get-Date) -lt $deadlineLocal -and -not $okLocal) {
            Start-Sleep -Seconds 1
            try {
              $resp = Invoke-WebRequest -Uri "http://127.0.0.1:3000/healthz" -TimeoutSec 5 -UseBasicParsing -ErrorAction Stop
              if ($resp.StatusCode -eq 200) { $okLocal = $true }
            } catch {}
          }
          if (-not $okLocal) {
            Write-Host "=== Caddy STDOUT (tail) ==="; if (Test-Path $caddyOut) { Get-Content $caddyOut -Tail 80 }
            Write-Host "=== Caddy STDERR (tail) ==="; if (Test-Path $caddyErr) { Get-Content $caddyErr -Tail 80 }
            throw "Caddy not responding on :3000"
          }
          Write-Host "Caddy responded 200 on /healthz"

          # --- Start Quick Tunnel (stable settings)
          # --- Start Quick Tunnel (with retries) ---------------------------------------
          function Start-QuickTunnel {
            param(
              [string]$CfExe,
              [string]$OriginUrl,
              [string]$StdOutPath,
              [string]$StdErrPath,
              [int]$MaxTries = 5
            )
          
            for ($attempt = 1; $attempt -le $MaxTries; $attempt++) {
              Write-Host "Starting Quick Tunnel (attempt $attempt of $MaxTries)..."
          
              # Clean previous logs
              foreach ($p in @($StdOutPath,$StdErrPath)) { if (Test-Path $p) { Remove-Item $p -Force } }
          
              $args = @(
                "tunnel",
                "--no-autoupdate",
                "--edge-ip-version","4",
                "--protocol","http2",
                "--ha-connections","2",
                "--url",$OriginUrl
              )
          
              $proc = Start-Process -FilePath $CfExe -ArgumentList $args `
                -RedirectStandardOutput $StdOutPath -RedirectStandardError $StdErrPath `
                -PassThru -WindowStyle Hidden
          
              # Wait up to 45s this attempt for the URL to appear
              $url = $null
              $deadline = (Get-Date).AddSeconds(45)
              while ((Get-Date) -lt $deadline -and -not $url) {
                Start-Sleep -Seconds 1
                $content = ""
                if (Test-Path $StdOutPath) { $content += (Get-Content $StdOutPath -Raw -ErrorAction SilentlyContinue) }
                if (Test-Path $StdErrPath) { $content += "`n" + (Get-Content $StdErrPath -Raw -ErrorAction SilentlyContinue) }
          
                # If Cloudflare returns HTML (1101) this will *not* match; we’ll retry below.
                $m = [regex]::Match($content, 'https://[a-z0-9-]+\.trycloudflare\.com')
                if ($m.Success) { $url = $m.Value }
                elseif ($proc.HasExited) { break }
              }
          
              if ($url) {
                return [pscustomobject]@{ Url = $url; Proc = $proc }
              }
          
              # Didn’t get a URL — dump tails for visibility, then retry fresh
              Write-Host "Quick Tunnel did not return a URL on attempt $attempt."
              Write-Host "cloudflared STDOUT (tail):"; if (Test-Path $StdOutPath) { Get-Content $StdOutPath -Tail 60 }
              Write-Host "cloudflared STDERR (tail):"; if (Test-Path $StdErrPath) { Get-Content $StdErrPath -Tail 60 }
          
              try { if ($proc -and -not $proc.HasExited) { Stop-Process -Id $proc.Id -Force } } catch {}
              Start-Sleep -Seconds ([Math]::Min(5 * $attempt, 15))  # simple backoff
            }
          
            throw "Failed to obtain a Quick Tunnel URL after $MaxTries attempts."
          }
          
          # call it
          $qt = Start-QuickTunnel -CfExe $cf -OriginUrl "http://127.0.0.1:3000" -StdOutPath $cfOut -StdErrPath $cfErr -MaxTries 6
          $url = $qt.Url
          $cfProc = $qt.Proc
          Write-Host "✅ Quick Tunnel URL: $url"
          "## Quick Tunnel URL`n$url" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8
          
          # Wait up to 60s for DNS to resolve publicly (best-effort)
          $publicHost = ([Uri]$url).Host
          $dnsOk = $false
          $dnsDeadline = (Get-Date).AddSeconds(60)
          while ((Get-Date) -lt $dnsDeadline -and -not $dnsOk) {
            try { Resolve-DnsName $publicHost -Type A -ErrorAction Stop | Out-Null; $dnsOk = $true } catch { Start-Sleep -Seconds 2 }
          }
          
          # Prove edge → origin path via /healthz (any HTTP status means the tunnel is reachable)
          $okEdge = $false
          $deadline2 = (Get-Date).AddSeconds(60)
          while ((Get-Date) -lt $deadline2 -and -not $okEdge) {
            Start-Sleep -Seconds 2
            try {
              $resp = Invoke-WebRequest -Uri ($url + "/healthz") -SkipHttpErrorCheck -TimeoutSec 10 -ErrorAction Stop
              if ($resp.StatusCode -ge 200 -and $resp.StatusCode -lt 600) { $okEdge = $true }
            } catch { $okEdge = $false }
          }
          if (-not $okEdge) {
            Write-Host "Edge cannot reach /healthz yet (but tunnel is running)."
            Write-Host "==== cloudflared STDOUT (tail) ===="; if (Test-Path $cfOut) { Get-Content $cfOut -Tail 120 }
            Write-Host "==== cloudflared STDERR (tail) ===="; if (Test-Path $cfErr) { Get-Content $cfErr -Tail 120 }
          }


          # --- Tail logs in background
          $tailJobs = @()
          $tailJobs += Start-Job -ScriptBlock { param($p,$tag) Get-Content -Path $p -Wait | ForEach-Object { Write-Host "[$tag] $_" } } -ArgumentList $caddyOut,"CADDY-OUT"
          $tailJobs += Start-Job -ScriptBlock { param($p,$tag) Get-Content -Path $p -Wait | ForEach-Object { Write-Host "[$tag] $_" } } -ArgumentList $caddyErr,"CADDY-ERR"
          $tailJobs += Start-Job -ScriptBlock { param($p,$tag) Get-Content -Path $p -Wait | ForEach-Object { Write-Host "[$tag] $_" } } -ArgumentList $cfOut,"CF-OUT"
          $tailJobs += Start-Job -ScriptBlock { param($p,$tag) Get-Content -Path $p -Wait | ForEach-Object { Write-Host "[$tag] $_" } } -ArgumentList $cfErr,"CF-ERR"

          # --- Start your app (listens on 4000/4001/4002)
          # --- Start your app (background) so cloudflared stays up
          $env:Path += ';' + (Join-Path $env:WOLFRAMENGINE_INSTALLATION_DIRECTORY '')
          
          $wolfOut = Join-Path $env:RUNNER_TEMP "wolfram.out.log"
          $wolfErr = Join-Path $env:RUNNER_TEMP "wolfram.err.log"
          $wolfram = Start-Process -FilePath "wolframscript" -ArgumentList @(
            "-f","./Scripts/start.wls",
            "http","4000","ws","4001","ws2","4002","wsprefix","ws","ws2prefix","ws2"
          ) -RedirectStandardOutput $wolfOut -RedirectStandardError $wolfErr -PassThru -WindowStyle Hidden
          
          Write-Host "Wolfram server launched (PID $($wolfram.Id)). Tailing logs:"
          $tailJobs += Start-Job -ScriptBlock { param($p,$tag) Get-Content -Path $p -Wait | % { Write-Host "[$tag] $_" } } -ArgumentList $wolfOut,"WOLFRAM-OUT"
          $tailJobs += Start-Job -ScriptBlock { param($p,$tag) Get-Content -Path $p -Wait | % { Write-Host "[$tag] $_" } } -ArgumentList $wolfErr,"WOLFRAM-ERR"
          
          # --- Keep the tunnel alive while monitoring processes
          $mins = [int]($env:KEEP_ALIVE_MINUTES)
          if ($mins -le 0) { $stopAt = [DateTime]::MaxValue } else { $stopAt = (Get-Date).AddMinutes($mins) }
          
          Write-Host "Keep-alive running until $stopAt (or until a process exits). URL: $url"
          while ((Get-Date) -lt $stopAt) {
            Start-Sleep -Seconds 5
          
            if ($caddyProc.HasExited) { throw "caddy exited early with code $($caddyProc.ExitCode)" }
            if ($cfProc.HasExited)   { throw "cloudflared exited early with code $($cfProc.ExitCode)" }
            if ($wolfram.HasExited)  { Write-Host "Wolfram exited with code $($wolfram.ExitCode). Keeping tunnel up until keep-alive window ends."; break }
          }
          
          # (Optional) wait out remaining time if Wolfram exited early
          while ((Get-Date) -lt $stopAt) {
            Start-Sleep -Seconds 5
            if ($caddyProc.HasExited) { throw "caddy exited early with code $($caddyProc.ExitCode)" }
            if ($cfProc.HasExited)   { throw "cloudflared exited early with code $($cfProc.ExitCode)" }
          }


          # --- Keep the tunnel alive
          $mins = [int]($env:KEEP_ALIVE_MINUTES)
          if ($mins -le 0) {
            Write-Host "Keep-alive: infinite (until job is cancelled)."
            while ($true) {
              Start-Sleep -Seconds 5
              if ($cfProc.HasExited) { throw "cloudflared exited early with code $($cfProc.ExitCode)" }
              if ($caddyProc.HasExited) { throw "caddy exited early with code $($caddyProc.ExitCode)" }
            }
          } else {
            Write-Host "Keep-alive: $mins minute(s). URL: $url"
            $stopAt = (Get-Date).AddMinutes($mins)
            while ((Get-Date) -lt $stopAt) {
              Start-Sleep -Seconds 5
              if ($cfProc.HasExited) { throw "cloudflared exited early with code $($cfProc.ExitCode)" }
              if ($caddyProc.HasExited) { throw "caddy exited early with code $($caddyProc.ExitCode)" }
            }
          }

          # --- Cleanup (normally not reached unless you shorten the loop above)
          foreach ($j in $tailJobs) {
            if ($j.State -eq 'Running') { Stop-Job $j -Force }
            Receive-Job $j -Keep | Out-Null
            Remove-Job $j -Force
          }
          foreach ($p in @($cfProc,$caddyProc)) {
            if ($p -and !$p.HasExited) { try { Stop-Process -Id $p.Id -Force -ErrorAction Stop } catch {} }
          }

          if ($appExit -ne 0) { throw "Wolfram startup exited with non-zero code: $appExit" }
