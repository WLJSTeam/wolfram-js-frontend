name: Run server on Windows

on:
  workflow_dispatch:

jobs:
  WindowsServer-x86:
    runs-on: windows-latest
    timeout-minutes: 60
    env:
      # Wolfram
      WOLFRAM_SYSTEM_ID: Windows-x86-64-v7
      WOLFRAMENGINE_INSTALL_MSI_DOWNLOAD_URL: https://files.wolframcdn.com/packages/winget/14.0.0.0/WolframEngine_14.0.0_WIN.msi
      WOLFRAMENGINE_CACHE_KEY: WolframEngine-U
      WOLFRAMENGINE_INSTALLATION_SUBDIRECTORY: WolframEngine

    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_TOKEN }}

      - name: Cache/restore Wolfram Engine install
        id: cache-restore
        uses: actions/cache@v4
        env:
          WOLFRAMENGINE_INSTALLATION_DIRECTORY: '${{ runner.temp }}\${{ env.WOLFRAMENGINE_INSTALLATION_SUBDIRECTORY }}'
        with:
          path: ${{ env.WOLFRAMENGINE_INSTALLATION_DIRECTORY }}
          key: wolframengine-${{ env.WOLFRAM_SYSTEM_ID }}-${{ env.WOLFRAMENGINE_CACHE_KEY }}

      - name: Download and install Wolfram Engine
        if: steps.cache-restore.outputs.cache-hit != 'true'
        env:
          WOLFRAMENGINE_INSTALLATION_DIRECTORY: '${{ runner.temp }}\${{ env.WOLFRAMENGINE_INSTALLATION_SUBDIRECTORY }}'
          WOLFRAMENGINE_INSTALL_MSI_PATH: '${{ runner.temp }}\WolframEngine-Install.msi'
          WOLFRAMENGINE_INSTALL_LOG_PATH: '${{ runner.temp }}\WolframEngine-Install.log'
        shell: pwsh
        run: |
          echo 'Downloading Wolfram Engine installer...'
          $msiFile = '${{ env.WOLFRAMENGINE_INSTALL_MSI_PATH }}'
          $logFile = '${{ env.WOLFRAMENGINE_INSTALL_LOG_PATH }}'
          Import-Module BitsTransfer
          Start-BitsTransfer '${{ env.WOLFRAMENGINE_INSTALL_MSI_DOWNLOAD_URL }}' $msiFile
          echo 'Installing Wolfram Engine...'
          $MSIArguments = @(
            "/i", ('"{0}"' -f $msiFile),
            'INSTALLLOCATION="${{ env.WOLFRAMENGINE_INSTALLATION_DIRECTORY }}"',
            "/qn", "/norestart", "/L*v", $logFile
          )
          Start-Process "msiexec.exe" -ArgumentList $MSIArguments -Wait -NoNewWindow
          echo 'Installed Wolfram Engine.'

      - name: Download Caddy (reverse proxy)
        shell: pwsh
        run: |
          $caddyZip = Join-Path $env:RUNNER_TEMP "caddy.zip"
          $caddyExe = Join-Path $env:RUNNER_TEMP "caddy.exe"
          Invoke-WebRequest -Uri "https://github.com/caddyserver/caddy/releases/latest/download/caddy_windows_amd64.zip" -OutFile $caddyZip
          Expand-Archive -Path $caddyZip -DestinationPath $env:RUNNER_TEMP -Force
          if (-not (Test-Path $caddyExe)) {
            $found = Get-ChildItem -Path $env:RUNNER_TEMP -Recurse -Filter "caddy.exe" | Select-Object -First 1
            if ($found) { Copy-Item $found.FullName $caddyExe }
          }
          Write-Host "Caddy at $caddyExe"

      - name: Start local proxy (Caddy) on :3000
        shell: pwsh
        run: |
          $caddy = Join-Path $env:RUNNER_TEMP "caddy.exe"
          $caddyfile = Join-Path $env:RUNNER_TEMP "Caddyfile"
          
          $lines = @(
            ':3000',
            '',
            '# WebSocket service 1',
            'route /ws* {',
            '  reverse_proxy 127.0.0.1:4001',
            '}',
            '',
            '# WebSocket service 2',
            'route /ws2* {',
            '  reverse_proxy 127.0.0.1:4002',
            '}',
            '',
            '# Everything else to the HTTP app',
            'route /* {',
            '  reverse_proxy 127.0.0.1:4000',
            '}'
          )
          
          $cfg = $lines -join "`r`n"
          Set-Content -Path $caddyfile -Value $cfg -Encoding utf8
          
          $caddyLog = Join-Path $env:RUNNER_TEMP "caddy.log"
          $proc = Start-Process -FilePath $caddy -ArgumentList @("run","--config",$caddyfile) `
            -RedirectStandardOutput $caddyLog -RedirectStandardError $caddyLog -PassThru -WindowStyle Hidden
          Set-Content -Path (Join-Path $env:RUNNER_TEMP "caddy.pid") -Value $proc.Id
          
          Start-Sleep -Seconds 1
          Get-Content $caddyLog -Tail 50


      - name: Download cloudflared (Quick Tunnel)
        shell: pwsh
        run: |
          $cf = Join-Path $env:RUNNER_TEMP "cloudflared.exe"
          Invoke-WebRequest -Uri "https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-windows-amd64.exe" -OutFile $cf
          Write-Host "cloudflared at $cf"

      - name: Start Quick Tunnel (â†’ http://127.0.0.1:3000)
        shell: pwsh
        run: |
          $cf = Join-Path $env:RUNNER_TEMP "cloudflared.exe"
          $log = Join-Path $env:RUNNER_TEMP "cloudflared.log"

          # Quick Tunnel (no secrets): prints a https://*.trycloudflare.com URL
          $proc = Start-Process -FilePath $cf -ArgumentList @("tunnel","--url","http://127.0.0.1:3000") `
            -RedirectStandardOutput $log -RedirectStandardError $log -PassThru -WindowStyle Hidden
          Set-Content -Path (Join-Path $env:RUNNER_TEMP "cloudflared.pid") -Value $proc.Id

          # Tail so the public URL appears in logs
          $null = Start-Job -Name "tail-cloudflared" -ScriptBlock { param($p) Get-Content -Path $p -Wait } -ArgumentList $log
          Start-Sleep -Seconds 3
          Write-Host "==== Cloudflared log (tail) ===="
          Get-Content $log -Tail 80

      - name: Start Wolfram server (your app)
        env:
          WOLFRAMENGINE_INSTALLATION_DIRECTORY: '${{ runner.temp }}\${{ env.WOLFRAMENGINE_INSTALLATION_SUBDIRECTORY }}'
          # If you use the entitlement secret, keep this line; otherwise remove it:
          WOLFRAMINIT: "-pwfile !cloudlm.wolfram.com -entitlement ${{ secrets.WOLFRAM_LICENSE_ENTITLEMENT_ID }}"
        shell: pwsh
        run: |
          # Put Wolfram on PATH
          $env:Path += ';' + (Join-Path $env:WOLFRAMENGINE_INSTALLATION_DIRECTORY '')

          Write-Host "==== Starting Wolfram server (console output below) ===="
          # Your script should start services on 4000/4001/4002 as needed.
          & wolfram -script ./Scripts/start.wls http 4000 ws 4001 ws2 4002 wsprefix ws ws2prefix ws2
          $exitCode = $LASTEXITCODE
          Write-Host "==== Wolfram server exited with code $exitCode ===="
          
          if ($exitCode -ne 0) {
            throw "Wolfram server process exited with non-zero code: $exitCode"
          }

      - name: Cleanup (stop tunnel & proxy)
        if: always()
        shell: pwsh
        run: |
          # Stop cloudflared
          $cfPidFile = Join-Path $env:RUNNER_TEMP "cloudflared.pid"
          if (Test-Path $cfPidFile) {
            $pid = Get-Content $cfPidFile
            try { Stop-Process -Id $pid -Force -ErrorAction Stop } catch {}
            Remove-Item $cfPidFile -Force
          }
          # Stop Caddy
          $caddyPidFile = Join-Path $env:RUNNER_TEMP "caddy.pid"
          if (Test-Path $caddyPidFile) {
            $pid = Get-Content $caddyPidFile
            try { Stop-Process -Id $pid -Force -ErrorAction Stop } catch {}
            Remove-Item $caddyPidFile -Force
          }
          # Stop tail job
          $job = Get-Job -Name "tail-cloudflared" -ErrorAction SilentlyContinue
          if ($job -and $job.State -eq 'Running') { Stop-Job $job -Force }
          if ($job) { Receive-Job $job -Keep | Out-Null; Remove-Job $job -Force }
