<|"Notebook" -> <|"Controller" -> "5aaa4fad-9d68-4e0c-9158-f9d34144d99e", 
   "FocusedCell" -> CoffeeLiqueur`Notebook`Cells`CellObj[
     CoffeeLiqueur`Notebook`Cells`CellObj`$1575], "HaveToSaveAs" -> True, 
   "MessangerChannel" -> Messanger, "ModalsChannel" -> 
    "e45edb62-6142-4d1e-ba3d-59b2e24b6274", 
   "Objects" -> <|"dfbd9007-8bd8-4a34-b67c-0ffcc1868e35" -> 
      <|"Public" -> Hold[Graphics3D[{{GraphicsComplex[
             {{-0.9999998571428571, -0.9999998571428571, 0.8414708304357857}, 
              {-0.8571427346938776, -0.9999998571428571, 0.7559752048365008}, 
              {-0.714285612244898, -0.9999998571428571, 0.6550777429823227}, 
              {-0.5714284897959183, -0.9999998571428571, 0.5408340760316155}, 
              {-0.42857136734693874, -0.9999998571428571, 
               0.4155717436183199}, {-0.28571424489795916, 
               -0.9999998571428571, 0.2818427737989018}, 
              {-0.14285712244897958, -0.9999998571428571, 
               0.14237168939172518}, {0, -0.9999998571428571, 0}, 
              {0.14285712244897958, -0.9999998571428571, 
               -0.14237168939172518}, {0.28571424489795916, 
               -0.9999998571428571, -0.2818427737989018}, 
              {0.42857136734693874, -0.9999998571428571, 
               -0.4155717436183199}, {0.5714284897959183, 
               -0.9999998571428571, -0.5408340760316155}, {0.714285612244898, 
               -0.9999998571428571, -0.6550777429823227}, 
              {0.8571427346938776, -0.9999998571428571, -0.7559752048365008}, 
              {0.9999998571428571, -0.9999998571428571, -0.8414708304357857}, 
              {-0.9999998571428571, -0.8571427346938776, 0.7559752048365008}, 
              {-0.8571427346938776, -0.8571427346938776, 0.6703598774111473}, 
              {-0.714285612244898, -0.8571427346938776, 0.574705898062841}, 
              {-0.5714284897959183, -0.8571427346938776, 0.4704456869528707}, 
              {-0.42857136734693874, -0.8571427346938776, 
               0.3591405427269559}, {-0.28571424489795916, 
               -0.8571427346938776, 0.2424572620383107}, 
              {-0.14285712244897958, -0.8571427346938776, 
               0.12214317923603903}, {0, -0.8571427346938776, 0}, 
              {0.14285712244897958, -0.8571427346938776, 
               -0.12214317923603903}, {0.28571424489795916, 
               -0.8571427346938776, -0.2424572620383107}, 
              {0.42857136734693874, -0.8571427346938776, 
               -0.3591405427269559}, {0.5714284897959183, 
               -0.8571427346938776, -0.4704456869528707}, {0.714285612244898, 
               -0.8571427346938776, -0.574705898062841}, {0.8571427346938776, 
               -0.8571427346938776, -0.6703598774111473}, 
              {0.9999998571428571, -0.8571427346938776, -0.7559752048365008}, 
              {-0.9999998571428571, -0.714285612244898, 0.6550777429823227}, 
              {-0.8571427346938776, -0.714285612244898, 0.574705898062841}, 
              {-0.714285612244898, -0.714285612244898, 0.4883552206318552}, 
              {-0.5714284897959183, -0.714285612244898, 0.39692404188686137}, 
              {-0.42857136734693874, -0.714285612244898, 0.3013635469573115}, 
              {-0.28571424489795916, -0.714285612244898, 
               0.20266787944922382}, {-0.14285712244897958, 
               -0.714285612244898, 0.10186379908027478}, 
              {0, -0.714285612244898, 0}, {0.14285712244897958, 
               -0.714285612244898, -0.10186379908027478}, 
              {0.28571424489795916, -0.714285612244898, 
               -0.20266787944922382}, {0.42857136734693874, 
               -0.714285612244898, -0.3013635469573115}, {0.5714284897959183, 
               -0.714285612244898, -0.39692404188686137}, {0.714285612244898, 
               -0.714285612244898, -0.4883552206318552}, {0.8571427346938776, 
               -0.714285612244898, -0.574705898062841}, {0.9999998571428571, 
               -0.714285612244898, -0.6550777429823227}, 
              {-0.9999998571428571, -0.5714284897959183, 0.5408340760316155}, 
              {-0.8571427346938776, -0.5714284897959183, 0.4704456869528707}, 
              {-0.714285612244898, -0.5714284897959183, 0.39692404188686137}, 
              {-0.5714284897959183, -0.5714284897959183, 
               0.32075880869745665}, {-0.42857136734693874, 
               -0.5714284897959183, 0.24245726203831067}, 
              {-0.28571424489795916, -0.5714284897959183, 
               0.16254090480909056}, {-0.14285712244897958, 
               -0.5714284897959183, 0.08154199484893322}, 
              {0, -0.5714284897959183, 0}, {0.14285712244897958, 
               -0.5714284897959183, -0.08154199484893322}, 
              {0.28571424489795916, -0.5714284897959183, 
               -0.16254090480909056}, {0.42857136734693874, 
               -0.5714284897959183, -0.24245726203831067}, 
              {0.5714284897959183, -0.5714284897959183, 
               -0.32075880869745665}, {0.714285612244898, 
               -0.5714284897959183, -0.39692404188686137}, 
              {0.8571427346938776, -0.5714284897959183, -0.4704456869528707}, 
              {0.9999998571428571, -0.5714284897959183, -0.5408340760316155}, 
              {-0.9999998571428571, -0.42857136734693874, 
               0.4155717436183199}, {-0.8571427346938776, 
               -0.42857136734693874, 0.3591405427269559}, 
              {-0.714285612244898, -0.42857136734693874, 0.3013635469573115}, 
              {-0.5714284897959183, -0.42857136734693874, 
               0.24245726203831067}, {-0.42857136734693874, 
               -0.42857136734693874, 0.1826424254448722}, 
              {-0.28571424489795916, -0.42857136734693874, 
               0.12214317923603901}, {-0.14285712244897958, 
               -0.42857136734693874, 0.06118623013522766}, 
              {0, -0.42857136734693874, 0}, {0.14285712244897958, 
               -0.42857136734693874, -0.06118623013522766}, 
              {0.28571424489795916, -0.42857136734693874, 
               -0.12214317923603901}, {0.42857136734693874, 
               -0.42857136734693874, -0.1826424254448722}, 
              {0.5714284897959183, -0.42857136734693874, 
               -0.24245726203831067}, {0.714285612244898, 
               -0.42857136734693874, -0.3013635469573115}, 
              {0.8571427346938776, -0.42857136734693874, 
               -0.3591405427269559}, {0.9999998571428571, 
               -0.42857136734693874, -0.4155717436183199}, 
              {-0.9999998571428571, -0.28571424489795916, 
               0.2818427737989018}, {-0.8571427346938776, 
               -0.28571424489795916, 0.2424572620383107}, 
              {-0.714285612244898, -0.28571424489795916, 
               0.20266787944922382}, {-0.5714284897959183, 
               -0.28571424489795916, 0.16254090480909056}, 
              {-0.42857136734693874, -0.28571424489795916, 
               0.12214317923603901}, {-0.28571424489795916, 
               -0.28571424489795916, 0.08154199484893322}, 
              {-0.14285712244897958, -0.28571424489795916, 
               0.040804982676179914}, {0, -0.28571424489795916, 0}, 
              {0.14285712244897958, -0.28571424489795916, 
               -0.040804982676179914}, {0.28571424489795916, 
               -0.28571424489795916, -0.08154199484893322}, 
              {0.42857136734693874, -0.28571424489795916, 
               -0.12214317923603901}, {0.5714284897959183, 
               -0.28571424489795916, -0.16254090480909056}, 
              {0.714285612244898, -0.28571424489795916, 
               -0.20266787944922382}, {0.8571427346938776, 
               -0.28571424489795916, -0.2424572620383107}, 
              {0.9999998571428571, -0.28571424489795916, 
               -0.2818427737989018}, {-0.9999998571428571, 
               -0.14285712244897958, 0.14237168939172518}, 
              {-0.8571427346938776, -0.14285712244897958, 
               0.12214317923603903}, {-0.714285612244898, 
               -0.14285712244897958, 0.10186379908027478}, 
              {-0.5714284897959183, -0.14285712244897958, 
               0.08154199484893322}, {-0.42857136734693874, 
               -0.14285712244897958, 0.06118623013522766}, 
              {-0.28571424489795916, -0.14285712244897958, 
               0.040804982676179914}, {-0.14285712244897958, 
               -0.14285712244897958, 0.020406740821825736}, 
              {0, -0.14285712244897958, 0}, {0.14285712244897958, 
               -0.14285712244897958, -0.020406740821825736}, 
              {0.28571424489795916, -0.14285712244897958, 
               -0.040804982676179914}, {0.42857136734693874, 
               -0.14285712244897958, -0.06118623013522766}, 
              {0.5714284897959183, -0.14285712244897958, 
               -0.08154199484893322}, {0.714285612244898, 
               -0.14285712244897958, -0.10186379908027478}, 
              {0.8571427346938776, -0.14285712244897958, 
               -0.12214317923603903}, {0.9999998571428571, 
               -0.14285712244897958, -0.14237168939172518}, 
              {-0.9999998571428571, 0, 0}, {-0.8571427346938776, 0, 0}, 
              {-0.714285612244898, 0, 0}, {-0.5714284897959183, 0, 0}, 
              {-0.42857136734693874, 0, 0}, {-0.28571424489795916, 0, 0}, 
              {-0.14285712244897958, 0, 0}, {0, 0, 0}, {0.14285712244897958, 
               0, 0}, {0.28571424489795916, 0, 0}, {0.42857136734693874, 0, 
               0}, {0.5714284897959183, 0, 0}, {0.714285612244898, 0, 0}, 
              {0.8571427346938776, 0, 0}, {0.9999998571428571, 0, 0}, 
              {-0.9999998571428571, 0.14285712244897958, 
               -0.14237168939172518}, {-0.8571427346938776, 
               0.14285712244897958, -0.12214317923603903}, 
              {-0.714285612244898, 0.14285712244897958, 
               -0.10186379908027478}, {-0.5714284897959183, 
               0.14285712244897958, -0.08154199484893322}, 
              {-0.42857136734693874, 0.14285712244897958, 
               -0.06118623013522766}, {-0.28571424489795916, 
               0.14285712244897958, -0.040804982676179914}, 
              {-0.14285712244897958, 0.14285712244897958, 
               -0.020406740821825736}, {0, 0.14285712244897958, 0}, 
              {0.14285712244897958, 0.14285712244897958, 
               0.020406740821825736}, {0.28571424489795916, 
               0.14285712244897958, 0.040804982676179914}, 
              {0.42857136734693874, 0.14285712244897958, 
               0.06118623013522766}, {0.5714284897959183, 
               0.14285712244897958, 0.08154199484893322}, {0.714285612244898, 
               0.14285712244897958, 0.10186379908027478}, 
              {0.8571427346938776, 0.14285712244897958, 0.12214317923603903}, 
              {0.9999998571428571, 0.14285712244897958, 0.14237168939172518}, 
              {-0.9999998571428571, 0.28571424489795916, 
               -0.2818427737989018}, {-0.8571427346938776, 
               0.28571424489795916, -0.2424572620383107}, 
              {-0.714285612244898, 0.28571424489795916, 
               -0.20266787944922382}, {-0.5714284897959183, 
               0.28571424489795916, -0.16254090480909056}, 
              {-0.42857136734693874, 0.28571424489795916, 
               -0.12214317923603901}, {-0.28571424489795916, 
               0.28571424489795916, -0.08154199484893322}, 
              {-0.14285712244897958, 0.28571424489795916, 
               -0.040804982676179914}, {0, 0.28571424489795916, 0}, 
              {0.14285712244897958, 0.28571424489795916, 
               0.040804982676179914}, {0.28571424489795916, 
               0.28571424489795916, 0.08154199484893322}, 
              {0.42857136734693874, 0.28571424489795916, 
               0.12214317923603901}, {0.5714284897959183, 
               0.28571424489795916, 0.16254090480909056}, {0.714285612244898, 
               0.28571424489795916, 0.20266787944922382}, 
              {0.8571427346938776, 0.28571424489795916, 0.2424572620383107}, 
              {0.9999998571428571, 0.28571424489795916, 0.2818427737989018}, 
              {-0.9999998571428571, 0.42857136734693874, 
               -0.4155717436183199}, {-0.8571427346938776, 
               0.42857136734693874, -0.3591405427269559}, 
              {-0.714285612244898, 0.42857136734693874, -0.3013635469573115}, 
              {-0.5714284897959183, 0.42857136734693874, 
               -0.24245726203831067}, {-0.42857136734693874, 
               0.42857136734693874, -0.1826424254448722}, 
              {-0.28571424489795916, 0.42857136734693874, 
               -0.12214317923603901}, {-0.14285712244897958, 
               0.42857136734693874, -0.06118623013522766}, 
              {0, 0.42857136734693874, 0}, {0.14285712244897958, 
               0.42857136734693874, 0.06118623013522766}, 
              {0.28571424489795916, 0.42857136734693874, 
               0.12214317923603901}, {0.42857136734693874, 
               0.42857136734693874, 0.1826424254448722}, {0.5714284897959183, 
               0.42857136734693874, 0.24245726203831067}, {0.714285612244898, 
               0.42857136734693874, 0.3013635469573115}, {0.8571427346938776, 
               0.42857136734693874, 0.3591405427269559}, {0.9999998571428571, 
               0.42857136734693874, 0.4155717436183199}, 
              {-0.9999998571428571, 0.5714284897959183, -0.5408340760316155}, 
              {-0.8571427346938776, 0.5714284897959183, -0.4704456869528707}, 
              {-0.714285612244898, 0.5714284897959183, -0.39692404188686137}, 
              {-0.5714284897959183, 0.5714284897959183, 
               -0.32075880869745665}, {-0.42857136734693874, 
               0.5714284897959183, -0.24245726203831067}, 
              {-0.28571424489795916, 0.5714284897959183, 
               -0.16254090480909056}, {-0.14285712244897958, 
               0.5714284897959183, -0.08154199484893322}, 
              {0, 0.5714284897959183, 0}, {0.14285712244897958, 
               0.5714284897959183, 0.08154199484893322}, 
              {0.28571424489795916, 0.5714284897959183, 0.16254090480909056}, 
              {0.42857136734693874, 0.5714284897959183, 0.24245726203831067}, 
              {0.5714284897959183, 0.5714284897959183, 0.32075880869745665}, 
              {0.714285612244898, 0.5714284897959183, 0.39692404188686137}, 
              {0.8571427346938776, 0.5714284897959183, 0.4704456869528707}, 
              {0.9999998571428571, 0.5714284897959183, 0.5408340760316155}, 
              {-0.9999998571428571, 0.714285612244898, -0.6550777429823227}, 
              {-0.8571427346938776, 0.714285612244898, -0.574705898062841}, 
              {-0.714285612244898, 0.714285612244898, -0.4883552206318552}, 
              {-0.5714284897959183, 0.714285612244898, -0.39692404188686137}, 
              {-0.42857136734693874, 0.714285612244898, -0.3013635469573115}, 
              {-0.28571424489795916, 0.714285612244898, 
               -0.20266787944922382}, {-0.14285712244897958, 
               0.714285612244898, -0.10186379908027478}, 
              {0, 0.714285612244898, 0}, {0.14285712244897958, 
               0.714285612244898, 0.10186379908027478}, {0.28571424489795916, 
               0.714285612244898, 0.20266787944922382}, {0.42857136734693874, 
               0.714285612244898, 0.3013635469573115}, {0.5714284897959183, 
               0.714285612244898, 0.39692404188686137}, {0.714285612244898, 
               0.714285612244898, 0.4883552206318552}, {0.8571427346938776, 
               0.714285612244898, 0.574705898062841}, {0.9999998571428571, 
               0.714285612244898, 0.6550777429823227}, {-0.9999998571428571, 
               0.8571427346938776, -0.7559752048365008}, 
              {-0.8571427346938776, 0.8571427346938776, -0.6703598774111473}, 
              {-0.714285612244898, 0.8571427346938776, -0.574705898062841}, 
              {-0.5714284897959183, 0.8571427346938776, -0.4704456869528707}, 
              {-0.42857136734693874, 0.8571427346938776, 
               -0.3591405427269559}, {-0.28571424489795916, 
               0.8571427346938776, -0.2424572620383107}, 
              {-0.14285712244897958, 0.8571427346938776, 
               -0.12214317923603903}, {0, 0.8571427346938776, 0}, 
              {0.14285712244897958, 0.8571427346938776, 0.12214317923603903}, 
              {0.28571424489795916, 0.8571427346938776, 0.2424572620383107}, 
              {0.42857136734693874, 0.8571427346938776, 0.3591405427269559}, 
              {0.5714284897959183, 0.8571427346938776, 0.4704456869528707}, 
              {0.714285612244898, 0.8571427346938776, 0.574705898062841}, 
              {0.8571427346938776, 0.8571427346938776, 0.6703598774111473}, 
              {0.9999998571428571, 0.8571427346938776, 0.7559752048365008}, 
              {-0.9999998571428571, 0.9999998571428571, -0.8414708304357857}, 
              {-0.8571427346938776, 0.9999998571428571, -0.7559752048365008}, 
              {-0.714285612244898, 0.9999998571428571, -0.6550777429823227}, 
              {-0.5714284897959183, 0.9999998571428571, -0.5408340760316155}, 
              {-0.42857136734693874, 0.9999998571428571, 
               -0.4155717436183199}, {-0.28571424489795916, 
               0.9999998571428571, -0.2818427737989018}, 
              {-0.14285712244897958, 0.9999998571428571, 
               -0.14237168939172518}, {0, 0.9999998571428571, 0}, 
              {0.14285712244897958, 0.9999998571428571, 0.14237168939172518}, 
              {0.28571424489795916, 0.9999998571428571, 0.2818427737989018}, 
              {0.42857136734693874, 0.9999998571428571, 0.4155717436183199}, 
              {0.5714284897959183, 0.9999998571428571, 0.5408340760316155}, 
              {0.714285612244898, 0.9999998571428571, 0.6550777429823227}, 
              {0.8571427346938776, 0.9999998571428571, 0.7559752048365008}, 
              {0.9999998571428571, 0.9999998571428571, 0.8414708304357857}, 
              {-0.9285712959183674, -0.9285712959183674, 0.7593051472953566}, 
              {-0.9999998571428571, -0.9285712959183674, 0.8007649157360611}, 
              {0.9285712959183674, -0.9285712959183674, -0.7593051472953566}, 
              {0.9999998571428571, -0.9285712959183674, -0.8007649157360611}, 
              {-0.9285712959183674, 0.9285712959183674, -0.7593051472953566}, 
              {-0.9999998571428571, 0.9285712959183674, -0.8007649157360611}, 
              {0.9285712959183674, 0.9285712959183674, 0.7593051472953566}, 
              {0.9285712959183674, 0.9999998571428571, 0.8007649157360611}, 
              {-0.9285712959183674, -0.9999998571428571, 0.8007649157360611}, 
              {0.9285712959183674, -0.9999998571428571, -0.8007649157360611}, 
              {-0.9285712959183674, 0.9999998571428571, -0.8007649157360611}, 
              {0.9999998571428571, 0.9285712959183674, 0.8007649157360611}, 
              {-0.9642855765306122, -0.9642855765306122, 0.8015282674331955}, 
              {0.9642855765306122, -0.9642855765306122, -0.8015282674331955}, 
              {-0.9642855765306122, 0.9642855765306122, -0.8015282674331955}, 
              {0.9642855765306122, 0.9642855765306122, 0.8015282674331955}, 
              {-0.9999998571428571, -0.9642855765306122, 0.8216418233558735}, 
              {0.9642855765306122, -0.9999998571428571, -0.8216418233558735}, 
              {-0.9642855765306122, 0.9999998571428571, -0.8216418233558735}, 
              {0.9999998571428571, 0.9642855765306122, 0.8216418233558735}, 
              {-0.9642855765306122, -0.9999998571428571, 0.8216418233558735}, 
              {0.9999998571428571, -0.9642855765306122, -0.8216418233558735}, 
              {-0.9999998571428571, 0.9642855765306122, -0.8216418233558735}, 
              {0.9642855765306122, 0.9999998571428571, 0.8216418233558735}, 
              {-0.7777776666666667, -0.9999998571428571, 0.6999210593619575}, 
              {-0.7777776666666667, -0.8571427346938776, 0.6172187777731994}, 
              {-0.5555554761904762, -0.9999998571428571, 0.526916039096805}, 
              {-0.5555554761904762, -0.8571427346938776, 
               0.45807844870554687}, {-0.3333332857142857, 
               -0.9999998571428571, 0.3264190970720412}, 
              {-0.3333332857142857, -0.8571427346938776, 0.2813516889345258}, 
              {-0.11111109523809526, -0.9999998571428571, 
               0.11073353619356406}, {-0.11111109523809526, 
               -0.8571427346938776, 0.09500025051691927}, 
              {0.1111110952380952, -0.9999998571428571, 
               -0.11073353619356399}, {0.1111110952380952, 
               -0.8571427346938776, -0.09500025051691921}, 
              {0.33333328571428567, -0.9999998571428571, 
               -0.32641909707204114}, {0.33333328571428567, 
               -0.8571427346938776, -0.2813516889345257}, 
              {0.5555554761904762, -0.9999998571428571, -0.5269160390968048}, 
              {0.5555554761904762, -0.8571427346938776, 
               -0.45807844870554687}, {0.7777776666666667, 
               -0.9999998571428571, -0.6999210593619575}, 
              {0.7777776666666667, -0.8571427346938776, -0.6172187777731994}, 
              {-0.7777776666666667, -0.714285612244898, 0.5267332994900711}, 
              {-0.5555554761904762, -0.714285612244898, 0.38630620911691144}, 
              {-0.3333332857142857, -0.714285612244898, 0.23556643528525306}, 
              {-0.11111109523809526, -0.714285612244898, 
               0.07922739928465818}, {0.1111110952380952, -0.714285612244898, 
               -0.07922739928465813}, {0.33333328571428567, 
               -0.714285612244898, -0.23556643528525303}, 
              {0.5555554761904762, -0.714285612244898, -0.3863062091169114}, 
              {0.7777776666666667, -0.714285612244898, -0.5267332994900711}, 
              {-0.7777776666666667, -0.5714284897959183, 0.4296003285828655}, 
              {-0.5555554761904762, -0.5714284897959183, 0.3120586368464405}, 
              {-0.3333332857142857, -0.5714284897959183, 
               0.18917969055216394}, {-0.11111109523809526, 
               -0.5714284897959183, 0.0634215515491703}, {0.1111110952380952, 
               -0.5714284897959183, -0.06342155154917027}, 
              {0.33333328571428567, -0.5714284897959183, 
               -0.1891796905521639}, {0.5555554761904762, 
               -0.5714284897959183, -0.3120586368464405}, 
              {0.7777776666666667, -0.5714284897959183, -0.4296003285828655}, 
              {-0.7777776666666667, -0.42857136734693874, 
               0.32704221174382014}, {-0.5555554761904762, 
               -0.42857136734693874, 0.23581116908348418}, 
              {-0.3333332857142857, -0.42857136734693874, 
               0.14230959463898343}, {-0.11111109523809526, 
               -0.42857136734693874, 0.04758929010517708}, 
              {0.1111110952380952, -0.42857136734693874, 
               -0.047589290105177054}, {0.33333328571428567, 
               -0.42857136734693874, -0.1423095946389834}, 
              {0.5555554761904762, -0.42857136734693874, 
               -0.23581116908348418}, {0.7777776666666667, 
               -0.42857136734693874, -0.32704221174382014}, 
              {-0.7777776666666667, -0.28571424489795916, 0.220352049488818}, 
              {-0.5555554761904762, -0.28571424489795916, 
               0.15805226863430707}, {-0.3333332857142857, 
               -0.28571424489795916, 0.0950757229779685}, 
              {-0.11111109523809526, -0.28571424489795916, 
               0.03173720874813994}, {0.1111110952380952, 
               -0.28571424489795916, -0.03173720874813993}, 
              {0.33333328571428567, -0.28571424489795916, 
               -0.09507572297796849}, {0.5555554761904762, 
               -0.28571424489795916, -0.15805226863430707}, 
              {0.7777776666666667, -0.28571424489795916, -0.220352049488818}, 
              {-0.7777776666666667, -0.14285712244897958, 
               0.11087685692728111}, {-0.5555554761904762, 
               -0.14285712244897958, 0.07928024321407705}, 
              {-0.3333332857142857, -0.14285712244897958, 
               0.047598731829195835}, {-0.11111109523809526, 
               -0.14285712244897958, 0.01587190952808669}, 
              {0.1111110952380952, -0.14285712244897958, 
               -0.01587190952808668}, {0.33333328571428567, 
               -0.14285712244897958, -0.04759873182919583}, 
              {0.5555554761904762, -0.14285712244897958, 
               -0.07928024321407705}, {0.7777776666666667, 
               -0.14285712244897958, -0.11087685692728111}, 
              {-0.7777776666666667, 0, 0}, {-0.5555554761904762, 0, 0}, 
              {-0.3333332857142857, 0, 0}, {-0.11111109523809526, 0, 0}, 
              {0.1111110952380952, 0, 0}, {0.33333328571428567, 0, 0}, 
              {0.5555554761904762, 0, 0}, {0.7777776666666667, 0, 0}, 
              {-0.7777776666666667, 0.14285712244897958, 
               -0.11087685692728111}, {-0.5555554761904762, 
               0.14285712244897958, -0.07928024321407705}, 
              {-0.3333332857142857, 0.14285712244897958, 
               -0.047598731829195835}, {-0.11111109523809526, 
               0.14285712244897958, -0.01587190952808669}, 
              {0.1111110952380952, 0.14285712244897958, 0.01587190952808668}, 
              {0.33333328571428567, 0.14285712244897958, 
               0.04759873182919583}, {0.5555554761904762, 
               0.14285712244897958, 0.07928024321407705}, 
              {0.7777776666666667, 0.14285712244897958, 0.11087685692728111}, 
              {-0.7777776666666667, 0.28571424489795916, -0.220352049488818}, 
              {-0.5555554761904762, 0.28571424489795916, 
               -0.15805226863430707}, {-0.3333332857142857, 
               0.28571424489795916, -0.0950757229779685}, 
              {-0.11111109523809526, 0.28571424489795916, 
               -0.03173720874813994}, {0.1111110952380952, 
               0.28571424489795916, 0.03173720874813993}, 
              {0.33333328571428567, 0.28571424489795916, 
               0.09507572297796849}, {0.5555554761904762, 
               0.28571424489795916, 0.15805226863430707}, 
              {0.7777776666666667, 0.28571424489795916, 0.220352049488818}, 
              {-0.7777776666666667, 0.42857136734693874, 
               -0.32704221174382014}, {-0.5555554761904762, 
               0.42857136734693874, -0.23581116908348418}, 
              {-0.3333332857142857, 0.42857136734693874, 
               -0.14230959463898343}, {-0.11111109523809526, 
               0.42857136734693874, -0.04758929010517708}, 
              {0.1111110952380952, 0.42857136734693874, 
               0.047589290105177054}, {0.33333328571428567, 
               0.42857136734693874, 0.1423095946389834}, {0.5555554761904762, 
               0.42857136734693874, 0.23581116908348418}, 
              {0.7777776666666667, 0.42857136734693874, 0.32704221174382014}, 
              {-0.7777776666666667, 0.5714284897959183, -0.4296003285828655}, 
              {-0.5555554761904762, 0.5714284897959183, -0.3120586368464405}, 
              {-0.3333332857142857, 0.5714284897959183, 
               -0.18917969055216394}, {-0.11111109523809526, 
               0.5714284897959183, -0.0634215515491703}, {0.1111110952380952, 
               0.5714284897959183, 0.06342155154917027}, 
              {0.33333328571428567, 0.5714284897959183, 0.1891796905521639}, 
              {0.5555554761904762, 0.5714284897959183, 0.3120586368464405}, 
              {0.7777776666666667, 0.5714284897959183, 0.4296003285828655}, 
              {-0.7777776666666667, 0.714285612244898, -0.5267332994900711}, 
              {-0.5555554761904762, 0.714285612244898, -0.38630620911691144}, 
              {-0.3333332857142857, 0.714285612244898, -0.23556643528525306}, 
              {-0.11111109523809526, 0.714285612244898, 
               -0.07922739928465818}, {0.1111110952380952, 0.714285612244898, 
               0.07922739928465813}, {0.33333328571428567, 0.714285612244898, 
               0.23556643528525303}, {0.5555554761904762, 0.714285612244898, 
               0.3863062091169114}, {0.7777776666666667, 0.714285612244898, 
               0.5267332994900711}, {-0.7777776666666667, 0.8571427346938776, 
               -0.6172187777731994}, {-0.5555554761904762, 
               0.8571427346938776, -0.45807844870554687}, 
              {-0.3333332857142857, 0.8571427346938776, -0.2813516889345258}, 
              {-0.11111109523809526, 0.8571427346938776, 
               -0.09500025051691927}, {0.1111110952380952, 
               0.8571427346938776, 0.09500025051691921}, 
              {0.33333328571428567, 0.8571427346938776, 0.2813516889345257}, 
              {0.5555554761904762, 0.8571427346938776, 0.45807844870554687}, 
              {0.7777776666666667, 0.8571427346938776, 0.6172187777731994}, 
              {-0.7777776666666667, 0.9999998571428571, -0.6999210593619575}, 
              {-0.5555554761904762, 0.9999998571428571, -0.526916039096805}, 
              {-0.3333332857142857, 0.9999998571428571, -0.3264190970720412}, 
              {-0.11111109523809526, 0.9999998571428571, 
               -0.11073353619356406}, {0.1111110952380952, 
               0.9999998571428571, 0.11073353619356399}, 
              {0.33333328571428567, 0.9999998571428571, 0.32641909707204114}, 
              {0.5555554761904762, 0.9999998571428571, 0.5269160390968048}, 
              {0.7777776666666667, 0.9999998571428571, 0.6999210593619575}, 
              {-0.7777776666666667, -0.9206347891156463, 0.6552700344066898}, 
              {-0.5555554761904762, -0.984126843537415, 0.5206459056644311}, 
              {-0.3333332857142857, -0.9047617755102041, 0.3001620892316471}, 
              {-0.11111109523809526, -0.9682538299319728, 
               0.11073353619356406}, {0.1111110952380952, -0.888888761904762, 
               -0.09500025051691921}, {0.33333328571428567, 
               -0.9523808163265306, -0.3076086967749198}, 
              {0.5555554761904762, -0.8730157482993197, 
               -0.46434858213792063}, {0.7777776666666667, 
               -0.9365078027210884, -0.661869802728467}, 
              {-0.7777776666666667, -0.7777776666666667, 0.5692461792004295}, 
              {-0.5555554761904762, -0.8412697210884355, 0.4516587825089197}, 
              {-0.3333332857142857, -0.7619046530612246, 
               0.25482543387513457}, {-0.11111109523809526, 
               -0.8253967074829932, 0.09500025051691927}, 
              {0.1111110952380952, -0.7460316394557823, 
               -0.07922739928465813}, {0.33333328571428567, 
               -0.8095236938775511, -0.2620926903446443}, 
              {0.5555554761904762, -0.7301586258503401, 
               -0.39272587531353853}, {0.7777776666666667, 
               -0.7936506802721088, -0.574705898062841}, 
              {-0.7777776666666667, -0.6349205442176871, 0.4759382001872968}, 
              {-0.5555554761904762, -0.6984125986394558, 
               0.37976106634813356}, {-0.3333332857142857, 
               -0.6190475306122449, 0.20881511885849757}, 
              {-0.11111109523809526, -0.6825395850340136, 
               0.07922739928465818}, {0.1111110952380952, 
               -0.6031745170068027, -0.06342155154917027}, 
              {0.33333328571428567, -0.6666665714285714, 
               -0.21593100697891943}, {0.5555554761904762, 
               -0.5873015034013604, -0.3186037796152183}, 
              {0.7777776666666667, -0.6507935578231292, -0.4803954278856399}, 
              {-0.7777776666666667, -0.4920634217687075, 
               0.37651116473311563}, {-0.5555554761904762, 
               -0.5555554761904762, 0.305412543891614}, {-0.3333332857142857, 
               -0.4761904081632653, 0.16224787350346292}, 
              {-0.11111109523809526, -0.5396824625850339, 
               0.0634215515491703}, {0.1111110952380952, -0.4603173945578231, 
               -0.047589290105177054}, {0.33333328571428567, 
               -0.5238094489795918, -0.16924141168768445}, 
              {0.5555554761904762, -0.44444438095238087, 
               -0.24245726203831067}, {0.7777776666666667, 
               -0.5079364353741496, -0.38013137559357}, {-0.7777776666666667, 
               -0.3492062993197279, 0.2722112853504381}, 
              {-0.5555554761904762, -0.4126983537414966, 
               0.22908903061583608}, {-0.3333332857142857, 
               -0.3333332857142857, 0.1152421383809129}, 
              {-0.11111109523809526, -0.3968253401360544, 
               0.04758929010517708}, {0.1111110952380952, 
               -0.31746027210884353, -0.03173720874813993}, 
              {0.33333328571428567, -0.38095232653061223, 
               -0.12214317923603901}, {0.5555554761904762, 
               -0.3015872585034013, -0.16477440710195518}, 
              {0.7777776666666667, -0.36507931292517, -0.27518297588220003}, 
              {-0.7777776666666667, -0.2063491768707483, 
               0.16434978261717964}, {-0.5555554761904762, 
               -0.269841231292517, 0.15127927428977248}, 
              {-0.3333332857142857, -0.19047616326530614, 
               0.06791771486279963}, {-0.11111109523809526, 
               -0.25396821768707484, 0.03173720874813994}, 
              {0.1111110952380952, -0.17460314965986395, 
               -0.01587190952808668}, {0.33333328571428567, 
               -0.23809520408163265, -0.0747567399443647}, 
              {0.5555554761904762, -0.1587301360544217, 
               -0.08605323755861163}, {0.7777776666666667, 
               -0.22222219047619043, -0.16687912379891945}, 
              {-0.7777776666666667, -0.06349205442176872, 
               0.05428585743823959}, {-0.5555554761904762, 
               -0.12698410884353745, 0.07248177319905177}, 
              {-0.3333332857142857, -0.04761904081632656, 
               0.0203954100450759}, {-0.11111109523809526, 
               -0.11111109523809526, 0.01587190952808669}, 
              {0.1111110952380952, -0.03174602721088438, 0}, 
              {0.33333328571428567, -0.09523808163265307, 
               -0.02720332178411995}, {0.5555554761904762, 
               -0.015873013605442136, -0.006798470015025278}, 
              {0.7777776666666667, -0.07936506802721086, 
               -0.056590999489041525}, {-0.7777776666666667, 
               0.07936506802721086, -0.056590999489041525}, 
              {-0.5555554761904762, 0.015873013605442132, 
               -0.006798470015025277}, {-0.3333332857142857, 
               0.09523808163265302, -0.02720332178411993}, 
              {-0.11111109523809526, 0.03174602721088432, 0}, 
              {0.1111110952380952, 0.1111110952380952, 0.01587190952808668}, 
              {0.33333328571428567, 0.04761904081632651, 
               0.020395410045075876}, {0.5555554761904762, 
               0.12698410884353745, 0.07248177319905177}, 
              {0.7777776666666667, 0.06349205442176872, 0.05428585743823959}, 
              {-0.7777776666666667, 0.22222219047619043, 
               -0.16687912379891945}, {-0.5555554761904762, 
               0.1587301360544217, -0.08605323755861163}, 
              {-0.3333332857142857, 0.2380952040816326, -0.0747567399443647}, 
              {-0.11111109523809526, 0.1746031496598639, 
               -0.01587190952808669}, {0.1111110952380952, 
               0.2539682176870748, 0.03173720874813993}, 
              {0.33333328571428567, 0.1904761632653061, 0.0679177148627996}, 
              {0.5555554761904762, 0.269841231292517, 0.15127927428977248}, 
              {0.7777776666666667, 0.2063491768707483, 0.16434978261717967}, 
              {-0.7777776666666667, 0.36507931292517, -0.27518297588220003}, 
              {-0.5555554761904762, 0.3015872585034013, 
               -0.16477440710195518}, {-0.3333332857142857, 
               0.3809523265306122, -0.12214317923603901}, 
              {-0.11111109523809526, 0.3174602721088435, 
               -0.03173720874813994}, {0.1111110952380952, 
               0.39682534013605436, 0.047589290105177054}, 
              {0.33333328571428567, 0.33333328571428567, 
               0.11524213838091286}, {0.5555554761904762, 0.4126983537414966, 
               0.22908903061583608}, {0.7777776666666667, 0.3492062993197279, 
               0.2722112853504381}, {-0.7777776666666667, 0.5079364353741496, 
               -0.38013137559357}, {-0.5555554761904762, 0.44444438095238087, 
               -0.24245726203831067}, {-0.3333332857142857, 
               0.5238094489795918, -0.16924141168768445}, 
              {-0.11111109523809526, 0.46031739455782306, 
               -0.04758929010517708}, {0.1111110952380952, 
               0.5396824625850339, 0.06342155154917027}, 
              {0.33333328571428567, 0.47619040816326524, 
               0.16224787350346287}, {0.5555554761904762, 0.5555554761904762, 
               0.305412543891614}, {0.7777776666666667, 0.4920634217687075, 
               0.37651116473311563}, {-0.7777776666666667, 
               0.6507935578231292, -0.4803954278856399}, 
              {-0.5555554761904762, 0.5873015034013604, -0.3186037796152183}, 
              {-0.3333332857142857, 0.6666665714285713, 
               -0.21593100697891945}, {-0.11111109523809526, 
               0.6031745170068027, -0.0634215515491703}, {0.1111110952380952, 
               0.6825395850340136, 0.07922739928465813}, 
              {0.33333328571428567, 0.6190475306122448, 0.20881511885849752}, 
              {0.5555554761904762, 0.6984125986394558, 0.37976106634813356}, 
              {0.7777776666666667, 0.6349205442176871, 0.4759382001872968}, 
              {-0.7777776666666667, 0.7936506802721088, -0.574705898062841}, 
              {-0.5555554761904762, 0.7301586258503401, 
               -0.39272587531353853}, {-0.3333332857142857, 
               0.809523693877551, -0.26209269034464433}, 
              {-0.11111109523809526, 0.7460316394557823, 
               -0.07922739928465818}, {0.1111110952380952, 
               0.8253967074829932, 0.09500025051691921}, 
              {0.33333328571428567, 0.7619046530612245, 0.2548254338751345}, 
              {0.5555554761904762, 0.8412697210884355, 0.4516587825089197}, 
              {0.7777776666666667, 0.7777776666666667, 0.5692461792004295}, 
              {-0.7777776666666667, 0.9365078027210884, -0.661869802728467}, 
              {-0.5555554761904762, 0.8730157482993197, 
               -0.46434858213792063}, {-0.3333332857142857, 
               0.9523808163265306, -0.30760869677491987}, 
              {-0.11111109523809526, 0.8888887619047618, 
               -0.09500025051691927}, {0.1111110952380952, 
               0.9682538299319727, 0.11073353619356399}, 
              {0.33333328571428567, 0.9047617755102041, 0.30016208923164706}, 
              {0.5555554761904762, 0.984126843537415, 0.5206459056644311}, 
              {0.7777776666666667, 0.9206347891156463, 0.6552700344066898}, 
              {-0.8571427346938776, -0.7777776666666667, 0.6172187777731994}, 
              {-0.9999998571428571, -0.7777776666666667, 0.6999210593619575}, 
              {-0.714285612244898, -0.7777776666666667, 0.5267332994900711}, 
              {-0.5714284897959183, -0.7777776666666667, 0.4296003285828655}, 
              {-0.42857136734693874, -0.7777776666666667, 
               0.32704221174382014}, {-0.28571424489795916, 
               -0.7777776666666667, 0.220352049488818}, 
              {-0.14285712244897958, -0.7777776666666667, 
               0.11087685692728111}, {0, -0.7777776666666667, 0}, 
              {0.14285712244897958, -0.7777776666666667, 
               -0.11087685692728111}, {0.28571424489795916, 
               -0.7777776666666667, -0.220352049488818}, 
              {0.42857136734693874, -0.7777776666666667, 
               -0.32704221174382014}, {0.5714284897959183, 
               -0.7777776666666667, -0.4296003285828655}, {0.714285612244898, 
               -0.7777776666666667, -0.5267332994900711}, 
              {0.8571427346938776, -0.7777776666666667, -0.6172187777731994}, 
              {0.9999998571428571, -0.7777776666666667, -0.6999210593619575}, 
              {-0.8571427346938776, -0.5555554761904762, 
               0.45807844870554687}, {-0.9999998571428571, 
               -0.5555554761904762, 0.526916039096805}, {-0.714285612244898, 
               -0.5555554761904762, 0.38630620911691144}, 
              {-0.5714284897959183, -0.5555554761904762, 0.3120586368464405}, 
              {-0.42857136734693874, -0.5555554761904762, 
               0.23581116908348418}, {-0.28571424489795916, 
               -0.5555554761904762, 0.15805226863430707}, 
              {-0.14285712244897958, -0.5555554761904762, 
               0.07928024321407705}, {0, -0.5555554761904762, 0}, 
              {0.14285712244897958, -0.5555554761904762, 
               -0.07928024321407705}, {0.28571424489795916, 
               -0.5555554761904762, -0.15805226863430707}, 
              {0.42857136734693874, -0.5555554761904762, 
               -0.23581116908348418}, {0.5714284897959183, 
               -0.5555554761904762, -0.3120586368464405}, {0.714285612244898, 
               -0.5555554761904762, -0.38630620911691144}, 
              {0.8571427346938776, -0.5555554761904762, 
               -0.45807844870554687}, {0.9999998571428571, 
               -0.5555554761904762, -0.526916039096805}, 
              {-0.8571427346938776, -0.3333332857142857, 0.2813516889345258}, 
              {-0.9999998571428571, -0.3333332857142857, 0.3264190970720412}, 
              {-0.714285612244898, -0.3333332857142857, 0.23556643528525306}, 
              {-0.5714284897959183, -0.3333332857142857, 
               0.18917969055216394}, {-0.42857136734693874, 
               -0.3333332857142857, 0.14230959463898343}, 
              {-0.28571424489795916, -0.3333332857142857, 
               0.0950757229779685}, {-0.14285712244897958, 
               -0.3333332857142857, 0.047598731829195835}, 
              {0, -0.3333332857142857, 0}, {0.14285712244897958, 
               -0.3333332857142857, -0.047598731829195835}, 
              {0.28571424489795916, -0.3333332857142857, 
               -0.0950757229779685}, {0.42857136734693874, 
               -0.3333332857142857, -0.14230959463898343}, 
              {0.5714284897959183, -0.3333332857142857, 
               -0.18917969055216394}, {0.714285612244898, 
               -0.3333332857142857, -0.23556643528525306}, 
              {0.8571427346938776, -0.3333332857142857, -0.2813516889345258}, 
              {0.9999998571428571, -0.3333332857142857, -0.3264190970720412}, 
              {-0.8571427346938776, -0.11111109523809526, 
               0.09500025051691927}, {-0.9999998571428571, 
               -0.11111109523809526, 0.11073353619356406}, 
              {-0.714285612244898, -0.11111109523809526, 
               0.07922739928465818}, {-0.5714284897959183, 
               -0.11111109523809526, 0.0634215515491703}, 
              {-0.42857136734693874, -0.11111109523809526, 
               0.04758929010517708}, {-0.28571424489795916, 
               -0.11111109523809526, 0.03173720874813994}, 
              {-0.14285712244897958, -0.11111109523809526, 
               0.01587190952808669}, {0, -0.11111109523809526, 0}, 
              {0.14285712244897958, -0.11111109523809526, 
               -0.01587190952808669}, {0.28571424489795916, 
               -0.11111109523809526, -0.03173720874813994}, 
              {0.42857136734693874, -0.11111109523809526, 
               -0.04758929010517708}, {0.5714284897959183, 
               -0.11111109523809526, -0.0634215515491703}, 
              {0.714285612244898, -0.11111109523809526, 
               -0.07922739928465818}, {0.8571427346938776, 
               -0.11111109523809526, -0.09500025051691927}, 
              {0.9999998571428571, -0.11111109523809526, 
               -0.11073353619356406}, {-0.8571427346938776, 
               0.1111110952380952, -0.09500025051691921}, 
              {-0.9999998571428571, 0.1111110952380952, 
               -0.11073353619356399}, {-0.714285612244898, 
               0.1111110952380952, -0.07922739928465813}, 
              {-0.5714284897959183, 0.1111110952380952, 
               -0.06342155154917027}, {-0.42857136734693874, 
               0.1111110952380952, -0.047589290105177054}, 
              {-0.28571424489795916, 0.1111110952380952, 
               -0.03173720874813993}, {-0.14285712244897958, 
               0.1111110952380952, -0.01587190952808668}, 
              {0, 0.1111110952380952, 0}, {0.14285712244897958, 
               0.1111110952380952, 0.01587190952808668}, 
              {0.28571424489795916, 0.1111110952380952, 0.03173720874813993}, 
              {0.42857136734693874, 0.1111110952380952, 
               0.047589290105177054}, {0.5714284897959183, 
               0.1111110952380952, 0.06342155154917027}, {0.714285612244898, 
               0.1111110952380952, 0.07922739928465813}, {0.8571427346938776, 
               0.1111110952380952, 0.09500025051691921}, {0.9999998571428571, 
               0.1111110952380952, 0.11073353619356399}, 
              {-0.8571427346938776, 0.33333328571428567, 
               -0.2813516889345257}, {-0.9999998571428571, 
               0.33333328571428567, -0.32641909707204114}, 
              {-0.714285612244898, 0.33333328571428567, 
               -0.23556643528525303}, {-0.5714284897959183, 
               0.33333328571428567, -0.1891796905521639}, 
              {-0.42857136734693874, 0.33333328571428567, 
               -0.1423095946389834}, {-0.28571424489795916, 
               0.33333328571428567, -0.09507572297796849}, 
              {-0.14285712244897958, 0.33333328571428567, 
               -0.04759873182919583}, {0, 0.33333328571428567, 0}, 
              {0.14285712244897958, 0.33333328571428567, 
               0.04759873182919583}, {0.28571424489795916, 
               0.33333328571428567, 0.09507572297796849}, 
              {0.42857136734693874, 0.33333328571428567, 0.1423095946389834}, 
              {0.5714284897959183, 0.33333328571428567, 0.1891796905521639}, 
              {0.714285612244898, 0.33333328571428567, 0.23556643528525303}, 
              {0.8571427346938776, 0.33333328571428567, 0.2813516889345257}, 
              {0.9999998571428571, 0.33333328571428567, 0.32641909707204114}, 
              {-0.8571427346938776, 0.5555554761904762, 
               -0.45807844870554687}, {-0.9999998571428571, 
               0.5555554761904762, -0.5269160390968048}, {-0.714285612244898, 
               0.5555554761904762, -0.3863062091169114}, 
              {-0.5714284897959183, 0.5555554761904762, -0.3120586368464405}, 
              {-0.42857136734693874, 0.5555554761904762, 
               -0.23581116908348418}, {-0.28571424489795916, 
               0.5555554761904762, -0.15805226863430707}, 
              {-0.14285712244897958, 0.5555554761904762, 
               -0.07928024321407705}, {0, 0.5555554761904762, 0}, 
              {0.14285712244897958, 0.5555554761904762, 0.07928024321407705}, 
              {0.28571424489795916, 0.5555554761904762, 0.15805226863430707}, 
              {0.42857136734693874, 0.5555554761904762, 0.23581116908348418}, 
              {0.5714284897959183, 0.5555554761904762, 0.3120586368464405}, 
              {0.714285612244898, 0.5555554761904762, 0.3863062091169114}, 
              {0.8571427346938776, 0.5555554761904762, 0.45807844870554687}, 
              {0.9999998571428571, 0.5555554761904762, 0.5269160390968048}, 
              {-0.8571427346938776, 0.7777776666666667, -0.6172187777731994}, 
              {-0.9999998571428571, 0.7777776666666667, -0.6999210593619575}, 
              {-0.714285612244898, 0.7777776666666667, -0.5267332994900711}, 
              {-0.5714284897959183, 0.7777776666666667, -0.4296003285828655}, 
              {-0.42857136734693874, 0.7777776666666667, 
               -0.32704221174382014}, {-0.28571424489795916, 
               0.7777776666666667, -0.220352049488818}, 
              {-0.14285712244897958, 0.7777776666666667, 
               -0.11087685692728111}, {0, 0.7777776666666667, 0}, 
              {0.14285712244897958, 0.7777776666666667, 0.11087685692728111}, 
              {0.28571424489795916, 0.7777776666666667, 0.220352049488818}, 
              {0.42857136734693874, 0.7777776666666667, 0.32704221174382014}, 
              {0.5714284897959183, 0.7777776666666667, 0.4296003285828655}, 
              {0.714285612244898, 0.7777776666666667, 0.5267332994900711}, 
              {0.8571427346938776, 0.7777776666666667, 0.6172187777731994}, 
              {0.9999998571428571, 0.7777776666666667, 0.6999210593619575}, 
              {-0.9206347891156463, -0.7777776666666667, 0.6552700344066898}, 
              {-0.6349205442176871, -0.7777776666666667, 0.4759382001872968}, 
              {-0.49206342176870743, -0.7777776666666667, 
               0.37651116473311563}, {-0.2063491768707483, 
               -0.7777776666666667, 0.16434978261717964}, 
              {-0.06349205442176875, -0.7777776666666667, 
               0.05428585743823961}, {0.22222219047619043, 
               -0.7777776666666667, -0.16687912379891945}, 
              {0.36507931292517004, -0.7777776666666667, 
               -0.27518297588220003}, {0.6507935578231292, 
               -0.7777776666666667, -0.4803954278856399}, 
              {0.7936506802721088, -0.7777776666666667, -0.574705898062841}, 
              {0.9365078027210884, -0.7777776666666667, -0.661869802728467}, 
              {-0.984126843537415, -0.5555554761904762, 0.5206459056644311}, 
              {-0.6984125986394558, -0.5555554761904762, 
               0.37976106634813356}, {-0.269841231292517, 
               -0.5555554761904762, 0.15127927428977248}, 
              {0.1587301360544217, -0.5555554761904762, 
               -0.08605323755861163}, {0.5873015034013604, 
               -0.5555554761904762, -0.3186037796152183}, 
              {0.8730157482993197, -0.5555554761904762, 
               -0.46434858213792063}, {-0.9047617755102041, 
               -0.3333332857142857, 0.3001620892316471}, 
              {-0.7619046530612246, -0.3333332857142857, 0.2548254338751345}, 
              {-0.6190475306122449, -0.3333332857142857, 
               0.20881511885849757}, {-0.4761904081632653, 
               -0.3333332857142857, 0.16224787350346292}, 
              {-0.19047616326530614, -0.3333332857142857, 
               0.06791771486279963}, {-0.04761904081632657, 
               -0.3333332857142857, 0.020395410045075904}, 
              {0.2380952040816326, -0.3333332857142857, -0.0747567399443647}, 
              {0.3809523265306122, -0.3333332857142857, 
               -0.12214317923603901}, {0.6666665714285713, 
               -0.3333332857142857, -0.21593100697891945}, 
              {0.809523693877551, -0.3333332857142857, -0.26209269034464433}, 
              {0.9523808163265306, -0.3333332857142857, 
               -0.30760869677491987}, {-0.9682538299319728, 
               -0.11111109523809526, 0.11073353619356406}, 
              {-0.6825395850340136, -0.11111109523809526, 
               0.07922739928465818}, {-0.5396824625850339, 
               -0.11111109523809526, 0.0634215515491703}, 
              {-0.25396821768707484, -0.11111109523809526, 
               0.03173720874813994}, {0.1746031496598639, 
               -0.11111109523809526, -0.01587190952808669}, 
              {0.6031745170068027, -0.11111109523809526, 
               -0.0634215515491703}, {0.8888887619047618, 
               -0.11111109523809526, -0.09500025051691927}, 
              {-0.888888761904762, 0.1111110952380952, -0.09500025051691921}, 
              {-0.7460316394557823, 0.1111110952380952, 
               -0.07922739928465815}, {-0.6031745170068027, 
               0.1111110952380952, -0.06342155154917027}, 
              {-0.4603173945578231, 0.1111110952380952, 
               -0.04758929010517706}, {-0.31746027210884353, 
               0.1111110952380952, -0.03173720874813993}, 
              {-0.17460314965986395, 0.1111110952380952, 
               -0.01587190952808668}, {-0.03174602721088437, 
               0.1111110952380952, 0}, {0.2539682176870748, 
               0.1111110952380952, 0.03173720874813993}, 
              {0.39682534013605436, 0.1111110952380952, 
               0.047589290105177054}, {0.6825395850340136, 
               0.1111110952380952, 0.07922739928465813}, {0.8253967074829932, 
               0.1111110952380952, 0.09500025051691922}, {0.9682538299319727, 
               0.1111110952380952, 0.11073353619356399}, 
              {-0.9523808163265306, 0.33333328571428567, 
               -0.3076086967749198}, {-0.6666665714285714, 
               0.33333328571428567, -0.21593100697891943}, 
              {-0.5238094489795918, 0.33333328571428567, 
               -0.16924141168768445}, {-0.23809520408163265, 
               0.33333328571428567, -0.0747567399443647}, 
              {-0.09523808163265307, 0.33333328571428567, 
               -0.02720332178411995}, {0.1904761632653061, 
               0.33333328571428567, 0.0679177148627996}, {0.6190475306122448, 
               0.33333328571428567, 0.20881511885849752}, 
              {0.9047617755102041, 0.33333328571428567, 0.30016208923164706}, 
              {-0.8730157482993197, 0.5555554761904762, 
               -0.46434858213792063}, {-0.7301586258503401, 
               0.5555554761904762, -0.39272587531353853}, 
              {-0.5873015034013604, 0.5555554761904762, -0.3186037796152183}, 
              {-0.44444438095238087, 0.5555554761904762, 
               -0.24245726203831067}, {-0.3015872585034013, 
               0.5555554761904762, -0.16477440710195518}, 
              {-0.1587301360544217, 0.5555554761904762, 
               -0.08605323755861163}, {-0.015873013605442136, 
               0.5555554761904762, -0.006798470015025279}, 
              {0.12698410884353745, 0.5555554761904762, 0.07248177319905177}, 
              {0.269841231292517, 0.5555554761904762, 0.15127927428977248}, 
              {0.4126983537414966, 0.5555554761904762, 0.22908903061583608}, 
              {0.6984125986394558, 0.5555554761904762, 0.37976106634813356}, 
              {0.8412697210884355, 0.5555554761904762, 0.4516587825089197}, 
              {0.984126843537415, 0.5555554761904762, 0.5206459056644311}, 
              {-0.9365078027210884, 0.7777776666666667, -0.661869802728467}, 
              {-0.6507935578231292, 0.7777776666666667, -0.4803954278856399}, 
              {-0.5079364353741496, 0.7777776666666667, -0.38013137559357}, 
              {-0.22222219047619043, 0.7777776666666667, 
               -0.16687912379891945}, {-0.07936506802721088, 
               0.7777776666666667, -0.05659099948904154}, 
              {0.2063491768707483, 0.7777776666666667, 0.16434978261717967}, 
              {0.3492062993197279, 0.7777776666666667, 0.27221128535043815}, 
              {0.6349205442176871, 0.7777776666666667, 0.4759382001872968}, 
              {0.9206347891156463, 0.7777776666666667, 0.6552700344066898}, 
              {-0.34920629931972785, -0.7777776666666667, 
               0.2722112853504381}, {0.07936506802721086, 
               -0.7777776666666667, -0.05659099948904152}, 
              {0.5079364353741496, -0.7777776666666667, -0.38013137559357}, 
              {-0.8412697210884355, -0.5555554761904762, 0.4516587825089197}, 
              {-0.4126983537414966, -0.5555554761904762, 
               0.22908903061583608}, {-0.12698410884353747, 
               -0.5555554761904762, 0.07248177319905179}, 
              {0.015873013605442132, -0.5555554761904762, 
               -0.006798470015025276}, {0.3015872585034013, 
               -0.5555554761904762, -0.16477440710195518}, 
              {0.44444438095238087, -0.5555554761904762, 
               -0.24245726203831067}, {0.7301586258503401, 
               -0.5555554761904762, -0.39272587531353853}, 
              {0.09523808163265302, -0.3333332857142857, 
               -0.027203321784119935}, {0.5238094489795917, 
               -0.3333332857142857, -0.16924141168768445}, 
              {-0.8253967074829932, -0.11111109523809526, 
               0.09500025051691927}, {-0.3968253401360544, 
               -0.11111109523809526, 0.04758929010517708}, 
              {0.03174602721088432, -0.11111109523809526, 0}, 
              {0.3174602721088435, -0.11111109523809526, 
               -0.03173720874813994}, {0.46031739455782306, 
               -0.11111109523809526, -0.04758929010517708}, 
              {0.7460316394557823, -0.11111109523809526, 
               -0.07922739928465818}, {0.5396824625850339, 
               0.1111110952380952, 0.06342155154917027}, 
              {-0.8095236938775511, 0.33333328571428567, 
               -0.2620926903446443}, {-0.38095232653061223, 
               0.33333328571428567, -0.12214317923603901}, 
              {0.04761904081632651, 0.33333328571428567, 
               0.020395410045075876}, {0.47619040816326524, 
               0.33333328571428567, 0.16224787350346287}, 
              {0.7619046530612245, 0.33333328571428567, 0.25482543387513445}, 
              {-0.7936506802721088, 0.7777776666666667, -0.574705898062841}, 
              {-0.36507931292517, 0.7777776666666667, -0.27518297588220003}, 
              {0.06349205442176872, 0.7777776666666667, 
               0.054285857438239576}, {0.49206342176870743, 
               0.7777776666666667, 0.37651116473311563}, 
              {-0.5555554761904762, -0.7777776666666667, 0.4189824958129156}, 
              {-0.11111109523809526, -0.7777776666666667, 
               0.08824045713166452}, {0.33333328571428567, 
               -0.7777776666666667, -0.2532506053248472}, 
              {0.7777776666666667, -0.7777776666666667, -0.5651113783482871}, 
              {-0.7777776666666667, -0.3333332857142857, 
               0.25924647638503306}, {-0.5555554761904762, 
               -0.3333332857142857, 0.18469105437738045}, 
              {-0.11111109523809526, -0.3333332857142857, 
               0.03853095790115586}, {0.33333328571428567, 
               -0.3333332857142857, -0.10860945110700376}, 
              {0.7777776666666667, -0.3333332857142857, -0.2532506053248473}, 
              {-0.5555554761904762, -0.11111109523809526, 
               0.0634215515491703}, {-0.7777776666666667, 0.1111110952380952, 
               -0.0837339282081613}, {-0.5555554761904762, 
               0.1111110952380952, -0.0611597999143141}, 
              {-0.3333332857142857, 0.1111110952380952, 
               -0.03400179179914523}, {-0.11111109523809526, 
               0.1111110952380952, -0.011337078234347634}, 
              {0.33333328571428567, 0.1111110952380952, 0.03853095790115584}, 
              {0.7777776666666667, 0.1111110952380952, 0.08824045713166448}, 
              {-0.5555554761904762, 0.33333328571428567, 
               -0.18253359759733745}, {-0.11111109523809526, 
               0.33333328571428567, -0.034001791799145246}, 
              {-0.7777776666666667, 0.5555554761904762, -0.4172330903355417}, 
              {-0.5555554761904762, 0.5555554761904762, -0.3033584649954243}, 
              {-0.3333332857142857, 0.5555554761904762, 
               -0.18253359759733745}, {-0.11111109523809526, 
               0.5555554761904762, -0.06115979991431413}, 
              {0.1111110952380952, 0.5555554761904762, 0.06342155154917027}, 
              {0.33333328571428567, 0.5555554761904762, 0.18469105437738043}, 
              {0.7777776666666667, 0.5555554761904762, 0.4189824958129156}, 
              {-0.5555554761904762, 0.7777776666666667, -0.4172330903355417}, 
              {-0.11111109523809526, 0.7777776666666667, 
               -0.08373392820816135}, {0.33333328571428567, 
               0.7777776666666667, 0.25924647638503306}, 
              {-0.3333332857142857, -0.7777776666666667, 
               0.25924647638503306}, {0.1111110952380952, 
               -0.7777776666666667, -0.0837339282081613}, 
              {0.5555554761904762, -0.7777776666666667, -0.4172330903355417}, 
              {-0.7777776666666667, -0.5555554761904762, 0.4189824958129156}, 
              {-0.3333332857142857, -0.5555554761904762, 
               0.18469105437738045}, {-0.11111109523809526, 
               -0.5555554761904762, 0.0634215515491703}, {0.1111110952380952, 
               -0.5555554761904762, -0.061159799914314104}, 
              {0.33333328571428567, -0.5555554761904762, 
               -0.18253359759733745}, {0.5555554761904762, 
               -0.5555554761904762, -0.3033584649954243}, 
              {0.7777776666666667, -0.5555554761904762, -0.4172330903355417}, 
              {0.1111110952380952, -0.3333332857142857, 
               -0.03400179179914523}, {0.5555554761904762, 
               -0.3333332857142857, -0.18253359759733748}, 
              {-0.7777776666666667, -0.11111109523809526, 
               0.08824045713166452}, {-0.3333332857142857, 
               -0.11111109523809526, 0.03853095790115586}, 
              {0.1111110952380952, -0.11111109523809526, 
               -0.011337078234347632}, {0.33333328571428567, 
               -0.11111109523809526, -0.034001791799145246}, 
              {0.5555554761904762, -0.11111109523809526, 
               -0.061159799914314125}, {0.7777776666666667, 
               -0.11111109523809526, -0.08373392820816135}, 
              {0.5555554761904762, 0.1111110952380952, 0.06342155154917027}, 
              {-0.7777776666666667, 0.33333328571428567, 
               -0.2532506053248472}, {-0.3333332857142857, 
               0.33333328571428567, -0.10860945110700376}, 
              {0.1111110952380952, 0.33333328571428567, 
               0.038530957901155835}, {0.5555554761904762, 
               0.33333328571428567, 0.18469105437738043}, 
              {0.7777776666666667, 0.33333328571428567, 0.259246476385033}, 
              {-0.7777776666666667, 0.7777776666666667, -0.5651113783482871}, 
              {-0.3333332857142857, 0.7777776666666667, -0.2532506053248473}, 
              {0.1111110952380952, 0.7777776666666667, 0.08824045713166447}, 
              {0.5555554761904762, 0.7777776666666667, 0.4189824958129156}}, 
             {{{EdgeForm[], Directive[Specularity[GrayLevel[1], 3], 
                 RGBColor[0.880722, 0.611041, 0.142051], Lighting -> 
                  "Neutral"], GraphicsGroup[Annotation[{Polygon[
                    {{226, 2, 17}, {473, 193, 353}, {475, 199, 355}, 
                     {471, 190, 351}, {214, 198, 199}, {230, 197, 212}, 
                     {372, 21, 255}, {474, 197, 354}, {476, 200, 356}, 
                     {217, 201, 202}, {477, 202, 357}, {223, 207, 208}, 
                     {481, 208, 361}, {237, 232, 210}, {227, 226, 16}, 
                     {371, 20, 253}, {373, 23, 257}, {370, 18, 251}, 
                     {3, 19, 18}, {478, 203, 358}, {384, 42, 272}, {31, 47, 
                      46}, {380, 36, 268}, {378, 33, 266}, {228, 29, 14}, 
                     {469, 187, 349}, {445, 142, 325}, {451, 154, 331}, 
                     {436, 125, 316}, {12, 28, 27}, {9, 25, 24}, {375, 26, 
                      261}, {386, 48, 274}, {388, 51, 276}, {387, 50, 275}, 
                     {33, 49, 48}, {382, 39, 270}, {374, 24, 259}, {376, 27, 
                      263}, {377, 29, 265}, {6, 22, 21}, {220, 204, 205}, 
                     {480, 206, 360}, {370, 2, 250}, {372, 5, 254}, 
                     {19, 3, 4}, {373, 7, 256}, {374, 8, 258}, {376, 11, 
                      262}, {28, 12, 13}, {371, 4, 252}, {22, 6, 7}, 
                     {377, 13, 264}, {421, 97, 301}, {139, 123, 124}, 
                     {379, 19, 253}, {378, 17, 251}, {381, 22, 257}, 
                     {375, 10, 260}, {239, 229, 228}, {383, 25, 261}, 
                     {25, 9, 10}, {385, 28, 265}, {47, 31, 32}, {58, 42, 43}, 
                     {392, 41, 272}, {391, 40, 271}, {434, 122, 314}, 
                     {435, 124, 315}, {55, 39, 40}, {479, 205, 359}, 
                     {36, 52, 51}, {447, 145, 327}, {393, 43, 273}, 
                     {52, 36, 37}, {395, 49, 275}, {386, 32, 266}, {60, 44, 
                      45}, {389, 37, 269}, {388, 35, 268}, {390, 38, 270}, 
                     {49, 33, 34}, {387, 34, 267}, {450, 152, 330}, 
                     {443, 139, 323}, {439, 130, 319}, {518, 82, 622}, 
                     {553, 117, 645}, {515, 79, 620}, {550, 114, 643}, 
                     {558, 136, 648}, {559, 138, 649}, {555, 119, 647}, 
                     {512, 77, 618}, {509, 73, 616}, {511, 75, 617}, 
                     {595, 189, 674}, {526, 90, 628}, {527, 107, 629}, 
                     {524, 88, 626}, {530, 109, 630}, {547, 111, 641}, 
                     {521, 85, 624}, {533, 112, 632}, {535, 99, 633}, 
                     {538, 102, 634}, {540, 104, 635}, {568, 147, 654}, 
                     {573, 151, 656}, {577, 156, 661}, {574, 153, 658}, 
                     {536, 115, 633}, {570, 149, 655}, {723, 445, 652}, 
                     {722, 443, 650}, {488, 37, 605}, {580, 159, 664}, 
                     {589, 183, 670}, {543, 106, 636}, {544, 108, 638}, 
                     {562, 141, 651}, {583, 162, 666}, {565, 144, 653}, 
                     {592, 186, 672}, {588, 181, 669}, {585, 164, 668}, 
                     {426, 107, 306}, {485, 34, 603}, {598, 192, 676}, 
                     {463, 175, 343}, {462, 173, 342}, {190, 174, 175}, 
                     {461, 172, 341}, {193, 177, 178}, {465, 178, 345}, 
                     {464, 176, 344}, {467, 184, 347}, {452, 155, 332}, 
                     {441, 133, 321}, {438, 128, 318}, {437, 127, 317}, 
                     {142, 126, 127}, {145, 129, 130}, {440, 131, 320}, 
                     {195, 179, 180}, {150, 134, 135}, {148, 132, 133}, 
                     {187, 171, 172}, {460, 170, 340}, {459, 169, 339}, 
                     {494, 43, 609}, {506, 70, 615}, {497, 62, 612}, 
                     {500, 64, 613}, {503, 67, 614}, {496, 45, 611}, 
                     {482, 32, 602}, {491, 40, 607}, {600, 194, 677}, 
                     {121, 137, 136}, {182, 166, 167}, {456, 161, 336}, 
                     {454, 158, 334}, {453, 157, 333}, {455, 160, 335}, 
                     {184, 168, 169}, {522, 71, 689}, {458, 167, 338}, 
                     {457, 163, 337}, {721, 433, 646}, {427, 109, 307}, 
                     {137, 121, 122}, {413, 98, 301}, {78, 94, 93}, 
                     {410, 93, 298}, {81, 97, 96}, {411, 95, 299}, {456, 177, 
                      344}, {412, 96, 300}, {408, 87, 296}, {76, 92, 91}, 
                     {414, 99, 302}, {87, 103, 102}, {416, 102, 304}, 
                     {418, 108, 306}, {421, 113, 309}, {420, 111, 308}, 
                     {241, 249, 233}, {84, 100, 99}, {415, 101, 303}, 
                     {89, 105, 104}, {486, 20, 678}, {482, 17, 378}, 
                     {239, 243, 15}, {238, 242, 1}, {237, 241, 232}, 
                     {249, 241, 225}, {506, 55, 685}, {507, 56, 686}, 
                     {244, 240, 236}, {240, 244, 211}, {236, 240, 230}, 
                     {235, 239, 228}, {239, 247, 229}, {238, 246, 234}, 
                     {241, 245, 225}, {248, 240, 211}, {247, 239, 15}, 
                     {240, 248, 231}, {246, 238, 1}, {227, 238, 226}, 
                     {417, 104, 305}, {422, 114, 310}, {395, 65, 283}, 
                     {430, 129, 318}, {439, 146, 327}, {425, 119, 313}, 
                     {440, 147, 328}, {441, 149, 329}, {449, 164, 337}, 
                     {132, 148, 147}, {760, 470, 704}, {437, 143, 325}, 
                     {438, 144, 326}, {434, 138, 322}, {432, 132, 320}, 
                     {123, 139, 138}, {435, 140, 323}, {436, 141, 324}, 
                     {448, 162, 336}, {129, 145, 144}, {126, 142, 141}, 
                     {442, 153, 330}, {134, 150, 149}, {444, 156, 332}, 
                     {44, 60, 59}, {42, 58, 57}, {392, 57, 280}, {391, 56, 
                      279}, {393, 59, 281}, {397, 68, 285}, {396, 66, 284}, 
                     {394, 63, 282}, {504, 53, 684}, {398, 69, 286}, 
                     {399, 71, 287}, {447, 161, 335}, {446, 159, 334}, 
                     {424, 117, 312}, {423, 116, 311}, {401, 74, 289}, 
                     {404, 81, 292}, {406, 84, 294}, {400, 72, 288}, 
                     {489, 23, 679}, {503, 52, 683}, {509, 58, 687}, 
                     {39, 55, 54}, {390, 54, 278}, {204, 220, 219}, 
                     {389, 53, 277}, {413, 82, 293}, {412, 80, 292}, 
                     {97, 81, 82}, {479, 221, 367}, {480, 222, 368}, 
                     {478, 219, 366}, {201, 217, 216}, {475, 215, 363}, 
                     {198, 214, 213}, {474, 213, 362}, {476, 216, 364}, 
                     {411, 79, 291}, {207, 223, 222}, {477, 218, 365}, 
                     {414, 83, 294}, {100, 84, 85}, {415, 85, 295}, 
                     {409, 73, 289}, {402, 62, 282}, {429, 112, 309}, 
                     {430, 113, 310}, {419, 94, 299}, {407, 70, 287}, 
                     {431, 115, 311}, {428, 110, 308}, {481, 224, 369}, 
                     {405, 67, 285}, {404, 65, 284}, {416, 86, 296}, 
                     {105, 89, 90}, {417, 88, 297}, {103, 87, 88}, {94, 78, 
                      79}, {403, 64, 283}, {92, 76, 77}, {410, 77, 290}, 
                     {433, 118, 313}, {232, 224, 209}, {210, 232, 209}, 
                     {470, 204, 358}, {472, 207, 360}, {468, 201, 356}, 
                     {179, 195, 194}, {177, 193, 192}, {460, 186, 348}, 
                     {465, 194, 353}, {473, 209, 361}, {466, 198, 354}, 
                     {243, 239, 235}, {516, 65, 404}, {519, 68, 688}, 
                     {501, 50, 682}, {500, 49, 395}, {497, 47, 681}, 
                     {168, 184, 183}, {245, 241, 237}, {492, 26, 680}, 
                     {458, 183, 346}, {166, 182, 181}, {459, 185, 347}, 
                     {16, 226, 17}, {228, 229, 30}, {197, 230, 196}, 
                     {236, 230, 212}, {230, 231, 196}, {240, 231, 230}, 
                     {241, 233, 232}, {232, 233, 224}, {238, 234, 226}, 
                     {242, 238, 227}, {235, 228, 14}, {171, 187, 186}, 
                     {464, 192, 352}, {461, 188, 349}, {463, 191, 351}, 
                     {174, 190, 189}, {29, 228, 30}, {226, 234, 2}, 
                     {462, 189, 350}, {732, 469, 673}, {761, 472, 705}, 
                     {724, 450, 657}, {550, 129, 430}, {586, 180, 668}, 
                     {552, 131, 644}, {555, 134, 646}, {537, 101, 694}, 
                     {590, 199, 670}, {587, 197, 669}, {548, 127, 641}, 
                     {569, 163, 654}, {593, 202, 672}, {597, 206, 675}, 
                     {600, 209, 473}, {571, 165, 655}, {575, 169, 658}, 
                     {578, 172, 661}, {572, 167, 656}, {510, 59, 617}, 
                     {514, 63, 620}, {513, 61, 618}, {596, 205, 674}, 
                     {584, 178, 666}, {549, 128, 642}, {581, 175, 664}, 
                     {551, 130, 643}, {546, 125, 639}, {742, 400, 686}, 
                     {601, 210, 677}, {599, 208, 676}, {539, 118, 634}, 
                     {743, 401, 687}, {561, 155, 650}, {744, 406, 688}, 
                     {745, 408, 689}, {741, 399, 685}, {557, 152, 648}, 
                     {556, 135, 647}, {560, 154, 649}, {545, 124, 638}, 
                     {542, 122, 636}, {541, 120, 635}, {554, 133, 645}, 
                     {566, 160, 653}, {531, 110, 631}, {544, 123, 637}, 
                     {534, 113, 421}, {563, 157, 651}, {547, 126, 640}, 
                     {505, 54, 615}, {508, 57, 616}, {517, 66, 622}, 
                     {569, 148, 701}, {566, 145, 447}, {501, 65, 395}, 
                     {564, 143, 699}, {567, 146, 700}, {493, 27, 609}, 
                     {490, 24, 607}, {499, 48, 613}, {495, 29, 611}, 
                     {561, 140, 698}, {720, 431, 644}, {557, 137, 697}, 
                     {534, 98, 692}, {552, 116, 696}, {536, 100, 693}, 
                     {527, 92, 690}, {549, 113, 430}, {533, 97, 421}, 
                     {582, 161, 456}, {587, 182, 702}, {531, 95, 691}, 
                     {498, 46, 612}, {487, 21, 605}, {525, 89, 627}, 
                     {522, 86, 625}, {502, 51, 614}, {484, 33, 378}, 
                     {486, 35, 604}, {520, 69, 624}, {523, 72, 626}, 
                     {525, 74, 628}, {529, 93, 630}, {532, 96, 632}, 
                     {528, 91, 629}, {489, 38, 606}, {740, 398, 684}, 
                     {483, 16, 602}, {594, 188, 704}, {514, 78, 619}, 
                     {519, 83, 623}, {484, 18, 603}, {517, 81, 404}, 
                     {516, 80, 621}, {591, 185, 703}, {599, 193, 473}, 
                     {492, 41, 608}, {495, 44, 610}, {597, 191, 705}, 
                     {738, 396, 682}, {539, 103, 695}, {731, 467, 671}, 
                     {754, 444, 698}, {718, 428, 640}, {717, 427, 639}, 
                     {753, 442, 697}, {564, 158, 652}, {574, 168, 657}, 
                     {755, 446, 699}, {582, 176, 665}, {756, 448, 700}, 
                     {580, 174, 663}, {759, 468, 703}, {710, 402, 619}, 
                     {594, 203, 673}, {719, 429, 642}, {576, 170, 659}, 
                     {728, 454, 663}, {708, 383, 608}, {707, 381, 606}, 
                     {749, 423, 693}, {583, 177, 456}, {716, 426, 637}, 
                     {711, 403, 621}, {733, 471, 675}, {712, 405, 623}, 
                     {714, 409, 627}, {713, 407, 625}, {758, 466, 702}, 
                     {567, 161, 447}, {585, 179, 667}, {734, 380, 678}, 
                     {750, 424, 694}, {709, 385, 610}, {752, 432, 696}, 
                     {706, 379, 604}, {751, 425, 695}, {591, 200, 671}, 
                     {757, 449, 701}, {715, 419, 631}, {739, 397, 683}, 
                     {747, 420, 691}, {730, 457, 667}, {726, 452, 660}, 
                     {727, 453, 662}, {729, 455, 665}, {748, 422, 692}, 
                     {577, 171, 660}, {746, 418, 690}, {737, 394, 681}, 
                     {735, 382, 679}, {736, 384, 680}, {579, 173, 662}, 
                     {725, 451, 659}}], Polygon[{{303, 100, 85, 415}, 
                     {278, 53, 38, 390}, {305, 103, 88, 417}, {668, 180, 179, 
                      585}, {300, 95, 80, 412}, {669, 197, 196, 588}, 
                     {354, 198, 213, 474}, {357, 203, 218, 477}, {671, 200, 
                      355, 731}, {670, 199, 198, 589}, {359, 206, 221, 479}, 
                     {279, 55, 40, 391}, {302, 98, 83, 414}, {301, 97, 82, 
                      413}, {360, 207, 222, 480}, {643, 130, 129, 550}, 
                     {491, 25, 383, 708}, {622, 66, 67, 518}, {634, 118, 117, 
                      538}, {275, 49, 34, 387}, {494, 28, 385, 709}, 
                     {274, 47, 32, 386}, {276, 50, 35, 388}, {281, 58, 43, 
                      393}, {355, 200, 215, 475}, {304, 101, 86, 416}, 
                     {635, 120, 119, 540}, {636, 122, 121, 543}, {570, 164, 
                      449, 757}, {280, 56, 41, 392}, {688, 68, 286, 744}, 
                     {277, 52, 37, 389}, {351, 190, 175, 463}, {356, 201, 
                      216, 476}, {644, 131, 319, 720}, {329, 148, 133, 441}, 
                     {328, 146, 131, 440}, {581, 160, 455, 729}, {646, 134, 
                      321, 721}, {346, 182, 167, 458}, {584, 163, 457, 730}, 
                     {575, 154, 451, 725}, {347, 184, 169, 459}, {348, 185, 
                      170, 460}, {349, 187, 172, 461}, {579, 158, 454, 728}, 
                     {353, 193, 178, 465}, {578, 157, 453, 727}, {576, 155, 
                      452, 726}, {563, 142, 445, 723}, {572, 152, 450, 724}, 
                     {350, 188, 173, 462}, {560, 139, 443, 722}, {327, 145, 
                      130, 439}, {325, 142, 127, 437}, {292, 81, 96, 412}, 
                     {647, 135, 134, 555}, {706, 267, 34, 485}, {674, 205, 
                      204, 595}, {675, 206, 359, 733}, {358, 204, 219, 478}, 
                     {645, 133, 132, 553}, {673, 203, 357, 732}, {352, 191, 
                      176, 464}, {672, 202, 201, 592}, {565, 159, 446, 755}, 
                     {530, 94, 419, 715}, {378, 266, 32, 482}, {568, 162, 
                      448, 756}, {677, 210, 209, 600}, {690, 92, 298, 746}, 
                     {676, 208, 207, 598}, {709, 273, 43, 494}, {707, 269, 
                      37, 488}, {708, 271, 40, 491}, {294, 84, 99, 414}, 
                     {616, 73, 72, 508}, {518, 67, 405, 712}, {532, 111, 420, 
                      747}, {613, 64, 63, 499}, {650, 155, 331, 722}, 
                     {589, 198, 466, 758}, {529, 108, 418, 746}, {614, 67, 
                      66, 502}, {297, 89, 104, 417}, {612, 62, 61, 498}, 
                     {345, 179, 194, 465}, {623, 83, 293, 712}, {624, 85, 84, 
                      520}, {654, 163, 162, 568}, {631, 110, 307, 715}, 
                     {317, 128, 143, 437}, {663, 174, 342, 728}, {630, 109, 
                      108, 529}, {320, 132, 147, 440}, {629, 107, 106, 528}, 
                     {318, 129, 144, 438}, {625, 86, 295, 713}, {319, 131, 
                      146, 439}, {296, 87, 102, 416}, {648, 152, 151, 558}, 
                     {344, 177, 192, 464}, {649, 154, 153, 559}, {617, 75, 
                      74, 510}, {618, 77, 76, 513}, {562, 156, 444, 754}, 
                     {652, 158, 333, 723}, {321, 134, 149, 441}, {340, 171, 
                      186, 460}, {342, 174, 189, 462}, {341, 173, 188, 461}, 
                     {595, 204, 470, 760}, {619, 78, 290, 710}, {632, 112, 
                      111, 532}, {653, 160, 159, 565}, {622, 82, 81, 517}, 
                     {540, 119, 425, 751}, {535, 114, 422, 748}, {343, 176, 
                      191, 463}, {538, 117, 424, 750}, {339, 170, 185, 459}, 
                     {615, 70, 69, 505}, {537, 116, 423, 749}, {651, 157, 
                      156, 562}, {621, 80, 291, 711}, {620, 79, 78, 514}, 
                     {316, 126, 141, 436}, {315, 125, 140, 435}, {664, 175, 
                      174, 580}, {642, 128, 317, 719}, {715, 307, 109, 530}, 
                     {640, 126, 316, 718}, {712, 293, 82, 518}, {641, 127, 
                      126, 547}, {404, 292, 80, 516}, {338, 168, 183, 458}, 
                     {265, 28, 13, 377}, {263, 26, 11, 376}, {639, 125, 315, 
                      717}, {261, 25, 10, 375}, {714, 297, 88, 524}, 
                     {488, 22, 381, 707}, {638, 124, 123, 544}, {395, 283, 
                      64, 500}, {637, 123, 314, 716}, {521, 70, 407, 713}, 
                     {515, 64, 403, 711}, {512, 62, 402, 710}, {633, 115, 
                      114, 535}, {713, 295, 85, 521}, {598, 207, 472, 761}, 
                     {485, 19, 379, 706}, {361, 209, 224, 481}, {259, 23, 8, 
                      374}, {257, 22, 7, 373}, {661, 172, 171, 577}, 
                     {660, 171, 340, 726}, {553, 132, 432, 752}, {628, 90, 
                      89, 525}, {662, 173, 341, 727}, {626, 88, 87, 523}, 
                     {665, 176, 343, 729}, {559, 153, 442, 753}, {627, 89, 
                      297, 714}, {295, 86, 101, 415}, {657, 168, 338, 724}, 
                     {659, 170, 339, 725}, {592, 201, 468, 759}, {658, 169, 
                      168, 574}, {711, 291, 79, 515}, {255, 20, 5, 372}, 
                     {656, 167, 166, 573}, {253, 19, 4, 371}, {251, 17, 2, 
                      370}, {710, 290, 77, 512}, {666, 178, 177, 583}, 
                     {667, 179, 345, 730}, {655, 165, 164, 570}, {314, 123, 
                      138, 434}, {678, 20, 255, 734}, {628, 74, 75, 526}, 
                     {649, 138, 139, 560}, {758, 346, 183, 589}, {761, 352, 
                      192, 598}, {447, 327, 146, 567}, {757, 329, 149, 570}, 
                     {655, 149, 150, 571}, {698, 140, 324, 754}, {701, 148, 
                      329, 757}, {656, 151, 152, 572}, {697, 137, 322, 753}, 
                     {648, 136, 137, 557}, {430, 310, 114, 550}, {669, 181, 
                      182, 587}, {755, 326, 144, 565}, {664, 159, 160, 581}, 
                     {702, 182, 346, 758}, {670, 183, 184, 590}, {752, 312, 
                      117, 553}, {658, 153, 154, 575}, {751, 305, 104, 540}, 
                     {661, 156, 157, 578}, {654, 147, 148, 569}, {700, 146, 
                      328, 756}, {651, 141, 142, 563}, {759, 348, 186, 592}, 
                     {609, 43, 42, 493}, {608, 41, 271, 708}, {607, 40, 39, 
                      490}, {672, 186, 187, 593}, {299, 94, 79, 411}, 
                     {258, 9, 24, 374}, {256, 8, 23, 373}, {677, 194, 195, 
                      601}, {260, 11, 26, 375}, {610, 44, 273, 709}, 
                     {754, 324, 141, 562}, {611, 45, 44, 495}, {606, 38, 269, 
                      707}, {703, 185, 348, 759}, {699, 143, 326, 755}, 
                     {653, 144, 145, 566}, {603, 34, 33, 484}, {604, 35, 267, 
                      706}, {602, 32, 31, 483}, {605, 37, 36, 487}, 
                     {456, 336, 162, 583}, {760, 350, 189, 595}, {624, 69, 
                      70, 521}, {493, 42, 384, 736}, {666, 162, 163, 584}, 
                     {668, 164, 165, 586}, {718, 316, 125, 546}, {717, 315, 
                      124, 545}, {716, 314, 122, 542}, {732, 357, 202, 593}, 
                     {473, 353, 194, 600}, {430, 318, 128, 549}, {719, 317, 
                      127, 548}, {721, 321, 133, 554}, {722, 331, 154, 560}, 
                     {730, 345, 178, 584}, {456, 344, 176, 582}, {729, 343, 
                      175, 581}, {725, 339, 169, 575}, {750, 304, 102, 538}, 
                     {421, 309, 112, 533}, {726, 340, 170, 576}, {724, 338, 
                      167, 572}, {447, 335, 160, 566}, {731, 355, 199, 590}, 
                     {728, 342, 173, 579}, {727, 341, 172, 578}, {723, 333, 
                      157, 563}, {720, 319, 130, 551}, {749, 303, 101, 537}, 
                     {733, 359, 205, 596}, {738, 276, 51, 502}, {735, 259, 
                      24, 490}, {473, 361, 208, 599}, {739, 277, 53, 504}, 
                     {395, 275, 50, 501}, {737, 274, 48, 499}, {753, 322, 
                      138, 559}, {298, 92, 77, 410}, {736, 263, 27, 493}, 
                     {378, 251, 18, 484}, {756, 328, 147, 568}, {734, 255, 
                      21, 487}, {741, 279, 56, 507}, {743, 281, 59, 510}, 
                     {744, 286, 69, 520}, {404, 284, 66, 517}, {745, 288, 72, 
                      523}, {421, 301, 98, 534}, {748, 302, 99, 535}, 
                     {742, 280, 57, 508}, {746, 298, 93, 529}, {747, 300, 96, 
                      532}, {740, 278, 54, 505}, {705, 191, 352, 761}, 
                     {524, 73, 409, 714}, {704, 188, 350, 760}, {611, 29, 30, 
                      496}, {499, 63, 394, 737}, {605, 21, 22, 488}, 
                     {603, 18, 19, 485}, {679, 23, 259, 735}, {593, 187, 469, 
                      732}, {618, 61, 62, 512}, {695, 103, 305, 751}, 
                     {634, 102, 103, 539}, {620, 63, 64, 515}, {590, 184, 
                      467, 731}, {635, 104, 105, 541}, {607, 24, 25, 491}, 
                     {680, 26, 263, 736}, {269, 38, 53, 389}, {271, 41, 56, 
                      391}, {505, 69, 398, 740}, {268, 36, 51, 388}, 
                     {609, 27, 28, 494}, {267, 35, 50, 387}, {504, 68, 397, 
                      739}, {502, 66, 396, 738}, {602, 16, 17, 482}, 
                     {273, 44, 59, 393}, {272, 42, 57, 392}, {694, 101, 304, 
                      750}, {636, 106, 107, 542}, {693, 100, 303, 749}, 
                     {554, 118, 433, 721}, {641, 111, 112, 548}, {551, 115, 
                      431, 720}, {324, 140, 125, 436}, {643, 114, 115, 551}, 
                     {630, 93, 94, 530}, {689, 71, 288, 745}, {322, 137, 122, 
                      434}, {323, 139, 124, 435}, {626, 72, 73, 524}, 
                     {629, 91, 92, 527}, {542, 107, 426, 716}, {696, 116, 
                      312, 752}, {645, 117, 118, 554}, {632, 96, 97, 533}, 
                     {691, 95, 300, 747}, {692, 98, 302, 748}, {293, 83, 98, 
                      413}, {633, 99, 100, 536}, {546, 110, 428, 718}, 
                     {638, 108, 109, 545}, {326, 143, 128, 438}, {507, 71, 
                      399, 741}, {647, 119, 120, 556}, {548, 112, 429, 719}, 
                     {545, 109, 427, 717}, {508, 72, 400, 742}, {270, 39, 54, 
                      390}, {367, 220, 205, 479}, {681, 47, 274, 737}, 
                     {252, 5, 20, 371}, {686, 56, 280, 742}, {616, 57, 58, 
                      509}, {685, 55, 279, 741}, {250, 3, 18, 370}, 
                     {684, 53, 278, 740}, {615, 54, 55, 506}, {487, 36, 380, 
                      734}, {612, 46, 47, 497}, {266, 33, 48, 386}, 
                     {368, 221, 206, 480}, {364, 215, 200, 476}, {596, 190, 
                      471, 733}, {362, 212, 197, 474}, {369, 223, 208, 481}, 
                     {510, 74, 401, 743}, {365, 217, 202, 477}, {366, 218, 
                      203, 478}, {683, 52, 277, 739}, {687, 58, 281, 743}, 
                     {363, 214, 199, 475}, {262, 12, 27, 376}, {254, 6, 21, 
                      372}, {291, 80, 95, 411}, {682, 50, 276, 738}, 
                     {617, 59, 60, 511}, {523, 87, 408, 745}, {613, 48, 49, 
                      500}, {674, 189, 190, 596}, {614, 51, 52, 503}, 
                     {490, 39, 382, 735}, {520, 84, 406, 744}, {290, 78, 93, 
                      410}, {264, 14, 29, 377}, {676, 192, 193, 599}}], 
                   Polygon[{{684, 398, 286, 68, 504}, {697, 442, 330, 152, 
                      557}, {688, 406, 294, 83, 519}, {686, 400, 288, 71, 
                      507}, {695, 425, 313, 118, 539}, {683, 397, 285, 67, 
                      503}, {698, 444, 332, 155, 561}, {693, 423, 311, 115, 
                      536}, {685, 399, 287, 70, 506}, {690, 418, 306, 107, 
                      527}, {692, 422, 310, 113, 534}, {703, 468, 356, 200, 
                      591}, {687, 401, 289, 73, 509}, {662, 453, 333, 158, 
                      579}, {700, 448, 336, 161, 567}, {663, 454, 334, 159, 
                      580}, {701, 449, 337, 163, 569}, {699, 446, 334, 158, 
                      564}, {694, 424, 312, 116, 537}, {702, 466, 354, 197, 
                      587}, {678, 380, 268, 35, 486}, {660, 452, 332, 156, 
                      577}, {650, 443, 323, 140, 561}, {689, 408, 296, 86, 
                      522}, {646, 433, 313, 119, 555}, {691, 420, 308, 110, 
                      531}, {610, 385, 265, 29, 495}, {679, 382, 270, 38, 
                      489}, {671, 467, 347, 185, 591}, {682, 396, 284, 65, 
                      501}, {680, 384, 272, 41, 492}, {640, 428, 308, 111, 
                      547}, {639, 427, 307, 110, 546}, {637, 426, 306, 108, 
                      544}, {681, 394, 282, 62, 497}, {644, 431, 311, 116, 
                      552}, {652, 445, 325, 143, 564}, {696, 432, 320, 131, 
                      552}, {608, 383, 261, 26, 492}, {606, 381, 257, 23, 
                      489}, {659, 451, 331, 155, 576}, {657, 450, 330, 153, 
                      574}, {621, 403, 283, 65, 516}, {623, 405, 285, 68, 
                      519}, {704, 470, 358, 203, 594}, {619, 402, 282, 63, 
                      514}, {705, 472, 360, 206, 597}, {625, 407, 287, 71, 
                      522}, {667, 457, 337, 164, 585}, {673, 469, 349, 188, 
                      594}, {604, 379, 253, 20, 486}, {675, 471, 351, 191, 
                      597}, {627, 409, 289, 74, 525}, {631, 419, 299, 95, 
                      531}, {642, 429, 309, 113, 549}, {665, 455, 335, 161, 
                      582}}]}, "Charting`Private`Tag$1345041#1"]]}, {}, {}, {
                }, {}}, {{GrayLevel[0], Line[{246, 1, 242, 227, 16, 483, 31, 
                  46, 498, 61, 513, 76, 91, 528, 106, 543, 121, 136, 558, 
                  151, 573, 166, 181, 588, 196, 231, 248, 211, 244, 236, 212, 
                  362, 213, 214, 363, 215, 364, 216, 217, 365, 218, 366, 219, 
                  220, 367, 221, 368, 222, 223, 369, 224, 233, 249, 225, 245, 
                  237, 210, 601, 195, 180, 586, 165, 571, 150, 135, 556, 120, 
                  541, 105, 90, 526, 75, 511, 60, 45, 496, 30, 229, 247, 15, 
                  243, 235, 14, 264, 13, 12, 262, 11, 260, 10, 9, 258, 8, 
                  256, 7, 6, 254, 5, 252, 4, 3, 250, 2, 234, 246}, 
                 VertexColors -> None]}, {GrayLevel[0.2], Line[{483, 602, 
                  482, 378, 484, 603, 485, 706, 604, 486, 678, 734, 487, 605, 
                  488, 707, 606, 489, 679, 735, 490, 607, 491, 708, 608, 492, 
                  680, 736, 493, 609, 494, 709, 610, 495, 611, 496}, 
                 VertexColors -> None], Line[{498, 612, 497, 681, 737, 499, 
                  613, 500, 395, 501, 682, 738, 502, 614, 503, 683, 739, 504, 
                  684, 740, 505, 615, 506, 685, 741, 507, 686, 742, 508, 616, 
                  509, 687, 743, 510, 617, 511}, VertexColors -> None], 
                Line[{513, 618, 512, 710, 619, 514, 620, 515, 711, 621, 516, 
                  404, 517, 622, 518, 712, 623, 519, 688, 744, 520, 624, 521, 
                  713, 625, 522, 689, 745, 523, 626, 524, 714, 627, 525, 628, 
                  526}, VertexColors -> None], Line[{528, 629, 527, 690, 746, 
                  529, 630, 530, 715, 631, 531, 691, 747, 532, 632, 533, 421, 
                  534, 692, 748, 535, 633, 536, 693, 749, 537, 694, 750, 538, 
                  634, 539, 695, 751, 540, 635, 541}, VertexColors -> None], 
                Line[{543, 636, 542, 716, 637, 544, 638, 545, 717, 639, 546, 
                  718, 640, 547, 641, 548, 719, 642, 549, 430, 550, 643, 551, 
                  720, 644, 552, 696, 752, 553, 645, 554, 721, 646, 555, 647, 
                  556}, VertexColors -> None], Line[{558, 648, 557, 697, 753, 
                  559, 649, 560, 722, 650, 561, 698, 754, 562, 651, 563, 723, 
                  652, 564, 699, 755, 565, 653, 566, 447, 567, 700, 756, 568, 
                  654, 569, 701, 757, 570, 655, 571}, VertexColors -> None], 
                Line[{573, 656, 572, 724, 657, 574, 658, 575, 725, 659, 576, 
                  726, 660, 577, 661, 578, 727, 662, 579, 728, 663, 580, 664, 
                  581, 729, 665, 582, 456, 583, 666, 584, 730, 667, 585, 668, 
                  586}, VertexColors -> None], Line[{588, 669, 587, 702, 758, 
                  589, 670, 590, 731, 671, 591, 703, 759, 592, 672, 593, 732, 
                  673, 594, 704, 760, 595, 674, 596, 733, 675, 597, 705, 761, 
                  598, 676, 599, 473, 600, 677, 601}, VertexColors -> None]}, 
               {GrayLevel[0.2], Line[{250, 370, 251, 378, 266, 386, 274, 737, 
                  394, 282, 402, 710, 290, 410, 298, 746, 418, 306, 426, 716, 
                  314, 434, 322, 753, 442, 330, 450, 724, 338, 458, 346, 758, 
                  466, 354, 474, 362}, VertexColors -> None], 
                Line[{252, 371, 253, 379, 706, 267, 387, 275, 395, 283, 403, 
                  711, 291, 411, 299, 419, 715, 307, 427, 717, 315, 435, 323, 
                  443, 722, 331, 451, 725, 339, 459, 347, 467, 731, 355, 475, 
                  363}, VertexColors -> None], Line[{254, 372, 255, 734, 380, 
                  268, 388, 276, 738, 396, 284, 404, 292, 412, 300, 747, 420, 
                  308, 428, 718, 316, 436, 324, 754, 444, 332, 452, 726, 340, 
                  460, 348, 759, 468, 356, 476, 364}, VertexColors -> None], 
                Line[{256, 373, 257, 381, 707, 269, 389, 277, 739, 397, 285, 
                  405, 712, 293, 413, 301, 421, 309, 429, 719, 317, 437, 325, 
                  445, 723, 333, 453, 727, 341, 461, 349, 469, 732, 357, 477, 
                  365}, VertexColors -> None], Line[{258, 374, 259, 735, 382, 
                  270, 390, 278, 740, 398, 286, 744, 406, 294, 414, 302, 748, 
                  422, 310, 430, 318, 438, 326, 755, 446, 334, 454, 728, 342, 
                  462, 350, 760, 470, 358, 478, 366}, VertexColors -> None], 
                Line[{260, 375, 261, 383, 708, 271, 391, 279, 741, 399, 287, 
                  407, 713, 295, 415, 303, 749, 423, 311, 431, 720, 319, 439, 
                  327, 447, 335, 455, 729, 343, 463, 351, 471, 733, 359, 479, 
                  367}, VertexColors -> None], Line[{262, 376, 263, 736, 384, 
                  272, 392, 280, 742, 400, 288, 745, 408, 296, 416, 304, 750, 
                  424, 312, 752, 432, 320, 440, 328, 756, 448, 336, 456, 344, 
                  464, 352, 761, 472, 360, 480, 368}, VertexColors -> None], 
                Line[{264, 377, 265, 385, 709, 273, 393, 281, 743, 401, 289, 
                  409, 714, 297, 417, 305, 751, 425, 313, 433, 721, 321, 441, 
                  329, 757, 449, 337, 457, 730, 345, 465, 353, 473, 361, 481, 
                  369}, VertexColors -> None]}, {}, {}}}, VertexColors -> 
              {{0.857359, 0.131106, 0.132128}, {0.8742234062351186, 
                0.26286587948357426, 0.15517390852054744}, {
                0.8972126290789038, 0.41732278655977734, 0.1848266640162075}, 
               {0.9012747655937479, 0.564553691168279, 0.21306399103673349}, {
                0.8601264776822561, 0.6732445918249519, 0.237755214115396}, {
                0.765862969026349, 0.7280267390584203, 0.27311536765836414}, {
                0.6420822516925644, 0.7433195482491758, 0.33757965795410205}, 
               {0.513417, 0.72992, 0.440682}, {0.40531900945814486, 
                0.6855538436597257, 0.5775750012742686}, {0.3234044323597477, 
                0.608067212106386, 0.7095496894379699}, {0.2680757089697266, 
                0.49151972550455114, 0.7994429380615644}, {
                0.24502266974836087, 0.34197795948656506, 
                0.8094291599533585}, {0.2644795096747588, 
                0.20081371245778284, 0.7452915397586227}, {
                0.3410745569397658, 0.1159302026487534, 0.6387406592556274}, {
                0.471412, 0.108766, 0.527016}, {0.8742234062351186, 
                0.26286587948357426, 0.15517390852054744}, {
                0.8936172892534713, 0.3939665896399829, 0.18024524274750292}, 
               {0.9018669694203086, 0.5230569160196759, 0.2051653638165682}, {
                0.8812355815496034, 0.6292078732499635, 0.22710153000410224}, 
               {0.8231277866635245, 0.7002772476601219, 0.2507734012239835}, {
                0.7323460706081208, 0.7360522072556015, 0.2874708195196776}, {
                0.623353199207058, 0.743536288082533, 0.34900725124418464}, {
                0.513417, 0.72992, 0.440682}, {0.41865841346997085, 
                0.694417675886378, 0.5573104999604352}, {0.3438344967607368, 
                0.6343472223686434, 0.6743616453768538}, {0.289426823429255, 
                0.5445855365532839, 0.7657169007152987}, {0.2557048706597953, 
                0.427389106791255, 0.8089351422832083}, {0.24716349141175206, 
                0.2982289420524988, 0.7943158864415842}, {0.2732451300719137, 
                0.1851506070985095, 0.7300821742471965}, {0.3410745569397658, 
                0.1159302026487534, 0.6387406592556274}, {0.8972126290789038, 
                0.41732278655977734, 0.1848266640162075}, {
                0.9018669694203086, 0.5230569160196759, 0.2051653638165682}, {
                0.8876210039099383, 0.6142335793595137, 0.22369240711735955}, 
               {0.84790025276282, 0.6821775384052287, 0.24205707667459608}, {
                0.7824750616905949, 0.7240490493658375, 0.2660003269531786}, {
                0.697908928969908, 0.7426735003650479, 0.30351682625688337}, {
                0.6046765697470289, 0.7432824757876085, 0.36117923965009885}, 
               {0.513417, 0.72992, 0.440682}, {0.4324799863785052, 
                0.702735041467317, 0.5371759647051406}, {0.36555754243163097, 
                0.6591329501553281, 0.6379784720803411}, {0.3132786110880166, 
                0.5950419625666934, 0.726990057616516}, {0.27513118905497225, 
                0.5090553334828343, 0.7882981622091435}, {0.2519518046988731, 
                0.4060336472616854, 0.811243136526031}, {0.24716349141175206, 
                0.2982289420524988, 0.7943158864415842}, {0.2644795096747588, 
                0.20081371245778284, 0.7452915397586227}, {
                0.9012747655937479, 0.564553691168279, 0.21306399103673349}, {
                0.8812355815496034, 0.6292078732499635, 0.22710153000410224}, 
               {0.84790025276282, 0.6821775384052287, 0.24205707667459608}, {
                0.7979630923864284, 0.7186635337923964, 0.2596277333532955}, {
                0.7323460706081208, 0.7360522072556015, 0.2874708195196776}, {
                0.660756404718962, 0.7431034437335756, 0.32618556175048585}, {
                0.586470306801995, 0.7406166649749977, 0.3770400218540763}, {
                0.513417, 0.72992, 0.440682}, {0.4486269017766758, 
                0.7081584343735934, 0.5179254411830548}, {0.3920187065202067, 
                0.6767159935053246, 0.5977801023508449}, {0.3438344967607368, 
                0.6343472223686434, 0.6743616453768538}, {0.3039488038846528, 
                0.5806782975358667, 0.7427781048923053}, {
                0.27513118905497225, 0.5090553334828343, 0.7882981622091435}, 
               {0.2557048706597953, 0.427389106791255, 0.8089351422832083}, {
                0.24502266974836087, 0.34197795948656506, 
                0.8094291599533585}, {0.8601264776822561, 0.6732445918249519, 
                0.237755214115396}, {0.8231277866635245, 0.7002772476601219, 
                0.2507734012239835}, {0.7824750616905949, 0.7240490493658375, 
                0.2660003269531786}, {0.7323460706081208, 0.7360522072556015, 
                0.2874708195196776}, {0.679367880904232, 0.742888064538603, 
                0.31482970802868593}, {0.623353199207058, 0.743536288082533, 
                0.34900725124418464}, {0.5682336187301061, 
                0.7379463992321031, 0.3929273095694831}, {0.513417, 0.72992, 
                0.440682}, {0.4648008008535281, 0.7135908905026549, 
                0.4986427474335066}, {0.41865841346997085, 0.694417675886378, 
                0.5573104999604352}, {0.37876304394550275, 
                0.6679078061971716, 0.617917388201298}, {0.3438344967607368, 
                0.6343472223686434, 0.6743616453768538}, {0.3132786110880166, 
                0.5950419625666934, 0.726990057616516}, {0.289426823429255, 
                0.5445855365532839, 0.7657169007152987}, {0.2680757089697266, 
                0.49151972550455114, 0.7994429380615644}, {0.765862969026349, 
                0.7280267390584203, 0.27311536765836414}, {
                0.7323460706081208, 0.7360522072556015, 0.2874708195196776}, {
                0.697908928969908, 0.7426735003650479, 0.30351682625688337}, {
                0.660756404718962, 0.7431034437335756, 0.32618556175048585}, {
                0.623353199207058, 0.743536288082533, 0.34900725124418464}, {
                0.586470306801995, 0.7406166649749977, 0.3770400218540763}, {
                0.5499741007186619, 0.7352727906670214, 0.40883448608360223}, 
               {0.513417, 0.72992, 0.440682}, {0.4809949475288944, 
                0.7190301473536774, 0.4793359142826024}, {0.4486269017766758, 
                0.7081584343735934, 0.5179254411830548}, {
                0.41865841346997085, 0.694417675886378, 0.5573104999604352}, {
                0.3920187065202067, 0.6767159935053246, 0.5977801023508449}, {
                0.36555754243163097, 0.6591329501553281, 0.6379784720803411}, 
               {0.3438344967607368, 0.6343472223686434, 0.6743616453768538}, {
                0.3234044323597477, 0.608067212106386, 0.7095496894379699}, {
                0.6420822516925644, 0.7433195482491758, 0.33757965795410205}, 
               {0.623353199207058, 0.743536288082533, 0.34900725124418464}, {
                0.6046765697470289, 0.7432824757876085, 0.36117923965009885}, 
               {0.586470306801995, 0.7406166649749977, 0.3770400218540763}, {
                0.5682336187301061, 0.7379463992321031, 0.3929273095694831}, {
                0.5499741007186619, 0.7352727906670214, 0.40883448608360223}, 
               {0.531699357463139, 0.7325969527800623, 0.4247549264004613}, {
                0.513417, 0.72992, 0.440682}, {0.49720259728991834, 
                0.7244739395934825, 0.46001298260998896}, {
                0.4809949475288944, 0.7190301473536774, 0.4793359142826024}, {
                0.4648008008535281, 0.7135908905026549, 0.4986427474335066}, {
                0.4486269017766758, 0.7081584343735934, 0.5179254411830548}, {
                0.4324799863785052, 0.702735041467317, 0.5371759647051406}, {
                0.41865841346997085, 0.694417675886378, 0.5573104999604352}, {
                0.40531900945814486, 0.6855538436597257, 0.5775750012742686}, 
               {0.513417, 0.72992, 0.440682}, {0.513417, 0.72992, 0.440682}, {
                0.513417, 0.72992, 0.440682}, {0.513417, 0.72992, 0.440682}, {
                0.513417, 0.72992, 0.440682}, {0.513417, 0.72992, 0.440682}, {
                0.513417, 0.72992, 0.440682}, {0.513417, 0.72992, 0.440682}, {
                0.513417, 0.72992, 0.440682}, {0.513417, 0.72992, 0.440682}, {
                0.513417, 0.72992, 0.440682}, {0.513417, 0.72992, 0.440682}, {
                0.513417, 0.72992, 0.440682}, {0.513417, 0.72992, 0.440682}, {
                0.513417, 0.72992, 0.440682}, {0.40531900945814486, 
                0.6855538436597257, 0.5775750012742686}, {
                0.41865841346997085, 0.694417675886378, 0.5573104999604352}, {
                0.4324799863785052, 0.702735041467317, 0.5371759647051406}, {
                0.4486269017766758, 0.7081584343735934, 0.5179254411830548}, {
                0.4648008008535281, 0.7135908905026549, 0.4986427474335066}, {
                0.4809949475288944, 0.7190301473536774, 0.4793359142826024}, {
                0.49720259728991834, 0.7244739395934825, 
                0.46001298260998896}, {0.513417, 0.72992, 0.440682}, {
                0.531699357463139, 0.7325969527800623, 0.4247549264004613}, {
                0.5499741007186619, 0.7352727906670214, 0.40883448608360223}, 
               {0.5682336187301061, 0.7379463992321031, 0.3929273095694831}, {
                0.586470306801995, 0.7406166649749977, 0.3770400218540763}, {
                0.6046765697470289, 0.7432824757876085, 0.36117923965009885}, 
               {0.623353199207058, 0.743536288082533, 0.34900725124418464}, {
                0.6420822516925644, 0.7433195482491758, 0.33757965795410205}, 
               {0.3234044323597477, 0.608067212106386, 0.7095496894379699}, {
                0.3438344967607368, 0.6343472223686434, 0.6743616453768538}, {
                0.36555754243163097, 0.6591329501553281, 0.6379784720803411}, 
               {0.3920187065202067, 0.6767159935053246, 0.5977801023508449}, {
                0.41865841346997085, 0.694417675886378, 0.5573104999604352}, {
                0.4486269017766758, 0.7081584343735934, 0.5179254411830548}, {
                0.4809949475288944, 0.7190301473536774, 0.4793359142826024}, {
                0.513417, 0.72992, 0.440682}, {0.5499741007186619, 
                0.7352727906670214, 0.40883448608360223}, {0.586470306801995, 
                0.7406166649749977, 0.3770400218540763}, {0.623353199207058, 
                0.743536288082533, 0.34900725124418464}, {0.660756404718962, 
                0.7431034437335756, 0.32618556175048585}, {0.697908928969908, 
                0.7426735003650479, 0.30351682625688337}, {
                0.7323460706081208, 0.7360522072556015, 0.2874708195196776}, {
                0.765862969026349, 0.7280267390584203, 0.27311536765836414}, {
                0.2680757089697266, 0.49151972550455114, 0.7994429380615644}, 
               {0.289426823429255, 0.5445855365532839, 0.7657169007152987}, {
                0.3132786110880166, 0.5950419625666934, 0.726990057616516}, {
                0.3438344967607368, 0.6343472223686434, 0.6743616453768538}, {
                0.37876304394550275, 0.6679078061971716, 0.617917388201298}, {
                0.41865841346997085, 0.694417675886378, 0.5573104999604352}, {
                0.4648008008535281, 0.7135908905026549, 0.4986427474335066}, {
                0.513417, 0.72992, 0.440682}, {0.5682336187301061, 
                0.7379463992321031, 0.3929273095694831}, {0.623353199207058, 
                0.743536288082533, 0.34900725124418464}, {0.679367880904232, 
                0.742888064538603, 0.31482970802868593}, {0.7323460706081208, 
                0.7360522072556015, 0.2874708195196776}, {0.7824750616905949, 
                0.7240490493658375, 0.2660003269531786}, {0.8231277866635245, 
                0.7002772476601219, 0.2507734012239835}, {0.8601264776822561, 
                0.6732445918249519, 0.237755214115396}, {0.24502266974836087, 
                0.34197795948656506, 0.8094291599533585}, {
                0.2557048706597953, 0.427389106791255, 0.8089351422832083}, {
                0.27513118905497225, 0.5090553334828343, 0.7882981622091435}, 
               {0.3039488038846528, 0.5806782975358667, 0.7427781048923053}, {
                0.3438344967607368, 0.6343472223686434, 0.6743616453768538}, {
                0.3920187065202067, 0.6767159935053246, 0.5977801023508449}, {
                0.4486269017766758, 0.7081584343735934, 0.5179254411830548}, {
                0.513417, 0.72992, 0.440682}, {0.586470306801995, 
                0.7406166649749977, 0.3770400218540763}, {0.660756404718962, 
                0.7431034437335756, 0.32618556175048585}, {
                0.7323460706081208, 0.7360522072556015, 0.2874708195196776}, {
                0.7979630923864284, 0.7186635337923964, 0.2596277333532955}, {
                0.84790025276282, 0.6821775384052287, 0.24205707667459608}, {
                0.8812355815496034, 0.6292078732499635, 0.22710153000410224}, 
               {0.9012747655937479, 0.564553691168279, 0.21306399103673349}, {
                0.2644795096747588, 0.20081371245778284, 0.7452915397586227}, 
               {0.24716349141175206, 0.2982289420524988, 0.7943158864415842}, 
               {0.2519518046988731, 0.4060336472616854, 0.811243136526031}, {
                0.27513118905497225, 0.5090553334828343, 0.7882981622091435}, 
               {0.3132786110880166, 0.5950419625666934, 0.726990057616516}, {
                0.36555754243163097, 0.6591329501553281, 0.6379784720803411}, 
               {0.4324799863785052, 0.702735041467317, 0.5371759647051406}, {
                0.513417, 0.72992, 0.440682}, {0.6046765697470289, 
                0.7432824757876085, 0.36117923965009885}, {0.697908928969908, 
                0.7426735003650479, 0.30351682625688337}, {
                0.7824750616905949, 0.7240490493658375, 0.2660003269531786}, {
                0.84790025276282, 0.6821775384052287, 0.24205707667459608}, {
                0.8876210039099383, 0.6142335793595137, 0.22369240711735955}, 
               {0.9018669694203086, 0.5230569160196759, 0.2051653638165682}, {
                0.8972126290789038, 0.41732278655977734, 0.1848266640162075}, 
               {0.3410745569397658, 0.1159302026487534, 0.6387406592556274}, {
                0.2732451300719137, 0.1851506070985095, 0.7300821742471965}, {
                0.24716349141175206, 0.2982289420524988, 0.7943158864415842}, 
               {0.2557048706597953, 0.427389106791255, 0.8089351422832083}, {
                0.289426823429255, 0.5445855365532839, 0.7657169007152987}, {
                0.3438344967607368, 0.6343472223686434, 0.6743616453768538}, {
                0.41865841346997085, 0.694417675886378, 0.5573104999604352}, {
                0.513417, 0.72992, 0.440682}, {0.623353199207058, 
                0.743536288082533, 0.34900725124418464}, {0.7323460706081208, 
                0.7360522072556015, 0.2874708195196776}, {0.8231277866635245, 
                0.7002772476601219, 0.2507734012239835}, {0.8812355815496034, 
                0.6292078732499635, 0.22710153000410224}, {
                0.9018669694203086, 0.5230569160196759, 0.2051653638165682}, {
                0.8936172892534713, 0.3939665896399829, 0.18024524274750292}, 
               {0.8742234062351186, 0.26286587948357426, 
                0.15517390852054744}, {0.471412, 0.108766, 0.527016}, {
                0.3410745569397658, 0.1159302026487534, 0.6387406592556274}, {
                0.2644795096747588, 0.20081371245778284, 0.7452915397586227}, 
               {0.24502266974836087, 0.34197795948656506, 
                0.8094291599533585}, {0.2680757089697266, 
                0.49151972550455114, 0.7994429380615644}, {
                0.3234044323597477, 0.608067212106386, 0.7095496894379699}, {
                0.40531900945814486, 0.6855538436597257, 0.5775750012742686}, 
               {0.513417, 0.72992, 0.440682}, {0.6420822516925644, 
                0.7433195482491758, 0.33757965795410205}, {0.765862969026349, 
                0.7280267390584203, 0.27311536765836414}, {
                0.8601264776822561, 0.6732445918249519, 0.237755214115396}, {
                0.9012747655937479, 0.564553691168279, 0.21306399103673349}, {
                0.8972126290789038, 0.41732278655977734, 0.1848266640162075}, 
               {0.8742234062351186, 0.26286587948357426, 
                0.15517390852054744}, {0.857359, 0.131106, 0.132128}, {
                0.8735665597359898, 0.2577340050281198, 0.15427630061666286}, 
               {0.8653884293053746, 0.19383910917967262, 
                0.14310054718986354}, {0.34615102936256775, 
                0.11565116635401074, 0.6343891303446604}, {
                0.40935613688184674, 0.11217699816356143, 
                0.5802100016537338}, {0.34615102936256775, 
                0.11565116635401074, 0.6343891303446604}, {
                0.40935613688184674, 0.11217699816356143, 
                0.5802100016537338}, {0.8735665597359898, 0.2577340050281198, 
                0.15427630061666286}, {0.8653884293053746, 
                0.19383910917967262, 0.14310054718986354}, {
                0.8653884293053746, 0.19383910917967262, 
                0.14310054718986354}, {0.40935613688184674, 
                0.11217699816356143, 0.5802100016537338}, {
                0.40935613688184674, 0.11217699816356143, 
                0.5802100016537338}, {0.8653884293053746, 
                0.19383910917967262, 0.14310054718986354}, {
                0.8652378546645026, 0.19266268492506342, 0.1428947807163411}, 
               {0.4105198608462342, 0.11211303224469475, 0.5792124628012284}, 
               {0.4105198608462342, 0.11211303224469475, 0.5792124628012284}, 
               {0.8652378546645026, 0.19266268492506342, 0.1428947807163411}, 
               {0.8612703630468302, 0.1616650790735148, 0.13747303935158953}, 
               {0.441182826716535, 0.11042759407628507, 0.552928308891265}, {
                0.441182826716535, 0.11042759407628507, 0.552928308891265}, {
                0.8612703630468302, 0.1616650790735148, 0.13747303935158953}, 
               {0.8612703630468302, 0.1616650790735148, 0.13747303935158953}, 
               {0.441182826716535, 0.11042759407628507, 0.552928308891265}, {
                0.441182826716535, 0.11042759407628507, 0.552928308891265}, {
                0.8612703630468302, 0.1616650790735148, 0.13747303935158953}, 
               {0.8866626000868756, 0.34878724705268604, 
                0.17138311498987502}, {0.9026102506650964, 
                0.4709738775390757, 0.19525171380452305}, {
                0.9010314272010446, 0.5816048450347985, 0.21630956150776445}, 
               {0.8768261959644992, 0.6395482128393715, 0.22945566360190908}, 
               {0.8016742177450988, 0.7159520439580311, 0.2583219540683435}, {
                0.7654450579524984, 0.7281268059557384, 0.27329436101950727}, 
               {0.6127893068719946, 0.7436585375271366, 0.35545284507541264}, 
               {0.5985275305939138, 0.7423821166578393, 0.3665361089354505}, {
                0.42618234068966826, 0.6994172117353422, 0.5458805565466534}, 
               {0.4379334951674943, 0.7045667548411215, 0.530674233778116}, {
                0.30180719670545514, 0.5753555720112891, 0.7461609692314741}, 
               {0.3236591680469857, 0.6083948888255282, 0.7091109414041636}, {
                0.24414299947392293, 0.35995456670738946, 0.815639251006295}, 
               {0.2582965104941205, 0.4421358925321468, 0.8073413813742945}, {
                0.2902010141258637, 0.15485248941104454, 0.7006617537337103}, 
               {0.24985045917431226, 0.2433190906159199, 0.775347058067265}, {
                0.9010282322416984, 0.5818287215172739, 0.21635217486439523}, 
               {0.8409387508323506, 0.6872638774242761, 0.24450651832218745}, 
               {0.726482007149869, 0.7374563304594615, 0.2899824266390536}, {
                0.5843966653588004, 0.7403130367236955, 0.37884651972785455}, 
               {0.45046598940550403, 0.7087761433634687, 0.5157328614373315}, 
               {0.34740890846818834, 0.6389451313379764, 0.6682052009239287}, 
               {0.2791485156261321, 0.5190399501242894, 0.7819524275999312}, {
                0.24413144966982633, 0.36019059411192417, 
                0.8157207876196917}, {0.8666726750369804, 0.6633589802109955, 
                0.23487654238199498}, {0.7915765364553948, 
                0.7218697428154252, 0.262102120704417}, {0.6854205649805092, 
                0.7428180205393632, 0.31113664283008174}, {
                0.5702362386237739, 0.738239628313887, 0.39118268366428155}, {
                0.46302470138185897, 0.7129943378461281, 0.5007602320312649}, 
               {0.37445213722387927, 0.6650432738768863, 0.6244662846022696}, 
               {0.3077308508725989, 0.5879056563597163, 0.7365453300360769}, {
                0.26426429643312027, 0.4760934121783326, 0.8036714177410877}, 
               {0.8020827581774524, 0.7156535487248626, 0.2581782069345028}, {
                0.7266902745428301, 0.7374064617837308, 0.28989322469391454}, 
               {0.6420247597727826, 0.7433202135678897, 0.3376147368390185}, {
                0.5560521479011938, 0.7361627549583024, 0.4035394629984867}, {
                0.47560440066385523, 0.7172195815020649, 
                0.48576258133717176}, {0.40535995696181476, 
                0.6855810526566425, 0.5775127960407229}, {
                0.34728196007941653, 0.6387818325399786, 0.6684238524861515}, 
               {0.30157143718823026, 0.574769618054754, 0.7465333729435958}, {
                0.7135346313144459, 0.7405565204504193, 0.29552785116540736}, 
               {0.656600492995417, 0.7431515375501265, 0.3287213050275635}, {
                0.5985951462177693, 0.7423920171224057, 0.36647720411314866}, 
               {0.5418503005589592, 0.7340832816299057, 0.4159117113983573}, {
                0.4881998480780289, 0.7214501146084158, 0.47074615555313526}, 
               {0.43787352768480525, 0.7045466130857334, 0.5307457276459909}, 
               {0.3949786739590693, 0.6786828471032194, 0.5932834798630217}, {
                0.3553009192038132, 0.6490969408991848, 0.65461227159951}, {
                0.6129220038191937, 0.7436570019067819, 0.3553718795943986}, {
                0.5844440081273407, 0.7403199687813427, 0.378805276044677}, {
                0.5560606067224767, 0.7361639935220486, 0.4035320939122291}, {
                0.5276366113602193, 0.7320020743844928, 0.42829427608924764}, 
               {0.5008057978921587, 0.7256841752393752, 0.4557172086966581}, {
                0.4755968986371056, 0.71721706173667, 0.4857715253329038}, {
                0.4504240016741038, 0.7087620406101557, 0.5157829196553273}, {
                0.42608782986531146, 0.6993544107218967, 0.5460241322808205}, 
               {0.513417, 0.72992, 0.440682}, {0.513417, 0.72992, 0.440682}, {
                0.513417, 0.72992, 0.440682}, {0.513417, 0.72992, 0.440682}, {
                0.513417, 0.72992, 0.440682}, {0.513417, 0.72992, 0.440682}, {
                0.513417, 0.72992, 0.440682}, {0.513417, 0.72992, 0.440682}, {
                0.42608782986531146, 0.6993544107218967, 0.5460241322808205}, 
               {0.4504240016741038, 0.7087620406101557, 0.5157829196553273}, {
                0.4755968986371056, 0.71721706173667, 0.4857715253329038}, {
                0.5008057978921587, 0.7256841752393752, 0.4557172086966581}, {
                0.5276366113602191, 0.7320020743844929, 0.4282942760892478}, {
                0.5560606067224767, 0.7361639935220486, 0.4035320939122291}, {
                0.5844440081273407, 0.7403199687813427, 0.378805276044677}, {
                0.6129220038191937, 0.7436570019067819, 0.3553718795943986}, {
                0.3553009192038132, 0.6490969408991848, 0.65461227159951}, {
                0.3949786739590693, 0.6786828471032194, 0.5932834798630217}, {
                0.4378735276848052, 0.7045466130857333, 0.530745727645991}, {
                0.4881998480780289, 0.7214501146084158, 0.47074615555313526}, 
               {0.5418503005589592, 0.7340832816299057, 0.4159117113983573}, {
                0.5985951462177693, 0.7423920171224057, 0.36647720411314866}, 
               {0.656600492995417, 0.7431515375501265, 0.3287213050275635}, {
                0.7135346313144459, 0.7405565204504193, 0.29552785116540736}, 
               {0.30157143718823026, 0.574769618054754, 0.7465333729435958}, {
                0.34728196007941653, 0.6387818325399786, 0.6684238524861515}, 
               {0.40535995696181476, 0.6855810526566425, 0.5775127960407229}, 
               {0.47560440066385523, 0.7172195815020649, 
                0.48576258133717176}, {0.5560521479011937, 
                0.7361627549583024, 0.40353946299848686}, {
                0.6420247597727826, 0.7433202135678897, 0.3376147368390185}, {
                0.7266902745428301, 0.7374064617837308, 0.28989322469391454}, 
               {0.8020827581774524, 0.7156535487248626, 0.2581782069345028}, {
                0.26426429643312027, 0.4760934121783326, 0.8036714177410877}, 
               {0.3077308508725989, 0.5879056563597163, 0.7365453300360769}, {
                0.3744521372238792, 0.6650432738768863, 0.6244662846022697}, {
                0.46302470138185897, 0.7129943378461281, 0.5007602320312649}, 
               {0.5702362386237739, 0.738239628313887, 0.39118268366428155}, {
                0.6854205649805092, 0.7428180205393632, 0.31113664283008174}, 
               {0.7915765364553948, 0.7218697428154252, 0.262102120704417}, {
                0.8666726750369804, 0.6633589802109955, 0.23487654238199498}, 
               {0.24413144966982633, 0.36019059411192417, 
                0.8157207876196917}, {0.2791485156261321, 0.5190399501242894, 
                0.7819524275999312}, {0.34740890846818834, 
                0.6389451313379764, 0.6682052009239287}, {
                0.45046598940550403, 0.7087761433634687, 0.5157328614373315}, 
               {0.5843966653588002, 0.7403130367236955, 0.3788465197278547}, {
                0.7264820071498688, 0.7374563304594616, 0.28998242663905366}, 
               {0.8409387508323506, 0.6872638774242761, 0.24450651832218745}, 
               {0.9010282322416984, 0.5818287215172739, 0.21635217486439523}, 
               {0.24985045917431226, 0.2433190906159199, 0.775347058067265}, {
                0.2582965104941205, 0.4421358925321468, 0.8073413813742945}, {
                0.3236591680469857, 0.6083948888255282, 0.7091109414041636}, {
                0.4379334951674943, 0.7045667548411215, 0.530674233778116}, {
                0.5985275305939138, 0.7423821166578393, 0.3665361089354505}, {
                0.7654450579524984, 0.7281268059557384, 0.27329436101950727}, 
               {0.8768261959644992, 0.6395482128393715, 0.22945566360190908}, 
               {0.9026102506650964, 0.4709738775390757, 0.19525171380452305}, 
               {0.2902010141258637, 0.15485248941104454, 0.7006617537337103}, 
               {0.24414299947392293, 0.35995456670738935, 
                0.8156392510062949}, {0.3018071967054551, 0.575355572011289, 
                0.7461609692314742}, {0.4261823406896682, 0.6994172117353422, 
                0.5458805565466535}, {0.6127893068719944, 0.7436585375271366, 
                0.3554528450754128}, {0.8016742177450988, 0.7159520439580311, 
                0.2583219540683435}, {0.9010314272010446, 0.5816048450347987, 
                0.21630956150776448}, {0.8866626000868756, 
                0.34878724705268604, 0.17138311498987502}, {
                0.8971673897820414, 0.41702890114773433, 
                0.18476901709355487}, {0.8991338476239814, 
                0.5872350982003348, 0.21754579742074143}, {
                0.7814526264156727, 0.724293866821205, 0.26643824099245833}, {
                0.6127893068719946, 0.7436585375271366, 0.35545284507541264}, 
               {0.4379334951674943, 0.7045667548411215, 0.530674233778116}, {
                0.3100391251129929, 0.5908748819840233, 0.7325696374449077}, {
                0.25698256090853777, 0.43465933936442347, 
                0.8081494108921501}, {0.2683753409623832, 0.1938523322981058, 
                0.7385318217535444}, {0.901771513486486, 0.5297456830366735, 
                0.20643852485235004}, {0.8745373435123592, 0.644915743341837, 
                0.2306776625298796}, {0.7428713308000883, 0.7335319817895198, 
                0.282962798994383}, {0.5985275305939138, 0.7423821166578393, 
                0.3665361089354505}, {0.45046598940550403, 
                0.7087761433634687, 0.5157328614373315}, {0.3336492015364968, 
                0.6212454691013267, 0.6919044494567411}, {0.276719592874337, 
                0.5130031338239954, 0.7857891331542718}, {
                0.24716349141175206, 0.2982289420524988, 0.7943158864415842}, 
               {0.8831938690991388, 0.6246155422131151, 0.22605601687635443}, 
               {0.8366474773674869, 0.690399245608289, 0.2460164258178723}, {
                0.7036004983762143, 0.7426076353243247, 0.30004409636796464}, 
               {0.5843966653588004, 0.7403130367236955, 0.37884651972785455}, 
               {0.46302470138185897, 0.7129943378461281, 0.5007602320312649}, 
               {0.35759420369242845, 0.652046884605293, 0.6506623968440413}, {
                0.30476417325251476, 0.5827048070603184, 0.7414901544294084}, 
               {0.25361983401483856, 0.4155249626081608, 0.8102173613069987}, 
               {0.8345167038982708, 0.6919560700328846, 0.24676614984714204}, 
               {0.785920740390104, 0.7232239973435545, 0.26452452587865394}, {
                0.6604850946392399, 0.7431065834386682, 0.32635110249254756}, 
               {0.5702362386237739, 0.738239628313887, 0.39118268366428155}, {
                0.47560440066385523, 0.7172195815020649, 
                0.48576258133717176}, {0.38760015232863865, 
                0.6737799310692736, 0.6044925309676628}, {0.3438344967607368, 
                0.6343472223686434, 0.6743616453768538}, {0.2814848043324313, 
                0.5248465348474786, 0.778262045989657}, {0.7576666144402825, 
                0.7299893187172686, 0.2766259064985136}, {0.7209697640783993, 
                0.7387762118790726, 0.29234334736247314}, {
                0.6169637046083196, 0.7436102297833019, 0.3529058224965246}, {
                0.5560521479011938, 0.7361627549583024, 0.4035394629984867}, {
                0.4881998480780289, 0.7214501146084158, 0.47074615555313526}, 
               {0.41865841346997085, 0.694417675886378, 0.5573104999604352}, {
                0.3905458551230173, 0.6757373060266408, 0.6000175785564509}, {
                0.3268590047203367, 0.6125109669231156, 0.7035996521766661}, {
                0.6624311977287697, 0.7430840623816287, 0.3251636812588824}, {
                0.6503295533371563, 0.7432241072873076, 0.3325475395910424}, {
                0.5742643421622139, 0.7388294342504216, 0.3876735135994993}, {
                0.5418503005589592, 0.7340832816299057, 0.4159117113983573}, {
                0.5008057978921587, 0.7256841752393752, 0.4557172086966581}, {
                0.4540182014689599, 0.7099692530832805, 0.5114978765998721}, {
                0.44504244374605223, 0.7069544939443067, 0.5221988700040335}, 
               {0.389157929559782, 0.6748150504802392, 0.6021260400270495}, {
                0.562051588910808, 0.7370412095187653, 0.39831291939168595}, {
                0.5783532727128845, 0.7394281466444423, 0.38411135275917885}, 
               {0.5316892062433688, 0.7325954664107011, 0.4247637698564942}, {
                0.5276366113602193, 0.7320020743844928, 0.42829427608924764}, 
               {0.513417, 0.72992, 0.440682}, {0.49180229835259626, 
                0.7226600982357849, 0.46645127618840165}, {
                0.5080152000948365, 0.728105654500295, 0.4471220830481674}, {
                0.46845199243250296, 0.7148172452596205, 
                0.49428975816952253}, {0.46845199243250296, 
                0.7148172452596205, 0.49428975816952253}, {
                0.5080152000948365, 0.728105654500295, 0.4471220830481674}, {
                0.49180229835259626, 0.7226600982357849, 
                0.46645127618840165}, {0.513417, 0.72992, 0.440682}, {
                0.5276366113602191, 0.7320020743844929, 0.4282942760892478}, {
                0.5316892062433687, 0.7325954664107011, 0.42476376985649444}, 
               {0.5783532727128845, 0.7394281466444423, 0.38411135275917885}, 
               {0.562051588910808, 0.7370412095187653, 0.39831291939168595}, {
                0.389157929559782, 0.6748150504802392, 0.6021260400270495}, {
                0.44504244374605223, 0.7069544939443067, 0.5221988700040335}, 
               {0.4540182014689599, 0.7099692530832805, 0.5114978765998721}, {
                0.5008057978921587, 0.7256841752393752, 0.4557172086966581}, {
                0.5418503005589592, 0.7340832816299057, 0.4159117113983573}, {
                0.5742643421622139, 0.7388294342504216, 0.3876735135994993}, {
                0.6503295533371563, 0.7432241072873076, 0.3325475395910424}, {
                0.6624311977287697, 0.7430840623816287, 0.3251636812588824}, {
                0.3268590047203367, 0.6125109669231156, 0.7035996521766661}, {
                0.3905458551230173, 0.6757373060266408, 0.6000175785564509}, {
                0.41865841346997085, 0.694417675886378, 0.5573104999604352}, {
                0.4881998480780289, 0.7214501146084158, 0.47074615555313526}, 
               {0.5560521479011937, 0.7361627549583024, 0.40353946299848686}, 
               {0.6169637046083196, 0.7436102297833019, 0.3529058224965246}, {
                0.7209697640783993, 0.7387762118790726, 0.29234334736247314}, 
               {0.7576666144402825, 0.7299893187172686, 0.2766259064985136}, {
                0.2814848043324313, 0.5248465348474786, 0.778262045989657}, {
                0.3438344967607368, 0.6343472223686434, 0.6743616453768538}, {
                0.38760015232863865, 0.6737799310692736, 0.6044925309676628}, 
               {0.47560440066385523, 0.7172195815020649, 
                0.48576258133717176}, {0.5702362386237739, 0.738239628313887, 
                0.39118268366428155}, {0.6604850946392399, 
                0.7431065834386682, 0.32635110249254756}, {0.785920740390104, 
                0.7232239973435545, 0.26452452587865394}, {
                0.8345167038982708, 0.6919560700328846, 0.24676614984714204}, 
               {0.25361983401483856, 0.4155249626081608, 0.8102173613069987}, 
               {0.30476417325251476, 0.5827048070603184, 0.7414901544294084}, 
               {0.35759420369242845, 0.652046884605293, 0.6506623968440413}, {
                0.46302470138185897, 0.7129943378461281, 0.5007602320312649}, 
               {0.5843966653588002, 0.7403130367236955, 0.3788465197278547}, {
                0.7036004983762143, 0.7426076353243247, 0.30004409636796464}, 
               {0.8366474773674869, 0.690399245608289, 0.2460164258178723}, {
                0.8831938690991388, 0.6246155422131151, 0.22605601687635443}, 
               {0.24716349141175206, 0.2982289420524988, 0.7943158864415842}, 
               {0.276719592874337, 0.5130031338239954, 0.7857891331542718}, {
                0.33364920153649674, 0.6212454691013266, 0.6919044494567412}, 
               {0.45046598940550403, 0.7087761433634687, 0.5157328614373315}, 
               {0.5985275305939138, 0.7423821166578393, 0.3665361089354505}, {
                0.7428713308000883, 0.7335319817895198, 0.282962798994383}, {
                0.8745373435123592, 0.644915743341837, 0.2306776625298796}, {
                0.901771513486486, 0.5297456830366735, 0.20643852485235004}, {
                0.2683753409623832, 0.1938523322981058, 0.7385318217535444}, {
                0.25698256090853777, 0.43465933936442347, 
                0.8081494108921501}, {0.3100391251129929, 0.5908748819840233, 
                0.7325696374449077}, {0.4379334951674943, 0.7045667548411215, 
                0.530674233778116}, {0.6127893068719944, 0.7436585375271366, 
                0.3554528450754128}, {0.7814526264156727, 0.724293866821205, 
                0.26643824099245833}, {0.8991338476239814, 
                0.5872350982003348, 0.21754579742074143}, {
                0.8971673897820414, 0.41702890114773433, 
                0.18476901709355487}, {0.9026102506650964, 
                0.4709738775390757, 0.19525171380452305}, {
                0.8866626000868756, 0.34878724705268604, 
                0.17138311498987502}, {0.9010282322416984, 
                0.5818287215172739, 0.21635217486439523}, {
                0.8666726750369804, 0.6633589802109955, 0.23487654238199498}, 
               {0.8020827581774524, 0.7156535487248626, 0.2581782069345028}, {
                0.7135346313144459, 0.7405565204504193, 0.29552785116540736}, 
               {0.6129220038191937, 0.7436570019067819, 0.3553718795943986}, {
                0.513417, 0.72992, 0.440682}, {0.42608782986531146, 
                0.6993544107218967, 0.5460241322808205}, {0.3553009192038132, 
                0.6490969408991848, 0.65461227159951}, {0.30157143718823026, 
                0.574769618054754, 0.7465333729435958}, {0.26426429643312027, 
                0.4760934121783326, 0.8036714177410877}, {
                0.24413144966982633, 0.36019059411192417, 
                0.8157207876196917}, {0.24985045917431226, 
                0.2433190906159199, 0.775347058067265}, {0.2902010141258637, 
                0.15485248941104454, 0.7006617537337103}, {
                0.8768261959644992, 0.6395482128393715, 0.22945566360190908}, 
               {0.9010314272010446, 0.5816048450347985, 0.21630956150776445}, 
               {0.8409387508323506, 0.6872638774242761, 0.24450651832218745}, 
               {0.7915765364553948, 0.7218697428154252, 0.262102120704417}, {
                0.7266902745428301, 0.7374064617837308, 0.28989322469391454}, 
               {0.656600492995417, 0.7431515375501265, 0.3287213050275635}, {
                0.5844440081273407, 0.7403199687813427, 0.378805276044677}, {
                0.513417, 0.72992, 0.440682}, {0.4504240016741038, 
                0.7087620406101557, 0.5157829196553273}, {0.3949786739590693, 
                0.6786828471032194, 0.5932834798630217}, {
                0.34728196007941653, 0.6387818325399786, 0.6684238524861515}, 
               {0.3077308508725989, 0.5879056563597163, 0.7365453300360769}, {
                0.2791485156261321, 0.5190399501242894, 0.7819524275999312}, {
                0.2582965104941205, 0.4421358925321468, 0.8073413813742945}, {
                0.24414299947392293, 0.35995456670738935, 
                0.8156392510062949}, {0.7654450579524984, 0.7281268059557384, 
                0.27329436101950727}, {0.8016742177450988, 
                0.7159520439580311, 0.2583219540683435}, {0.726482007149869, 
                0.7374563304594615, 0.2899824266390536}, {0.6854205649805092, 
                0.7428180205393632, 0.31113664283008174}, {
                0.6420247597727826, 0.7433202135678897, 0.3376147368390185}, {
                0.5985951462177693, 0.7423920171224057, 0.36647720411314866}, 
               {0.5560606067224767, 0.7361639935220486, 0.4035320939122291}, {
                0.513417, 0.72992, 0.440682}, {0.4755968986371056, 
                0.71721706173667, 0.4857715253329038}, {0.4378735276848052, 
                0.7045466130857333, 0.530745727645991}, {0.40535995696181476, 
                0.6855810526566425, 0.5775127960407229}, {0.3744521372238792, 
                0.6650432738768863, 0.6244662846022697}, {
                0.34740890846818834, 0.6389451313379764, 0.6682052009239287}, 
               {0.3236591680469857, 0.6083948888255282, 0.7091109414041636}, {
                0.3018071967054551, 0.575355572011289, 0.7461609692314742}, {
                0.5985275305939138, 0.7423821166578393, 0.3665361089354505}, {
                0.6127893068719946, 0.7436585375271366, 0.35545284507541264}, 
               {0.5843966653588004, 0.7403130367236955, 0.37884651972785455}, 
               {0.5702362386237739, 0.738239628313887, 0.39118268366428155}, {
                0.5560521479011938, 0.7361627549583024, 0.4035394629984867}, {
                0.5418503005589592, 0.7340832816299057, 0.4159117113983573}, {
                0.5276366113602193, 0.7320020743844928, 0.42829427608924764}, 
               {0.513417, 0.72992, 0.440682}, {0.5008057978921587, 
                0.7256841752393752, 0.4557172086966581}, {0.4881998480780289, 
                0.7214501146084158, 0.47074615555313526}, {
                0.47560440066385523, 0.7172195815020649, 
                0.48576258133717176}, {0.46302470138185897, 
                0.7129943378461281, 0.5007602320312649}, {
                0.45046598940550403, 0.7087761433634687, 0.5157328614373315}, 
               {0.4379334951674943, 0.7045667548411215, 0.530674233778116}, {
                0.4261823406896682, 0.6994172117353422, 0.5458805565466535}, {
                0.4379334951674943, 0.7045667548411215, 0.530674233778116}, {
                0.42618234068966826, 0.6994172117353422, 0.5458805565466534}, 
               {0.45046598940550403, 0.7087761433634687, 0.5157328614373315}, 
               {0.46302470138185897, 0.7129943378461281, 0.5007602320312649}, 
               {0.47560440066385523, 0.7172195815020649, 
                0.48576258133717176}, {0.4881998480780289, 
                0.7214501146084158, 0.47074615555313526}, {
                0.5008057978921587, 0.7256841752393752, 0.4557172086966581}, {
                0.513417, 0.72992, 0.440682}, {0.5276366113602191, 
                0.7320020743844929, 0.4282942760892478}, {0.5418503005589592, 
                0.7340832816299057, 0.4159117113983573}, {0.5560521479011937, 
                0.7361627549583024, 0.40353946299848686}, {
                0.5702362386237739, 0.738239628313887, 0.39118268366428155}, {
                0.5843966653588002, 0.7403130367236955, 0.3788465197278547}, {
                0.5985275305939138, 0.7423821166578393, 0.3665361089354505}, {
                0.6127893068719944, 0.7436585375271366, 0.3554528450754128}, {
                0.3236591680469857, 0.6083948888255282, 0.7091109414041636}, {
                0.30180719670545514, 0.5753555720112891, 0.7461609692314741}, 
               {0.34740890846818834, 0.6389451313379764, 0.6682052009239287}, 
               {0.37445213722387927, 0.6650432738768863, 0.6244662846022696}, 
               {0.40535995696181476, 0.6855810526566425, 0.5775127960407229}, 
               {0.43787352768480525, 0.7045466130857334, 0.5307457276459909}, 
               {0.4755968986371056, 0.71721706173667, 0.4857715253329038}, {
                0.513417, 0.72992, 0.440682}, {0.5560606067224767, 
                0.7361639935220486, 0.4035320939122291}, {0.5985951462177693, 
                0.7423920171224057, 0.36647720411314866}, {
                0.6420247597727826, 0.7433202135678897, 0.3376147368390185}, {
                0.6854205649805092, 0.7428180205393632, 0.31113664283008174}, 
               {0.7264820071498688, 0.7374563304594616, 0.28998242663905366}, 
               {0.7654450579524984, 0.7281268059557384, 0.27329436101950727}, 
               {0.8016742177450988, 0.7159520439580311, 0.2583219540683435}, {
                0.2582965104941205, 0.4421358925321468, 0.8073413813742945}, {
                0.24414299947392293, 0.35995456670738946, 0.815639251006295}, 
               {0.2791485156261321, 0.5190399501242894, 0.7819524275999312}, {
                0.3077308508725989, 0.5879056563597163, 0.7365453300360769}, {
                0.34728196007941653, 0.6387818325399786, 0.6684238524861515}, 
               {0.3949786739590693, 0.6786828471032194, 0.5932834798630217}, {
                0.4504240016741038, 0.7087620406101557, 0.5157829196553273}, {
                0.513417, 0.72992, 0.440682}, {0.5844440081273407, 
                0.7403199687813427, 0.378805276044677}, {0.656600492995417, 
                0.7431515375501265, 0.3287213050275635}, {0.7266902745428301, 
                0.7374064617837308, 0.28989322469391454}, {
                0.7915765364553948, 0.7218697428154252, 0.262102120704417}, {
                0.8409387508323506, 0.6872638774242761, 0.24450651832218745}, 
               {0.8768261959644992, 0.6395482128393715, 0.22945566360190908}, 
               {0.9010314272010446, 0.5816048450347987, 0.21630956150776448}, 
               {0.24985045917431226, 0.2433190906159199, 0.775347058067265}, {
                0.2902010141258637, 0.15485248941104454, 0.7006617537337103}, 
               {0.24413144966982633, 0.36019059411192417, 
                0.8157207876196917}, {0.26426429643312027, 
                0.4760934121783326, 0.8036714177410877}, {
                0.30157143718823026, 0.574769618054754, 0.7465333729435958}, {
                0.3553009192038132, 0.6490969408991848, 0.65461227159951}, {
                0.42608782986531146, 0.6993544107218967, 0.5460241322808205}, 
               {0.513417, 0.72992, 0.440682}, {0.6129220038191937, 
                0.7436570019067819, 0.3553718795943986}, {0.7135346313144459, 
                0.7405565204504193, 0.29552785116540736}, {
                0.8020827581774524, 0.7156535487248626, 0.2581782069345028}, {
                0.8666726750369804, 0.6633589802109955, 0.23487654238199498}, 
               {0.9010282322416984, 0.5818287215172739, 0.21635217486439523}, 
               {0.9026102506650964, 0.4709738775390757, 0.19525171380452305}, 
               {0.8866626000868756, 0.34878724705268604, 
                0.17138311498987502}, {0.8971673897820414, 
                0.41702890114773433, 0.18476901709355487}, {
                0.8831938690991388, 0.6246155422131151, 0.22605601687635443}, 
               {0.8345167038982708, 0.6919560700328846, 0.24676614984714204}, 
               {0.6624311977287697, 0.7430840623816287, 0.3251636812588824}, {
                0.562051588910808, 0.7370412095187653, 0.39831291939168595}, {
                0.389157929559782, 0.6748150504802392, 0.6021260400270495}, {
                0.3268590047203367, 0.6125109669231156, 0.7035996521766661}, {
                0.25361983401483856, 0.4155249626081608, 0.8102173613069987}, 
               {0.24716349141175206, 0.2982289420524988, 0.7943158864415842}, 
               {0.2683753409623832, 0.1938523322981058, 0.7385318217535444}, {
                0.8991338476239814, 0.5872350982003348, 0.21754579742074143}, 
               {0.8366474773674869, 0.690399245608289, 0.2460164258178723}, {
                0.6503295533371563, 0.7432241072873076, 0.3325475395910424}, {
                0.44504244374605223, 0.7069544939443067, 0.5221988700040335}, 
               {0.30476417325251476, 0.5827048070603184, 0.7414901544294084}, 
               {0.25698256090853777, 0.43465933936442347, 
                0.8081494108921501}, {0.7814526264156727, 0.724293866821205, 
                0.26643824099245833}, {0.7428713308000883, 
                0.7335319817895198, 0.282962798994383}, {0.7036004983762143, 
                0.7426076353243247, 0.30004409636796464}, {
                0.6604850946392399, 0.7431065834386682, 0.32635110249254756}, 
               {0.5742643421622139, 0.7388294342504216, 0.3876735135994993}, {
                0.5316892062433688, 0.7325954664107011, 0.4247637698564942}, {
                0.4540182014689599, 0.7099692530832805, 0.5114978765998721}, {
                0.41865841346997085, 0.694417675886378, 0.5573104999604352}, {
                0.35759420369242845, 0.652046884605293, 0.6506623968440413}, {
                0.33364920153649674, 0.6212454691013266, 0.6919044494567412}, 
               {0.3100391251129929, 0.5908748819840233, 0.7325696374449077}, {
                0.6127893068719946, 0.7436585375271366, 0.35545284507541264}, 
               {0.5843966653588004, 0.7403130367236955, 0.37884651972785455}, 
               {0.5702362386237739, 0.738239628313887, 0.39118268366428155}, {
                0.5418503005589592, 0.7340832816299057, 0.4159117113983573}, {
                0.5008057978921587, 0.7256841752393752, 0.4557172086966581}, {
                0.46302470138185897, 0.7129943378461281, 0.5007602320312649}, 
               {0.4379334951674943, 0.7045667548411215, 0.530674233778116}, {
                0.4379334951674943, 0.7045667548411215, 0.530674233778116}, {
                0.45046598940550403, 0.7087761433634687, 0.5157328614373315}, 
               {0.46302470138185897, 0.7129943378461281, 0.5007602320312649}, 
               {0.47560440066385523, 0.7172195815020649, 
                0.48576258133717176}, {0.4881998480780289, 
                0.7214501146084158, 0.47074615555313526}, {
                0.5008057978921587, 0.7256841752393752, 0.4557172086966581}, {
                0.513417, 0.72992, 0.440682}, {0.5418503005589592, 
                0.7340832816299057, 0.4159117113983573}, {0.5560521479011937, 
                0.7361627549583024, 0.40353946299848686}, {
                0.5843966653588002, 0.7403130367236955, 0.3788465197278547}, {
                0.5985275305939138, 0.7423821166578393, 0.3665361089354505}, {
                0.6127893068719944, 0.7436585375271366, 0.3554528450754128}, {
                0.3100391251129929, 0.5908748819840233, 0.7325696374449077}, {
                0.35759420369242845, 0.652046884605293, 0.6506623968440413}, {
                0.38760015232863865, 0.6737799310692736, 0.6044925309676628}, 
               {0.4540182014689599, 0.7099692530832805, 0.5114978765998721}, {
                0.49180229835259626, 0.7226600982357849, 
                0.46645127618840165}, {0.5742643421622139, 
                0.7388294342504216, 0.3876735135994993}, {0.7036004983762143, 
                0.7426076353243247, 0.30004409636796464}, {
                0.7814526264156727, 0.724293866821205, 0.26643824099245833}, {
                0.25698256090853777, 0.43465933936442347, 
                0.8081494108921501}, {0.276719592874337, 0.5130031338239954, 
                0.7857891331542718}, {0.30476417325251476, 
                0.5827048070603184, 0.7414901544294084}, {0.3438344967607368, 
                0.6343472223686434, 0.6743616453768538}, {0.3905458551230173, 
                0.6757373060266408, 0.6000175785564509}, {
                0.44504244374605223, 0.7069544939443067, 0.5221988700040335}, 
               {0.5080152000948365, 0.728105654500295, 0.4471220830481674}, {
                0.5783532727128845, 0.7394281466444423, 0.38411135275917885}, 
               {0.6503295533371563, 0.7432241072873076, 0.3325475395910424}, {
                0.7209697640783993, 0.7387762118790726, 0.29234334736247314}, 
               {0.8366474773674869, 0.690399245608289, 0.2460164258178723}, {
                0.8745373435123592, 0.644915743341837, 0.2306776625298796}, {
                0.8991338476239814, 0.5872350982003348, 0.21754579742074143}, 
               {0.2683753409623832, 0.1938523322981058, 0.7385318217535444}, {
                0.25361983401483856, 0.4155249626081608, 0.8102173613069987}, 
               {0.2814848043324313, 0.5248465348474786, 0.778262045989657}, {
                0.389157929559782, 0.6748150504802392, 0.6021260400270495}, {
                0.46845199243250296, 0.7148172452596205, 
                0.49428975816952253}, {0.6624311977287697, 
                0.7430840623816287, 0.3251636812588824}, {0.7576666144402826, 
                0.7299893187172685, 0.27662590649851354}, {
                0.8831938690991388, 0.6246155422131151, 0.22605601687635443}, 
               {0.8971673897820414, 0.41702890114773433, 
                0.18476901709355487}, {0.7576666144402825, 
                0.7299893187172686, 0.2766259064985136}, {
                0.46845199243250296, 0.7148172452596205, 
                0.49428975816952253}, {0.2814848043324313, 
                0.5248465348474786, 0.778262045989657}, {0.8745373435123592, 
                0.644915743341837, 0.2306776625298796}, {0.7209697640783993, 
                0.7387762118790726, 0.29234334736247314}, {
                0.5783532727128845, 0.7394281466444423, 0.38411135275917885}, 
               {0.5080152000948365, 0.728105654500295, 0.4471220830481674}, {
                0.3905458551230173, 0.6757373060266408, 0.6000175785564509}, {
                0.3438344967607368, 0.6343472223686434, 0.6743616453768538}, {
                0.276719592874337, 0.5130031338239954, 0.7857891331542718}, {
                0.49180229835259626, 0.7226600982357849, 
                0.46645127618840165}, {0.38760015232863865, 
                0.6737799310692736, 0.6044925309676628}, {0.5985275305939138, 
                0.7423821166578393, 0.3665361089354505}, {0.5560521479011938, 
                0.7361627549583024, 0.4035394629984867}, {0.513417, 0.72992, 
                0.440682}, {0.4881998480780289, 0.7214501146084158, 
                0.47074615555313526}, {0.47560440066385523, 
                0.7172195815020649, 0.48576258133717176}, {
                0.45046598940550403, 0.7087761433634687, 0.5157328614373315}, 
               {0.5702362386237739, 0.738239628313887, 0.39118268366428155}, {
                0.3336492015364968, 0.6212454691013267, 0.6919044494567411}, {
                0.41865841346997085, 0.694417675886378, 0.5573104999604352}, {
                0.5316892062433687, 0.7325954664107011, 0.42476376985649444}, 
               {0.6604850946392399, 0.7431065834386682, 0.32635110249254756}, 
               {0.7428713308000883, 0.7335319817895198, 0.282962798994383}, {
                0.24716349141175206, 0.2982289420524988, 0.7943158864415842}, 
               {0.3268590047203367, 0.6125109669231156, 0.7035996521766661}, {
                0.562051588910808, 0.7370412095187653, 0.39831291939168595}, {
                0.8345167038982708, 0.6919560700328846, 0.24676614984714204}, 
               {0.8623627116201488, 0.6716107139566951, 0.23696838325677666}, 
               {0.5924714454931508, 0.7414953681146348, 0.3718119992750524}, {
                0.3382357705137273, 0.6271453565135432, 0.6840046999458037}, {
                0.2465570830633669, 0.3106212724643838, 0.7985968666772058}, {
                0.7466336186588234, 0.7326311191505562, 0.281351392665237}, {
                0.6812646532569644, 0.7428661143559141, 0.3136723861071593}, {
                0.547936806562774, 0.7349744844849329, 0.41060931922698424}, {
                0.427583038462616, 0.7003479542219366, 0.5437526922256523}, {
                0.3382357705137273, 0.6271453565135432, 0.6840046999458037}, {
                0.5702362386237739, 0.738239628313887, 0.39118268366428155}, {
                0.44688527676607265, 0.7075734609285124, 0.52000182496327}, {
                0.46482180127928696, 0.7135979440826905, 0.4986177105035373}, 
               {0.48640049844743266, 0.72084575273608, 0.47289135923656905}, {
                0.504408998494399, 0.7268944108852681, 0.45142143478332725}, {
                0.547936806562774, 0.7349744844849329, 0.41060931922698424}, {
                0.5924714454931508, 0.7414953681146348, 0.3718119992750524}, {
                0.37883480892546567, 0.6679554929410154, 0.6178083667240674}, 
               {0.48640049844743266, 0.72084575273608, 0.47289135923656905}, {
                0.26744712755809485, 0.4899574565896606, 0.8004358398702285}, 
               {0.31224380660861606, 0.5937108521108321, 0.7287723694536742}, 
               {0.37883480892546567, 0.6679554929410154, 0.6178083667240674}, 
               {0.46482180127928696, 0.7135979440826905, 0.4986177105035373}, 
               {0.5702362386237739, 0.738239628313887, 0.39118268366428155}, {
                0.6812646532569644, 0.7428661143559141, 0.3136723861071593}, {
                0.8623627116201488, 0.6716107139566951, 0.23696838325677666}, 
               {0.26744712755809485, 0.4899574565896606, 0.8004358398702285}, 
               {0.44688527676607265, 0.7075734609285124, 0.52000182496327}, {
                0.7466336186588234, 0.7326311191505562, 0.281351392665237}, {
                0.7466336186588234, 0.7326311191505562, 0.281351392665237}, {
                0.44688527676607265, 0.7075734609285124, 0.52000182496327}, {
                0.26744712755809485, 0.4899574565896606, 0.8004358398702285}, 
               {0.8623627116201488, 0.6716107139566951, 0.23696838325677666}, 
               {0.6812646532569644, 0.7428661143559141, 0.3136723861071593}, {
                0.5702362386237739, 0.738239628313887, 0.39118268366428155}, {
                0.46482180127928696, 0.7135979440826905, 0.4986177105035373}, 
               {0.37883480892546567, 0.6679554929410154, 0.6178083667240674}, 
               {0.31224380660861606, 0.5937108521108321, 0.7287723694536742}, 
               {0.26744712755809485, 0.4899574565896606, 0.8004358398702285}, 
               {0.48640049844743266, 0.72084575273608, 0.47289135923656905}, {
                0.37883480892546567, 0.6679554929410154, 0.6178083667240674}, 
               {0.5924714454931508, 0.7414953681146348, 0.3718119992750524}, {
                0.547936806562774, 0.7349744844849329, 0.41060931922698424}, {
                0.504408998494399, 0.7268944108852681, 0.45142143478332725}, {
                0.48640049844743266, 0.72084575273608, 0.47289135923656905}, {
                0.46482180127928696, 0.7135979440826905, 0.4986177105035373}, 
               {0.44688527676607265, 0.7075734609285124, 0.52000182496327}, {
                0.5702362386237739, 0.738239628313887, 0.39118268366428155}, {
                0.3382357705137273, 0.6271453565135432, 0.6840046999458037}, {
                0.427583038462616, 0.7003479542219366, 0.5437526922256523}, {
                0.547936806562774, 0.7349744844849329, 0.41060931922698424}, {
                0.6812646532569644, 0.7428661143559141, 0.3136723861071593}, {
                0.7466336186588232, 0.7326311191505562, 0.28135139266523707}, 
               {0.2465570830633669, 0.3106212724643838, 0.7985968666772058}, {
                0.3382357705137273, 0.6271453565135432, 0.6840046999458037}, {
                0.5924714454931508, 0.7414953681146348, 0.3718119992750524}, {
                0.8623627116201488, 0.6716107139566951, 
                0.23696838325677666}}, VertexNormals -> {{0.4293183441601599, 
                0.4293183441601599, 0.7945888992020698}, {0.4957785258980193, 
                0.42495302219830233, 0.7573761167233333}, {
                0.5536868362914008, 0.39549059735100056, 0.7328151709159468}, 
               {0.6041263299252138, 0.3452150456715507, 0.718232517875013}, {
                0.6465183186964039, 0.27707927944131594, 0.7108031629742909}, 
               {0.6791693775913413, 0.19404839359752607, 0.7078659318574455}, 
               {0.6999517813649596, 0.09999311162356565, 0.707155486008457}, {
                0.7071067306789149, 0, 0.7071068316941767}, {
                0.6999517813649596, -0.09999311162356565, 0.707155486008457}, 
               {0.6791693775913413, -0.19404839359752607, 
                0.7078659318574455}, {0.6465183186964039, 
                -0.27707927944131594, 0.7108031629742909}, {
                0.6041263299252138, -0.3452150456715507, 0.718232517875013}, {
                0.5536868362914008, -0.39549059735100056, 
                0.7328151709159468}, {0.4957785258980193, 
                -0.42495302219830233, 0.7573761167233333}, {
                0.4293183441601599, -0.4293183441601599, 0.7945888992020698}, 
               {0.42495302219830233, 0.4957785258980193, 0.7573761167233333}, 
               {0.47287946088175675, 0.47287946088175675, 
                0.7434850576523768}, {0.5180009290021158, 0.4316674408350965, 
                0.7384702147519718}, {0.5596806640876318, 0.3731204427250878, 
                0.739958572804628}, {0.5962670546733819, 0.2981335273366909, 
                0.7453737313515367}, {0.6253379589536537, 
                0.20844598631788452, 0.7519991408769313}, {
                0.6442230331046442, 0.10737050551744068, 0.7572636648898333}, 
               {0.65079131986138, 0, 0.7592566483035121}, {
                0.6442230331046442, -0.10737050551744068, 
                0.7572636648898333}, {0.6253379589536537, 
                -0.20844598631788452, 0.7519991408769313}, {
                0.5962670546733819, -0.2981335273366909, 0.7453737313515367}, 
               {0.5596806640876318, -0.3731204427250878, 0.739958572804628}, {
                0.5180009290021158, -0.4316674408350965, 0.7384702147519718}, 
               {0.47287946088175675, -0.47287946088175675, 
                0.7434850576523768}, {0.42495302219830233, 
                -0.4957785258980193, 0.7573761167233333}, {
                0.3954905973510005, 0.5536868362914007, 0.7328151709159467}, {
                0.4316674408350965, 0.5180009290021158, 0.7384702147519718}, {
                0.46758401364024776, 0.46758401364024776, 
                0.7501535711946943}, {0.5021041690387599, 
                0.40168333523100785, 0.7658602363562101}, {
                0.5333208698811742, 0.3199925219287045, 0.783054043894095}, {
                0.5586719030349345, 0.22346876121397377, 0.7987161057101684}, 
               {0.5753828294961801, 0.11507656589923601, 0.8097480987948096}, 
               {0.5812381387371011, 0, 0.8137335104795859}, {
                0.5753828294961801, -0.11507656589923601, 
                0.8097480987948096}, {0.5586719030349345, 
                -0.22346876121397377, 0.7987161057101684}, {
                0.5333208698811742, -0.3199925219287045, 0.783054043894095}, {
                0.5021041690387599, -0.40168333523100785, 
                0.7658602363562101}, {0.46758401364024776, 
                -0.46758401364024776, 0.7501535711946943}, {
                0.4316674408350965, -0.5180009290021158, 0.7384702147519718}, 
               {0.3954905973510005, -0.5536868362914007, 0.7328151709159467}, 
               {0.3452150456715507, 0.6041263299252138, 0.718232517875013}, {
                0.3731204427250878, 0.5596806640876318, 0.739958572804628}, {
                0.40168333523100785, 0.5021041690387599, 0.7658602363562101}, 
               {0.42978559432824454, 0.42978559432824454, 0.794083550903704}, 
               {0.4556635887003626, 0.34174769152527196, 0.8219362562083841}, 
               {0.47696949378992737, 0.23848474689496368, 
                0.8459462911392339}, {0.491147048009862, 0.1227867620024655, 
                0.8623792601333524}, {0.4961388849264837, 0, 
                0.8682431726560855}, {0.491147048009862, -0.1227867620024655, 
                0.8623792601333524}, {0.47696949378992737, 
                -0.23848474689496368, 0.8459462911392339}, {
                0.4556635887003626, -0.34174769152527196, 
                0.8219362562083841}, {0.42978559432824454, 
                -0.42978559432824454, 0.794083550903704}, {
                0.40168333523100785, -0.5021041690387599, 
                0.7658602363562101}, {0.3731204427250878, 
                -0.5596806640876318, 0.739958572804628}, {0.3452150456715507, 
                -0.6041263299252138, 0.718232517875013}, {
                0.27707927944131594, 0.6465183186964039, 0.7108031629742909}, 
               {0.2981335273366909, 0.5962670546733819, 0.7453737313515367}, {
                0.3199925219287045, 0.5333208698811742, 0.783054043894095}, {
                0.34174769152527196, 0.4556635887003626, 0.8219362562083841}, 
               {0.3619690262048642, 0.3619690262048642, 0.8590441479555079}, {
                0.37874044009606794, 0.25249362673071196, 
                0.8903946582814883}, {0.38995864886761106, 
                0.12998621628920368, 0.9116116693791079}, {
                0.3939192510371818, 0, 0.9191450503931933}, {
                0.38995864886761106, -0.12998621628920368, 
                0.9116116693791079}, {0.37874044009606794, 
                -0.25249362673071196, 0.8903946582814883}, {
                0.3619690262048642, -0.3619690262048642, 0.8590441479555079}, 
               {0.34174769152527196, -0.4556635887003626, 
                0.8219362562083841}, {0.3199925219287045, 
                -0.5333208698811742, 0.783054043894095}, {0.2981335273366909, 
                -0.5962670546733819, 0.7453737313515367}, {
                0.27707927944131594, -0.6465183186964039, 
                0.7108031629742909}, {0.19404839359752607, 
                0.6791693775913413, 0.7078659318574455}, {
                0.20844598631788452, 0.6253379589536537, 0.7519991408769313}, 
               {0.22346876121397377, 0.5586719030349345, 0.7987161057101684}, 
               {0.23848474689496368, 0.47696949378992737, 
                0.8459462911392339}, {0.25249362673071196, 
                0.37874044009606794, 0.8903946582814883}, {
                0.26414755660173067, 0.26414755660173067, 0.9276055932791}, {
                0.271959778139236, 0.135979889069618, 0.9526527955362708}, {
                0.2747210916134549, 0, 0.9615239580076577}, {
                0.271959778139236, -0.135979889069618, 0.9526527955362708}, {
                0.26414755660173067, -0.26414755660173067, 0.9276055932791}, {
                0.25249362673071196, -0.37874044009606794, 
                0.8903946582814883}, {0.23848474689496368, 
                -0.47696949378992737, 0.8459462911392339}, {
                0.22346876121397377, -0.5586719030349345, 
                0.7987161057101684}, {0.20844598631788452, 
                -0.6253379589536537, 0.7519991408769313}, {
                0.19404839359752607, -0.6791693775913413, 
                0.7078659318574455}, {0.09999311162356565, 
                0.6999517813649596, 0.707155486008457}, {0.10737050551744068, 
                0.6442230331046442, 0.7572636648898333}, {
                0.11507656589923601, 0.5753828294961801, 0.8097480987948096}, 
               {0.1227867620024655, 0.491147048009862, 0.8623792601333524}, {
                0.12998621628920368, 0.38995864886761106, 
                0.9116116693791079}, {0.135979889069618, 0.271959778139236, 
                0.9526527955362708}, {0.13999997302363665, 
                0.13999997302363665, 0.9802040680933547}, {
                0.14142133643831953, 0, 0.9899494964895934}, {
                0.13999997302363665, -0.13999997302363665, 
                0.9802040680933547}, {0.135979889069618, -0.271959778139236, 
                0.9526527955362708}, {0.12998621628920368, 
                -0.38995864886761106, 0.9116116693791079}, {
                0.1227867620024655, -0.491147048009862, 0.8623792601333524}, {
                0.11507656589923601, -0.5753828294961801, 
                0.8097480987948096}, {0.10737050551744068, 
                -0.6442230331046442, 0.7572636648898333}, {
                0.09999311162356565, -0.6999517813649596, 0.707155486008457}, 
               {0, 0.7071067306789149, 0.7071068316941767}, {0, 
                0.65079131986138, 0.7592566483035121}, {0, 
                0.5812381387371011, 0.8137335104795859}, {0, 
                0.4961388849264837, 0.8682431726560855}, {0, 
                0.3939192510371818, 0.9191450503931933}, {0, 
                0.2747210916134549, 0.9615239580076577}, {0, 
                0.14142133643831953, 0.9899494964895934}, {0, 0, 1}, {0, 
                -0.14142133643831953, 0.9899494964895934}, {0, 
                -0.2747210916134549, 0.9615239580076577}, {0, 
                -0.3939192510371818, 0.9191450503931933}, {0, 
                -0.4961388849264837, 0.8682431726560855}, {0, 
                -0.5812381387371011, 0.8137335104795859}, {0, 
                -0.65079131986138, 0.7592566483035121}, {0, 
                -0.7071067306789149, 0.7071068316941767}, {
                -0.09999311162356565, 0.6999517813649596, 0.707155486008457}, 
               {-0.10737050551744068, 0.6442230331046442, 
                0.7572636648898333}, {-0.11507656589923601, 
                0.5753828294961801, 0.8097480987948096}, {
                -0.1227867620024655, 0.491147048009862, 0.8623792601333524}, {
                -0.12998621628920368, 0.38995864886761106, 
                0.9116116693791079}, {-0.135979889069618, 0.271959778139236, 
                0.9526527955362708}, {-0.13999997302363665, 
                0.13999997302363665, 0.9802040680933547}, {
                -0.14142133643831953, 0, 0.9899494964895934}, {
                -0.13999997302363665, -0.13999997302363665, 
                0.9802040680933547}, {-0.135979889069618, -0.271959778139236, 
                0.9526527955362708}, {-0.12998621628920368, 
                -0.38995864886761106, 0.9116116693791079}, {
                -0.1227867620024655, -0.491147048009862, 0.8623792601333524}, 
               {-0.11507656589923601, -0.5753828294961801, 
                0.8097480987948096}, {-0.10737050551744068, 
                -0.6442230331046442, 0.7572636648898333}, {
                -0.09999311162356565, -0.6999517813649596, 
                0.707155486008457}, {-0.19404839359752607, 
                0.6791693775913413, 0.7078659318574455}, {
                -0.20844598631788452, 0.6253379589536537, 
                0.7519991408769313}, {-0.22346876121397377, 
                0.5586719030349345, 0.7987161057101684}, {
                -0.23848474689496368, 0.47696949378992737, 
                0.8459462911392339}, {-0.25249362673071196, 
                0.37874044009606794, 0.8903946582814883}, {
                -0.26414755660173067, 0.26414755660173067, 0.9276055932791}, {
                -0.271959778139236, 0.135979889069618, 0.9526527955362708}, {
                -0.2747210916134549, 0, 0.9615239580076577}, {
                -0.271959778139236, -0.135979889069618, 0.9526527955362708}, {
                -0.26414755660173067, -0.26414755660173067, 0.9276055932791}, 
               {-0.25249362673071196, -0.37874044009606794, 
                0.8903946582814883}, {-0.23848474689496368, 
                -0.47696949378992737, 0.8459462911392339}, {
                -0.22346876121397377, -0.5586719030349345, 
                0.7987161057101684}, {-0.20844598631788452, 
                -0.6253379589536537, 0.7519991408769313}, {
                -0.19404839359752607, -0.6791693775913413, 
                0.7078659318574455}, {-0.27707927944131594, 
                0.6465183186964039, 0.7108031629742909}, {
                -0.2981335273366909, 0.5962670546733819, 0.7453737313515367}, 
               {-0.3199925219287045, 0.5333208698811742, 0.783054043894095}, {
                -0.34174769152527196, 0.4556635887003626, 
                0.8219362562083841}, {-0.3619690262048642, 
                0.3619690262048642, 0.8590441479555079}, {
                -0.37874044009606794, 0.25249362673071196, 
                0.8903946582814883}, {-0.38995864886761106, 
                0.12998621628920368, 0.9116116693791079}, {
                -0.3939192510371818, 0, 0.9191450503931933}, {
                -0.38995864886761106, -0.12998621628920368, 
                0.9116116693791079}, {-0.37874044009606794, 
                -0.25249362673071196, 0.8903946582814883}, {
                -0.3619690262048642, -0.3619690262048642, 
                0.8590441479555079}, {-0.34174769152527196, 
                -0.4556635887003626, 0.8219362562083841}, {
                -0.3199925219287045, -0.5333208698811742, 0.783054043894095}, 
               {-0.2981335273366909, -0.5962670546733819, 
                0.7453737313515367}, {-0.27707927944131594, 
                -0.6465183186964039, 0.7108031629742909}, {
                -0.3452150456715507, 0.6041263299252138, 0.718232517875013}, {
                -0.3731204427250878, 0.5596806640876318, 0.739958572804628}, {
                -0.40168333523100785, 0.5021041690387599, 
                0.7658602363562101}, {-0.42978559432824454, 
                0.42978559432824454, 0.794083550903704}, {
                -0.4556635887003626, 0.34174769152527196, 
                0.8219362562083841}, {-0.47696949378992737, 
                0.23848474689496368, 0.8459462911392339}, {
                -0.491147048009862, 0.1227867620024655, 0.8623792601333524}, {
                -0.4961388849264837, 0, 0.8682431726560855}, {
                -0.491147048009862, -0.1227867620024655, 0.8623792601333524}, 
               {-0.47696949378992737, -0.23848474689496368, 
                0.8459462911392339}, {-0.4556635887003626, 
                -0.34174769152527196, 0.8219362562083841}, {
                -0.42978559432824454, -0.42978559432824454, 
                0.794083550903704}, {-0.40168333523100785, 
                -0.5021041690387599, 0.7658602363562101}, {
                -0.3731204427250878, -0.5596806640876318, 0.739958572804628}, 
               {-0.3452150456715507, -0.6041263299252138, 0.718232517875013}, 
               {-0.3954905973510005, 0.5536868362914007, 0.7328151709159467}, 
               {-0.4316674408350965, 0.5180009290021158, 0.7384702147519718}, 
               {-0.46758401364024776, 0.46758401364024776, 
                0.7501535711946943}, {-0.5021041690387599, 
                0.40168333523100785, 0.7658602363562101}, {
                -0.5333208698811742, 0.3199925219287045, 0.783054043894095}, {
                -0.5586719030349345, 0.22346876121397377, 
                0.7987161057101684}, {-0.5753828294961801, 
                0.11507656589923601, 0.8097480987948096}, {
                -0.5812381387371011, 0, 0.8137335104795859}, {
                -0.5753828294961801, -0.11507656589923601, 
                0.8097480987948096}, {-0.5586719030349345, 
                -0.22346876121397377, 0.7987161057101684}, {
                -0.5333208698811742, -0.3199925219287045, 0.783054043894095}, 
               {-0.5021041690387599, -0.40168333523100785, 
                0.7658602363562101}, {-0.46758401364024776, 
                -0.46758401364024776, 0.7501535711946943}, {
                -0.4316674408350965, -0.5180009290021158, 
                0.7384702147519718}, {-0.3954905973510005, 
                -0.5536868362914007, 0.7328151709159467}, {
                -0.42495302219830233, 0.4957785258980193, 
                0.7573761167233333}, {-0.47287946088175675, 
                0.47287946088175675, 0.7434850576523768}, {
                -0.5180009290021158, 0.4316674408350965, 0.7384702147519718}, 
               {-0.5596806640876318, 0.3731204427250878, 0.739958572804628}, {
                -0.5962670546733819, 0.2981335273366909, 0.7453737313515367}, 
               {-0.6253379589536537, 0.20844598631788452, 
                0.7519991408769313}, {-0.6442230331046442, 
                0.10737050551744068, 0.7572636648898333}, {-0.65079131986138, 
                0, 0.7592566483035121}, {-0.6442230331046442, 
                -0.10737050551744068, 0.7572636648898333}, {
                -0.6253379589536537, -0.20844598631788452, 
                0.7519991408769313}, {-0.5962670546733819, 
                -0.2981335273366909, 0.7453737313515367}, {
                -0.5596806640876318, -0.3731204427250878, 0.739958572804628}, 
               {-0.5180009290021158, -0.4316674408350965, 
                0.7384702147519718}, {-0.47287946088175675, 
                -0.47287946088175675, 0.7434850576523768}, {
                -0.42495302219830233, -0.4957785258980193, 
                0.7573761167233333}, {-0.4293183441601599, 
                0.4293183441601599, 0.7945888992020698}, {
                -0.4957785258980193, 0.42495302219830233, 
                0.7573761167233333}, {-0.5536868362914008, 
                0.39549059735100056, 0.7328151709159468}, {
                -0.6041263299252138, 0.3452150456715507, 0.718232517875013}, {
                -0.6465183186964039, 0.27707927944131594, 
                0.7108031629742909}, {-0.6791693775913413, 
                0.19404839359752607, 0.7078659318574455}, {
                -0.6999517813649596, 0.09999311162356565, 0.707155486008457}, 
               {-0.7071067306789149, 0, 0.7071068316941767}, {
                -0.6999517813649596, -0.09999311162356565, 
                0.707155486008457}, {-0.6791693775913413, 
                -0.19404839359752607, 0.7078659318574455}, {
                -0.6465183186964039, -0.27707927944131594, 
                0.7108031629742909}, {-0.6041263299252138, 
                -0.3452150456715507, 0.718232517875013}, {
                -0.5536868362914008, -0.39549059735100056, 
                0.7328151709159468}, {-0.4957785258980193, 
                -0.42495302219830233, 0.7573761167233333}, {
                -0.4293183441601599, -0.4293183441601599, 
                0.7945888992020698}, {0.4593729990005652, 0.4593729990005652, 
                0.7602321326926752}, {0.4306376737641892, 0.4637636486691268, 
                0.774257368132888}, {0.4593729990005652, -0.4593729990005652, 
                0.7602321326926752}, {0.4306376737641892, 
                -0.4637636486691268, 0.774257368132888}, {
                -0.4593729990005652, 0.4593729990005652, 0.7602321326926752}, 
               {-0.4306376737641892, 0.4637636486691268, 0.774257368132888}, {
                -0.4593729990005652, -0.4593729990005652, 
                0.7602321326926752}, {-0.4637636486691268, 
                -0.4306376737641892, 0.774257368132888}, {0.4637636486691268, 
                0.4306376737641892, 0.774257368132888}, {0.4637636486691268, 
                -0.4306376737641892, 0.774257368132888}, {
                -0.4637636486691268, 0.4306376737641892, 0.774257368132888}, {
                -0.4306376737641892, -0.4637636486691268, 0.774257368132888}, 
               {0.44686518835530753, 0.44686518835530753, 
                0.7749987141101274}, {0.44686518835530753, 
                -0.44686518835530753, 0.7749987141101274}, {
                -0.44686518835530753, 0.44686518835530753, 
                0.7749987141101274}, {-0.44686518835530753, 
                -0.44686518835530753, 0.7749987141101274}, {
                0.43091115817353537, 0.44687083069848105, 
                0.7839783379867021}, {0.44687083069848105, 
                -0.43091115817353537, 0.7839783379867021}, {
                -0.44687083069848105, 0.43091115817353537, 
                0.7839783379867021}, {-0.43091115817353537, 
                -0.44687083069848105, 0.7839783379867021}, {
                0.44687083069848105, 0.43091115817353537, 
                0.7839783379867021}, {0.43091115817353537, 
                -0.44687083069848105, 0.7839783379867021}, {
                -0.43091115817353537, 0.44687083069848105, 
                0.7839783379867021}, {-0.44687083069848105, 
                -0.43091115817353537, 0.7839783379867021}, {
                0.5282645562989748, 0.4088285937534415, 0.7441745356351765}, {
                0.49817822081123136, 0.4501928947959336, 0.7410430606817754}, 
               {0.6090319163241771, 0.33775274939846234, 0.7176372378662357}, 
               {0.5639405419069264, 0.36491456476877304, 0.7408160538307328}, 
               {0.6688781968303905, 0.22192193838816213, 0.709473474533732}, {
                0.6162596242911283, 0.23857875013645213, 0.7505359787857512}, 
               {0.7021518559955869, 0.07784005383865548, 0.7077596323190154}, 
               {0.6463295352744644, 0.0835940588081242, 0.7584656651186518}, {
                0.7021518559955869, -0.07784005383865544, 
                0.7077596323190154}, {0.6463295352744644, 
                -0.08359405880812415, 0.7584656651186518}, {
                0.6688781968303905, -0.2219219383881621, 0.709473474533732}, {
                0.6162596242911283, -0.2385787501364521, 0.7505359787857512}, 
               {0.6090319163241771, -0.33775274939846234, 
                0.7176372378662357}, {0.5639405419069264, 
                -0.36491456476877304, 0.7408160538307328}, {
                0.5282645562989748, -0.4088285937534415, 0.7441745356351765}, 
               {0.49817822081123136, -0.4501928947959336, 
                0.7410430606817754}, {0.45184251413284654, 
                0.49023176565783877, 0.7453262093621197}, {0.505771129896187, 
                0.39276067725801583, 0.7680720113136261}, {
                0.5508465003377766, 0.2559337078527797, 0.7943966705936978}, {
                0.5773476240654188, 0.08960699174175904, 0.811566576453841}, {
                0.5773476240654188, -0.08960699174175898, 0.811566576453841}, 
               {0.5508465003377766, -0.2559337078527797, 0.7943966705936978}, 
               {0.505771129896187, -0.39276067725801583, 0.7680720113136261}, 
               {0.45184251413284654, -0.49023176565783877, 
                0.7453262093621197}, {0.3892195192816053, 0.5280068246987126, 
                0.7547959716915419}, {0.4328575449380158, 
                0.42019447105180713, 0.7975405646659771}, {
                0.4704792145732721, 0.2732610061775047, 0.8390338081134601}, {
                0.4929015022651667, 0.09562597942222517, 0.8648143044170129}, 
               {0.4929015022651667, -0.09562597942222513, 
                0.8648143044170129}, {0.4704792145732721, 
                -0.2732610061775047, 0.8390338081134601}, {
                0.4328575449380158, -0.42019447105180713, 
                0.7975405646659771}, {0.3892195192816053, 
                -0.5280068246987126, 0.7547959716915419}, {
                0.31050212341342714, 0.5617034564507506, 0.7668622160251687}, 
               {0.3441741114346882, 0.445485555397011, 0.8264906538798605}, {
                0.3737005028971536, 0.28941178685153307, 0.8812427314683606}, 
               {0.3914131897727447, 0.10124897544848033, 0.9146279898639438}, 
               {0.3914131897727447, -0.10124897544848027, 
                0.9146279898639438}, {0.3737005028971536, 
                -0.28941178685153307, 0.8812427314683607}, {
                0.3441741114346882, -0.445485555397011, 0.8264906538798605}, {
                0.31050212341342714, -0.5617034564507506, 
                0.7668622160251687}, {0.21697560934658114, 
                0.5887995908547458, 0.7786119872940332}, {0.240181535014239, 
                0.46632745069418663, 0.8513821345126199}, {
                0.26068765874921046, 0.3028386075494427, 0.9166955450711921}, 
               {0.27301205120528754, 0.10593233719130543, 
                0.9561604257831784}, {0.27301205120528754, 
                -0.10593233719130538, 0.9561604257831784}, {
                0.26068765874921046, -0.30283860754944264, 
                0.9166955450711921}, {0.240181535014239, 
                -0.46632745069418663, 0.8513821345126199}, {
                0.21697560934658114, -0.5887995908547458, 
                0.7786119872940332}, {0.11175590736391439, 0.606544321305862, 
                0.7871560223112565}, {0.12366437327268699, 
                0.4802055030720416, 0.8683949548462389}, {
                0.13421549809053748, 0.3118352470157374, 0.9406088341021165}, 
               {0.14055528997197267, 0.10907469409007282, 
                0.9840461989002608}, {0.14055528997197267, 
                -0.10907469409007277, 0.9840461989002608}, {
                0.13421549809053748, -0.31183524701573734, 
                0.9406088341021165}, {0.12366437327268699, 
                -0.4802055030720416, 0.8683949548462389}, {
                0.11175590736391439, -0.606544321305862, 0.7871560223112565}, 
               {0, 0.6127414022112175, 0.7902834769981154}, {0, 
                0.485093621324142, 0.8744622224834129}, {0, 
                0.3150144821779027, 0.9490868643165323}, {0, 
                0.11018594598156567, 0.9939109906365596}, {0, 
                -0.11018594598156561, 0.9939109906365596}, {0, 
                -0.3150144821779026, 0.9490868643165323}, {0, 
                -0.485093621324142, 0.8744622224834129}, {0, 
                -0.6127414022112175, 0.7902834769981154}, {
                -0.11175590736391439, 0.606544321305862, 0.7871560223112565}, 
               {-0.12366437327268699, 0.4802055030720416, 
                0.8683949548462389}, {-0.13421549809053748, 
                0.3118352470157374, 0.9406088341021165}, {
                -0.14055528997197267, 0.10907469409007282, 
                0.9840461989002608}, {-0.14055528997197267, 
                -0.10907469409007277, 0.9840461989002608}, {
                -0.13421549809053748, -0.31183524701573734, 
                0.9406088341021165}, {-0.12366437327268699, 
                -0.4802055030720416, 0.8683949548462389}, {
                -0.11175590736391439, -0.606544321305862, 
                0.7871560223112565}, {-0.21697560934658114, 
                0.5887995908547458, 0.7786119872940332}, {-0.240181535014239, 
                0.46632745069418663, 0.8513821345126199}, {
                -0.26068765874921046, 0.3028386075494427, 
                0.9166955450711921}, {-0.27301205120528754, 
                0.10593233719130543, 0.9561604257831784}, {
                -0.27301205120528754, -0.10593233719130538, 
                0.9561604257831784}, {-0.26068765874921046, 
                -0.30283860754944264, 0.9166955450711921}, {
                -0.240181535014239, -0.46632745069418663, 
                0.8513821345126199}, {-0.21697560934658114, 
                -0.5887995908547458, 0.7786119872940332}, {
                -0.31050212341342714, 0.5617034564507506, 
                0.7668622160251687}, {-0.3441741114346882, 0.445485555397011, 
                0.8264906538798605}, {-0.3737005028971536, 
                0.28941178685153307, 0.8812427314683606}, {
                -0.3914131897727447, 0.10124897544848033, 
                0.9146279898639438}, {-0.3914131897727447, 
                -0.10124897544848027, 0.9146279898639438}, {
                -0.3737005028971536, -0.28941178685153307, 
                0.8812427314683607}, {-0.3441741114346882, 
                -0.445485555397011, 0.8264906538798605}, {
                -0.31050212341342714, -0.5617034564507506, 
                0.7668622160251687}, {-0.3892195192816053, 
                0.5280068246987126, 0.7547959716915419}, {
                -0.4328575449380158, 0.42019447105180713, 
                0.7975405646659771}, {-0.4704792145732721, 
                0.2732610061775047, 0.8390338081134601}, {
                -0.4929015022651667, 0.09562597942222517, 
                0.8648143044170129}, {-0.4929015022651667, 
                -0.09562597942222513, 0.8648143044170129}, {
                -0.4704792145732721, -0.2732610061775047, 
                0.8390338081134601}, {-0.4328575449380158, 
                -0.42019447105180713, 0.7975405646659771}, {
                -0.3892195192816053, -0.5280068246987126, 
                0.7547959716915419}, {-0.45184251413284654, 
                0.49023176565783877, 0.7453262093621197}, {
                -0.505771129896187, 0.39276067725801583, 0.7680720113136261}, 
               {-0.5508465003377766, 0.2559337078527797, 0.7943966705936978}, 
               {-0.5773476240654188, 0.08960699174175904, 0.811566576453841}, 
               {-0.5773476240654188, -0.08960699174175898, 
                0.811566576453841}, {-0.5508465003377766, 
                -0.2559337078527797, 0.7943966705936978}, {
                -0.505771129896187, -0.39276067725801583, 
                0.7680720113136261}, {-0.45184251413284654, 
                -0.49023176565783877, 0.7453262093621197}, {
                -0.49817822081123136, 0.4501928947959336, 
                0.7410430606817754}, {-0.5639405419069264, 
                0.36491456476877304, 0.7408160538307328}, {
                -0.6162596242911283, 0.23857875013645213, 
                0.7505359787857512}, {-0.6463295352744644, 
                0.0835940588081242, 0.7584656651186518}, {
                -0.6463295352744644, -0.08359405880812415, 
                0.7584656651186518}, {-0.6162596242911283, 
                -0.2385787501364521, 0.7505359787857512}, {
                -0.5639405419069264, -0.36491456476877304, 
                0.7408160538307328}, {-0.49817822081123136, 
                -0.4501928947959336, 0.7410430606817754}, {
                -0.5282645562989748, 0.4088285937534415, 0.7441745356351765}, 
               {-0.6090319163241771, 0.33775274939846234, 
                0.7176372378662357}, {-0.6688781968303905, 
                0.22192193838816213, 0.709473474533732}, {
                -0.7021518559955869, 0.07784005383865548, 
                0.7077596323190154}, {-0.7021518559955869, 
                -0.07784005383865544, 0.7077596323190154}, {
                -0.6688781968303905, -0.2219219383881621, 0.709473474533732}, 
               {-0.6090319163241771, -0.33775274939846234, 
                0.7176372378662357}, {-0.5282645562989748, 
                -0.4088285937534415, 0.7441745356351765}, {
                0.5081805441317284, 0.428730701043212, 0.7469555010500802}, {
                0.6033429173391309, 0.3400343983644961, 0.721355621053584}, {
                0.6328803941128504, 0.23150017591439412, 0.7388302073542796}, 
               {0.6899299238670964, 0.07787430922626942, 0.7196751295656075}, 
               {0.6592233595029507, -0.08364059120767867, 
                0.7472809470259987}, {0.6529233620952455, 
                -0.22923077475592787, 0.7219032727000467}, {
                0.5698251778589052, -0.36276489540396084, 
                0.7373607647146818}, {0.5185818562448119, 
                -0.4305576675827605, 0.7387103310901902}, {
                0.46994337961425486, 0.46994337961425486, 
                0.7471990631106712}, {0.5568996266659998, 0.3673148438728283, 
                0.7449447035115759}, {0.5718287567712153, 
                0.24862882341230252, 0.7817899852889524}, {
                0.6312464867698683, 0.08364556474882683, 0.7710585531842238}, 
               {0.5932424495992948, -0.08967059358464644, 
                0.8000141127752718}, {0.596116200212913, 
                -0.24622734071181998, 0.7642104242482587}, {
                0.5130739279995142, -0.39056390581979317, 
                0.7643395710532963}, {0.48051562836131406, 
                -0.47090531579408784, 0.7398330314722382}, {
                0.41510708742973934, 0.5092889962495459, 0.753863929542148}, {
                0.49716249963913195, 0.39519742281141357, 
                0.7724302207680556}, {0.4965137786928492, 0.2660615224125327, 
                0.8262477436336355}, {0.5588823197961618, 
                0.08968199429626607, 0.8243832194545843}, {
                0.5123001305218013, -0.09571246214877566, 
                0.8534563262737962}, {0.5258065963636849, 
                -0.26363251013939526, 0.8087183210599588}, {
                0.44178930691947726, -0.41805931157284865, 
                0.7937560206378556}, {0.42652318272674894, 
                -0.5096186517957828, 0.7472394558228929}, {
                0.3438331522796962, 0.545398345064275, 0.7644078810390151}, {
                0.4225304900244621, 0.4225304900244621, 0.8018328815902824}, {
                0.4052184552658533, 0.2828291561518307, 0.8693708483394178}, {
                0.4706710557494883, 0.09573068534582119, 0.877099990401825}, {
                0.41463247673195763, -0.10136397967671404, 
                0.9043258554653965}, {0.4400387876089751, 
                -0.28054049777781126, 0.8530315905675482}, {
                0.3548601161268645, -0.44357514515858065, 
                0.8229917305659713}, {0.35654303421690425, 
                -0.5453030352804524, 0.7586314417853568}, {
                0.2569652544764677, 0.5760806627658615, 0.7759509829744982}, {
                0.3321352935560967, 0.4475271597762059, 0.8303045152454898}, {
                0.2975438790787949, 0.2975438790787949, 0.9071578032765231}, {
                0.365383278008056, 0.1013870217328346, 0.9253192594862777}, {
                0.29995720999917613, -0.10607876496543003, 
                0.9480363747203581}, {0.3378569291782775, 
                -0.29562481303099275, 0.893565143303282}, {
                0.2525627429280798, -0.46484969191130476, 
                0.8486028663719029}, {0.27114951894736616, 
                -0.5757743470591195, 0.7713376949451236}, {
                0.15685606670699206, 0.5986613245141305, 0.7854939801603821}, 
               {0.2266943193179215, 0.46784845246742224, 0.8542408975885095}, 
               {0.17538097012932408, 0.30854410279558053, 
                0.9349021616974512}, {0.24373016907410588, 
                0.10610122322631044, 0.964021854063998}, {
                0.17050029571315187, -0.10924916290723842, 
                0.9792825279590132}, {0.2202628429894255, 
                -0.30725037329463484, 0.9257869561127566}, {
                0.13740400631971914, -0.47937391960398995, 
                0.866787623498858}, {0.1723492949306979, -0.5983602473048216, 
                0.7824709163810525}, {0.047830683824691765, 
                0.6106416277358906, 0.7904612755606212}, {
                0.10929367585201454, 0.48100361687621107, 0.869879539344821}, 
               {0.043486870796992774, 0.3142764192858112, 
                0.9483349747579569}, {0.10926335632674587, 
                0.10926335632674587, 0.9879893916072323}, {
                0.03153616660483702, -0.11037658311692944, 
                0.9933893899651353}, {0.09100264627866471, 
                -0.31381777788058235, 0.945112120680067}, {
                0.01446439438039001, -0.48506145867937667, 
                0.8743604306000151}, {0.06410162715499337, 
                -0.6105187541174609, 0.789403466084958}, {
                -0.06410162715499337, 0.6105187541174609, 0.789403466084958}, 
               {-0.014464394380390008, 0.48506145867937667, 
                0.8743604306000151}, {-0.09100264627866465, 
                0.3138177778805824, 0.945112120680067}, {
                -0.03153616660483696, 0.1103765831169295, 
                0.9933893899651353}, {-0.10926335632674582, 
                -0.10926335632674582, 0.9879893916072323}, {
                -0.043486870796992726, -0.3142764192858111, 
                0.9483349747579569}, {-0.10929367585201454, 
                -0.48100361687621107, 0.869879539344821}, {
                -0.047830683824691765, -0.6106416277358906, 
                0.7904612755606212}, {-0.1723492949306979, 
                0.5983602473048216, 0.7824709163810525}, {
                -0.13740400631971914, 0.47937391960398995, 
                0.866787623498858}, {-0.22026284298942544, 
                0.3072503732946349, 0.9257869561127566}, {
                -0.1705002957131518, 0.10924916290723848, 
                0.9792825279590132}, {-0.24373016907410583, 
                -0.10610122322631038, 0.964021854063998}, {
                -0.17538097012932405, -0.30854410279558053, 
                0.9349021616974512}, {-0.2266943193179215, 
                -0.46784845246742224, 0.8542408975885095}, {
                -0.15685606670699206, -0.5986613245141305, 
                0.7854939801603821}, {-0.27114951894736616, 
                0.5757743470591195, 0.7713376949451236}, {
                -0.2525627429280798, 0.46484969191130476, 
                0.8486028663719029}, {-0.3378569291782774, 
                0.2956248130309928, 0.893565143303282}, {-0.2999572099991761, 
                0.10607876496543009, 0.9480363747203581}, {
                -0.365383278008056, -0.10138702173283455, 
                0.9253192594862778}, {-0.2975438790787949, 
                -0.2975438790787949, 0.9071578032765231}, {
                -0.3321352935560967, -0.4475271597762059, 
                0.8303045152454898}, {-0.2569652544764677, 
                -0.5760806627658615, 0.7759509829744982}, {
                -0.35654303421690425, 0.5453030352804524, 
                0.7586314417853568}, {-0.3548601161268645, 
                0.44357514515858065, 0.8229917305659713}, {
                -0.440038787608975, 0.2805404977778113, 0.8530315905675482}, {
                -0.41463247673195763, 0.1013639796767141, 
                0.9043258554653966}, {-0.4706710557494883, 
                -0.09573068534582115, 0.877099990401825}, {
                -0.40521845526585326, -0.28282915615183063, 
                0.8693708483394178}, {-0.4225304900244621, 
                -0.4225304900244621, 0.8018328815902824}, {
                -0.3438331522796962, -0.545398345064275, 0.7644078810390151}, 
               {-0.42652318272674894, 0.5096186517957828, 
                0.7472394558228929}, {-0.44178930691947726, 
                0.41805931157284865, 0.7937560206378556}, {
                -0.5258065963636848, 0.26363251013939537, 
                0.8087183210599589}, {-0.5123001305218013, 
                0.0957124621487757, 0.8534563262737962}, {
                -0.5588823197961618, -0.08968199429626601, 
                0.8243832194545843}, {-0.4965137786928492, 
                -0.26606152241253267, 0.8262477436336355}, {
                -0.49716249963913195, -0.39519742281141357, 
                0.7724302207680556}, {-0.41510708742973934, 
                -0.5092889962495459, 0.753863929542148}, {
                -0.48051562836131406, 0.47090531579408784, 
                0.7398330314722382}, {-0.5130739279995142, 
                0.39056390581979317, 0.7643395710532963}, {
                -0.596116200212913, 0.24622734071182, 0.7642104242482587}, {
                -0.5932424495992948, 0.08967059358464649, 
                0.8000141127752718}, {-0.6312464867698683, 
                -0.08364556474882677, 0.7710585531842238}, {
                -0.5718287567712153, -0.2486288234123025, 
                0.7817899852889524}, {-0.5568996266659998, 
                -0.3673148438728283, 0.7449447035115759}, {
                -0.46994337961425486, -0.46994337961425486, 
                0.7471990631106712}, {-0.5185818562448119, 
                0.4305576675827605, 0.7387103310901902}, {
                -0.5698251778589052, 0.36276489540396084, 
                0.7373607647146818}, {-0.6529233620952455, 
                0.2292307747559279, 0.7219032727000467}, {
                -0.6592233595029507, 0.08364059120767872, 
                0.7472809470259987}, {-0.6899299238670964, 
                -0.07787430922626938, 0.7196751295656075}, {
                -0.6328803941128504, -0.2315001759143941, 
                0.7388302073542796}, {-0.6033429173391309, 
                -0.3400343983644961, 0.721355621053584}, {
                -0.5081805441317284, -0.428730701043212, 0.7469555010500802}, 
               {0.4501928947959336, 0.49817822081123136, 0.7410430606817754}, 
               {0.40882859375344155, 0.528264556298975, 0.7441745356351765}, {
                0.49023176565783877, 0.45184251413284654, 
                0.7453262093621197}, {0.5280068246987126, 0.3892195192816053, 
                0.7547959716915419}, {0.5617034564507506, 
                0.31050212341342714, 0.7668622160251687}, {
                0.5887995908547458, 0.21697560934658114, 0.7786119872940332}, 
               {0.606544321305862, 0.11175590736391439, 0.7871560223112565}, {
                0.6127414022112175, 0, 0.7902834769981154}, {
                0.606544321305862, -0.11175590736391439, 0.7871560223112565}, 
               {0.5887995908547458, -0.21697560934658114, 
                0.7786119872940332}, {0.5617034564507506, 
                -0.31050212341342714, 0.7668622160251687}, {
                0.5280068246987126, -0.3892195192816053, 0.7547959716915419}, 
               {0.49023176565783877, -0.45184251413284654, 
                0.7453262093621197}, {0.4501928947959336, 
                -0.49817822081123136, 0.7410430606817754}, {
                0.40882859375344155, -0.528264556298975, 0.7441745356351765}, 
               {0.36491456476877304, 0.5639405419069264, 0.7408160538307328}, 
               {0.33775274939846234, 0.6090319163241771, 0.7176372378662357}, 
               {0.39276067725801583, 0.505771129896187, 0.7680720113136261}, {
                0.42019447105180713, 0.4328575449380158, 0.7975405646659771}, 
               {0.445485555397011, 0.3441741114346882, 0.8264906538798605}, {
                0.46632745069418663, 0.240181535014239, 0.8513821345126199}, {
                0.4802055030720416, 0.12366437327268699, 0.8683949548462389}, 
               {0.485093621324142, 0, 0.8744622224834129}, {
                0.4802055030720416, -0.12366437327268699, 
                0.8683949548462389}, {0.46632745069418663, 
                -0.240181535014239, 0.8513821345126199}, {0.445485555397011, 
                -0.3441741114346882, 0.8264906538798605}, {
                0.42019447105180713, -0.4328575449380158, 
                0.7975405646659771}, {0.39276067725801583, 
                -0.505771129896187, 0.7680720113136261}, {
                0.36491456476877304, -0.5639405419069264, 
                0.7408160538307328}, {0.33775274939846234, 
                -0.6090319163241771, 0.7176372378662357}, {
                0.23857875013645213, 0.6162596242911283, 0.7505359787857512}, 
               {0.22192193838816213, 0.6688781968303905, 0.709473474533732}, {
                0.2559337078527797, 0.5508465003377766, 0.7943966705936978}, {
                0.2732610061775047, 0.4704792145732721, 0.8390338081134601}, {
                0.28941178685153307, 0.3737005028971536, 0.8812427314683606}, 
               {0.3028386075494427, 0.26068765874921046, 0.9166955450711921}, 
               {0.3118352470157374, 0.13421549809053748, 0.9406088341021165}, 
               {0.3150144821779027, 0, 0.9490868643165323}, {
                0.3118352470157374, -0.13421549809053748, 
                0.9406088341021165}, {0.3028386075494427, 
                -0.26068765874921046, 0.9166955450711921}, {
                0.28941178685153307, -0.3737005028971536, 
                0.8812427314683606}, {0.2732610061775047, 
                -0.4704792145732721, 0.8390338081134601}, {
                0.2559337078527797, -0.5508465003377766, 0.7943966705936978}, 
               {0.23857875013645213, -0.6162596242911283, 
                0.7505359787857512}, {0.22192193838816213, 
                -0.6688781968303905, 0.709473474533732}, {0.0835940588081242, 
                0.6463295352744644, 0.7584656651186518}, {
                0.07784005383865548, 0.7021518559955869, 0.7077596323190154}, 
               {0.08960699174175904, 0.5773476240654188, 0.811566576453841}, {
                0.09562597942222517, 0.4929015022651667, 0.8648143044170129}, 
               {0.10124897544848033, 0.3914131897727447, 0.9146279898639438}, 
               {0.10593233719130543, 0.27301205120528754, 
                0.9561604257831784}, {0.10907469409007282, 
                0.14055528997197267, 0.9840461989002608}, {
                0.11018594598156567, 0, 0.9939109906365596}, {
                0.10907469409007282, -0.14055528997197267, 
                0.9840461989002608}, {0.10593233719130543, 
                -0.27301205120528754, 0.9561604257831784}, {
                0.10124897544848033, -0.3914131897727447, 
                0.9146279898639438}, {0.09562597942222517, 
                -0.4929015022651667, 0.8648143044170129}, {
                0.08960699174175904, -0.5773476240654188, 0.811566576453841}, 
               {0.0835940588081242, -0.6463295352744644, 0.7584656651186518}, 
               {0.07784005383865548, -0.7021518559955869, 
                0.7077596323190154}, {-0.08359405880812415, 
                0.6463295352744644, 0.7584656651186518}, {
                -0.07784005383865544, 0.7021518559955869, 
                0.7077596323190154}, {-0.08960699174175898, 
                0.5773476240654188, 0.811566576453841}, {
                -0.09562597942222513, 0.4929015022651667, 
                0.8648143044170129}, {-0.10124897544848027, 
                0.3914131897727447, 0.9146279898639438}, {
                -0.10593233719130538, 0.27301205120528754, 
                0.9561604257831784}, {-0.10907469409007277, 
                0.14055528997197267, 0.9840461989002608}, {
                -0.11018594598156561, 0, 0.9939109906365596}, {
                -0.10907469409007277, -0.14055528997197267, 
                0.9840461989002608}, {-0.10593233719130538, 
                -0.27301205120528754, 0.9561604257831784}, {
                -0.10124897544848027, -0.3914131897727447, 
                0.9146279898639438}, {-0.09562597942222513, 
                -0.4929015022651667, 0.8648143044170129}, {
                -0.08960699174175898, -0.5773476240654188, 
                0.811566576453841}, {-0.08359405880812415, 
                -0.6463295352744644, 0.7584656651186518}, {
                -0.07784005383865544, -0.7021518559955869, 
                0.7077596323190154}, {-0.2385787501364521, 
                0.6162596242911283, 0.7505359787857512}, {
                -0.2219219383881621, 0.6688781968303905, 0.709473474533732}, {
                -0.2559337078527797, 0.5508465003377766, 0.7943966705936978}, 
               {-0.2732610061775047, 0.4704792145732721, 0.8390338081134601}, 
               {-0.28941178685153307, 0.3737005028971536, 
                0.8812427314683607}, {-0.30283860754944264, 
                0.26068765874921046, 0.9166955450711921}, {
                -0.31183524701573734, 0.13421549809053748, 
                0.9406088341021165}, {-0.3150144821779026, 0, 
                0.9490868643165323}, {-0.31183524701573734, 
                -0.13421549809053748, 0.9406088341021165}, {
                -0.30283860754944264, -0.26068765874921046, 
                0.9166955450711921}, {-0.28941178685153307, 
                -0.3737005028971536, 0.8812427314683607}, {
                -0.2732610061775047, -0.4704792145732721, 
                0.8390338081134601}, {-0.2559337078527797, 
                -0.5508465003377766, 0.7943966705936978}, {
                -0.2385787501364521, -0.6162596242911283, 
                0.7505359787857512}, {-0.2219219383881621, 
                -0.6688781968303905, 0.709473474533732}, {
                -0.36491456476877304, 0.5639405419069264, 
                0.7408160538307328}, {-0.33775274939846234, 
                0.6090319163241771, 0.7176372378662357}, {
                -0.39276067725801583, 0.505771129896187, 0.7680720113136261}, 
               {-0.42019447105180713, 0.4328575449380158, 
                0.7975405646659771}, {-0.445485555397011, 0.3441741114346882, 
                0.8264906538798605}, {-0.46632745069418663, 
                0.240181535014239, 0.8513821345126199}, {-0.4802055030720416, 
                0.12366437327268699, 0.8683949548462389}, {
                -0.485093621324142, 0, 0.8744622224834129}, {
                -0.4802055030720416, -0.12366437327268699, 
                0.8683949548462389}, {-0.46632745069418663, 
                -0.240181535014239, 0.8513821345126199}, {-0.445485555397011, 
                -0.3441741114346882, 0.8264906538798605}, {
                -0.42019447105180713, -0.4328575449380158, 
                0.7975405646659771}, {-0.39276067725801583, 
                -0.505771129896187, 0.7680720113136261}, {
                -0.36491456476877304, -0.5639405419069264, 
                0.7408160538307328}, {-0.33775274939846234, 
                -0.6090319163241771, 0.7176372378662357}, {
                -0.4501928947959336, 0.49817822081123136, 
                0.7410430606817754}, {-0.40882859375344155, 
                0.528264556298975, 0.7441745356351765}, {
                -0.49023176565783877, 0.45184251413284654, 
                0.7453262093621197}, {-0.5280068246987126, 
                0.3892195192816053, 0.7547959716915419}, {
                -0.5617034564507506, 0.31050212341342714, 
                0.7668622160251687}, {-0.5887995908547458, 
                0.21697560934658114, 0.7786119872940332}, {
                -0.606544321305862, 0.11175590736391439, 0.7871560223112565}, 
               {-0.6127414022112175, 0, 0.7902834769981154}, {
                -0.606544321305862, -0.11175590736391439, 
                0.7871560223112565}, {-0.5887995908547458, 
                -0.21697560934658114, 0.7786119872940332}, {
                -0.5617034564507506, -0.31050212341342714, 
                0.7668622160251687}, {-0.5280068246987126, 
                -0.3892195192816053, 0.7547959716915419}, {
                -0.49023176565783877, -0.45184251413284654, 
                0.7453262093621197}, {-0.4501928947959336, 
                -0.49817822081123136, 0.7410430606817754}, {
                -0.40882859375344155, -0.528264556298975, 
                0.7441745356351765}, {0.428730701043212, 0.5081805441317284, 
                0.7469555010500802}, {0.5092889962495459, 
                0.41510708742973934, 0.753863929542148}, {0.5453999108496428, 
                0.34383629478776606, 0.7644053503422266}, {
                0.5986613245141305, 0.15685606670699206, 0.7854939801603821}, 
               {0.6106612690893328, 0.04786384836234817, 0.7904440944520692}, 
               {0.5983602473048216, -0.1723492949306979, 0.7824709163810525}, 
               {0.5758078898706069, -0.27110928294341136, 
                0.7713267988762404}, {0.5096186517957828, 
                -0.42652318272674894, 0.7472394558228929}, {
                0.4709195472530765, -0.480501526250668, 0.7398331320546114}, {
                0.4305576675827605, -0.5185818562448118, 0.7387103310901902}, 
               {0.3400343983644961, 0.6033429173391309, 0.721355621053584}, {
                0.39519742281141357, 0.49716249963913195, 
                0.7724302207680556}, {0.46784845246742224, 
                0.2266943193179215, 0.8542408975885095}, {
                0.47937391960398995, -0.13740400631971914, 
                0.866787623498858}, {0.41805931157284865, 
                -0.44178930691947726, 0.7937560206378556}, {
                0.36276489540396084, -0.5698251778589052, 
                0.7373607647146818}, {0.23150017591439412, 
                0.6328803941128504, 0.7388302073542796}, {
                0.24863643367895422, 0.571832662951955, 0.781784707850369}, {
                0.2660615224125327, 0.4965137786928492, 0.8262477436336355}, {
                0.28284642905663193, 0.40523343774133813, 
                0.8693582452051909}, {0.30854410279558053, 
                0.17538097012932408, 0.9349021616974512}, {
                0.31433972976278945, 0.043557365538104166, 
                0.9483107561343151}, {0.3072503732946349, 
                -0.22026284298942544, 0.9257869561127566}, {
                0.29570080433352414, -0.33778294230147937, 
                0.8935679706696421}, {0.26363251013939537, 
                -0.5258065963636848, 0.8087183210599589}, {0.246268026581679, 
                -0.5960836932904334, 0.7642226702190938}, {
                0.2292307747559279, -0.6529233620952455, 0.7219032727000467}, 
               {0.07787430922626942, 0.6899299238670964, 0.7196751295656075}, 
               {0.08968199429626607, 0.5588823197961618, 0.8243832194545843}, 
               {0.0957470000889903, 0.47068356647075094, 0.8770914959274962}, 
               {0.10610122322631044, 0.24373016907410588, 0.964021854063998}, 
               {0.10924916290723848, -0.1705002957131518, 
                0.9792825279590132}, {0.0957124621487757, 
                -0.5123001305218013, 0.8534563262737962}, {
                0.08364059120767872, -0.6592233595029507, 
                0.7472809470259987}, {-0.08364059120767867, 
                0.6592233595029507, 0.7472809470259987}, {
                -0.08963669371801349, 0.5932658166605725, 
                0.8000005837006414}, {-0.09571246214877566, 
                0.5123001305218013, 0.8534563262737962}, {
                -0.10133189609364888, 0.41465971831559, 0.9043169603852963}, {
                -0.10604021862229211, 0.29999286567480843, 
                0.9480294049125021}, {-0.10924916290723842, 
                0.17050029571315187, 0.9792825279590132}, {
                -0.11029906691607658, 0.031614556833489134, 
                0.9933955081606041}, {-0.10610122322631038, 
                -0.24373016907410583, 0.964021854063998}, {
                -0.10131712603158774, -0.3653226692913393, 
                0.9253508455037744}, {-0.08968199429626601, 
                -0.5588823197961618, 0.8243832194545843}, {
                -0.08361253823696309, -0.6312280471864186, 
                0.7710772308237307}, {-0.07787430922626938, 
                -0.6899299238670964, 0.7196751295656075}, {
                -0.22923077475592787, 0.6529233620952455, 
                0.7219032727000467}, {-0.26363251013939526, 
                0.5258065963636849, 0.8087183210599588}, {
                -0.28051094247593955, 0.44006551652781495, 
                0.8530275214284516}, {-0.30725037329463484, 
                0.2202628429894255, 0.9257869561127566}, {
                -0.31378244251020854, 0.09104131688968764, 
                0.945120128550503}, {-0.30854410279558053, 
                -0.17538097012932405, 0.9349021616974512}, {
                -0.26606152241253267, -0.4965137786928492, 
                0.8262477436336355}, {-0.2315001759143941, 
                -0.6328803941128504, 0.7388302073542796}, {
                -0.36276489540396084, 0.5698251778589052, 
                0.7373607647146818}, {-0.390543131152732, 0.5130942168488697, 
                0.7643365667987271}, {-0.41805931157284865, 
                0.44178930691947726, 0.7937560206378556}, {
                -0.44356146740330665, 0.3548748022409074, 
                0.8229927699375629}, {-0.46482366795752017, 
                0.2525926733281593, 0.8486082129507414}, {
                -0.47937391960398995, 0.13740400631971914, 
                0.866787623498858}, {-0.48503647493489016, 
                0.014496748746958638, 0.8743737543284926}, {
                -0.48099130827314696, -0.10927741167456598, 
                0.8698883886243073}, {-0.46784845246742224, 
                -0.2266943193179215, 0.8542408975885095}, {
                -0.44751302967767664, -0.33211863906861855, 
                0.8303187929054212}, {-0.39519742281141357, 
                -0.49716249963913195, 0.7724302207680556}, {
                -0.3673117521431721, -0.5568981389299562, 
                0.7449473401481908}, {-0.3400343983644961, 
                -0.6033429173391309, 0.721355621053584}, {
                -0.4305576675827605, 0.5185818562448118, 0.7387103310901902}, 
               {-0.5096186517957828, 0.42652318272674894, 
                0.7472394558228929}, {-0.5452834609541293, 
                0.35656433938033893, 0.7586354981756055}, {
                -0.5983602473048216, 0.1723492949306979, 0.7824709163810525}, 
               {-0.6104962282343493, 0.06413564921370624, 
                0.7894181235641665}, {-0.5986613245141305, 
                -0.15685606670699206, 0.7854939801603821}, {
                -0.5760768199275003, -0.25695767175058487, 0.77595634701363}, 
               {-0.5092889962495459, -0.41510708742973934, 
                0.753863929542148}, {-0.428730701043212, -0.5081805441317284, 
                0.7469555010500802}, {0.5760768199275003, 0.2569576717505848, 
                0.77595634701363}, {0.6104962282343493, -0.0641356492137062, 
                0.7894181235641665}, {0.5452834609541293, 
                -0.35656433938033893, 0.7586354981756055}, {
                0.3673117521431721, 0.5568981389299562, 0.7449473401481908}, {
                0.44751302967767664, 0.33211863906861855, 
                0.8303187929054212}, {0.48099130827314696, 
                0.10927741167456599, 0.8698883886243073}, {
                0.48503647493489016, -0.014496748746958632, 
                0.8743737543284926}, {0.46482366795752017, 
                -0.25259267332815927, 0.8486082129507413}, {
                0.44356146740330665, -0.3548748022409074, 
                0.8229927699375629}, {0.390543131152732, -0.5130942168488697, 
                0.7643365667987271}, {0.3137824425102086, 
                -0.09104131688968758, 0.945120128550503}, {
                0.2805109424759396, -0.4400655165278149, 0.8530275214284516}, 
               {0.08361253823696313, 0.6312280471864186, 0.7710772308237307}, 
               {0.10131712603158778, 0.36532266929133933, 
                0.9253508455037744}, {0.11029906691607663, 
                -0.03161455683348908, 0.9933955081606041}, {
                0.10604021862229217, -0.2999928656748084, 
                0.9480294049125021}, {0.10133189609364894, 
                -0.41465971831558995, 0.9043169603852963}, {
                0.08963669371801353, -0.5932658166605725, 
                0.8000005837006414}, {-0.09574700008899026, 
                -0.4706835664707509, 0.8770914959274962}, {
                -0.24626802658167896, 0.5960836932904334, 
                0.7642226702190938}, {-0.29570080433352414, 
                0.3377829423014794, 0.8935679706696421}, {
                -0.31433972976278945, -0.04355736553810411, 
                0.9483107561343151}, {-0.28284642905663193, 
                -0.40523343774133813, 0.8693582452051909}, {
                -0.24863643367895422, -0.571832662951955, 0.781784707850369}, 
               {-0.4709195472530765, 0.480501526250668, 0.7398331320546114}, {
                -0.5758078898706069, 0.2711092829434113, 0.7713267988762404}, 
               {-0.6106612690893328, -0.047863848362348145, 
                0.7904440944520692}, {-0.5453999108496428, 
                -0.34383629478776606, 0.7644053503422266}, {
                0.531587708829175, 0.3802182400522678, 0.7568676223444257}, {
                0.6084884339349544, 0.08624886149693425, 0.7888618127770346}, 
               {0.5812236119382314, -0.2495475119097137, 0.7745354428463217}, 
               {0.47482757258727454, -0.4748171718184725, 
                0.7410043384874232}, {0.24700878884542896, 0.579356432368956, 
                0.776744991941261}, {0.2749625148235865, 0.45977617538635623, 
                0.8443941520338613}, {0.3129641564235779, 0.1041055724075025, 
                0.9440420894153949}, {0.2995173301319369, 
                -0.29947671322958164, 0.9058714407595834}, {
                0.2495745333678173, -0.581204696734607, 0.7745409303502753}, {
                0.09569469675521547, 0.4818307201122268, 0.8710233534005046}, 
               {-0.0879539672353713, 0.6087059400213184, 0.7885056615080973}, 
               {-0.09647282493605432, 0.4819612710529593, 0.870865275030457}, 
               {-0.10542909093526778, 0.3132227722727162, 0.943809409634359}, 
               {-0.10954089374773308, 0.10958063570979738, 
                0.9879235177251245}, {-0.10406861017835005, 
                -0.3129376096203773, 0.9440549649573541}, {
                -0.08622839921732574, -0.6084837250357538, 
                0.7888676818928703}, {-0.2757049464671569, 
                0.46040837494534065, 0.8438073896178753}, {
                -0.3132046429266069, 0.1054501696786961, 0.9438130711978675}, 
               {-0.38109976396025586, 0.5323998420187861, 
                0.7558527489715234}, {-0.42327637087223574, 
                0.423285563510318, 0.8010408513833623}, {-0.4603925443760355, 
                0.27572351977121257, 0.8438099583009991}, {
                -0.48194806475969476, 0.09649131219619769, 
                0.870870535467265}, {-0.4818251362658734, 
                -0.09568604907887453, 0.8710273922638987}, {
                -0.45977074269664964, -0.2749563589277574, 
                0.8443991146640086}, {-0.3802169210069558, 
                -0.5315895336866849, 0.7568670032804727}, {
                -0.5323859553183197, 0.3811150960378159, 0.7558547996486406}, 
               {-0.6086948157886751, 0.08797557842174589, 0.78851183810603}, {
                -0.5793567025433196, -0.24700616694178176, 
                0.7767456241980769}, {0.5793567025433196, 0.2470061669417818, 
                0.7767456241980769}, {0.6086948157886751, 
                -0.08797557842174583, 0.78851183810603}, {0.5323859553183197, 
                -0.3811150960378159, 0.7558547996486406}, {
                0.3802169210069558, 0.5315895336866849, 0.7568670032804727}, {
                0.45977074269664964, 0.27495635892775744, 
                0.8443991146640085}, {0.4818251362658734, 
                0.09568604907887457, 0.8710273922638987}, {
                0.48194806475969476, -0.09649131219619765, 
                0.870870535467265}, {0.4603925443760355, 
                -0.27572351977121257, 0.8438099583009991}, {
                0.42327637087223574, -0.423285563510318, 0.8010408513833623}, 
               {0.38109976396025586, -0.5323998420187861, 
                0.7558527489715234}, {0.31320464292660694, 
                -0.10545016967869604, 0.9438130711978675}, {
                0.27570494646715693, -0.46040837494534065, 
                0.8438073896178753}, {0.0862283992173258, 0.6084837250357538, 
                0.7888676818928703}, {0.1040686101783501, 
                0.31293760962037737, 0.9440549649573541}, {
                0.10954089374773314, -0.10958063570979733, 
                0.9879235177251245}, {0.10542909093526784, 
                -0.31322277227271617, 0.943809409634359}, {
                0.09647282493605436, -0.4819612710529593, 0.870865275030457}, 
               {0.08795396723537136, -0.6087059400213185, 
                0.7885056615080973}, {-0.09569469675521543, 
                -0.4818307201122268, 0.8710233534005046}, {
                -0.24957453336781724, 0.581204696734607, 0.7745409303502753}, 
               {-0.29951733013193677, 0.29947671322958175, 
                0.9058714407595833}, {-0.3129641564235778, 
                -0.10410557240750243, 0.9440420894153949}, {
                -0.27496251482358647, -0.4597761753863563, 
                0.8443941520338613}, {-0.24700878884542893, 
                -0.579356432368956, 0.776744991941261}, {
                -0.47482757258727454, 0.4748171718184725, 
                0.7410043384874232}, {-0.5812236119382314, 
                0.24954751190971367, 0.7745354428463216}, {
                -0.6084884339349544, -0.0862488614969342, 
                0.7888618127770346}, {-0.531587708829175, 
                -0.3802182400522678, 0.7568676223444257}}], {}}}, 
          {DisplayFunction -> Identity, PlotInteractivity :> 
            $PlotInteractivity, DisplayFunction -> Identity, 
           PlotInteractivity :> $PlotInteractivity, DisplayFunction -> 
            Identity, Ticks -> {Automatic, Automatic, Automatic}, 
           FaceGrids -> None, PlotInteractivity :> $PlotInteractivity, 
           DisplayFunction -> Identity, PlotInteractivity :> 
            $PlotInteractivity, Axes -> True, AxesLabel -> 
            {None, None, None}, AxesOrigin -> {Automatic, Automatic, 
             Automatic}, BoxRatios -> {1, 1, 0.4}, DisplayFunction :> 
            Identity, Epilog -> {Scale[SplatMesh[
               "https://sparkjs.dev/assets/splats/butterfly.spz"], 0.8]}, 
           FaceGridsStyle -> Automatic, Lighting -> "Neutral", 
           Method -> {"DefaultBoundaryStyle" -> Directive[GrayLevel[0.3]], 
             "DefaultGraphicsInteraction" -> {"Version" -> 1.2, 
               "TrackMousePosition" -> {True, False}, "Effects" -> 
                {"Highlight" -> {"ratio" -> 2}, "HighlightPoint" -> 
                  {"ratio" -> 2}, "Droplines" -> {"freeformCursorMode" -> 
                    True, "placement" -> {"x" -> "All", "y" -> "None"}}}}, 
             "RotationControl" -> "Globe"}, PlotRange -> {{-1, 1}, {-1, 1}, 
             {-0.8414708304357857, 0.8414708304357857}}, PlotRangePadding -> 
            {Scaled[0.02], Scaled[0.02], Scaled[0.02]}, 
           Ticks -> {Automatic, Automatic, Automatic}}]]|>|>, 
   "Path" -> "/Users/kirill/Github/wljs-demos-archive/Demos/Mixing \
languages/C - Gaussian Splatting.wln", "PublicFields" -> {"Properties"}, 
   "Quick" -> True, "Symbols" -> <||>, 
   "TOC" -> {CoffeeLiqueur`Extensions`TOC`Private`heading[1, 
      "Extending Graphics3D with Gaussian Splatting", 
      CoffeeLiqueur`Notebook`Cells`CellObj[
       CoffeeLiqueur`Notebook`Cells`CellObj`$1567]]}|>, 
 "Cells" -> {<|"Data" -> ".md\n# Extending Graphics3D with Gaussian \
Splatting\nAn example notebook that explores the possibilities of integrating \
the Spark.js JavaScript library for rendering Gaussian splats into the \
Wolfram Standard Library of Graphics3D primitives.\n\n:::note\nWe use the \
Spark.js library, which is licensed under the MIT License. Please consider \
starring their amazing project on GitHub: \
https://github.com/sparkjsdev/spark!\n:::", "Display" -> "codemirror", 
    "Hash" -> "e8990b1d-4ee3-4256-9f99-0973ec40fc83", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <|"Hidden" -> True|>, 
    "PublicFields" -> {"Properties"}, "State" -> "Idle", "Type" -> "Input", 
    "UID" -> Null, "Notebook" -> "86740df4-dd4a-49d0-81ce-da87f3e03e12"|>, 
   <|"Data" -> "# Extending Graphics3D with Gaussian Splatting\nAn example \
notebook that explores the possibilities of integrating the Spark.js \
JavaScript library for rendering Gaussian splats into the Wolfram Standard \
Library of Graphics3D primitives.\n\n:::note\nWe use the Spark.js library, \
which is licensed under the MIT License. Please consider starring their \
amazing project on GitHub: https://github.com/sparkjsdev/spark!\n:::", 
    "Display" -> "markdown", "Hash" -> 
     "941337f8-a6d2-4786-a87f-7ec5617b1028", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "PublicFields" -> {"Properties"}, 
    "State" -> "Idle", "Type" -> "Output", "UID" -> Null, 
    "Notebook" -> "86740df4-dd4a-49d0-81ce-da87f3e03e12"|>, 
   <|"Data" -> ".md\nTo avoid any issues with JS module packaging, we use \
their distributed bundle directly and build a basic \
function:\n\n<br/>\n\n<pre>\nSplatMesh[url_String]\n</pre>\n\nThis function \
takes a URL and loads a given model into the scene.", 
    "Display" -> "codemirror", "Hash" -> 
     "f16b1de1-f072-45f3-80c9-96cc9ac9524f", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <|"Hidden" -> True|>, 
    "PublicFields" -> {"Properties"}, "State" -> "Idle", "Type" -> "Input", 
    "UID" -> Null, "Notebook" -> "86740df4-dd4a-49d0-81ce-da87f3e03e12"|>, 
   <|"Data" -> "To avoid any issues with JS module packaging, we use their \
distributed bundle directly and build a basic function:\n\n<br /><pre \
>\nSplatMesh[url_String]\n</pre>\n\nThis function takes a URL and loads a \
given model into the scene.", "Display" -> "markdown", 
    "Hash" -> "7efe9d7a-e67b-4b02-b366-45ecd1f1f463", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "PublicFields" -> {"Properties"}, 
    "State" -> "Idle", "Type" -> "Output", "UID" -> Null, 
    "Notebook" -> "86740df4-dd4a-49d0-81ce-da87f3e03e12"|>, 
   <|"Data" -> ".js\nlet loadSpark = async () => {\n  await \
interpretate.shared.THREE.load();\n  const THREE = \
interpretate.shared.THREE.THREE;\n\n  const { Mesh, OrthographicCamera, \
BufferGeometry, Float32BufferAttribute, Loader, FileLoader, Quaternion, \
Vector3, Color, Matrix4 } = interpretate.shared.THREE.THREE;\n  \nconst \
_camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);\nclass \
FullscreenTriangleGeometry extends BufferGeometry {\n  constructor() {\n    \
super();\n    this.setAttribute(\"position\", new Float32BufferAttribute([-1, \
3, 0, -1, -1, 0, 3, -1, 0], 3));\n    this.setAttribute(\"uv\", new \
Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));\n  }\n}\nconst _geometry = \
new FullscreenTriangleGeometry();\nclass FullScreenQuad {\n  /**\n   * \
Constructs a new full screen quad.\n   *\n   * @param {?Material} material - \
The material to render te full screen quad with.\n   */\n  \
constructor(material) {\n    this._mesh = new Mesh(_geometry, material);\n  \
}\n  /**\n   * Frees the GPU-related resources allocated by this instance. \
Call this\n   * method whenever the instance is no longer used in your app.\n \
  */\n  dispose() {\n    this._mesh.geometry.dispose();\n  }\n  /**\n   * \
Renders the full screen quad.\n   *\n   * @param {WebGLRenderer} renderer - \
The renderer.\n   */\n  render(renderer) {\n    renderer.render(this._mesh, \
_camera);\n  }\n  /**\n   * The quad's material.\n   *\n   * @type \
{?Material}\n   */\n  get material() {\n    return this._mesh.material;\n  \
}\n  set material(value) {\n    this._mesh.material = value;\n  }\n}\nvar u8 \
= Uint8Array, u16 = Uint16Array, i32 = Int32Array;\nvar fleb = new u8([\n  \
0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  1,\n  1,\n  1,\n  1,\n  2,\n  \
2,\n  2,\n  2,\n  3,\n  3,\n  3,\n  3,\n  4,\n  4,\n  4,\n  4,\n  5,\n  5,\n  \
5,\n  5,\n  0,\n  /* unused */\n  0,\n  0,\n  /* impossible */\n  0\n]);\nvar \
fdeb = new u8([\n  0,\n  0,\n  0,\n  0,\n  1,\n  1,\n  2,\n  2,\n  3,\n  3,\n \
 4,\n  4,\n  5,\n  5,\n  6,\n  6,\n  7,\n  7,\n  8,\n  8,\n  9,\n  9,\n  \
10,\n  10,\n  11,\n  11,\n  12,\n  12,\n  13,\n  13,\n  /* unused */\n  0,\n  \
0\n]);\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, \
13, 2, 14, 1, 15]);\nvar freb = function(eb, start) {\n  var b = new \
u16(31);\n  for (var i = 0; i < 31; ++i) {\n    b[i] = start += 1 << eb[i - \
1];\n  }\n  var r = new i32(b[30]);\n  for (var i = 1; i < 30; ++i) {\n    \
for (var j = b[i]; j < b[i + 1]; ++j) {\n      r[j] = j - b[i] << 5 | i;\n    \
}\n  }\n  return { b, r };\n};\nvar _a = freb(fleb, 2), fl = _a.b, revfl = \
_a.r;\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = \
_b.b;\nvar rev = new u16(32768);\nfor (var i = 0; i < 32768; ++i) {\n  var x \
= (i & 43690) >> 1 | (i & 21845) << 1;\n  x = (x & 52428) >> 2 | (x & 13107) \
<< 2;\n  x = (x & 61680) >> 4 | (x & 3855) << 4;\n  rev[i] = ((x & 65280) >> \
8 | (x & 255) << 8) >> 1;\n}\nvar hMap = function(cd, mb, r) {\n  var s = \
cd.length;\n  var i = 0;\n  var l = new u16(mb);\n  for (; i < s; ++i) {\n    \
if (cd[i])\n      ++l[cd[i] - 1];\n  }\n  var le = new u16(mb);\n  for (i = \
1; i < mb; ++i) {\n    le[i] = le[i - 1] + l[i - 1] << 1;\n  }\n  var co;\n  \
if (r) {\n    co = new u16(1 << mb);\n    var rvb = 15 - mb;\n    for (i = 0; \
i < s; ++i) {\n      if (cd[i]) {\n        var sv = i << 4 | cd[i];\n        \
var r_1 = mb - cd[i];\n        var v = le[cd[i] - 1]++ << r_1;\n        for \
(var m = v | (1 << r_1) - 1; v <= m; ++v) {\n          co[rev[v] >> rvb] = \
sv;\n        }\n      }\n    }\n  } else {\n    co = new u16(s);\n    for (i \
= 0; i < s; ++i) {\n      if (cd[i]) {\n        co[i] = rev[le[cd[i] - 1]++] \
>> 15 - cd[i];\n      }\n    }\n  }\n  return co;\n};\nvar flt = new \
u8(288);\nfor (var i = 0; i < 144; ++i)\n  flt[i] = 8;\nfor (var i = 144; i < \
256; ++i)\n  flt[i] = 9;\nfor (var i = 256; i < 280; ++i)\n  flt[i] = 7;\nfor \
(var i = 280; i < 288; ++i)\n  flt[i] = 8;\nvar fdt = new u8(32);\nfor (var i \
= 0; i < 32; ++i)\n  fdt[i] = 5;\nvar flrm = /* @__PURE__ */ hMap(flt, 9, \
1);\nvar fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);\nvar max$1 = function(a) {\n \
 var m = a[0];\n  for (var i = 1; i < a.length; ++i) {\n    if (a[i] > m)\n   \
   m = a[i];\n  }\n  return m;\n};\nvar bits = function(d, p, m) {\n  var o = \
p / 8 | 0;\n  return (d[o] | d[o + 1] << 8) >> (p & 7) & m;\n};\nvar bits16 = \
function(d, p) {\n  var o = p / 8 | 0;\n  return (d[o] | d[o + 1] << 8 | d[o \
+ 2] << 16) >> (p & 7);\n};\nvar shft = function(p) {\n  return (p + 7) / 8 | \
0;\n};\nvar slc = function(v, s, e) {\n  if (s == null || s < 0)\n    s = \
0;\n  if (e == null || e > v.length)\n    e = v.length;\n  return new \
u8(v.subarray(s, e));\n};\nvar ec = [\n  \"unexpected EOF\",\n  \"invalid \
block type\",\n  \"invalid length/literal\",\n  \"invalid distance\",\n  \
\"stream finished\",\n  \"no stream handler\",\n  ,\n  \"no callback\",\n  \
\"invalid UTF-8 data\",\n  \"extra field too long\",\n  \"date not in range \
1980-2099\",\n  \"filename too long\",\n  \"stream finishing\",\n  \"invalid \
zip data\"\n  // determined by unknown compression method\n];\nvar err = \
function(ind, msg, nt) {\n  var e = new Error(msg || ec[ind]);\n  e.code = \
ind;\n  if (Error.captureStackTrace)\n    Error.captureStackTrace(e, err);\n  \
if (!nt)\n    throw e;\n  return e;\n};\nvar inflt = function(dat, st, buf, \
dict) {\n  var sl = dat.length, dl = dict ? dict.length : 0;\n  if (!sl || \
st.f && !st.l)\n    return buf || new u8(0);\n  var noBuf = !buf;\n  var \
resize = noBuf || st.i != 2;\n  var noSt = st.i;\n  if (noBuf)\n    buf = new \
u8(sl * 3);\n  var cbuf = function(l2) {\n    var bl = buf.length;\n    if \
(l2 > bl) {\n      var nbuf = new u8(Math.max(bl * 2, l2));\n      \
nbuf.set(buf);\n      buf = nbuf;\n    }\n  };\n  var final = st.f || 0, pos \
= st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n  \
var tbts = sl * 8;\n  do {\n    if (!lm) {\n      final = bits(dat, pos, \
1);\n      var type = bits(dat, pos + 1, 3);\n      pos += 3;\n      if \
(!type) {\n        var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t \
= s + l;\n        if (t > sl) {\n          if (noSt)\n            err(0);\n   \
       break;\n        }\n        if (resize)\n          cbuf(bt + l);\n      \
  buf.set(dat.subarray(s, t), bt);\n        st.b = bt += l, st.p = pos = t * \
8, st.f = final;\n        continue;\n      } else if (type == 1)\n        lm \
= flrm, dm = fdrm, lbt = 9, dbt = 5;\n      else if (type == 2) {\n        \
var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n   \
     var tl = hLit + bits(dat, pos + 5, 31) + 1;\n        pos += 14;\n        \
var ldt = new u8(tl);\n        var clt = new u8(19);\n        for (var i = 0; \
i < hcLen; ++i) {\n          clt[clim[i]] = bits(dat, pos + i * 3, 7);\n      \
  }\n        pos += hcLen * 3;\n        var clb = max$1(clt), clbmsk = (1 << \
clb) - 1;\n        var clm = hMap(clt, clb, 1);\n        for (var i = 0; i < \
tl; ) {\n          var r = clm[bits(dat, pos, clbmsk)];\n          pos += r & \
15;\n          var s = r >> 4;\n          if (s < 16) {\n            ldt[i++] \
= s;\n          } else {\n            var c = 0, n = 0;\n            if (s == \
16)\n              n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n     \
       else if (s == 17)\n              n = 3 + bits(dat, pos, 7), pos += \
3;\n            else if (s == 18)\n              n = 11 + bits(dat, pos, \
127), pos += 7;\n            while (n--)\n              ldt[i++] = c;\n       \
   }\n        }\n        var lt = ldt.subarray(0, hLit), dt = \
ldt.subarray(hLit);\n        lbt = max$1(lt);\n        dbt = max$1(dt);\n     \
   lm = hMap(lt, lbt, 1);\n        dm = hMap(dt, dbt, 1);\n      } else\n     \
   err(1);\n      if (pos > tbts) {\n        if (noSt)\n          err(0);\n   \
     break;\n      }\n    }\n    if (resize)\n      cbuf(bt + 131072);\n    \
var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n    var lpos = pos;\n    for \
(; ; lpos = pos) {\n      var c = lm[bits16(dat, pos) & lms], sym = c >> 4;\n \
     pos += c & 15;\n      if (pos > tbts) {\n        if (noSt)\n          \
err(0);\n        break;\n      }\n      if (!c)\n        err(2);\n      if \
(sym < 256)\n        buf[bt++] = sym;\n      else if (sym == 256) {\n        \
lpos = pos, lm = null;\n        break;\n      } else {\n        var add2 = \
sym - 254;\n        if (sym > 264) {\n          var i = sym - 257, b = \
fleb[i];\n          add2 = bits(dat, pos, (1 << b) - 1) + fl[i];\n          \
pos += b;\n        }\n        var d = dm[bits16(dat, pos) & dms], dsym = d >> \
4;\n        if (!d)\n          err(3);\n        pos += d & 15;\n        var \
dt = fd[dsym];\n        if (dsym > 3) {\n          var b = fdeb[dsym];\n      \
    dt += bits16(dat, pos) & (1 << b) - 1, pos += b;\n        }\n        if \
(pos > tbts) {\n          if (noSt)\n            err(0);\n          break;\n  \
      }\n        if (resize)\n          cbuf(bt + 131072);\n        var end = \
bt + add2;\n        if (bt < dt) {\n          var shift = dl - dt, dend = \
Math.min(dt, end);\n          if (shift + bt < 0)\n            err(3);\n      \
    for (; bt < dend; ++bt)\n            buf[bt] = dict[shift + bt];\n        \
}\n        for (; bt < end; ++bt)\n          buf[bt] = buf[bt - dt];\n      \
}\n    }\n    st.l = lm, st.p = lpos, st.b = bt, st.f = final;\n    if (lm)\n \
     final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n  } while (!final);\n  \
return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, \
bt);\n};\nvar et = /* @__PURE__ */ new u8(0);\nvar b2 = function(d, b) {\n  \
return d[b] | d[b + 1] << 8;\n};\nvar b4 = function(d, b) {\n  return (d[b] | \
d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;\n};\nvar b8 = \
function(d, b) {\n  return b4(d, b) + b4(d, b + 4) * 4294967296;\n};\nvar gzs \
= function(d) {\n  if (d[0] != 31 || d[1] != 139 || d[2] != 8)\n    err(6, \
\"invalid gzip data\");\n  var flg = d[3];\n  var st = 10;\n  if (flg & 4)\n  \
  st += (d[10] | d[11] << 8) + 2;\n  for (var zs = (flg >> 3 & 1) + (flg >> 4 \
& 1); zs > 0; zs -= !d[st++])\n    ;\n  return st + (flg & 2);\n};\nvar \
Inflate = /* @__PURE__ */ function() {\n  function Inflate2(opts, cb) {\n    \
if (typeof opts == \"function\")\n      cb = opts, opts = {};\n    \
this.ondata = cb;\n    var dict = opts && opts.dictionary && \
opts.dictionary.subarray(-32768);\n    this.s = { i: 0, b: dict ? dict.length \
: 0 };\n    this.o = new u8(32768);\n    this.p = new u8(0);\n    if (dict)\n \
     this.o.set(dict);\n  }\n  Inflate2.prototype.e = function(c) {\n    if \
(!this.ondata)\n      err(5);\n    if (this.d)\n      err(4);\n    if \
(!this.p.length)\n      this.p = c;\n    else if (c.length) {\n      var n = \
new u8(this.p.length + c.length);\n      n.set(this.p), n.set(c, \
this.p.length), this.p = n;\n    }\n  };\n  Inflate2.prototype.c = \
function(final) {\n    this.s.i = +(this.d = final || false);\n    var bts = \
this.s.b;\n    var dt = inflt(this.p, this.s, this.o);\n    \
this.ondata(slc(dt, bts, this.s.b), this.d);\n    this.o = slc(dt, this.s.b - \
32768), this.s.b = this.o.length;\n    this.p = slc(this.p, this.s.p / 8 | \
0), this.s.p &= 7;\n  };\n  Inflate2.prototype.push = function(chunk, final) \
{\n    this.e(chunk), this.c(final);\n  };\n  return \
Inflate2;\n}();\nfunction inflateSync(data, opts) {\n  return inflt(data, { \
i: 2 }, opts && opts.out, opts && opts.dictionary);\n}\nvar Gunzip = /* \
@__PURE__ */ function() {\n  function Gunzip2(opts, cb) {\n    this.v = 1;\n  \
  this.r = 0;\n    Inflate.call(this, opts, cb);\n  }\n  \
Gunzip2.prototype.push = function(chunk, final) {\n    \
Inflate.prototype.e.call(this, chunk);\n    this.r += chunk.length;\n    if \
(this.v) {\n      var p = this.p.subarray(this.v - 1);\n      var s = \
p.length > 3 ? gzs(p) : 4;\n      if (s > p.length) {\n        if (!final)\n  \
        return;\n      } else if (this.v > 1 && this.onmember) {\n        \
this.onmember(this.r - p.length);\n      }\n      this.p = p.subarray(s), \
this.v = 0;\n    }\n    Inflate.prototype.c.call(this, final);\n    if \
(this.s.f && !this.s.l && !final) {\n      this.v = shft(this.s.p) + 9;\n     \
 this.s = { i: 0 };\n      this.o = new u8(0);\n      this.push(new u8(0), \
final);\n    }\n  };\n  return Gunzip2;\n}();\nvar td = typeof TextDecoder != \
\"undefined\" && /* @__PURE__ */ new TextDecoder();\nvar tds = 0;\ntry {\n  \
td.decode(et, { stream: true });\n  tds = 1;\n} catch (e) {\n}\nvar dutf8 = \
function(d) {\n  for (var r = \"\", i = 0; ; ) {\n    var c = d[i++];\n    \
var eb = (c > 127) + (c > 223) + (c > 239);\n    if (i + eb > d.length)\n     \
 return { s: r, r: slc(d, i - 1) };\n    if (!eb)\n      r += \
String.fromCharCode(c);\n    else if (eb == 3) {\n      c = ((c & 15) << 18 | \
(d[i++] & 63) << 12 | (d[i++] & 63) << 6 | d[i++] & 63) - 65536, r += \
String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);\n    } else if (eb & \
1)\n      r += String.fromCharCode((c & 31) << 6 | d[i++] & 63);\n    else\n  \
    r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | d[i++] & \
63);\n  }\n};\nfunction strFromU8(dat, latin1) {\n  if (latin1) {\n    var r \
= \"\";\n    for (var i = 0; i < dat.length; i += 16384)\n      r += \
String.fromCharCode.apply(null, dat.subarray(i, i + 16384));\n    return r;\n \
 } else if (td) {\n    return td.decode(dat);\n  } else {\n    var _a2 = \
dutf8(dat), s = _a2.s, r = _a2.r;\n    if (r.length)\n      err(8);\n    \
return s;\n  }\n}\nvar slzh = function(d, b) {\n  return b + 30 + b2(d, b + \
26) + b2(d, b + 28);\n};\nvar zh = function(d, b, z) {\n  var fnl = b2(d, b + \
28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & \
2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\n  var _a2 = z && bs == \
4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a2[0], \
su = _a2[1], off = _a2[2];\n  return [b2(d, b + 10), sc, su, fn, es + b2(d, b \
+ 30) + b2(d, b + 32), off];\n};\nvar z64e = function(d, b) {\n  for (; b2(d, \
b) != 1; b += 4 + b2(d, b + 2))\n    ;\n  return [b8(d, b + 12), b8(d, b + \
4), b8(d, b + 20)];\n};\nfunction unzipSync(data, opts) {\n  var files = \
{};\n  var e = data.length - 22;\n  for (; b4(data, e) != 101010256; --e) {\n \
   if (!e || data.length - e > 65558)\n      err(13);\n  }\n  var c = \
b2(data, e + 8);\n  if (!c)\n    return {};\n  var o = b4(data, e + 16);\n  \
var z = o == 4294967295 || c == 65535;\n  if (z) {\n    var ze = b4(data, e - \
12);\n    z = b4(data, ze) == 101075792;\n    if (z) {\n      c = b4(data, ze \
+ 32);\n      o = b4(data, ze + 48);\n    }\n  }\n  var fltr = opts && \
opts.filter;\n  for (var i = 0; i < c; ++i) {\n    var _a2 = zh(data, o, z), \
c_2 = _a2[0], sc = _a2[1], su = _a2[2], fn = _a2[3], no = _a2[4], off = \
_a2[5], b = slzh(data, off);\n    o = no;\n    if (!fltr || fltr({\n      \
name: fn,\n      size: sc,\n      originalSize: su,\n      compression: c_2\n \
   })) {\n      if (!c_2)\n        files[fn] = slc(data, b, b + sc);\n      \
else if (c_2 == 8)\n        files[fn] = inflateSync(data.subarray(b, b + sc), \
{ out: new u8(su) });\n      else\n        err(14, \"unknown compression type \
\" + c_2);\n    }\n  }\n  return files;\n}\nlet wasm;\nconst \
cachedTextDecoder = typeof TextDecoder !== \"undefined\" ? new \
TextDecoder(\"utf-8\", { ignoreBOM: true, fatal: true }) : { decode: () => \
{\n  throw Error(\"TextDecoder not available\");\n} };\nif (typeof \
TextDecoder !== \"undefined\") {\n  cachedTextDecoder.decode();\n}\nlet \
cachedUint8ArrayMemory0 = null;\nfunction getUint8ArrayMemory0() {\n  if \
(cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === \
0) {\n    cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\n  \
}\n  return cachedUint8ArrayMemory0;\n}\nfunction getStringFromWasm0(ptr, \
len) {\n  ptr = ptr >>> 0;\n  return \
cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + \
len));\n}\nfunction raycast_splats(origin_x, origin_y, origin_z, dir_x, \
dir_y, dir_z, near, far, num_splats, packed_splats, raycast_ellipsoid, \
ln_scale_min, ln_scale_max) {\n  const ret = wasm.raycast_splats(origin_x, \
origin_y, origin_z, dir_x, dir_y, dir_z, near, far, num_splats, \
packed_splats, raycast_ellipsoid, ln_scale_min, ln_scale_max);\n  return \
ret;\n}\nasync function __wbg_load(module, imports) {\n  if (typeof Response \
=== \"function\" && module instanceof Response) {\n    if (typeof \
WebAssembly.instantiateStreaming === \"function\") {\n      try {\n        \
return await WebAssembly.instantiateStreaming(module, imports);\n      } \
catch (e) {\n        if (module.headers.get(\"Content-Type\") != \
\"application/wasm\") {\n          \
console.warn(\"`WebAssembly.instantiateStreaming` failed because your server \
does not serve Wasm with `application/wasm` MIME type. Falling back to \
`WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n        \
} else {\n          throw e;\n        }\n      }\n    }\n    const bytes = \
await module.arrayBuffer();\n    return await WebAssembly.instantiate(bytes, \
imports);\n  } else {\n    const instance = await \
WebAssembly.instantiate(module, imports);\n    if (instance instanceof \
WebAssembly.Instance) {\n      return { instance, module };\n    } else {\n   \
   return instance;\n    }\n  }\n}\nfunction __wbg_get_imports() {\n  const \
imports = {};\n  imports.wbg = {};\n  \
imports.wbg.__wbg_buffer_609cc3eee51ed158 = function(arg0) {\n    const ret = \
arg0.buffer;\n    return ret;\n  };\n  \
imports.wbg.__wbg_length_3b4f022188ae8db6 = function(arg0) {\n    const ret = \
arg0.length;\n    return ret;\n  };\n  \
imports.wbg.__wbg_length_6ca527665d89694d = function(arg0) {\n    const ret = \
arg0.length;\n    return ret;\n  };\n  \
imports.wbg.__wbg_length_8cfd2c6409af88ad = function(arg0) {\n    const ret = \
arg0.length;\n    return ret;\n  };\n  imports.wbg.__wbg_new_9fee97a409b32b68 \
= function(arg0) {\n    const ret = new Uint16Array(arg0);\n    return ret;\n \
 };\n  imports.wbg.__wbg_new_e3b321dcfef89fc7 = function(arg0) {\n    const \
ret = new Uint32Array(arg0);\n    return ret;\n  };\n  \
imports.wbg.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354 = \
function(arg0, arg1, arg2) {\n    const ret = new Float32Array(arg0, arg1 >>> \
0, arg2 >>> 0);\n    return ret;\n  };\n  \
imports.wbg.__wbg_newwithbyteoffsetandlength_f1dead44d1fc7212 = \
function(arg0, arg1, arg2) {\n    const ret = new Uint32Array(arg0, arg1 >>> \
0, arg2 >>> 0);\n    return ret;\n  };\n  \
imports.wbg.__wbg_newwithlength_5a5efe313cfd59f1 = function(arg0) {\n    \
const ret = new Float32Array(arg0 >>> 0);\n    return ret;\n  };\n  \
imports.wbg.__wbg_set_10bad9bee0e9c58b = function(arg0, arg1, arg2) {\n    \
arg0.set(arg1, arg2 >>> 0);\n  };\n  imports.wbg.__wbg_set_d23661d19148b229 = \
function(arg0, arg1, arg2) {\n    arg0.set(arg1, arg2 >>> 0);\n  };\n  \
imports.wbg.__wbg_set_f4f1f0daa30696fc = function(arg0, arg1, arg2) {\n    \
arg0.set(arg1, arg2 >>> 0);\n  };\n  \
imports.wbg.__wbg_subarray_3aaeec89bb2544f0 = function(arg0, arg1, arg2) {\n  \
  const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);\n    return ret;\n  };\n \
 imports.wbg.__wbg_subarray_769e1e0f81bb259b = function(arg0, arg1, arg2) {\n \
   const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);\n    return ret;\n  \
};\n  imports.wbg.__wbindgen_init_externref_table = function() {\n    const \
table = wasm.__wbindgen_export_0;\n    const offset = table.grow(4);\n    \
table.set(0, void 0);\n    table.set(offset + 0, void 0);\n    \
table.set(offset + 1, null);\n    table.set(offset + 2, true);\n    \
table.set(offset + 3, false);\n  };\n  imports.wbg.__wbindgen_memory = \
function() {\n    const ret = wasm.memory;\n    return ret;\n  };\n  \
imports.wbg.__wbindgen_throw = function(arg0, arg1) {\n    throw new \
Error(getStringFromWasm0(arg0, arg1));\n  };\n  return imports;\n}\nfunction \
__wbg_finalize_init(instance, module) {\n  wasm = instance.exports;\n  \
__wbg_init.__wbindgen_wasm_module = module;\n  cachedUint8ArrayMemory0 = \
null;\n  wasm.__wbindgen_start();\n  return wasm;\n}\nasync function \
__wbg_init(module_or_path) {\n  if (wasm !== void 0) return wasm;\n  if \
(typeof module_or_path !== \"undefined\") {\n    if \
(Object.getPrototypeOf(module_or_path) === Object.prototype) {\n      ({ \
module_or_path } = module_or_path);\n    } else {\n      console.warn(\"using \
deprecated parameters for the initialization function; pass a single object \
instead\");\n    }\n  }\n  if (typeof module_or_path === \"undefined\") {\n   \
 module_or_path = new \
URL(\"data:application/wasm;base64,AGFzbQEAAAABzAEeYAJ/fwF/YAJ/fwBgA39/fwF/YA\
N/f38AYAF/AX9gAX8AYANvf38Bb2AFf39/f38Bf2AFf39/f38AYAFvAW9gA29vfwBgAW8Bf2AAAGA\
AAX9gBH9/f38AYAR/f39/AX9gA39vbwF/YAF/AW9gAAFvYAF9AX1gBn9/f39/fwBgDX19fX19fX19\
f29/fX0Bb2AGf39/f39/AX9gBX9/fX9/AGAEf31/fwBgBX9/fH9/AGAEf3x/fwBgBX9/fn9/AGAEf\
35/fwBgAn19AX0C8gQRA3diZx1fX3diZ19idWZmZXJfNjA5Y2MzZWVlNTFlZDE1OAAJA3diZxpfX3\
diZ19uZXdfOWZlZTk3YTQwOWIzMmI2OAAJA3diZxpfX3diZ19zZXRfZjRmMWYwZGFhMzA2OTZmYwA\
KA3diZx1fX3diZ19sZW5ndGhfOGNmZDJjNjQwOWFmODhhZAALA3diZzFfX3diZ19uZXd3aXRoYnl0\
ZW9mZnNldGFuZGxlbmd0aF9mMWRlYWQ0NGQxZmM3MjEyAAYDd2JnGl9fd2JnX25ld19lM2IzMjFkY\
2ZlZjg5ZmM3AAkDd2JnGl9fd2JnX3NldF9kMjM2NjFkMTkxNDhiMjI5AAoDd2JnHV9fd2JnX2xlbm\
d0aF82Y2E1Mjc2NjVkODk2OTRkAAsDd2JnMV9fd2JnX25ld3dpdGhieXRlb2Zmc2V0YW5kbGVuZ3R\
oX2U2YjdlNjlhY2Q0YzczNTQABgN3YmcaX193Ymdfc2V0XzEwYmFkOWJlZTBlOWM1OGIACgN3Ymcd\
X193YmdfbGVuZ3RoXzNiNGYwMjIxODhhZThkYjYACwN3YmcfX193Ymdfc3ViYXJyYXlfNzY5ZTFlM\
GY4MWJiMjU5YgAGA3diZx9fX3diZ19zdWJhcnJheV8zYWFlZWM4OWJiMjU0NGYwAAYDd2JnJF9fd2\
JnX25ld3dpdGhsZW5ndGhfNWE1ZWZlMzEzY2ZkNTlmMQARA3diZxBfX3diaW5kZ2VuX3Rocm93AAE\
Dd2JnEV9fd2JpbmRnZW5fbWVtb3J5ABIDd2JnH19fd2JpbmRnZW5faW5pdF9leHRlcm5yZWZfdGFi\
bGUADANeXQQAAQcFAgMCEwEBAA0BAwEAAA0BAwgIAwEBBRQBAw4AAwEDAgwMAgABAQcDABUBFhcIG\
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\
4EccSABQf+B/AdxakGBgARsQRB2IARqDwsgAUUEQEEADwsgAUEDcSEDAkAgAUEESQRADAELIAFBfH\
EhBQNAIAQgACACaiIBLAAAQb9/SmogAUEBaiwAAEG/f0pqIAFBAmosAABBv39KaiABQQNqLAAAQb9\
/SmohBCAFIAJBBGoiAkcNAAsLIANFDQAgACACaiEBA0AgBCABLAAAQb9/SmohBCABQQFqIQEgA0EB\
ayIDDQALCyAEC4oGAQZ/IAAoAggiAyABSQRAIAEgAyICayIEIAAoAgAgAmtLBEAgACACIARBBEEEE\
CYgACgCCCECCyAAKAIEIgYgAkECdGohBSAEQQJPBEAgASADQX9zakECdCIHBEAgBUEAIAf8CwALIA\
EgAmpBAnQgA0ECdGsgBmpBBGshBSACIARqQQFrIQILIAVBADYCACAAIAJBAWo2AggLIAAoAhQiAyA\
BSQRAIAEgAyICayIEIAAoAgwgAmtLBEAgAEEMaiACIARBBEEEECYgACgCFCECCyAAKAIQIgYgAkEC\
dGohBSAEQQJPBEAgASADQX9zakECdCIHBEAgBUEAIAf8CwALIAEgAmpBAnQgA0ECdGsgBmpBBGshB\
SACIARqQQFrIQILIAVBADYCACAAIAJBAWo2AhQLIAAoAjgiAyABSQRAIAEgAyICayIEIAAoAjAgAm\
tLBEAgAEEwaiACIARBBEEEECYgACgCOCECCyAAKAI0IgYgAkECdGohBSAEQQJPBEAgASADQX9zakE\
CdCIHBEAgBUEAIAf8CwALIAEgAmpBAnQgA0ECdGsgBmpBBGshBSACIARqQQFrIQILIAVBADYCACAA\
IAJBAWo2AjgLIAAoAiAiA0H//wNNBEAgAyEBQYCABCADayICIAAoAhggA2tLBEAgAEEYaiADIAJBB\
EEEECYgACgCICEBCyAAKAIcIgUgAUECdCIEaiECIANB//8DRwRAQfz/DyADQQJ0IgZrIgcEQCACQQ\
AgB/wLAAsgBCAGayAFakH8/w9qIQIgASADa0H//wNqIQELIAJBADYCACAAIAFBAWo2AiALIAAoAiw\
iA0H//wNNBEAgAyEBQYCABCADayICIAAoAiQgA2tLBEAgAEEkaiADIAJBBEEEECYgACgCLCEBCyAA\
KAIoIgUgAUECdCIEaiECIANB//8DRwRAQfz/DyADQQJ0IgZrIgcEQCACQQAgB/wLAAsgBCAGayAFa\
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\
zYCCCANIAo2AgQgDSAANgIAIA0gDUEEaiIAKAIAEG02AgwgDSANQQhqNgIcIA0gDTYCGCANIAA2Ah\
QgDSANQQxqNgIQIA1BEGohACMAQdAAayIIJAACQAJAAkACQAJAQQBBjIbAACgCABEEACIPBEAgDyg\
CAA0BIAAoAgwhFiAAKAIIIQogACgCACEDIA9BfzYCACAAKAIEIQAgD0EEaiILIAMoAgAQEyAIIABB\
ACAKKAIAEGE2AgggCigCACIAIA8oAgwiCUsNAiAIQQhqIA8oAgggABAzIAhBDGohFSADKAIAIQAgC\
igCACETIwBBMGsiDiQAIAsgABATAkAgCygCCCIAIBNPBEAgCygCBCEKIAsoAhwhAwJAIAsoAiAiDE\
UNACAMQQJ0IgBFDQAgA0EAIAD8CwALIAsoAighFAJAIAsoAiwiEEUNACAQQQJ0IgBFDQAgFEEAIAD\
8CwALIBNBAnQhCSATBEAgCSEEIAohAANAAkAgACgCACIGQYCAgPwHTw0AIAwgBkF/cyIFQf//A3Ei\
BksEQCADIAZBAnRqIgYgBigCAEEBajYCACAQIAVBEHYiBksEQCAUIAZBAnRqIgYgBigCAEEBajYCA\
AwCCyAGIBBB3InAABAxAAsgBiAMQcyJwAAQMQALIABBBGohACAEQQRrIgQNAAsLAkAgDEUEQEEAIQ\
QMAQsgDEEBa0H/////A3EiAEEBaiIEQQdxIQUCQCAAQQdJBEBBACEEIAMhAAwBCyAEQfj///8HcSE\
GQQAhBCADIQADQCAAKAIAIQcgACAENgIAIABBBGoiESgCACESIBEgBCAHaiIENgIAIABBCGoiBygC\
ACERIAcgBCASaiIENgIAIABBDGoiBygCACESIAcgBCARaiIENgIAIABBEGoiBygCACERIAcgBCASa\
iIENgIAIABBFGoiBygCACESIAcgBCARaiIENgIAIABBGGoiBygCACERIAcgBCASaiIENgIAIABBHG\
oiBygCACESIAcgBCARaiIENgIAIAQgEmohBCAAQSBqIQAgBkEIayIGDQALCyAFRQ0AA0AgACgCACE\
GIAAgBDYCACAAQQRqIQAgBCAGaiEEIAVBAWsiBQ0ACwsgDiAENgIEIBMEQCAJIApqIREgCkEEaiEG\
IBNBAWtB/////wNxQQFqIRIgCygCNCEXIAsoAjghB0EAIQUgCiEJA0AgBiEAAkAgCSgCACIJQYCAg\
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\
3I2AgQgByAHKAIEQQFyNgIEIAEgAxAaDAkLQciZwAAoAgAgBGoiBCABSw0HCyADEBEiAUUNASADQX\
xBeCAFKAIAIgJBA3EbIAJBeHFqIgIgAiADSxsiAgRAIAEgACAC/AoAAAsgABAVIAEMCAsgAyABIAE\
gA0sbIgIEQCAIIAAgAvwKAAALIAUoAgAiAkF4cSIDIAFBBEEIIAJBA3EiAhtqSQ0DIAJBACADIAlL\
Gw0EIAAQFQsgCAwGC0HQi8AAQYCMwAAQOgALQZCMwABBwIzAABA6AAtB0IvAAEGAjMAAEDoAC0GQj\
MAAQcCMwAAQOgALIAUgASAGQQFxckECcjYCACABIAJqIgIgBCABayIBQQFyNgIEQciZwAAgATYCAE\
HQmcAAIAI2AgAgAAwBCyAACwsWACAAKAIAIAEgAiAAKAIEKAIMEQIAC4UCAQN/QfCVwAAoAgBFBEA\
CQAJAAn8CQCAARQ0AIAAoAgAgAEEANgIAQQFxRQ0AIAAoAhAhAiAAKAIMIQEgACgCCCEDIAAoAgQM\
AQsCQEGAgMAAEBEiAEUNACAAQQRrLQAAQQNxRQ0AIABBAEGAgMAA/AsACyAAIgFFDQFBgIAQIQJBg\
IAQIQNBAAshAEGAlsAAIAI2AgBB9JXAACAANgIAQfyVwAAoAgAhAkH8lcAAIAE2AgBB+JXAACgCAC\
EAQfiVwAAgAzYCAEHwlcAAKAIAQfCVwABBATYCAEUgAEVyRQRAIAIgAEECdBBgCwwBC0EEQYCAwAB\
B+IXAABBMAAsLQfSVwAALxAQBEX9BrJXAACgCAEUEQAJAIAAEQCAAKAJAIQEgACgCPCECIAAoAjgh\
AyAAKAI0IQQgACgCMCEFIAAoAiwhBiAAKAIoIQcgACgCJCEIIAAoAiAhCSAAKAIcIQogACgCGCELI\
AAoAhQhDCAAKAIQIQ0gACgCDCEOIAAoAgghDyAAKAIEIRAgACgCACAAQQA2AgBBAXENAQtBBCECQQ\
AhAUEAIQNBACEEQQQhBUEAIQZBACEHQQQhCEEAIQlBACEKQQQhC0EAIQxBACENQQQhDkEAIQ9BACE\
QC0HslcAAIAE2AgBB4JXAACAENgIAQdSVwAAgBzYCAEHIlcAAIAo2AgBBvJXAACANNgIAQbCVwAAg\
EDYCAEHolcAAKAIAIQdB6JXAACACNgIAQeSVwAAoAgAhAEHklcAAIAM2AgBB3JXAACgCACEKQdyVw\
AAgBTYCAEHYlcAAKAIAIQFB2JXAACAGNgIAQdCVwAAoAgAhBUHQlcAAIAg2AgBBzJXAACgCACECQc\
yVwAAgCTYCAEHElcAAKAIAIQZBxJXAACALNgIAQcCVwAAoAgAhA0HAlcAAIAw2AgBBuJXAACgCACE\
IQbiVwAAgDjYCAEG0lcAAKAIAIQRBtJXAACAPNgIAQayVwAAoAgAhCUGslcAAQQE2AgACQCAJRQ0A\
IAQEQCAIIARBAnQQYAsgAwRAIAYgA0ECdBBgCyACBEAgBSACQQJ0EGALIAEEQCAKIAFBAnQQYAsgA\
EUNACAHIABBAnQQYAsLQbCVwAAL8gIBCX9BgJXAACgCAEUEQAJ/AkAgAEUNACAAKAIAIABBADYCAE\
EBcUUNACAAKAIoIQEgACgCJCEHIAAoAiAhAiAAKAIcIQMgACgCGCEIIAAoAhQhBCAAKAIQIQUgACg\
CDCEJIAAoAgghBiAAKAIEDAELQQIhCUEEIQdBACEBQQQhCEEACyEAQaiVwAAgATYCAEGclcAAIAM2\
AgBBkJXAACAFNgIAQYSVwAAgADYCAEGklcAAKAIAIQVBpJXAACAHNgIAQaCVwAAoAgAhAEGglcAAI\
AI2AgBBmJXAACgCACEBQZiVwAAgCDYCAEGUlcAAKAIAIQJBlJXAACAENgIAQYyVwAAoAgAhBEGMlc\
AAIAk2AgBBiJXAACgCACEDQYiVwAAgBjYCAEGAlcAAKAIAIQZBgJXAAEEBNgIAAkAgBkUNACADBEA\
gBCADQQF0EGALIAIEQCABIAJBAnQQYAsgAEUNACAFIABBAnQQYAsLQYSVwAALFAAgACgCACABIAAo\
AgQoAgwRAAALFAIBbwF/EA8hABAdIgEgACYBIAELEAAgASAAKAIEIAAoAggQFgsZAAJ/IAFBCU8EQ\
CABIAAQHAwBCyAAEBELCyAAIABC356dmJy3lrgCNwMIIABCoe2sjPn0nLgHNwMACyIAIABC7bqtts\
2F1PXjADcDCCAAQviCmb2V7sbFuX83AwALEwAgAEGAjsAANgIEIAAgATYCAAsQACABIAAoAgAgACg\
CBBBRCxAAIAEgACgCACAAKAIEEBYLEAAgASgCACABKAIEIAAQGAsOACAAJQEgASUBIAIQBgtbAQJ/\
AkACQCAAQQRrKAIAIgJBeHEiA0EEQQggAkEDcSICGyABak8EQCACQQAgAyABQSdqSxsNASAAEBUMA\
gtB0IvAAEGAjMAAEDoAC0GQjMAAQcCMwAAQOgALCx0BAW8gACgCACUBIAEgAhAMIQMQHSIAIAMmAS\
AAC2oBAX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQQI2AgwgA0G0lMAANgIIIANCAjcCFCADIAN\
BBGqtQoCAgIDQAIQ3AyggAyADrUKAgICA0ACENwMgIAMgA0EgajYCECADQQhqIAIQPwALCQAgACAB\
EA4ACw0AIABBuIvAACABEBgLDAAgACABKQIANwMACw0AIABB0I7AACABEBgLDQAgAUHIjsAAQQUQU\
QsZACAAIAFBkJbAACgCACIAQRQgABsRAQAACw0AIAFBpJDAAEEYEBYLoAIBA38gACgCACEAIwBBkA\
FrIgMkAAJ/AkAgASgCCCICQYCAgBBxRQRAIAJBgICAIHENASADQQhqIAAoAgAgA0EQahAfIAFBAUE\
AIAMoAgggAygCDBAUDAILIAAoAgAhAkEAIQADQCAAIANqQY8BaiACQQ9xIgRBMHIgBEHXAGogBEEK\
SRs6AAAgAEEBayEAIAJBD0sgAkEEdiECDQALIAFBt5LAAEECIAAgA2pBkAFqQQAgAGsQFAwBCyAAK\
AIAIQJBACEAA0AgACADakGPAWogAkEPcSIEQTByIARBN2ogBEEKSRs6AAAgAEEBayEAIAJBD0sgAk\
EEdiECDQALIAFBt5LAAEECIAAgA2pBkAFqQQAgAGsQFAsgA0GQAWokAAsJACAAQQA2AgALCAAgACU\
BEAMLCAAgACUBEAcLC/UUAwBBgIDAAAuhD3NwYXJrLWludGVybmFsLXJzL3NyYy9yYXljYXN0LnJz\
AHNwYXJrLWludGVybmFsLXJzL3NyYy9zb3J0LnJzAGxpYnJhcnkvYWxsb2Mvc3JjL2ZtdC5ycwAva\
G9tZS9ydW5uZXIvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2Yj\
ViNTU3Zi93YXNtLWJpbmRnZW4tMC4yLjEwMC9zcmMvY29udmVydC9zbGljZXMucnMAL3J1c3RjLzI\
5NDgzODgzZWVkNjlkNWZiNGRiMDE5NjRjZGYyYWY0ZDg2ZTljYjIvbGlicmFyeS9zdGQvc3JjL3Ro\
cmVhZC9sb2NhbC5ycwBsaWJyYXJ5L2FsbG9jL3NyYy9zdHJpbmcucnMAL3J1c3RjLzI5NDgzODgzZ\
WVkNjlkNWZiNGRiMDE5NjRjZGYyYWY0ZDg2ZTljYjIvbGlicmFyeS9hbGxvYy9zcmMvc2xpY2Uucn\
MAL3J1c3RjLzI5NDgzODgzZWVkNjlkNWZiNGRiMDE5NjRjZGYyYWY0ZDg2ZTljYjIvbGlicmFyeS9\
hbGxvYy9zcmMvcmF3X3ZlYy9tb2QucnMAL3J1c3QvZGVwcy9kbG1hbGxvYy0wLjIuOS9zcmMvZGxt\
YWxsb2MucnMAbGlicmFyeS9zdGQvc3JjL2FsbG9jLnJzAHNwYXJrLWludGVybmFsLXJzL3NyYy9sa\
WIucnMAL2hvbWUvcnVubmVyLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5ND\
ljZjhjNmI1YjU1N2YvanMtc3lzLTAuMy43Ny9zcmMvbGliLnJzAC9ob21lL3J1bm5lci8uY2FyZ28\
vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL29uY2VfY2VsbC0x\
LjIxLjMvc3JjL2xpYi5ycwAAAHwBEABRAAAALgIAABEAAAAQAhAAHQAAABEAAAA9AAAAAQAAAAIAA\
AADAAAAxQAQAFAAAAAZAQAAGQAAAMUAEABQAAAAGAIAACYAAAAxARAASwAAAMEBAAAdAAAAAAAQAC\
EAAAAqAAAAFwAAAAAAEAAhAAAAeAAAABcAAAAAABAAIQAAAH4AAAAcAAAAAAAQACEAAACAAAAAHAA\
AAAAAEAAhAAAAhQAAACAAAAAQAhAAHQAAAB0AAAAzAAAAEAIQAB0AAAAoAAAALQAAAAEAAAAAAAAA\
EAIQAB0AAAA6AAAAMwAAABACEAAdAAAARQAAAC0AAAAQAhAAHQAAAF4AAAAoAAAAIQAQAB4AAAAbA\
AAAHQAAAEV4cGVjdGVkICBhY3RpdmUgc3BsYXRzIGJ1dCBnb3Qg/AMQAAkAAAAFBBAAFwAAACEAEA\
AeAAAAMwAAAB0AAAAhABAAHgAAADMAAAAVAAAAIQAQAB4AAAAkAAAAFAAAACEAEAAeAAAAdAAAABk\
AAAAhABAAHgAAAKcAAAATAAAAIQAQAB4AAACfAAAAEwAAACEAEAAeAAAAogAAAB0AAAAhABAAHgAA\
AKIAAAARAAAAIQAQAB4AAACQAAAAIAAAACEAEAAeAAAAkAAAABQAAAAhABAAHgAAAHwAAAAYAAAAI\
QAQAB4AAAB9AAAAGAAAAC0CEABbAAAA+xgAAAEAAABYABAAbQAAACQBAAAOAAAAY2xvc3VyZSBpbn\
Zva2VkIHJlY3Vyc2l2ZWx5IG9yIGFmdGVyIGJlaW5nIGRyb3BwZWRMYXp5IGluc3RhbmNlIGhhcyB\
wcmV2aW91c2x5IGJlZW4gcG9pc29uZWQ+BRAAKgAAAIgCEABeAAAACAMAABkAAAByZWVudHJhbnQg\
aW5pdAAAgAUQAA4AAACIAhAAXgAAAHoCAAANAAAAfAEQAFEAAAAuAgAAEQAAABUAAAAMAAAABAAAA\
BYAAAAXAAAAGAAAAGFzc2VydGlvbiBmYWlsZWQ6IHBzaXplID49IHNpemUgKyBtaW5fb3ZlcmhlYW\
QAAM0BEAAqAAAAsAQAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA8PSBzaXplICsgbWF4X29\
2ZXJoZWFkAADNARAAKgAAALYEAAANAAAAQWNjZXNzRXJyb3JjYW5ub3QgYWNjZXNzIGEgVGhyZWFk\
IExvY2FsIFN0b3JhZ2UgdmFsdWUgZHVyaW5nIG9yIGFmdGVyIGRlc3RydWN0aW9uOiAAWwYQAEgAA\
ABtZW1vcnkgYWxsb2NhdGlvbiBvZiAgYnl0ZXMgZmFpbGVkAACsBhAAFQAAAMEGEAANAAAA9wEQAB\
kAAABkAQAACQAAABUAAAAMAAAABAAAABkAAAAAAAAACAAAAAQAAAAaAAAAAAAAAAgAAAAEAAAAGwA\
AABwAAAAdAAAAHgAAAB8AAAAQAAAABAAAACAAAAAhAAAAIgAAACMAAABFcnJvcgAAACQAAAAMAAAA\
BAAAACUAAAAmAAAAJwAAAGNhcGFjaXR5IG92ZXJmbG93AAAAaAcQABEAAACsARAAIQAAAC4CAAARA\
AAAFQEQABwAAADoAQAAFwBBrI/AAAu4BQEAAAAoAAAAYSBmb3JtYXR0aW5nIHRyYWl0IGltcGxlbW\
VudGF0aW9uIHJldHVybmVkIGFuIGVycm9yIHdoZW4gdGhlIHVuZGVybHlpbmcgc3RyZWFtIGRpZCB\
ub3QAAD8AEAAZAAAAigIAAA4AAAABAAAAAAAAAFJlZkNlbGwgYWxyZWFkeSBib3Jyb3dlZGluZGV4\
IG91dCBvZiBib3VuZHM6IHRoZSBsZW4gaXMgIGJ1dCB0aGUgaW5kZXggaXMgAAA8CBAAIAAAAFwIE\
AASAAAAAAAAAAQAAAAEAAAALQAAAD09IT1tYXRjaGVzYXNzZXJ0aW9uIGBsZWZ0ICByaWdodGAgZm\
FpbGVkCiAgbGVmdDogCiByaWdodDogAJsIEAAQAAAAqwgQABcAAADCCBAACQAAACByaWdodGAgZmF\
pbGVkOiAKICBsZWZ0OiAAAACbCBAAEAAAAOQIEAAQAAAA9AgQAAkAAADCCBAACQAAADogAAABAAAA\
AAAAACAJEAACAAAAfSB9MHgwMDAxMDIwMzA0MDUwNjA3MDgwOTEwMTExMjEzMTQxNTE2MTcxODE5M\
jAyMTIyMjMyNDI1MjYyNzI4MjkzMDMxMzIzMzM0MzUzNjM3MzgzOTQwNDE0MjQzNDQ0NTQ2NDc0OD\
Q5NTA1MTUyNTM1NDU1NTY1NzU4NTk2MDYxNjI2MzY0NjU2NjY3Njg2OTcwNzE3MjczNzQ3NTc2Nzc\
3ODc5ODA4MTgyODM4NDg1ODY4Nzg4ODk5MDkxOTI5Mzk0OTU5Njk3OTg5OSBvdXQgb2YgcmFuZ2Ug\
Zm9yIHNsaWNlIG9mIGxlbmd0aCByYW5nZSBlbmQgaW5kZXggACMKEAAQAAAAAQoQACIAAACQCBAAk\
ggQAJQIEAACAAAAAgAAAAcAAAAAAAA/AAAAvwBB/JTAAAsBEgB8CXByb2R1Y2VycwIIbGFuZ3VhZ2\
UBBFJ1c3QADHByb2Nlc3NlZC1ieQMFcnVzdGMdMS44OS4wICgyOTQ4Mzg4M2UgMjAyNS0wOC0wNCk\
Gd2FscnVzBjAuMjMuMwx3YXNtLWJpbmRnZW4TMC4yLjEwMCAoMjQwNWVjMmI0KQBrD3RhcmdldF9m\
ZWF0dXJlcwYrD211dGFibGUtZ2xvYmFscysTbm9udHJhcHBpbmctZnB0b2ludCsLYnVsay1tZW1vc\
nkrCHNpZ24tZXh0Kw9yZWZlcmVuY2UtdHlwZXMrCm11bHRpdmFsdWU=\");\n  }\n  const \
imports = __wbg_get_imports();\n  if (typeof module_or_path === \"string\" || \
typeof Request === \"function\" && module_or_path instanceof Request || \
typeof URL === \"function\" && module_or_path instanceof URL) {\n    \
module_or_path = fetch(module_or_path);\n  }\n  const { instance, module } = \
await __wbg_load(await module_or_path, imports);\n  return \
__wbg_finalize_init(instance, module);\n}\nconst LN_SCALE_MIN = -12;\nconst \
LN_SCALE_MAX = 9;\nconst SCALE_MIN = Math.exp(LN_SCALE_MIN);\nconst SCALE_MAX \
= Math.exp(LN_SCALE_MAX);\nconst LN_SCALE_ZERO = -30;\nconst SCALE_ZERO = \
Math.exp(LN_SCALE_ZERO);\nconst SPLAT_TEX_WIDTH_BITS = 11;\nconst \
SPLAT_TEX_HEIGHT_BITS = 11;\nconst SPLAT_TEX_DEPTH_BITS = 11;\nconst \
SPLAT_TEX_LAYER_BITS = SPLAT_TEX_WIDTH_BITS + SPLAT_TEX_HEIGHT_BITS;\nconst \
SPLAT_TEX_WIDTH = 1 << SPLAT_TEX_WIDTH_BITS;\nconst SPLAT_TEX_HEIGHT = 1 << \
SPLAT_TEX_HEIGHT_BITS;\nconst SPLAT_TEX_DEPTH = 1 << \
SPLAT_TEX_DEPTH_BITS;\nconst SPLAT_TEX_MIN_HEIGHT = 1;\nconst \
SPLAT_TEX_WIDTH_MASK = SPLAT_TEX_WIDTH - 1;\nconst SPLAT_TEX_HEIGHT_MASK = \
SPLAT_TEX_HEIGHT - 1;\nconst SPLAT_TEX_DEPTH_MASK = SPLAT_TEX_DEPTH - \
1;\nconst WASM_SPLAT_SORT = true;\nconst USE_COMPILED_PARSER_FUNCTION = \
true;\nconst defines = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ \
Object.defineProperty({\n  __proto__: null,\n  LN_SCALE_MAX,\n  \
LN_SCALE_MIN,\n  LN_SCALE_ZERO,\n  SCALE_MAX,\n  SCALE_MIN,\n  SCALE_ZERO,\n  \
SPLAT_TEX_DEPTH,\n  SPLAT_TEX_DEPTH_BITS,\n  SPLAT_TEX_DEPTH_MASK,\n  \
SPLAT_TEX_HEIGHT,\n  SPLAT_TEX_HEIGHT_BITS,\n  SPLAT_TEX_HEIGHT_MASK,\n  \
SPLAT_TEX_LAYER_BITS,\n  SPLAT_TEX_MIN_HEIGHT,\n  SPLAT_TEX_WIDTH,\n  \
SPLAT_TEX_WIDTH_BITS,\n  SPLAT_TEX_WIDTH_MASK,\n  \
USE_COMPILED_PARSER_FUNCTION,\n  WASM_SPLAT_SORT\n}, Symbol.toStringTag, { \
value: \"Module\" }));\nfunction isBoolType(type) {\n  return type === \
\"bool\" || type === \"bvec2\" || type === \"bvec3\" || type === \
\"bvec4\";\n}\nfunction isScalarType(type) {\n  return type === \"int\" || \
type === \"uint\" || type === \"float\";\n}\nfunction isIntType(type) {\n  \
return type === \"int\" || type === \"ivec2\" || type === \"ivec3\" || type \
=== \"ivec4\";\n}\nfunction isUintType(type) {\n  return type === \"uint\" || \
type === \"uvec2\" || type === \"uvec3\" || type === \"uvec4\";\n}\nfunction \
isFloatType(type) {\n  return type === \"float\" || type === \"vec2\" || type \
=== \"vec3\" || type === \"vec4\";\n}\nfunction isMatFloatType(type) {\n  \
return type === \"mat2\" || type === \"mat2x2\" || type === \"mat2x3\" || \
type === \"mat2x4\" || type === \"mat3\" || type === \"mat3x2\" || type === \
\"mat3x3\" || type === \"mat3x4\" || type === \"mat4\" || type === \"mat4x2\" \
|| type === \"mat4x3\" || type === \"mat4x4\";\n}\nfunction \
isAllFloatType(type) {\n  return isFloatType(type) || \
isMatFloatType(type);\n}\nfunction isVector2Type(type) {\n  return type === \
\"vec2\" || type === \"ivec2\" || type === \"uvec2\";\n}\nfunction \
isVector3Type(type) {\n  return type === \"vec3\" || type === \"ivec3\" || \
type === \"uvec3\";\n}\nfunction isVector4Type(type) {\n  return type === \
\"vec4\" || type === \"ivec4\" || type === \"uvec4\";\n}\nfunction \
isVectorType(type) {\n  return isVector2Type(type) || isVector3Type(type) || \
isVector4Type(type);\n}\nfunction isMat2(type) {\n  return type === \"mat2\" \
|| type === \"mat2x2\";\n}\nfunction isMat3(type) {\n  return type === \
\"mat3\" || type === \"mat3x3\";\n}\nfunction isMat4(type) {\n  return type \
=== \"mat4\" || type === \"mat4x4\";\n}\nfunction vectorElementType(type) {\n \
 switch (type) {\n    case \"vec2\":\n      return \"float\";\n    case \
\"vec3\":\n      return \"float\";\n    case \"vec4\":\n      return \
\"float\";\n    case \"ivec2\":\n      return \"int\";\n    case \"ivec3\":\n \
     return \"int\";\n    case \"ivec4\":\n      return \"int\";\n    case \
\"uvec2\":\n      return \"uint\";\n    case \"uvec3\":\n      return \
\"uint\";\n    case \"uvec4\":\n      return \"uint\";\n    default:\n      \
throw new Error(`Invalid vector type: ${type}`);\n  }\n}\nfunction \
vectorDim(type) {\n  switch (type) {\n    case \"vec2\":\n    case \
\"ivec2\":\n    case \"uvec2\":\n      return 2;\n    case \"vec3\":\n    \
case \"ivec3\":\n    case \"uvec3\":\n      return 3;\n    case \"vec4\":\n   \
 case \"ivec4\":\n    case \"uvec4\":\n      return 4;\n    default:\n      \
throw new Error(`Invalid vector type: ${type}`);\n  }\n}\nfunction \
sameSizeVec(type) {\n  if (isScalarType(type)) {\n    return \"float\";\n  \
}\n  if (isVector2Type(type)) {\n    return \"vec2\";\n  }\n  if \
(isVector3Type(type)) {\n    return \"vec3\";\n  }\n  if \
(isVector4Type(type)) {\n    return \"vec4\";\n  }\n  throw new \
Error(`Invalid vector type: ${type}`);\n}\nfunction sameSizeUvec(type) {\n  \
if (isScalarType(type)) {\n    return \"uint\";\n  }\n  if \
(isVector2Type(type)) {\n    return \"uvec2\";\n  }\n  if \
(isVector3Type(type)) {\n    return \"uvec3\";\n  }\n  if \
(isVector4Type(type)) {\n    return \"uvec4\";\n  }\n  throw new \
Error(`Invalid vector type: ${type}`);\n}\nfunction sameSizeIvec(type) {\n  \
if (isScalarType(type)) {\n    return \"int\";\n  }\n  if \
(isVector2Type(type)) {\n    return \"ivec2\";\n  }\n  if \
(isVector3Type(type)) {\n    return \"ivec3\";\n  }\n  if \
(isVector4Type(type)) {\n    return \"ivec4\";\n  }\n  throw new \
Error(`Invalid vector type: ${type}`);\n}\nfunction typeLiteral(type) {\n  if \
(typeof type === \"string\") {\n    return type;\n  }\n  if (typeof type === \
\"object\" && type.type) {\n    return type.type;\n  }\n  throw new \
Error(`Invalid DynoType: ${String(type)}`);\n}\nfunction numberAsInt(value) \
{\n  return Math.trunc(value).toString();\n}\nfunction numberAsUint(value) \
{\n  const v = Math.max(0, Math.trunc(value));\n  return \
`${v.toString()}u`;\n}\nfunction numberAsFloat(value) {\n  return value === \
Number.POSITIVE_INFINITY ? \"INFINITY\" : value === Number.NEGATIVE_INFINITY \
? \"-INFINITY\" : Number.isInteger(value) ? value.toFixed(1) : \
value.toString();\n}\nfunction valType(val) {\n  if (val instanceof \
DynoValue) {\n    return val.type;\n  }\n  const value = val.dynoOut();\n  \
return value.type;\n}\nclass DynoValue {\n  constructor(type) {\n    \
this.__isDynoValue = true;\n    this.type = type;\n  }\n}\nclass DynoOutput \
extends DynoValue {\n  constructor(dyno2, key) {\n    \
super(dyno2.outTypes[key]);\n    this.dyno = dyno2;\n    this.key = key;\n  \
}\n}\nclass DynoLiteral extends DynoValue {\n  constructor(type, literal) {\n \
   super(type);\n    this.literal = literal;\n  }\n  getLiteral() {\n    \
return this.literal;\n  }\n}\nfunction dynoLiteral(type, literal) {\n  return \
new DynoLiteral(type, literal);\n}\nclass DynoConst extends DynoLiteral {\n  \
constructor(type, value) {\n    super(type, \"\");\n    this.value = value;\n \
 }\n  getLiteral() {\n    const { type, value } = this;\n    switch (type) \
{\n      case \"bool\":\n        return value ? \"true\" : \"false\";\n      \
case \"uint\":\n        return numberAsUint(value);\n      case \"int\":\n    \
    return numberAsInt(value);\n      case \"float\":\n        return \
numberAsFloat(value);\n      case \"bvec2\": {\n        const v = value;\n    \
    return `bvec2(${v[0]}, ${v[1]})`;\n      }\n      case \"uvec2\": {\n     \
   if (value instanceof THREE.Vector2) {\n          return \
`uvec2(${numberAsUint(value.x)}, ${numberAsUint(value.y)})`;\n        }\n     \
   const v = value;\n        return `uvec2(${numberAsUint(v[0])}, \
${numberAsUint(v[1])})`;\n      }\n      case \"ivec2\": {\n        if (value \
instanceof THREE.Vector2) {\n          return `ivec2(${numberAsInt(value.x)}, \
${numberAsInt(value.y)})`;\n        }\n        const v = value;\n        \
return `ivec2(${numberAsInt(v[0])}, ${numberAsInt(v[1])})`;\n      }\n      \
case \"vec2\": {\n        if (value instanceof THREE.Vector2) {\n          \
return `vec2(${numberAsFloat(value.x)}, ${numberAsFloat(value.y)})`;\n        \
}\n        const v = value;\n        return `vec2(${numberAsFloat(v[0])}, \
${numberAsFloat(v[1])})`;\n      }\n      case \"bvec3\": {\n        const v \
= value;\n        return `bvec3(${v[0]}, ${v[1]}, ${v[2]})`;\n      }\n      \
case \"uvec3\": {\n        if (value instanceof THREE.Vector3) {\n          \
return `uvec3(${numberAsUint(value.x)}, ${numberAsUint(value.y)}, \
${numberAsUint(value.z)})`;\n        }\n        const v = value;\n        \
return `uvec3(${numberAsUint(v[0])}, ${numberAsUint(v[1])}, \
${numberAsUint(v[2])})`;\n      }\n      case \"ivec3\": {\n        if (value \
instanceof THREE.Vector3) {\n          return `ivec3(${numberAsInt(value.x)}, \
${numberAsInt(value.y)}, ${numberAsInt(value.z)})`;\n        }\n        const \
v = value;\n        return `ivec3(${numberAsInt(v[0])}, ${numberAsInt(v[1])}, \
${numberAsInt(v[2])})`;\n      }\n      case \"vec3\": {\n        if (value \
instanceof THREE.Vector3) {\n          return \
`vec3(${numberAsFloat(value.x)}, ${numberAsFloat(value.y)}, \
${numberAsFloat(value.z)})`;\n        }\n        const v = value;\n        \
return `vec3(${numberAsFloat(v[0])}, ${numberAsFloat(v[1])}, \
${numberAsFloat(v[2])})`;\n      }\n      case \"bvec4\": {\n        const v \
= value;\n        return `bvec4(${v[0]}, ${v[1]}, ${v[2]}, ${v[3]})`;\n      \
}\n      case \"uvec4\": {\n        if (value instanceof THREE.Vector4) {\n   \
       return `uvec4(${numberAsUint(value.x)}, ${numberAsUint(value.y)}, \
${numberAsUint(value.z)}, ${numberAsUint(value.w)})`;\n        }\n        \
const v = value;\n        return `uvec4(${numberAsUint(v[0])}, \
${numberAsUint(v[1])}, ${numberAsUint(v[2])}, ${numberAsUint(v[3])})`;\n      \
}\n      case \"ivec4\": {\n        if (value instanceof THREE.Vector4) {\n   \
       return `ivec4(${numberAsInt(value.x)}, ${numberAsInt(value.y)}, \
${numberAsInt(value.z)}, ${numberAsInt(value.w)})`;\n        }\n        const \
v = value;\n        return `ivec4(${numberAsInt(v[0])}, ${numberAsInt(v[1])}, \
${numberAsInt(v[2])}, ${numberAsInt(v[3])})`;\n      }\n      case \"vec4\": \
{\n        if (value instanceof THREE.Vector4) {\n          return \
`vec4(${numberAsFloat(value.x)}, ${numberAsFloat(value.y)}, \
${numberAsFloat(value.z)}, ${numberAsFloat(value.w)})`;\n        }\n        \
if (value instanceof THREE.Quaternion) {\n          return \
`vec4(${numberAsFloat(value.x)}, ${numberAsFloat(value.y)}, \
${numberAsFloat(value.z)}, ${numberAsFloat(value.w)})`;\n        }\n        \
const v = value;\n        return `vec4(${numberAsFloat(v[0])}, \
${numberAsFloat(v[1])}, ${numberAsFloat(v[2])}, ${numberAsFloat(v[3])})`;\n   \
   }\n      case \"mat2\":\n      case \"mat2x2\": {\n        const m = \
value;\n        const e = m instanceof THREE.Matrix2 ? m.elements : value;\n  \
      const arg = new Array(4).fill(0).map((_, i) => numberAsFloat(e[i]));\n  \
      return `${type}(${arg.join(\", \")})`;\n      }\n      case \"mat2x3\": \
{\n        const e = value;\n        const arg = new Array(6).fill(0).map((_, \
i) => numberAsFloat(e[i]));\n        return `${type}(${arg.join(\", \")})`;\n \
     }\n      case \"mat2x4\": {\n        const e = value;\n        const arg \
= new Array(8).fill(0).map((_, i) => numberAsFloat(e[i]));\n        return \
`${type}(${arg.join(\", \")})`;\n      }\n      case \"mat3\":\n      case \
\"mat3x3\": {\n        const m = value;\n        const e = m instanceof \
THREE.Matrix3 ? m.elements : value;\n        const arg = new \
Array(9).fill(0).map((_, i) => numberAsFloat(e[i]));\n        return \
`${type}(${arg.join(\", \")})`;\n      }\n      case \"mat3x2\": {\n        \
const e = value;\n        const arg = new Array(6).fill(0).map((_, i) => \
numberAsFloat(e[i]));\n        return `${type}(${arg.join(\", \")})`;\n      \
}\n      case \"mat3x4\": {\n        const e = value;\n        const arg = \
new Array(12).fill(0).map((_, i) => numberAsFloat(e[i]));\n        return \
`${type}(${arg.join(\", \")})`;\n      }\n      case \"mat4\":\n      case \
\"mat4x4\": {\n        const m = value;\n        const e = m instanceof \
THREE.Matrix4 ? m.elements : value;\n        const arg = new \
Array(16).fill(0).map((_, i) => numberAsFloat(e[i]));\n        return \
`${type}(${arg.join(\", \")})`;\n      }\n      case \"mat4x2\": {\n        \
const e = value;\n        const arg = new Array(8).fill(0).map((_, i) => \
numberAsFloat(e[i]));\n        return `${type}(${arg.join(\", \")})`;\n      \
}\n      case \"mat4x3\": {\n        const e = value;\n        const arg = \
new Array(12).fill(0).map((_, i) => numberAsFloat(e[i]));\n        return \
`${type}(${arg.join(\", \")})`;\n      }\n      default:\n        throw new \
Error(`Type not implemented: ${String(type)}`);\n    }\n  }\n}\nfunction \
dynoConst(type, value) {\n  return new DynoConst(type, value);\n}\nfunction \
literalZero(type) {\n  const typeString = String(type);\n  if \
(isBoolType(type)) {\n    return `${typeString}(false)`;\n  }\n  if \
(isAllFloatType(type)) {\n    return `${typeString}(0.0)`;\n  }\n  if \
(isIntType(type)) {\n    return `${typeString}(0)`;\n  }\n  if \
(isUintType(type)) {\n    return `${typeString}(0u)`;\n  }\n  throw new \
Error(`Type not implemented: ${typeString}`);\n}\nfunction literalOne(type) \
{\n  const typeString = String(type);\n  if (isBoolType(type)) {\n    return \
`${typeString}(true)`;\n  }\n  if (isAllFloatType(type)) {\n    return \
`${typeString}(1.0)`;\n  }\n  if (isIntType(type)) {\n    return \
`${typeString}(1)`;\n  }\n  if (isUintType(type)) {\n    return \
`${typeString}(1u)`;\n  }\n  throw new Error(`Type not implemented: \
${typeString}`);\n}\nfunction literalNegOne(type) {\n  const typeString = \
String(type);\n  if (isBoolType(type)) {\n    return `${typeString}(true)`;\n \
 }\n  if (isAllFloatType(type)) {\n    return `${typeString}(-1.0)`;\n  }\n  \
if (isIntType(type)) {\n    return `${typeString}(-1)`;\n  }\n  if \
(isUintType(type)) {\n    return `${typeString}(0xFFFFFFFFu)`;\n  }\n  throw \
new Error(`Type not implemented: ${typeString}`);\n}\nconst DEFAULT_INDENT = \
\"    \";\nclass Compilation {\n  constructor({ indent } = {}) {\n    \
this.globals = /* @__PURE__ */ new Set();\n    this.statements = [];\n    \
this.uniforms = {};\n    this.declares = /* @__PURE__ */ new Set();\n    \
this.updaters = [];\n    this.sequence = 0;\n    this.indent = \
DEFAULT_INDENT;\n    this.indent = indent ?? DEFAULT_INDENT;\n  }\n  \
nextSequence() {\n    return this.sequence++;\n  }\n}\nclass Dyno {\n  \
constructor({\n    inTypes,\n    outTypes,\n    inputs,\n    update,\n    \
globals,\n    statements,\n    generate\n  }) {\n    this.inTypes = inTypes \
?? {};\n    this.outTypes = outTypes ?? {};\n    this.inputs = inputs ?? \
{};\n    this.update = update;\n    this.globals = globals;\n    \
this.statements = statements;\n    this.generate = generate ?? (({ inputs: \
inputs2, outputs, compile }) => {\n      var _a2, _b2;\n      return {\n      \
  globals: (_a2 = this.globals) == null ? void 0 : _a2.call(this, { inputs: \
inputs2, outputs, compile }),\n        statements: (_b2 = this.statements) == \
null ? void 0 : _b2.call(this, { inputs: inputs2, outputs, compile })\n      \
};\n    });\n  }\n  get outputs() {\n    const outputs = {};\n    for (const \
key in this.outTypes) {\n      outputs[key] = new DynoOutput(this, key);\n    \
}\n    return outputs;\n  }\n  apply(inputs) {\n    \
Object.assign(this.inputs, inputs);\n    return this.outputs;\n  }\n  \
compile({\n    inputs,\n    outputs,\n    compile\n  }) {\n    const result = \
[\n      `// ${this.constructor.name}(${Object.values(inputs).join(\", \")}) \
=> (${Object.values(outputs).join(\", \")})`\n    ];\n    const declares = \
[];\n    for (const key in outputs) {\n      const name = outputs[key];\n     \
 if (name && !compile.declares.has(name)) {\n        \
compile.declares.add(name);\n        declares.push(key);\n      }\n    }\n    \
const { globals, statements, uniforms } = this.generate({\n      inputs,\n    \
  outputs,\n      compile\n    });\n    for (const global of globals ?? []) \
{\n      compile.globals.add(global);\n    }\n    for (const key in uniforms) \
{\n      compile.uniforms[key] = uniforms[key];\n    }\n    if (this.update) \
{\n      compile.updaters.push(this.update);\n    }\n    for (const key of \
declares) {\n      const name = outputs[key];\n      if (name) {\n        if \
(!compile.uniforms[name]) {\n          result.push(`${dynoDeclare(name, \
this.outTypes[key])};`);\n        }\n      }\n    }\n    if (statements == \
null ? void 0 : statements.length) {\n      result.push(\"{\");\n      \
result.push(...statements.map((line) => compile.indent + line));\n      \
result.push(\"}\");\n    }\n    return result;\n  }\n}\nclass DynoBlock \
extends Dyno {\n  constructor({\n    inTypes,\n    outTypes,\n    inputs,\n   \
 update,\n    globals,\n    construct\n  }) {\n    super({\n      inTypes,\n  \
    outTypes,\n      inputs,\n      update,\n      globals,\n      generate: \
(args) => this.generateBlock(args)\n    });\n    this.construct = \
construct;\n  }\n  generateBlock({\n    inputs,\n    outputs,\n    compile\n  \
}) {\n    var _a2, _b2;\n    const blockInputs = {};\n    const blockOutputs \
= {};\n    for (const key in inputs) {\n      if (inputs[key] != null) {\n    \
    blockInputs[key] = new DynoLiteral(this.inTypes[key], inputs[key]);\n     \
 }\n    }\n    for (const key in outputs) {\n      if (outputs[key] != null) \
{\n        blockOutputs[key] = new DynoValue(this.outTypes[key]);\n      }\n  \
  }\n    const options = { roots: [] };\n    const returned = \
this.construct(blockInputs, blockOutputs, options);\n    for (const global of \
((_a2 = this.globals) == null ? void 0 : _a2.call(this, { inputs, outputs, \
compile })) ?? []) {\n      compile.globals.add(global);\n    }\n    const \
ordering = [];\n    const nodeOuts = /* @__PURE__ */ new Map();\n    function \
visit(node, outKey, outName) {\n      let outs = nodeOuts.get(node);\n      \
if (!outs) {\n        outs = {\n          sequence: compile.nextSequence(),\n \
         outNames: /* @__PURE__ */ new Map(),\n          newOuts: /* \
@__PURE__ */ new Set()\n        };\n        nodeOuts.set(node, outs);\n       \
 for (const key in node.inputs) {\n          let input = node.inputs[key];\n  \
        while (input) {\n            if (input instanceof DynoValue) {\n      \
        if (input instanceof DynoOutput) {\n                visit(input.dyno, \
input.key);\n              }\n              break;\n            }\n           \
 input = input.dynoOut();\n          }\n        }\n        \
ordering.push(node);\n      }\n      if (outKey) {\n        if (!outName) {\n \
         outs.newOuts.add(outKey);\n        }\n        \
outs.outNames.set(outKey, outName ?? `${outKey}_${outs.sequence}`);\n      \
}\n    }\n    for (const root of options.roots) {\n      visit(root);\n    \
}\n    for (const key in blockOutputs) {\n      let value = (returned == null \
? void 0 : returned[key]) ?? blockOutputs[key];\n      while (value) {\n      \
  if (value instanceof DynoValue) {\n          if (value instanceof \
DynoOutput) {\n            visit(value.dyno, value.key, outputs[key]);\n      \
    }\n          break;\n        }\n        value = value.dynoOut();\n      \
}\n      blockOutputs[key] = value;\n    }\n    const steps = [];\n    for \
(const dyno2 of ordering) {\n      const inputs2 = {};\n      const outputs2 \
= {};\n      for (const key in dyno2.inputs) {\n        let value = \
dyno2.inputs[key];\n        while (value) {\n          if (value instanceof \
DynoValue) {\n            if (value instanceof DynoLiteral) {\n              \
inputs2[key] = value.getLiteral();\n            } else if (value instanceof \
DynoOutput) {\n              const source = (_b2 = nodeOuts.get(value.dyno)) \
== null ? void 0 : _b2.outNames.get(value.key);\n              if (!source) \
{\n                throw new Error(\n                  `Source not found for \
${value.dyno.constructor.name}.${value.key}`\n                );\n            \
  }\n              inputs2[key] = source;\n            }\n            \
break;\n          }\n          value = value.dynoOut();\n        }\n      }\n \
     const outs = nodeOuts.get(dyno2) ?? { outNames: /* @__PURE__ */ new \
Map() };\n      for (const [key, name] of outs.outNames.entries()) {\n        \
outputs2[key] = name;\n      }\n      const newSteps = dyno2.compile({ \
inputs: inputs2, outputs: outputs2, compile });\n      \
steps.push(newSteps);\n    }\n    const literalOutputs = [];\n    for (const \
key in outputs) {\n      if (blockOutputs[key] instanceof DynoLiteral) {\n    \
    literalOutputs.push(\n          `${outputs[key]} = \
${blockOutputs[key].getLiteral()};`\n        );\n      }\n    }\n    if \
(literalOutputs.length > 0) {\n      steps.push(literalOutputs);\n    }\n    \
const statements = steps.flatMap((step2, index) => {\n      return index === \
0 ? step2 : [\"\", ...step2];\n    });\n    return { statements };\n  \
}\n}\nfunction dynoBlock(inTypes, outTypes, construct, { update, globals } = \
{}) {\n  return new DynoBlock({ inTypes, outTypes, construct, update, globals \
});\n}\nfunction dyno$1({\n  inTypes,\n  outTypes,\n  inputs,\n  update,\n  \
globals,\n  statements,\n  generate\n}) {\n  return new Dyno({\n    \
inTypes,\n    outTypes,\n    inputs,\n    update,\n    globals,\n    \
statements,\n    generate\n  });\n}\nfunction dynoDeclare(name, type, count) \
{\n  const typeStr = typeof type === \"string\" ? type : type.type;\n  if \
(!typeStr) {\n    throw new Error(`Invalid DynoType: ${String(type)}`);\n  \
}\n  return `${typeStr} ${name}${count != null ? `[${count}]` : \
\"\"}`;\n}\nfunction unindentLines(s) {\n  var _a2;\n  let seenNonEmpty = \
false;\n  const lines = s.split(\"\\n\").map((line) => {\n    const \
trimmedLine = line.trimEnd();\n    if (seenNonEmpty) {\n      return \
trimmedLine;\n    }\n    if (trimmedLine.length > 0) {\n      seenNonEmpty = \
true;\n      return trimmedLine;\n    }\n    return null;\n  }).filter((line) \
=> line != null);\n  while (lines.length > 0 && lines[lines.length - \
1].length === 0) {\n    lines.pop();\n  }\n  if (lines.length === 0) {\n    \
return [];\n  }\n  const indent = (_a2 = lines[0].match(/^\\s*/)) == null ? \
void 0 : _a2[0];\n  if (!indent) {\n    return lines;\n  }\n  const regex = \
new RegExp(`^${indent}`);\n  return lines.map((line) => line.replace(regex, \
\"\"));\n}\nfunction unindent(s) {\n  return \
unindentLines(s).join(\"\\n\");\n}\nclass UnaryOp extends Dyno {\n  \
constructor({\n    a,\n    outKey,\n    outTypeFunc\n  }) {\n    const \
inTypes = { a: valType(a) };\n    const outType = outTypeFunc(valType(a));\n  \
  const outTypes = { [outKey]: outType };\n    super({ inTypes, outTypes, \
inputs: { a } });\n    this.outKey = outKey;\n  }\n  dynoOut() {\n    return \
new DynoOutput(this, this.outKey);\n  }\n}\nclass BinaryOp extends Dyno {\n  \
constructor({\n    a,\n    b,\n    outKey,\n    outTypeFunc\n  }) {\n    \
const inTypes = { a: valType(a), b: valType(b) };\n    const outType = \
outTypeFunc(valType(a), valType(b));\n    const outTypes = { [outKey]: \
outType };\n    super({ inTypes, outTypes, inputs: { a, b } });\n    \
this.outKey = outKey;\n  }\n  dynoOut() {\n    return new DynoOutput(this, \
this.outKey);\n  }\n}\nclass TrinaryOp extends Dyno {\n  constructor({\n    \
a,\n    b,\n    c,\n    outKey,\n    outTypeFunc\n  }) {\n    const inTypes = \
{ a: valType(a), b: valType(b), c: valType(c) };\n    const outType = \
outTypeFunc(valType(a), valType(b), valType(c));\n    const outTypes = { \
[outKey]: outType };\n    super({ inTypes, outTypes, inputs: { a, b, c } \
});\n    this.outKey = outKey;\n  }\n  dynoOut() {\n    return new \
DynoOutput(this, this.outKey);\n  }\n}\nconst Gsplat = { type: \"Gsplat\" \
};\nconst TPackedSplats = { type: \"PackedSplats\" };\nconst numPackedSplats \
= (packedSplats) => new NumPackedSplats({ packedSplats });\nconst \
readPackedSplat = (packedSplats, index) => new ReadPackedSplat({ \
packedSplats, index });\nconst readPackedSplatRange = (packedSplats, index, \
base, count) => new ReadPackedSplatRange({ packedSplats, index, base, count \
});\nconst splitGsplat = (gsplat) => new SplitGsplat({ gsplat });\nconst \
combineGsplat = ({\n  gsplat,\n  flags,\n  index,\n  center,\n  scales,\n  \
quaternion,\n  rgba,\n  rgb,\n  opacity,\n  x,\n  y,\n  z,\n  r,\n  g,\n  \
b\n}) => {\n  return new CombineGsplat({\n    gsplat,\n    flags,\n    \
index,\n    center,\n    scales,\n    quaternion,\n    rgba,\n    rgb,\n    \
opacity,\n    x,\n    y,\n    z,\n    r,\n    g,\n    b\n  });\n};\nconst \
gsplatNormal = (gsplat) => new GsplatNormal({ gsplat });\nconst \
transformGsplat = (gsplat, {\n  scale,\n  rotate,\n  translate,\n  \
recolor\n}) => {\n  return new TransformGsplat({ gsplat, scale, rotate, \
translate, recolor });\n};\nconst defineGsplat = unindent(`\n  struct Gsplat \
{\n    vec3 center;\n    uint flags;\n    vec3 scales;\n    int index;\n    \
vec4 quaternion;\n    vec4 rgba;\n  };\n  const uint GSPLAT_FLAG_ACTIVE = 1u \
<< 0u;\n\n  bool isGsplatActive(uint flags) {\n    return (flags & \
GSPLAT_FLAG_ACTIVE) != 0u;\n  }\n`);\nconst definePackedSplats = unindent(`\n \
 struct PackedSplats {\n    usampler2DArray texture;\n    int numSplats;\n    \
vec4 rgbMinMaxLnScaleMinMax;\n  };\n`);\nclass NumPackedSplats extends \
UnaryOp {\n  constructor({\n    packedSplats\n  }) {\n    super({ a: \
packedSplats, outKey: \"numSplats\", outTypeFunc: () => \"int\" });\n    \
this.statements = ({ inputs, outputs }) => [\n      `${outputs.numSplats} = \
${inputs.a}.numSplats;`\n    ];\n  }\n}\nconst defineReadPackedSplat = \
unindent(`\n  bool readPackedSplat(usampler2DArray texture, int numSplats, \
vec4 rgbMinMaxLnScaleMinMax, int index, out Gsplat gsplat) {\n    if ((index \
>= 0) && (index < numSplats)) {\n      uvec4 packed = texelFetch(texture, \
splatTexCoord(index), 0);\n      unpackSplatEncoding(packed, gsplat.center, \
gsplat.scales, gsplat.quaternion, gsplat.rgba, rgbMinMaxLnScaleMinMax);\n     \
 return true;\n    } else {\n      return false;\n    }\n  }\n`);\nclass \
ReadPackedSplat extends Dyno {\n  constructor({\n    packedSplats,\n    \
index\n  }) {\n    super({\n      inTypes: { packedSplats: TPackedSplats, \
index: \"int\" },\n      outTypes: { gsplat: Gsplat },\n      inputs: { \
packedSplats, index },\n      globals: () => [defineGsplat, \
definePackedSplats, defineReadPackedSplat],\n      statements: ({ inputs, \
outputs }) => {\n        const { gsplat } = outputs;\n        if (!gsplat) \
{\n          return [];\n        }\n        const { packedSplats: \
packedSplats2, index: index2 } = inputs;\n        let statements;\n        if \
(packedSplats2 && index2) {\n          statements = unindentLines(`\n         \
   if (readPackedSplat(${packedSplats2}.texture, ${packedSplats2}.numSplats, \
${packedSplats2}.rgbMinMaxLnScaleMinMax, ${index2}, ${gsplat})) {\n           \
   bool zeroSize = all(equal(${gsplat}.scales, vec3(0.0, 0.0, 0.0)));\n       \
       ${gsplat}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;\n            } \
else {\n              ${gsplat}.flags = 0u;\n            }\n          `);\n   \
     } else {\n          statements = [`${gsplat}.flags = 0u;`];\n        }\n \
       statements.push(`${gsplat}.index = ${index2 ?? \"0\"};`);\n        \
return statements;\n      }\n    });\n  }\n  dynoOut() {\n    return new \
DynoOutput(this, \"gsplat\");\n  }\n}\nclass ReadPackedSplatRange extends \
Dyno {\n  constructor({\n    packedSplats,\n    index,\n    base,\n    \
count\n  }) {\n    super({\n      inTypes: {\n        packedSplats: \
TPackedSplats,\n        index: \"int\",\n        base: \"int\",\n        \
count: \"int\"\n      },\n      outTypes: { gsplat: Gsplat },\n      inputs: \
{ packedSplats, index, base, count },\n      globals: () => [defineGsplat, \
definePackedSplats, defineReadPackedSplat],\n      statements: ({ inputs, \
outputs }) => {\n        const { gsplat } = outputs;\n        if (!gsplat) \
{\n          return [];\n        }\n        const { packedSplats: \
packedSplats2, index: index2, base: base2, count: count2 } = inputs;\n        \
let statements;\n        if (packedSplats2 && index2 && base2 && count2) {\n  \
        statements = unindentLines(`\n            ${gsplat}.flags = 0u;\n     \
       if ((${index2} >= ${base2}) && (${index2} < (${base2} + ${count2}))) \
{\n              if (readPackedSplat(${packedSplats2}.texture, \
${packedSplats2}.numSplats, ${packedSplats2}.rgbMinMaxLnScaleMinMax, \
${index2}, ${gsplat})) {\n                bool zeroSize = \
all(equal(${gsplat}.scales, vec3(0.0, 0.0, 0.0)));\n                \
${gsplat}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;\n              }\n      \
      }\n          `);\n        } else {\n          statements = \
[`${gsplat}.flags = 0u;`];\n        }\n        \
statements.push(`${gsplat}.index = ${index2 ?? \"0\"};`);\n        return \
statements;\n      }\n    });\n  }\n  dynoOut() {\n    return new \
DynoOutput(this, \"gsplat\");\n  }\n}\nclass SplitGsplat extends Dyno {\n  \
constructor({ gsplat }) {\n    super({\n      inTypes: { gsplat: Gsplat },\n  \
    outTypes: {\n        flags: \"uint\",\n        active: \"bool\",\n        \
index: \"int\",\n        center: \"vec3\",\n        scales: \"vec3\",\n       \
 quaternion: \"vec4\",\n        rgba: \"vec4\",\n        rgb: \"vec3\",\n     \
   opacity: \"float\",\n        x: \"float\",\n        y: \"float\",\n        \
z: \"float\",\n        r: \"float\",\n        g: \"float\",\n        b: \
\"float\"\n      },\n      inputs: { gsplat },\n      globals: () => \
[defineGsplat],\n      statements: ({ inputs, outputs }) => {\n        const \
{ gsplat: gsplat2 } = inputs;\n        const {\n          flags,\n          \
active,\n          index,\n          center,\n          scales,\n          \
quaternion,\n          rgba,\n          rgb,\n          opacity,\n          \
x,\n          y,\n          z,\n          r,\n          g,\n          b\n     \
   } = outputs;\n        return [\n          !flags ? null : `${flags} = \
${gsplat2 ? `${gsplat2}.flags` : \"0u\"};`,\n          !active ? null : \
`${active} = isGsplatActive(${gsplat2 ? `${gsplat2}.flags` : \"0u\"});`,\n    \
      !index ? null : `${index} = ${gsplat2 ? `${gsplat2}.index` : \
\"0\"};`,\n          !center ? null : `${center} = ${gsplat2 ? \
`${gsplat2}.center` : \"vec3(0.0, 0.0, 0.0)\"};`,\n          !scales ? null : \
`${scales} = ${gsplat2 ? `${gsplat2}.scales` : \"vec3(0.0, 0.0, 0.0)\"};`,\n  \
        !quaternion ? null : `${quaternion} = ${gsplat2 ? \
`${gsplat2}.quaternion` : \"vec4(0.0, 0.0, 0.0, 1.0)\"};`,\n          !rgba ? \
null : `${rgba} = ${gsplat2 ? `${gsplat2}.rgba` : \"vec4(0.0, 0.0, 0.0, \
0.0)\"};`,\n          !rgb ? null : `${rgb} = ${gsplat2 ? \
`${gsplat2}.rgba.rgb` : \"vec3(0.0, 0.0, 0.0)\"};`,\n          !opacity ? \
null : `${opacity} = ${gsplat2 ? `${gsplat2}.rgba.a` : \"0.0\"};`,\n          \
!x ? null : `${x} = ${gsplat2 ? `${gsplat2}.center.x` : \"0.0\"};`,\n         \
 !y ? null : `${y} = ${gsplat2 ? `${gsplat2}.center.y` : \"0.0\"};`,\n        \
  !z ? null : `${z} = ${gsplat2 ? `${gsplat2}.center.z` : \"0.0\"};`,\n       \
   !r ? null : `${r} = ${gsplat2 ? `${gsplat2}.rgba.r` : \"0.0\"};`,\n        \
  !g ? null : `${g} = ${gsplat2 ? `${gsplat2}.rgba.g` : \"0.0\"};`,\n         \
 !b ? null : `${b} = ${gsplat2 ? `${gsplat2}.rgba.b` : \"0.0\"};`\n        \
].filter(Boolean);\n      }\n    });\n  }\n}\nclass CombineGsplat extends \
Dyno {\n  constructor({\n    gsplat,\n    flags,\n    index,\n    center,\n   \
 scales,\n    quaternion,\n    rgba,\n    rgb,\n    opacity,\n    x,\n    \
y,\n    z,\n    r,\n    g,\n    b\n  }) {\n    super({\n      inTypes: {\n    \
    gsplat: Gsplat,\n        flags: \"uint\",\n        index: \"int\",\n      \
  center: \"vec3\",\n        scales: \"vec3\",\n        quaternion: \
\"vec4\",\n        rgba: \"vec4\",\n        rgb: \"vec3\",\n        opacity: \
\"float\",\n        x: \"float\",\n        y: \"float\",\n        z: \
\"float\",\n        r: \"float\",\n        g: \"float\",\n        b: \
\"float\"\n      },\n      outTypes: { gsplat: Gsplat },\n      inputs: {\n   \
     gsplat,\n        flags,\n        index,\n        center,\n        \
scales,\n        quaternion,\n        rgba,\n        rgb,\n        opacity,\n \
       x,\n        y,\n        z,\n        r,\n        g,\n        b\n      \
},\n      globals: () => [defineGsplat],\n      statements: ({ inputs, \
outputs }) => {\n        const { gsplat: outGsplat } = outputs;\n        if \
(!outGsplat) {\n          return [];\n        }\n        const {\n          \
gsplat: gsplat2,\n          flags: flags2,\n          index: index2,\n        \
  center: center2,\n          scales: scales2,\n          quaternion: \
quaternion2,\n          rgba: rgba2,\n          rgb: rgb2,\n          \
opacity: opacity2,\n          x: x2,\n          y: y2,\n          z: z2,\n    \
      r: r2,\n          g: g2,\n          b: b22\n        } = inputs;\n       \
 return [\n          `${outGsplat}.flags = ${flags2 ?? (gsplat2 ? \
`${gsplat2}.flags` : \"0u\")};`,\n          `${outGsplat}.index = ${index2 ?? \
(gsplat2 ? `${gsplat2}.index` : \"0\")};`,\n          `${outGsplat}.center = \
${center2 ?? (gsplat2 ? `${gsplat2}.center` : \"vec3(0.0, 0.0, 0.0)\")};`,\n  \
        `${outGsplat}.scales = ${scales2 ?? (gsplat2 ? `${gsplat2}.scales` : \
\"vec3(0.0, 0.0, 0.0)\")};`,\n          `${outGsplat}.quaternion = \
${quaternion2 ?? (gsplat2 ? `${gsplat2}.quaternion` : \"vec4(0.0, 0.0, 0.0, \
1.0)\")};`,\n          `${outGsplat}.rgba = ${rgba2 ?? (gsplat2 ? \
`${gsplat2}.rgba` : \"vec4(0.0, 0.0, 0.0, 0.0)\")};`,\n          !rgb2 ? null \
: `${outGsplat}.rgba.rgb = ${rgb2};`,\n          !opacity2 ? null : \
`${outGsplat}.rgba.a = ${opacity2};`,\n          !x2 ? null : \
`${outGsplat}.center.x = ${x2};`,\n          !y2 ? null : \
`${outGsplat}.center.y = ${y2};`,\n          !z2 ? null : \
`${outGsplat}.center.z = ${z2};`,\n          !r2 ? null : \
`${outGsplat}.rgba.r = ${r2};`,\n          !g2 ? null : `${outGsplat}.rgba.g \
= ${g2};`,\n          !b22 ? null : `${outGsplat}.rgba.b = ${b22};`\n        \
].filter(Boolean);\n      }\n    });\n  }\n  dynoOut() {\n    return new \
DynoOutput(this, \"gsplat\");\n  }\n}\nconst defineGsplatNormal = \
unindent(`\n  vec3 gsplatNormal(vec3 scales, vec4 quaternion) {\n    float \
minScale = min(scales.x, min(scales.y, scales.z));\n    vec3 normal;\n    if \
(scales.z == minScale) {\n      normal = vec3(0.0, 0.0, 1.0);\n    } else if \
(scales.y == minScale) {\n      normal = vec3(0.0, 1.0, 0.0);\n    } else {\n \
     normal = vec3(1.0, 0.0, 0.0);\n    }\n    return quatVec(quaternion, \
normal);\n  }\n`);\nclass GsplatNormal extends UnaryOp {\n  constructor({ \
gsplat }) {\n    super({ a: gsplat, outKey: \"normal\", outTypeFunc: () => \
\"vec3\" });\n    this.globals = () => [defineGsplat, defineGsplatNormal];\n  \
  this.statements = ({ inputs, outputs }) => [\n      `${outputs.normal} = \
gsplatNormal(${inputs.a}.scales, ${inputs.a}.quaternion);`\n    ];\n  \
}\n}\nclass TransformGsplat extends Dyno {\n  constructor({\n    gsplat,\n    \
scale,\n    rotate,\n    translate,\n    recolor\n  }) {\n    super({\n      \
inTypes: {\n        gsplat: Gsplat,\n        scale: \"float\",\n        \
rotate: \"vec4\",\n        translate: \"vec3\",\n        recolor: \"vec4\"\n  \
    },\n      outTypes: { gsplat: Gsplat },\n      inputs: { gsplat, scale, \
rotate, translate, recolor },\n      globals: () => [defineGsplat],\n      \
statements: ({ inputs, outputs, compile }) => {\n        const { gsplat: \
gsplat2 } = outputs;\n        if (!gsplat2 || !inputs.gsplat) {\n          \
return [];\n        }\n        const { scale: scale2, rotate: rotate2, \
translate: translate2, recolor: recolor2 } = inputs;\n        const indent = \
compile.indent;\n        const statements = [\n          `${gsplat2} = \
${inputs.gsplat};`,\n          `if (isGsplatActive(${gsplat2}.flags)) {`,\n   \
       scale2 ? `${indent}${gsplat2}.center *= ${scale2};` : null,\n          \
rotate2 ? `${indent}${gsplat2}.center = quatVec(${rotate2}, \
${gsplat2}.center);` : null,\n          translate2 ? \
`${indent}${gsplat2}.center += ${translate2};` : null,\n          scale2 ? \
`${indent}${gsplat2}.scales *= ${scale2};` : null,\n          rotate2 ? \
`${indent}${gsplat2}.quaternion = quatQuat(${rotate2}, \
${gsplat2}.quaternion);` : null,\n          recolor2 ? \
`${indent}${gsplat2}.rgba *= ${recolor2};` : null,\n          \"}\"\n        \
].filter(Boolean);\n        return statements;\n      }\n    });\n  }\n  \
dynoOut() {\n    return new DynoOutput(this, \"gsplat\");\n  }\n}\nconst \
outputPackedSplat = (gsplat, rgbMinMaxLnScaleMinMax) => new \
OutputPackedSplat({ gsplat, rgbMinMaxLnScaleMinMax });\nconst outputRgba8 = \
(rgba8) => new OutputRgba8({ rgba8 });\nclass OutputPackedSplat extends Dyno \
{\n  constructor({\n    gsplat,\n    rgbMinMaxLnScaleMinMax\n  }) {\n    \
super({\n      inTypes: { gsplat: Gsplat, rgbMinMaxLnScaleMinMax: \"vec4\" \
},\n      inputs: { gsplat, rgbMinMaxLnScaleMinMax },\n      globals: () => \
[defineGsplat],\n      statements: ({ inputs, outputs }) => {\n        const \
{ output } = outputs;\n        if (!output) {\n          return [];\n        \
}\n        const { gsplat: gsplat2, rgbMinMaxLnScaleMinMax: \
rgbMinMaxLnScaleMinMax2 } = inputs;\n        if (gsplat2) {\n          return \
unindentLines(`\n            if (isGsplatActive(${gsplat2}.flags)) {\n        \
      ${output} = packSplatEncoding(${gsplat2}.center, ${gsplat2}.scales, \
${gsplat2}.quaternion, ${gsplat2}.rgba, ${rgbMinMaxLnScaleMinMax2});\n        \
    } else {\n              ${output} = uvec4(0u, 0u, 0u, 0u);\n            \
}\n          `);\n        }\n        return [`${output} = uvec4(0u, 0u, 0u, \
0u);`];\n      }\n    });\n  }\n  dynoOut() {\n    return new \
DynoOutput(this, \"output\");\n  }\n}\nclass OutputRgba8 extends Dyno {\n  \
constructor({ rgba8 }) {\n    super({\n      inTypes: { rgba8: \"vec4\" },\n  \
    inputs: { rgba8 },\n      statements: ({ inputs, outputs }) => [\n        \
`target = ${inputs.rgba8 ?? \"vec4(0.0, 0.0, 0.0, 0.0)\"};`\n      ]\n    \
});\n  }\n  dynoOut() {\n    return new DynoOutput(this, \"rgba8\");\n  \
}\n}\nconst uniform = (key, type, value) => new DynoUniform({ key, type, \
value });\nconst dynoBool = (value = false, key) => new DynoBool({ key, value \
});\nconst dynoUint = (value = 0, key) => new DynoUint({ key, value \
});\nconst dynoInt = (value = 0, key) => new DynoInt({ key, value });\nconst \
dynoFloat = (value = 0, key) => new DynoFloat({ key, value });\nconst \
dynoBvec2 = (value, key) => new DynoBvec2({ key, value });\nconst dynoUvec2 = \
(value, key) => new DynoUvec2({ key, value });\nconst dynoIvec2 = (value, \
key) => new DynoIvec2({ key, value });\nconst dynoVec2 = (value, key) => new \
DynoVec2({ key, value });\nconst dynoBvec3 = (value, key) => new DynoBvec3({ \
key, value });\nconst dynoUvec3 = (value, key) => new DynoUvec3({ key, value \
});\nconst dynoIvec3 = (value, key) => new DynoIvec3({ key, value });\nconst \
dynoVec3 = (value, key) => new DynoVec3({ key, value });\nconst dynoBvec4 = \
(value, key) => new DynoBvec4({ key, value });\nconst dynoUvec4 = (value, \
key) => new DynoUvec4({ key, value });\nconst dynoIvec4 = (value, key) => new \
DynoIvec4({ key, value });\nconst dynoVec4 = (value, key) => new DynoVec4({ \
key, value });\nconst dynoMat2 = (value, key) => new DynoMat2({ key, value \
});\nconst dynoMat2x2 = (value, key) => new DynoMat2x2({ key, value \
});\nconst dynoMat2x3 = (value, key) => new DynoMat2x3({ key, value \
});\nconst dynoMat2x4 = (value, key) => new DynoMat2x4({ key, value \
});\nconst dynoMat3 = (value, key) => new DynoMat3({ key, value });\nconst \
dynoMat3x2 = (value, key) => new DynoMat3x2({ key, value });\nconst \
dynoMat3x3 = (value, key) => new DynoMat3x3({ key, value });\nconst \
dynoMat3x4 = (value, key) => new DynoMat3x4({ key, value });\nconst dynoMat4 \
= (value, key) => new DynoMat4({ key, value });\nconst dynoMat4x2 = (value, \
key) => new DynoMat4x2({ key, value });\nconst dynoMat4x3 = (value, key) => \
new DynoMat4x3({ key, value });\nconst dynoMat4x4 = (value, key) => new \
DynoMat4x4({ key, value });\nconst dynoUsampler2D = (value, key) => new \
DynoUsampler2D({ key, value });\nconst dynoIsampler2D = (value, key) => new \
DynoIsampler2D({ key, value });\nconst dynoSampler2D = (value, key) => new \
DynoSampler2D({ key, value });\nconst dynoUsampler2DArray = (value, key) => \
new DynoUsampler2DArray({ key, value });\nconst dynoIsampler2DArray = (key, \
value) => new DynoIsampler2DArray({ key, value });\nconst dynoSampler2DArray \
= (value, key) => new DynoSampler2DArray({ key, value });\nconst \
dynoUsampler3D = (value, key) => new DynoUsampler3D({ key, value });\nconst \
dynoIsampler3D = (value, key) => new DynoIsampler3D({ key, value });\nconst \
dynoSampler3D = (value, key) => new DynoSampler3D({ key, value });\nconst \
dynoUsamplerCube = (value, key) => new DynoUsamplerCube({ key, value \
});\nconst dynoIsamplerCube = (value, key) => new DynoIsamplerCube({ key, \
value });\nconst dynoSamplerCube = (value, key) => new DynoSamplerCube({ key, \
value });\nconst dynoSampler2DShadow = (value, key) => new \
DynoSampler2DShadow({ key, value });\nconst dynoSampler2DArrayShadow = \
(value, key) => new DynoSampler2DArrayShadow({ key, value });\nconst \
dynoSamplerCubeShadow = (value, key) => new DynoSamplerCubeShadow({ key, \
value });\nclass DynoUniform extends Dyno {\n  constructor({\n    key,\n    \
type,\n    count,\n    value,\n    update,\n    globals\n  }) {\n    key = \
key ?? \"value\";\n    super({\n      outTypes: { [key]: type },\n      \
update: () => {\n        if (update) {\n          const value2 = \
update(this.value);\n          if (value2 !== void 0) {\n            \
this.value = value2;\n          }\n        }\n        this.uniform.value = \
this.value;\n      },\n      generate: ({ inputs, outputs }) => {\n        \
const allGlobals = (globals == null ? void 0 : globals({ inputs, outputs })) \
?? [];\n        const uniforms = {};\n        const name = outputs[key];\n    \
    if (name) {\n          allGlobals.push(`uniform ${dynoDeclare(name, type, \
count)};`);\n          uniforms[name] = this.uniform;\n        }\n        \
return { globals: allGlobals, uniforms };\n      }\n    });\n    this.type = \
type;\n    this.count = count;\n    this.value = value;\n    this.uniform = { \
value };\n    this.outKey = key;\n  }\n  dynoOut() {\n    return new \
DynoOutput(this, this.outKey);\n  }\n}\nclass DynoBool extends DynoUniform \
{\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ \
key, type: \"bool\", value, update });\n  }\n}\nclass DynoUint extends \
DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    \
super({ key, type: \"uint\", value, update });\n  }\n}\nclass DynoInt extends \
DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    \
super({ key, type: \"int\", value, update });\n  }\n}\nclass DynoFloat \
extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  \
}) {\n    super({ key, type: \"float\", value, update });\n  }\n}\nclass \
DynoBvec2 extends DynoUniform {\n  constructor({\n    key,\n    value,\n    \
update\n  }) {\n    super({ key, type: \"bvec2\", value, update });\n  \
}\n}\nclass DynoUvec2 extends DynoUniform {\n  constructor({\n    key,\n    \
value,\n    update\n  }) {\n    super({ key, type: \"uvec2\", value, update \
});\n  }\n}\nclass DynoIvec2 extends DynoUniform {\n  constructor({\n    \
key,\n    value,\n    update\n  }) {\n    super({ key, type: \"ivec2\", \
value, update });\n  }\n}\nclass DynoVec2 extends DynoUniform {\n  \
constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, \
type: \"vec2\", value, update });\n  }\n}\nclass DynoBvec3 extends \
DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    \
super({ key, type: \"bvec3\", value, update });\n  }\n}\nclass DynoUvec3 \
extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  \
}) {\n    super({ key, type: \"uvec3\", value, update });\n  }\n}\nclass \
DynoIvec3 extends DynoUniform {\n  constructor({\n    key,\n    value,\n    \
update\n  }) {\n    super({ key, type: \"ivec3\", value, update });\n  \
}\n}\nclass DynoVec3 extends DynoUniform {\n  constructor({\n    key,\n    \
value,\n    update\n  }) {\n    super({ key, type: \"vec3\", value, update \
});\n  }\n}\nclass DynoBvec4 extends DynoUniform {\n  constructor({\n    \
key,\n    value,\n    update\n  }) {\n    super({ key, type: \"bvec4\", \
value, update });\n  }\n}\nclass DynoUvec4 extends DynoUniform {\n  \
constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, \
type: \"uvec4\", value, update });\n  }\n}\nclass DynoIvec4 extends \
DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    \
super({ key, type: \"ivec4\", value, update });\n  }\n}\nclass DynoVec4 \
extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  \
}) {\n    super({ key, type: \"vec4\", value, update });\n  }\n}\nclass \
DynoMat2 extends DynoUniform {\n  constructor({\n    key,\n    value,\n    \
update\n  }) {\n    super({ key, type: \"mat2\", value, update });\n  \
}\n}\nclass DynoMat2x2 extends DynoUniform {\n  constructor({\n    key,\n    \
value,\n    update\n  }) {\n    super({ key, type: \"mat2x2\", value, update \
});\n  }\n}\nclass DynoMat2x3 extends DynoUniform {\n  constructor({\n    \
key,\n    value,\n    update\n  }) {\n    super({ key, type: \"mat2x3\", \
value, update });\n  }\n}\nclass DynoMat2x4 extends DynoUniform {\n  \
constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, \
type: \"mat2x4\", value, update });\n  }\n}\nclass DynoMat3 extends \
DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    \
super({ key, type: \"mat3\", value, update });\n  }\n}\nclass DynoMat3x2 \
extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  \
}) {\n    super({ key, type: \"mat3x2\", value, update });\n  }\n}\nclass \
DynoMat3x3 extends DynoUniform {\n  constructor({\n    key,\n    value,\n    \
update\n  }) {\n    super({ key, type: \"mat3x3\", value, update });\n  \
}\n}\nclass DynoMat3x4 extends DynoUniform {\n  constructor({\n    key,\n    \
value,\n    update\n  }) {\n    super({ key, type: \"mat3x4\", value, update \
});\n  }\n}\nclass DynoMat4 extends DynoUniform {\n  constructor({\n    \
key,\n    value,\n    update\n  }) {\n    super({ key, type: \"mat4\", value, \
update });\n  }\n}\nclass DynoMat4x2 extends DynoUniform {\n  constructor({\n \
   key,\n    value,\n    update\n  }) {\n    super({ key, type: \"mat4x2\", \
value, update });\n  }\n}\nclass DynoMat4x3 extends DynoUniform {\n  \
constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, \
type: \"mat4x3\", value, update });\n  }\n}\nclass DynoMat4x4 extends \
DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    \
super({ key, type: \"mat4x4\", value, update });\n  }\n}\nclass \
DynoUsampler2D extends DynoUniform {\n  constructor({\n    key,\n    value,\n \
   update\n  }) {\n    super({ key, type: \"usampler2D\", value, update });\n \
 }\n}\nclass DynoIsampler2D extends DynoUniform {\n  constructor({\n    \
key,\n    value,\n    update\n  }) {\n    super({ key, type: \"isampler2D\", \
value, update });\n  }\n}\nclass DynoSampler2D extends DynoUniform {\n  \
constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, \
type: \"sampler2D\", value, update });\n  }\n}\nclass DynoUsampler2DArray \
extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  \
}) {\n    super({ key, type: \"usampler2DArray\", value, update });\n  \
}\n}\nclass DynoIsampler2DArray extends DynoUniform {\n  constructor({\n    \
key,\n    value,\n    update\n  }) {\n    super({ key, type: \
\"isampler2DArray\", value, update });\n  }\n}\nclass DynoSampler2DArray \
extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  \
}) {\n    super({ key, type: \"sampler2DArray\", value, update });\n  \
}\n}\nclass DynoUsampler3D extends DynoUniform {\n  constructor({\n    key,\n \
   value,\n    update\n  }) {\n    super({ key, type: \"usampler3D\", value, \
update });\n  }\n}\nclass DynoIsampler3D extends DynoUniform {\n  \
constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, \
type: \"isampler3D\", value, update });\n  }\n}\nclass DynoSampler3D extends \
DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    \
super({ key, type: \"sampler3D\", value, update });\n  }\n}\nclass \
DynoUsamplerCube extends DynoUniform {\n  constructor({\n    key,\n    \
value,\n    update\n  }) {\n    super({ key, type: \"usamplerCube\", value, \
update });\n  }\n}\nclass DynoIsamplerCube extends DynoUniform {\n  \
constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, \
type: \"isamplerCube\", value, update });\n  }\n}\nclass DynoSamplerCube \
extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  \
}) {\n    super({ key, type: \"samplerCube\", value, update });\n  \
}\n}\nclass DynoSampler2DShadow extends DynoUniform {\n  constructor({\n    \
key,\n    value,\n    update\n  }) {\n    super({ key, type: \
\"sampler2DShadow\", value, update });\n  }\n}\nclass \
DynoSampler2DArrayShadow extends DynoUniform {\n  constructor({\n    key,\n   \
 value,\n    update\n  }) {\n    super({ key, type: \"sampler2DArrayShadow\", \
value, update });\n  }\n}\nclass DynoSamplerCubeShadow extends DynoUniform \
{\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ \
key, type: \"samplerCubeShadow\", value, update });\n  }\n}\nconst f32buffer \
= new Float32Array(1);\nconst u32buffer = new \
Uint32Array(f32buffer.buffer);\nconst supportsFloat16Array = \"Float16Array\" \
in globalThis;\nconst f16buffer = supportsFloat16Array ? new \
globalThis[\"Float16Array\"](1) : null;\nconst u16buffer = new \
Uint16Array(f16buffer == null ? void 0 : f16buffer.buffer);\nfunction \
normalize$1(vec) {\n  const norm = Math.sqrt(vec.reduce((acc, v) => acc + v * \
v, 0));\n  return vec.map((v) => v / norm);\n}\nfunction floatBitsToUint$1(f) \
{\n  f32buffer[0] = f;\n  return u32buffer[0];\n}\nfunction \
uintBitsToFloat$1(u) {\n  u32buffer[0] = u;\n  return f32buffer[0];\n}\nconst \
toHalf = supportsFloat16Array ? toHalfNative : toHalfJS;\nconst fromHalf = \
supportsFloat16Array ? fromHalfNative : fromHalfJS;\nfunction toHalfNative(f) \
{\n  f16buffer[0] = f;\n  return u16buffer[0];\n}\nfunction toHalfJS(f) {\n  \
f32buffer[0] = f;\n  const bits2 = u32buffer[0];\n  const sign2 = bits2 >> 31 \
& 1;\n  const exp3 = bits2 >> 23 & 255;\n  const frac = bits2 & 8388607;\n  \
const halfSign = sign2 << 15;\n  if (exp3 === 255) {\n    if (frac !== 0) {\n \
     return halfSign | 32767;\n    }\n    return halfSign | 31744;\n  }\n  \
const newExp = exp3 - 127 + 15;\n  if (newExp >= 31) {\n    return halfSign | \
31744;\n  }\n  if (newExp <= 0) {\n    if (newExp < -10) {\n      return \
halfSign;\n    }\n    const subFrac = (frac | 8388608) >> 1 - newExp + 13;\n  \
  return halfSign | subFrac;\n  }\n  const halfFrac = frac >> 13;\n  return \
halfSign | newExp << 10 | halfFrac;\n}\nfunction fromHalfNative(u) {\n  \
u16buffer[0] = u;\n  return f16buffer[0];\n}\nfunction fromHalfJS(h) {\n  \
const sign2 = h >> 15 & 1;\n  const exp3 = h >> 10 & 31;\n  const frac = h & \
1023;\n  let f32bits;\n  if (exp3 === 0) {\n    if (frac === 0) {\n      \
f32bits = sign2 << 31;\n    } else {\n      let mant = frac;\n      let e = \
-14;\n      while ((mant & 1024) === 0) {\n        mant <<= 1;\n        \
e--;\n      }\n      mant &= 1023;\n      const newExp = e + 127;\n      \
const newFrac = mant << 13;\n      f32bits = sign2 << 31 | newExp << 23 | \
newFrac;\n    }\n  } else if (exp3 === 31) {\n    if (frac === 0) {\n      \
f32bits = sign2 << 31 | 2139095040;\n    } else {\n      f32bits = sign2 << \
31 | 2143289344;\n    }\n  } else {\n    const newExp = exp3 - 15 + 127;\n    \
const newFrac = frac << 13;\n    f32bits = sign2 << 31 | newExp << 23 | \
newFrac;\n  }\n  u32buffer[0] = f32bits;\n  return f32buffer[0];\n}\nfunction \
floatToUint8(v) {\n  return Math.max(0, Math.min(255, Math.round(v * \
255)));\n}\nfunction floatToSint8(v) {\n  return Math.max(-127, Math.min(127, \
Math.round(v * 127)));\n}\nfunction Uint8ToFloat(v) {\n  return v / \
255;\n}\nfunction Sint8ToFloat(v) {\n  return v / 127;\n}\nclass DataCache \
{\n  // Create a DataCache with a given function that fetches data not in the \
cache.\n  constructor({\n    asyncFetch,\n    maxItems = 5\n  }) {\n    \
this.asyncFetch = asyncFetch;\n    this.maxItems = maxItems;\n    this.items \
= [];\n  }\n  // Fetch data for the key, returning cached data if \
available.\n  async getFetch(key) {\n    const index = \
this.items.findIndex((item) => item.key === key);\n    if (index >= 0) {\n    \
  const item = this.items.splice(index, 1)[0];\n      \
this.items.push(item);\n      return item.data;\n    }\n    const data = \
await this.asyncFetch(key);\n    this.items.push({ key, data });\n    while \
(this.items.length > this.maxItems) {\n      this.items.shift();\n    }\n    \
return data;\n  }\n}\nfunction mapObject(obj, fn) {\n  const entries = \
Object.entries(obj).map(([key, value]) => [\n    key,\n    fn(value, key)\n  \
]);\n  return Object.fromEntries(entries);\n}\nfunction mapFilterObject(obj, \
fn) {\n  const entries = Object.entries(obj).map(([key, value]) => [key, \
fn(value, key)]).filter(([_, value]) => value !== void 0);\n  return \
Object.fromEntries(entries);\n}\nfunction getArrayBuffers(ctx) {\n  const \
buffers = [];\n  const seen = /* @__PURE__ */ new Set();\n  function \
traverse(obj) {\n    if (obj && typeof obj === \"object\" && !seen.has(obj)) \
{\n      seen.add(obj);\n      if (obj instanceof ArrayBuffer) {\n        \
buffers.push(obj);\n      } else if (ArrayBuffer.isView(obj)) {\n        \
buffers.push(obj.buffer);\n      } else if (Array.isArray(obj)) {\n        \
obj.forEach(traverse);\n      } else {\n        \
Object.values(obj).forEach(traverse);\n      }\n    }\n  }\n  \
traverse(ctx);\n  return buffers;\n}\nfunction newArray(n, initFunction) {\n  \
return new Array(n).fill(null).map((_, i) => initFunction(i));\n}\nclass \
FreeList {\n  constructor({\n    // Allocate a new item with the given args\n \
   allocate,\n    // Dispose of an item (optional, if GC is enough)\n    \
dispose,\n    // Check if an existing item in the list is valid for the given \
args,\n    // allowing you to store heterogeneous items in the list.\n    \
valid\n  }) {\n    this.items = [];\n    this.allocate = allocate;\n    \
this.dispose = dispose;\n    this.valid = valid;\n  }\n  // Allocate a new \
item from the free list, first checking if a existing item\n  // on the \
freelist is valid for the given args.\n  alloc(args) {\n    while (true) {\n  \
    const item = this.items.pop();\n      if (!item) {\n        break;\n      \
}\n      if (this.valid(item, args)) {\n        return item;\n      }\n      \
if (this.dispose) {\n        this.dispose(item);\n      }\n    }\n    return \
this.allocate(args);\n  }\n  free(item) {\n    this.items.push(item);\n  }\n  \
disposeAll() {\n    let item;\n    item = this.items.pop();\n    while (item) \
{\n      if (this.dispose) {\n        this.dispose(item);\n      }\n      \
item = this.items.pop();\n    }\n  }\n}\nfunction \
setPackedSplat(packedSplats, index, x, y, z, scaleX, scaleY, scaleZ, quatX, \
quatY, quatZ, quatW, opacity, r, g, b, encoding) {\n  const rgbMin = \
(encoding == null ? void 0 : encoding.rgbMin) ?? 0;\n  const rgbMax = \
(encoding == null ? void 0 : encoding.rgbMax) ?? 1;\n  const rgbRange = \
rgbMax - rgbMin;\n  const uR = floatToUint8((r - rgbMin) / rgbRange);\n  \
const uG = floatToUint8((g - rgbMin) / rgbRange);\n  const uB = \
floatToUint8((b - rgbMin) / rgbRange);\n  const uA = floatToUint8(opacity);\n \
 const uQuat = encodeQuatOctXy88R8(\n    tempQuaternion.set(quatX, quatY, \
quatZ, quatW)\n  );\n  const uQuatX = uQuat & 255;\n  const uQuatY = uQuat \
>>> 8 & 255;\n  const uQuatZ = uQuat >>> 16 & 255;\n  const lnScaleMin = \
(encoding == null ? void 0 : encoding.lnScaleMin) ?? LN_SCALE_MIN;\n  const \
lnScaleMax = (encoding == null ? void 0 : encoding.lnScaleMax) ?? \
LN_SCALE_MAX;\n  const lnScaleScale = 254 / (lnScaleMax - lnScaleMin);\n  \
const uScaleX = scaleX < SCALE_ZERO ? 0 : Math.min(\n    255,\n    \
Math.max(\n      1,\n      Math.round((Math.log(scaleX) - lnScaleMin) * \
lnScaleScale) + 1\n    )\n  );\n  const uScaleY = scaleY < SCALE_ZERO ? 0 : \
Math.min(\n    255,\n    Math.max(\n      1,\n      \
Math.round((Math.log(scaleY) - lnScaleMin) * lnScaleScale) + 1\n    )\n  );\n \
 const uScaleZ = scaleZ < SCALE_ZERO ? 0 : Math.min(\n    255,\n    \
Math.max(\n      1,\n      Math.round((Math.log(scaleZ) - lnScaleMin) * \
lnScaleScale) + 1\n    )\n  );\n  const uCenterX = toHalf(x);\n  const \
uCenterY = toHalf(y);\n  const uCenterZ = toHalf(z);\n  const i4 = index * \
4;\n  packedSplats[i4] = uR | uG << 8 | uB << 16 | uA << 24;\n  \
packedSplats[i4 + 1] = uCenterX | uCenterY << 16;\n  packedSplats[i4 + 2] = \
uCenterZ | uQuatX << 16 | uQuatY << 24;\n  packedSplats[i4 + 3] = uScaleX | \
uScaleY << 8 | uScaleZ << 16 | uQuatZ << 24;\n}\nfunction \
setPackedSplatCenter(packedSplats, index, x, y, z) {\n  const uCenterX = \
toHalf(x);\n  const uCenterY = toHalf(y);\n  const uCenterZ = toHalf(z);\n  \
const i4 = index * 4;\n  packedSplats[i4 + 1] = uCenterX | uCenterY << 16;\n  \
packedSplats[i4 + 2] = uCenterZ | packedSplats[i4 + 2] & \
4294901760;\n}\nfunction setPackedSplatScales(packedSplats, index, scaleX, \
scaleY, scaleZ, encoding) {\n  const lnScaleMin = (encoding == null ? void 0 \
: encoding.lnScaleMin) ?? LN_SCALE_MIN;\n  const lnScaleMax = (encoding == \
null ? void 0 : encoding.lnScaleMax) ?? LN_SCALE_MAX;\n  const lnScaleScale = \
254 / (lnScaleMax - lnScaleMin);\n  const uScaleX = scaleX < SCALE_ZERO ? 0 : \
Math.min(\n    255,\n    Math.max(\n      1,\n      \
Math.round((Math.log(scaleX) - lnScaleMin) * lnScaleScale) + 1\n    )\n  );\n \
 const uScaleY = scaleY < SCALE_ZERO ? 0 : Math.min(\n    255,\n    \
Math.max(\n      1,\n      Math.round((Math.log(scaleY) - lnScaleMin) * \
lnScaleScale) + 1\n    )\n  );\n  const uScaleZ = scaleZ < SCALE_ZERO ? 0 : \
Math.min(\n    255,\n    Math.max(\n      1,\n      \
Math.round((Math.log(scaleZ) - lnScaleMin) * lnScaleScale) + 1\n    )\n  );\n \
 const i4 = index * 4;\n  packedSplats[i4 + 3] = uScaleX | uScaleY << 8 | \
uScaleZ << 16 | packedSplats[i4 + 3] & 4278190080;\n}\nconst tempQuaternion = \
new THREE.Quaternion();\nfunction setPackedSplatQuat(packedSplats, index, \
quatX, quatY, quatZ, quatW) {\n  const uQuat = encodeQuatOctXy88R8(\n    \
tempQuaternion.set(quatX, quatY, quatZ, quatW)\n  );\n  const uQuatX = uQuat \
& 255;\n  const uQuatY = uQuat >>> 8 & 255;\n  const uQuatZ = uQuat >>> 16 & \
255;\n  const i4 = index * 4;\n  packedSplats[i4 + 2] = packedSplats[i4 + 2] \
& 65535 | uQuatX << 16 | uQuatY << 24;\n  packedSplats[i4 + 3] = \
packedSplats[i4 + 3] & 16777215 | uQuatZ << 24;\n}\nfunction \
setPackedSplatRgba(packedSplats, index, r, g, b, a, encoding) {\n  const \
rgbMin = (encoding == null ? void 0 : encoding.rgbMin) ?? 0;\n  const rgbMax \
= (encoding == null ? void 0 : encoding.rgbMax) ?? 1;\n  const rgbRange = \
rgbMax - rgbMin;\n  const uR = floatToUint8((r - rgbMin) / rgbRange);\n  \
const uG = floatToUint8((g - rgbMin) / rgbRange);\n  const uB = \
floatToUint8((b - rgbMin) / rgbRange);\n  const uA = floatToUint8(a);\n  \
const i4 = index * 4;\n  packedSplats[i4] = uR | uG << 8 | uB << 16 | uA << \
24;\n}\nfunction setPackedSplatRgb(packedSplats, index, r, g, b, encoding) \
{\n  const rgbMin = (encoding == null ? void 0 : encoding.rgbMin) ?? 0;\n  \
const rgbMax = (encoding == null ? void 0 : encoding.rgbMax) ?? 1;\n  const \
rgbRange = rgbMax - rgbMin;\n  const uR = floatToUint8((r - rgbMin) / \
rgbRange);\n  const uG = floatToUint8((g - rgbMin) / rgbRange);\n  const uB = \
floatToUint8((b - rgbMin) / rgbRange);\n  const i4 = index * 4;\n  \
packedSplats[i4] = uR | uG << 8 | uB << 16 | packedSplats[i4] & \
4278190080;\n}\nfunction setPackedSplatOpacity(packedSplats, index, opacity) \
{\n  const uA = floatToUint8(opacity);\n  const i4 = index * 4;\n  \
packedSplats[i4] = packedSplats[i4] & 16777215 | uA << 24;\n}\nconst \
packedCenter = new THREE.Vector3();\nconst packedScales = new \
THREE.Vector3();\nconst packedQuaternion = new THREE.Quaternion();\nconst \
packedColor = new THREE.Color();\nconst packedFields = {\n  center: \
packedCenter,\n  scales: packedScales,\n  quaternion: packedQuaternion,\n  \
color: packedColor,\n  opacity: 0\n};\nfunction unpackSplat(packedSplats, \
index, encoding) {\n  const result = packedFields;\n  const i4 = index * 4;\n \
 const word0 = packedSplats[i4];\n  const word1 = packedSplats[i4 + 1];\n  \
const word2 = packedSplats[i4 + 2];\n  const word3 = packedSplats[i4 + 3];\n  \
const rgbMin = (encoding == null ? void 0 : encoding.rgbMin) ?? 0;\n  const \
rgbMax = (encoding == null ? void 0 : encoding.rgbMax) ?? 1;\n  const \
rgbRange = rgbMax - rgbMin;\n  result.color.set(\n    rgbMin + (word0 & 255) \
/ 255 * rgbRange,\n    rgbMin + (word0 >>> 8 & 255) / 255 * rgbRange,\n    \
rgbMin + (word0 >>> 16 & 255) / 255 * rgbRange\n  );\n  result.opacity = \
(word0 >>> 24 & 255) / 255;\n  result.center.set(\n    fromHalf(word1 & \
65535),\n    fromHalf(word1 >>> 16 & 65535),\n    fromHalf(word2 & 65535)\n  \
);\n  const lnScaleMin = (encoding == null ? void 0 : encoding.lnScaleMin) ?? \
LN_SCALE_MIN;\n  const lnScaleMax = (encoding == null ? void 0 : \
encoding.lnScaleMax) ?? LN_SCALE_MAX;\n  const lnScaleScale = (lnScaleMax - \
lnScaleMin) / 254;\n  const uScalesX = word3 & 255;\n  result.scales.x = \
uScalesX === 0 ? 0 : Math.exp(lnScaleMin + (uScalesX - 1) * lnScaleScale);\n  \
const uScalesY = word3 >>> 8 & 255;\n  result.scales.y = uScalesY === 0 ? 0 : \
Math.exp(lnScaleMin + (uScalesY - 1) * lnScaleScale);\n  const uScalesZ = \
word3 >>> 16 & 255;\n  result.scales.z = uScalesZ === 0 ? 0 : \
Math.exp(lnScaleMin + (uScalesZ - 1) * lnScaleScale);\n  const uQuat = word2 \
>>> 16 & 65535 | word3 >>> 8 & 16711680;\n  decodeQuatOctXy88R8(uQuat, \
result.quaternion);\n  return result;\n}\nfunction getTextureSize(numSplats) \
{\n  const width = SPLAT_TEX_WIDTH;\n  const height = Math.max(\n    \
SPLAT_TEX_MIN_HEIGHT,\n    Math.min(SPLAT_TEX_HEIGHT, Math.ceil(numSplats / \
width))\n  );\n  const depth = Math.ceil(numSplats / (width * height));\n  \
const maxSplats = width * height * depth;\n  return { width, height, depth, \
maxSplats };\n}\nfunction computeMaxSplats(numSplats) {\n  const width = \
SPLAT_TEX_WIDTH;\n  const height = Math.max(\n    SPLAT_TEX_MIN_HEIGHT,\n    \
Math.min(SPLAT_TEX_HEIGHT, Math.ceil(numSplats / width))\n  );\n  const depth \
= Math.ceil(numSplats / (width * height));\n  return width * height * \
depth;\n}\nfunction isMobile() {\n  if (navigator.maxTouchPoints > 0) {\n    \
return true;\n  }\n  return /Mobi|Android|iPhone|iPad|iPod|Opera \
Mini|IEMobile/.test(\n    navigator.userAgent\n  );\n}\nfunction isAndroid() \
{\n  return /Android/.test(navigator.userAgent);\n}\nfunction isOculus() {\n  \
return /Oculus/.test(navigator.userAgent);\n}\nfunction flipPixels(pixels, \
width, height) {\n  const tempLine = new Uint8Array(width * 4);\n  for (let y \
= 0; y < height / 2; y++) {\n    const topOffset = y * width * 4;\n    const \
bottomOffset = (height - 1 - y) * width * 4;\n    \
tempLine.set(pixels.subarray(topOffset, topOffset + width * 4));\n    \
pixels.set(\n      pixels.subarray(bottomOffset, bottomOffset + width * 4),\n \
     topOffset\n    );\n    pixels.set(tempLine, bottomOffset);\n  }\n  \
return pixels;\n}\nfunction pixelsToPngUrl(pixels, width, height) {\n  const \
canvas = document.createElement(\"canvas\");\n  canvas.width = width;\n  \
canvas.height = height;\n  const ctx = canvas.getContext(\"2d\");\n  if \
(!ctx) {\n    throw new Error(\"Can't get 2d context\");\n  }\n  const \
imageData = ctx.createImageData(width, height);\n  \
imageData.data.set(pixels);\n  ctx.putImageData(imageData, 0, 0);\n  return \
canvas.toDataURL(\"image/png\");\n}\nfunction cloneClock(clock) {\n  const \
newClock = new THREE.Clock(clock.autoStart);\n  newClock.startTime = \
clock.startTime;\n  newClock.oldTime = clock.oldTime;\n  newClock.elapsedTime \
= clock.elapsedTime;\n  newClock.running = clock.running;\n  return \
newClock;\n}\nfunction omitUndefined(obj) {\n  return Object.fromEntries(\n   \
 Object.entries(obj).filter(([_, value]) => value !== void 0)\n  );\n}\nconst \
IDENT_VERTEX_SHADER = unindent(`\n  precision highp float;\n\n  in vec3 \
position;\n\n  void main() {\n    gl_Position = vec4(position.xy, 0.0, \
1.0);\n  }\n`);\nfunction averagePositions(positions) {\n  const sum = new \
THREE.Vector3();\n  for (const position of positions) {\n    \
sum.add(position);\n  }\n  return \
sum.divideScalar(positions.length);\n}\nfunction \
averageQuaternions(quaternions) {\n  if (quaternions.length === 0) {\n    \
return new THREE.Quaternion();\n  }\n  const sum = quaternions[0].clone();\n  \
for (let i = 1; i < quaternions.length; i++) {\n    if \
(quaternions[i].dot(quaternions[0]) < 0) {\n      sum.x -= \
quaternions[i].x;\n      sum.y -= quaternions[i].y;\n      sum.z -= \
quaternions[i].z;\n      sum.w -= quaternions[i].w;\n    } else {\n      \
sum.x += quaternions[i].x;\n      sum.y += quaternions[i].y;\n      sum.z += \
quaternions[i].z;\n      sum.w += quaternions[i].w;\n    }\n  }\n  return \
sum.normalize();\n}\nfunction coinciDist(matrix1, matrix2) {\n  const origin1 \
= new THREE.Vector3(0, 0, 0).applyMatrix4(matrix1);\n  const origin2 = new \
THREE.Vector3(0, 0, 0).applyMatrix4(matrix2);\n  const direction1 = new \
THREE.Vector3(0, 0, -1).applyMatrix4(matrix1).sub(origin1).normalize();\n  \
const direction2 = new THREE.Vector3(0, 0, \
-1).applyMatrix4(matrix2).sub(origin2).normalize();\n  const distance2 = \
origin1.distanceTo(origin2);\n  const coincidence = \
direction1.dot(direction2);\n  return { distance: distance2, coincidence \
};\n}\nfunction withinDist({\n  matrix1,\n  matrix2,\n  maxDistance\n}) {\n  \
const origin1 = new THREE.Vector3(0, 0, 0).applyMatrix4(matrix1);\n  const \
origin2 = new THREE.Vector3(0, 0, 0).applyMatrix4(matrix2);\n  return \
origin1.distanceTo(origin2) <= maxDistance;\n}\nfunction withinCoinciDist({\n \
 matrix1,\n  matrix2,\n  maxDistance,\n  minCoincidence\n}) {\n  const { \
distance: distance2, coincidence } = coinciDist(matrix1, matrix2);\n  return \
distance2 <= maxDistance && (minCoincidence == null || coincidence >= \
minCoincidence);\n}\nfunction coorientDist(matrix1, matrix2) {\n  const \
[origin1, rotate1] = [new THREE.Vector3(), new THREE.Quaternion()];\n  const \
[origin2, rotate2] = [new THREE.Vector3(), new THREE.Quaternion()];\n  \
matrix1.decompose(origin1, rotate1, new THREE.Vector3());\n  \
matrix2.decompose(origin2, rotate2, new THREE.Vector3());\n  const distance2 \
= origin1.distanceTo(origin2);\n  const coorient = \
Math.abs(rotate1.dot(rotate2));\n  return { distance: distance2, coorient \
};\n}\nfunction withinCoorientDist({\n  matrix1,\n  matrix2,\n  \
maxDistance,\n  minCoorient\n}) {\n  const { distance: distance2, coorient } \
= coorientDist(matrix1, matrix2);\n  return distance2 <= maxDistance && \
(minCoorient == null || coorient >= minCoorient);\n}\nfunction \
epsilonSign(value, epsilon = 1e-3) {\n  if (Math.abs(value) < epsilon) {\n    \
return 0;\n  }\n  return Math.sign(value);\n}\nfunction encodeQuatXyz888(q) \
{\n  const negQuat = q.w < 0;\n  const iQuatX = floatToSint8(negQuat ? -q.x : \
q.x);\n  const iQuatY = floatToSint8(negQuat ? -q.y : q.y);\n  const iQuatZ = \
floatToSint8(negQuat ? -q.z : q.z);\n  const uQuatX = iQuatX & 255;\n  const \
uQuatY = iQuatY & 255;\n  const uQuatZ = iQuatZ & 255;\n  return uQuatX | \
uQuatY << 8 | uQuatZ << 16;\n}\nfunction decodeQuatXyz888(encoded, out) {\n  \
const iQuatX = encoded << 24 >> 24;\n  const iQuatY = encoded << 16 >> 24;\n  \
const iQuatZ = encoded << 8 >> 24;\n  out.set(iQuatX / 127, iQuatY / 127, \
iQuatZ / 127, 0);\n  const dotSelf = out.x * out.x + out.y * out.y + out.z * \
out.z;\n  out.w = Math.sqrt(Math.max(0, 1 - dotSelf));\n  return \
out;\n}\nconst tempNormalizedQuaternion = new THREE.Quaternion();\nconst \
tempAxis = new THREE.Vector3();\nfunction encodeQuatOctXy88R8(q) {\n  const \
qnorm = tempNormalizedQuaternion.copy(q).normalize();\n  if (qnorm.w < 0) {\n \
   qnorm.set(-qnorm.x, -qnorm.y, -qnorm.z, -qnorm.w);\n  }\n  const theta = 2 \
* Math.acos(qnorm.w);\n  const xyz_norm = Math.sqrt(\n    qnorm.x * qnorm.x + \
qnorm.y * qnorm.y + qnorm.z * qnorm.z\n  );\n  const axis = xyz_norm < 1e-6 ? \
tempAxis.set(1, 0, 0) : tempAxis.set(qnorm.x, qnorm.y, \
qnorm.z).divideScalar(xyz_norm);\n  const sum = Math.abs(axis.x) + \
Math.abs(axis.y) + Math.abs(axis.z);\n  let p_x = axis.x / sum;\n  let p_y = \
axis.y / sum;\n  if (axis.z < 0) {\n    const tmp = p_x;\n    p_x = (1 - \
Math.abs(p_y)) * (p_x >= 0 ? 1 : -1);\n    p_y = (1 - Math.abs(tmp)) * (p_y \
>= 0 ? 1 : -1);\n  }\n  const u_f = p_x * 0.5 + 0.5;\n  const v_f = p_y * 0.5 \
+ 0.5;\n  const quantU = Math.round(u_f * 255);\n  const quantV = \
Math.round(v_f * 255);\n  const angleInt = Math.round(theta * (255 / \
Math.PI));\n  return angleInt << 16 | quantV << 8 | quantU;\n}\nfunction \
decodeQuatOctXy88R8(encoded, out) {\n  const quantU = encoded & 255;\n  const \
quantV = encoded >>> 8 & 255;\n  const angleInt = encoded >>> 16 & 255;\n  \
const u_f = quantU / 255;\n  const v_f = quantV / 255;\n  let f_x = (u_f - \
0.5) * 2;\n  let f_y = (v_f - 0.5) * 2;\n  const f_z = 1 - (Math.abs(f_x) + \
Math.abs(f_y));\n  const t = Math.max(-f_z, 0);\n  f_x += f_x >= 0 ? -t : \
t;\n  f_y += f_y >= 0 ? -t : t;\n  const axis = tempAxis.set(f_x, f_y, \
f_z).normalize();\n  const theta = angleInt / 255 * Math.PI;\n  const \
halfTheta = theta * 0.5;\n  const s = Math.sin(halfTheta);\n  const w = \
Math.cos(halfTheta);\n  out.set(axis.x * s, axis.y * s, axis.z * s, w);\n  \
return out;\n}\nfunction encodeQuatEulerXyz888(q) {\n  const qNorm = \
q.clone().normalize();\n  const sinr_cosp = 2 * (qNorm.w * qNorm.x + qNorm.y \
* qNorm.z);\n  const cosr_cosp = 1 - 2 * (qNorm.x * qNorm.x + qNorm.y * \
qNorm.y);\n  const roll = Math.atan2(sinr_cosp, cosr_cosp);\n  const sinp = 2 \
* (qNorm.w * qNorm.y - qNorm.z * qNorm.x);\n  const pitch = Math.abs(sinp) >= \
1 ? Math.sign(sinp) * (Math.PI / 2) : Math.asin(sinp);\n  const siny_cosp = 2 \
* (qNorm.w * qNorm.z + qNorm.x * qNorm.y);\n  const cosy_cosp = 1 - 2 * \
(qNorm.y * qNorm.y + qNorm.z * qNorm.z);\n  const yaw = Math.atan2(siny_cosp, \
cosy_cosp);\n  const normRoll = (roll + Math.PI) / (2 * Math.PI);\n  const \
normPitch = (pitch + Math.PI) / (2 * Math.PI);\n  const normYaw = (yaw + \
Math.PI) / (2 * Math.PI);\n  const rollQ = Math.round(normRoll * 255);\n  \
const pitchQ = Math.round(normPitch * 255);\n  const yawQ = \
Math.round(normYaw * 255);\n  return yawQ << 16 | pitchQ << 8 | \
rollQ;\n}\nfunction decodeQuatEulerXyz888(encoded, out) {\n  const rollQ = \
encoded & 255;\n  const pitchQ = encoded >>> 8 & 255;\n  const yawQ = encoded \
>>> 16 & 255;\n  const normRoll = rollQ / 255;\n  const normPitch = pitchQ / \
255;\n  const normYaw = yawQ / 255;\n  const roll = normRoll * (2 * Math.PI) \
- Math.PI;\n  const pitch = normPitch * (2 * Math.PI) - Math.PI;\n  const yaw \
= normYaw * (2 * Math.PI) - Math.PI;\n  const cr = Math.cos(roll * 0.5);\n  \
const sr = Math.sin(roll * 0.5);\n  const cp = Math.cos(pitch * 0.5);\n  \
const sp = Math.sin(pitch * 0.5);\n  const cy = Math.cos(yaw * 0.5);\n  const \
sy = Math.sin(yaw * 0.5);\n  out.w = cr * cp * cy + sr * sp * sy;\n  out.x = \
sr * cp * cy - cr * sp * sy;\n  out.y = cr * sp * cy + sr * cp * sy;\n  out.z \
= cr * cp * sy - sr * sp * cy;\n  out.normalize();\n  return \
out;\n}\nfunction packSint8Bytes(b0, b1, b22, b3) {\n  const clampedB0 = \
Math.max(-127, Math.min(127, b0 * 127));\n  const clampedB1 = Math.max(-127, \
Math.min(127, b1 * 127));\n  const clampedB2 = Math.max(-127, Math.min(127, \
b22 * 127));\n  const clampedB3 = Math.max(-127, Math.min(127, b3 * 127));\n  \
return clampedB0 & 255 | (clampedB1 & 255) << 8 | (clampedB2 & 255) << 16 | \
(clampedB3 & 255) << 24;\n}\nfunction encodeSh1Rgb(sh1Array, index, sh1Rgb, \
encoding) {\n  const sh1Min = (encoding == null ? void 0 : encoding.sh1Min) \
?? -1;\n  const sh1Max = (encoding == null ? void 0 : encoding.sh1Max) ?? \
1;\n  const sh1Mid = 0.5 * (sh1Min + sh1Max);\n  const sh1Scale = 126 / \
(sh1Max - sh1Min);\n  const base = index * 2;\n  for (let i = 0; i < 9; ++i) \
{\n    const s = (sh1Rgb[i] - sh1Mid) * sh1Scale;\n    const value = \
Math.round(Math.max(-63, Math.min(63, s))) & 127;\n    const bitStart = i * \
7;\n    const bitEnd = bitStart + 7;\n    const wordStart = \
Math.floor(bitStart / 32);\n    const bitOffset = bitStart - wordStart * \
32;\n    const firstWord = value << bitOffset & 4294967295;\n    \
sh1Array[base + wordStart] |= firstWord;\n    if (bitEnd > wordStart * 32 + \
32) {\n      const secondWord = value >>> 32 - bitOffset & 4294967295;\n      \
sh1Array[base + wordStart + 1] |= secondWord;\n    }\n  }\n}\nfunction \
encodeSh2Rgb(sh2Array, index, sh2Rgb, encoding) {\n  const sh2Min = (encoding \
== null ? void 0 : encoding.sh2Min) ?? -1;\n  const sh2Max = (encoding == \
null ? void 0 : encoding.sh2Max) ?? 1;\n  const sh2Mid = 0.5 * (sh2Min + \
sh2Max);\n  const sh2Scale = 2 / (sh2Max - sh2Min);\n  sh2Array[index * 4 + \
0] = packSint8Bytes(\n    (sh2Rgb[0] - sh2Mid) * sh2Scale,\n    (sh2Rgb[1] - \
sh2Mid) * sh2Scale,\n    (sh2Rgb[2] - sh2Mid) * sh2Scale,\n    (sh2Rgb[3] - \
sh2Mid) * sh2Scale\n  );\n  sh2Array[index * 4 + 1] = packSint8Bytes(\n    \
(sh2Rgb[4] - sh2Mid) * sh2Scale,\n    (sh2Rgb[5] - sh2Mid) * sh2Scale,\n    \
(sh2Rgb[6] - sh2Mid) * sh2Scale,\n    (sh2Rgb[7] - sh2Mid) * sh2Scale\n  );\n \
 sh2Array[index * 4 + 2] = packSint8Bytes(\n    (sh2Rgb[8] - sh2Mid) * \
sh2Scale,\n    (sh2Rgb[9] - sh2Mid) * sh2Scale,\n    (sh2Rgb[10] - sh2Mid) * \
sh2Scale,\n    (sh2Rgb[11] - sh2Mid) * sh2Scale\n  );\n  sh2Array[index * 4 + \
3] = packSint8Bytes(\n    (sh2Rgb[12] - sh2Mid) * sh2Scale,\n    (sh2Rgb[13] \
- sh2Mid) * sh2Scale,\n    (sh2Rgb[14] - sh2Mid) * sh2Scale,\n    0\n  \
);\n}\nfunction encodeSh3Rgb(sh3Array, index, sh3Rgb, encoding) {\n  const \
sh3Min = (encoding == null ? void 0 : encoding.sh3Min) ?? -1;\n  const sh3Max \
= (encoding == null ? void 0 : encoding.sh3Max) ?? 1;\n  const sh3Mid = 0.5 * \
(sh3Min + sh3Max);\n  const sh3Scale = 62 / (sh3Max - sh3Min);\n  const base \
= index * 4;\n  for (let i = 0; i < 21; ++i) {\n    const s = (sh3Rgb[i] - \
sh3Mid) * sh3Scale;\n    const value = Math.round(Math.max(-31, Math.min(31, \
s))) & 63;\n    const bitStart = i * 6;\n    const bitEnd = bitStart + 6;\n   \
 const wordStart = Math.floor(bitStart / 32);\n    const bitOffset = bitStart \
- wordStart * 32;\n    const firstWord = value << bitOffset & 4294967295;\n   \
 sh3Array[base + wordStart] |= firstWord;\n    if (bitEnd > wordStart * 32 + \
32) {\n      const secondWord = value >>> 32 - bitOffset & 4294967295;\n      \
sh3Array[base + wordStart + 1] |= secondWord;\n    }\n  }\n}\nfunction \
decompressPartialGzip(fileBytes, numBytes) {\n  const chunks = [];\n  let \
totalBytes = 0;\n  let result = null;\n  const gunzip = new Gunzip((data, \
final) => {\n    chunks.push(data);\n    totalBytes += data.length;\n    if \
(final || totalBytes >= numBytes) {\n      const allBytes = new \
Uint8Array(totalBytes);\n      let offset2 = 0;\n      for (const chunk of \
chunks) {\n        allBytes.set(chunk, offset2);\n        offset2 += \
chunk.length;\n      }\n      result = allBytes.slice(0, numBytes);\n    }\n  \
});\n  const CHUNK_SIZE = 1024;\n  let offset = 0;\n  while (result == null \
&& offset < fileBytes.length) {\n    const chunk = fileBytes.slice(offset, \
offset + CHUNK_SIZE);\n    gunzip.push(chunk, false);\n    offset += \
CHUNK_SIZE;\n  }\n  if (result == null) {\n    gunzip.push(new Uint8Array(), \
true);\n    if (result == null) {\n      throw new Error(\"Failed to \
decompress partial gzip\");\n    }\n  }\n  return result;\n}\nclass \
GunzipReader {\n  constructor({\n    fileBytes,\n    chunkBytes = 64 * 1024\n \
 }) {\n    this.fileBytes = fileBytes;\n    this.chunkBytes = chunkBytes;\n   \
 this.chunks = [];\n    this.totalBytes = 0;\n    const ds = new \
DecompressionStream(\"gzip\");\n    const decompressionStream = new \
Blob([fileBytes]).stream().pipeThrough(ds);\n    this.reader = \
decompressionStream.getReader();\n  }\n  async read(numBytes) {\n    while \
(this.totalBytes < numBytes) {\n      const { value: chunk, done: readerDone \
} = await this.reader.read();\n      if (readerDone) {\n        break;\n      \
}\n      this.chunks.push(chunk);\n      this.totalBytes += chunk.length;\n   \
 }\n    if (this.totalBytes < numBytes) {\n      throw new Error(\n        \
`Unexpected EOF: needed ${numBytes}, got ${this.totalBytes}`\n      );\n    \
}\n    const allBytes = new Uint8Array(this.totalBytes);\n    let outOffset = \
0;\n    for (const chunk of this.chunks) {\n      allBytes.set(chunk, \
outOffset);\n      outOffset += chunk.length;\n    }\n    const result = \
allBytes.subarray(0, numBytes);\n    this.chunks = \
[allBytes.subarray(numBytes)];\n    this.totalBytes -= numBytes;\n    return \
result;\n  }\n}\nconst utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ \
Object.defineProperty({\n  __proto__: null,\n  DataCache,\n  FreeList,\n  \
GunzipReader,\n  IDENT_VERTEX_SHADER,\n  Sint8ToFloat,\n  Uint8ToFloat,\n  \
averagePositions,\n  averageQuaternions,\n  cloneClock,\n  coinciDist,\n  \
computeMaxSplats,\n  coorientDist,\n  decodeQuatEulerXyz888,\n  \
decodeQuatOctXy88R8,\n  decodeQuatXyz888,\n  decompressPartialGzip,\n  \
encodeQuatEulerXyz888,\n  encodeQuatOctXy88R8,\n  encodeQuatXyz888,\n  \
encodeSh1Rgb,\n  encodeSh2Rgb,\n  encodeSh3Rgb,\n  epsilonSign,\n  \
flipPixels,\n  floatBitsToUint: floatBitsToUint$1,\n  floatToSint8,\n  \
floatToUint8,\n  fromHalf,\n  getArrayBuffers,\n  getTextureSize,\n  \
isAndroid,\n  isMobile,\n  isOculus,\n  mapFilterObject,\n  mapObject,\n  \
newArray,\n  normalize: normalize$1,\n  omitUndefined,\n  pixelsToPngUrl,\n  \
setPackedSplat,\n  setPackedSplatCenter,\n  setPackedSplatOpacity,\n  \
setPackedSplatQuat,\n  setPackedSplatRgb,\n  setPackedSplatRgba,\n  \
setPackedSplatScales,\n  toHalf,\n  uintBitsToFloat: uintBitsToFloat$1,\n  \
unpackSplat,\n  withinCoinciDist,\n  withinCoorientDist,\n  withinDist\n}, \
Symbol.toStringTag, { value: \"Module\" }));\nclass DynoProgram {\n  \
constructor({\n    graph,\n    inputs,\n    outputs,\n    template\n  }) {\n  \
  this.graph = graph;\n    this.template = template;\n    this.inputs = \
inputs ?? {};\n    this.outputs = outputs ?? {};\n    const compile = new \
Compilation({ indent: this.template.indent });\n    for (const key in \
this.outputs) {\n      if (this.outputs[key]) {\n        \
compile.declares.add(this.outputs[key]);\n      }\n    }\n    const \
statements = graph.compile({\n      inputs: this.inputs,\n      outputs: \
this.outputs,\n      compile\n    });\n    this.shader = template.generate({ \
globals: compile.globals, statements });\n    this.uniforms = \
compile.uniforms;\n    this.updaters = compile.updaters;\n  }\n  \
prepareMaterial() {\n    return getMaterial(this);\n  }\n  update() {\n    \
for (const updater of this.updaters) {\n      updater();\n    }\n  \
}\n}\nclass DynoProgramTemplate {\n  constructor(template) {\n    const \
globals = template.match(/^([ \\t]*)\\{\\{\\s*GLOBALS\\s*\\}\\}/m);\n    \
const statements = template.match(/^([ \
\\t]*)\\{\\{\\s*STATEMENTS\\s*\\}\\}/m);\n    if (!globals || !statements) \
{\n      throw new Error(\n        \"Template must contain {{ GLOBALS }} and \
{{ STATEMENTS }}\"\n      );\n    }\n    this.before = template.substring(0, \
globals.index);\n    this.between = template.substring(\n      globals.index \
+ globals[0].length,\n      statements.index\n    );\n    this.after = \
template.substring(\n      statements.index + statements[0].length\n    );\n  \
  this.indent = statements[1];\n  }\n  generate({\n    globals,\n    \
statements\n  }) {\n    return this.before + \
Array.from(globals).join(\"\\n\\n\") + this.between + statements.map((s) => \
this.indent + s).join(\"\\n\") + this.after;\n  }\n}\nconst programMaterial = \
/* @__PURE__ */ new Map();\nfunction getMaterial(program) {\n  let material = \
programMaterial.get(program);\n  if (material) {\n    return material;\n  }\n \
 material = new THREE.RawShaderMaterial({\n    glslVersion: THREE.GLSL3,\n    \
vertexShader: IDENT_VERTEX_SHADER,\n    fragmentShader: program.shader,\n    \
uniforms: program.uniforms\n  });\n  programMaterial.set(program, \
material);\n  return material;\n}\nfunction addOutputType(a, b, operation = \
\"add\") {\n  const error = () => {\n    throw new Error(`Invalid \
${operation} types: ${a}, ${b}`);\n  };\n  if (a === b) return a;\n  if (a \
=== \"int\") {\n    if (isIntType(b)) return b;\n    error();\n  }\n  if (b \
=== \"int\") {\n    if (isIntType(a)) return a;\n    error();\n  }\n  if (a \
=== \"uint\") {\n    if (isUintType(b)) return b;\n    error();\n  }\n  if (b \
=== \"uint\") {\n    if (isUintType(a)) return a;\n    error();\n  }\n  if (a \
=== \"float\") {\n    if (isAllFloatType(b)) return b;\n    error();\n  }\n  \
if (b === \"float\") {\n    if (isAllFloatType(a)) return a;\n    error();\n  \
}\n  throw new Error(`Invalid ${operation} types: ${a}, ${b}`);\n}\nfunction \
subOutputType(a, b) {\n  return addOutputType(a, b, \"sub\");\n}\nfunction \
mulOutputType(a, b) {\n  const error = () => {\n    throw new Error(`Invalid \
mul types: ${a}, ${b}`);\n  };\n  const result = (value) => value;\n  if (a \
=== \"int\") {\n    if (isIntType(b)) return result(b);\n    error();\n  }\n  \
if (b === \"int\") {\n    if (isIntType(a)) return result(a);\n    error();\n \
 }\n  if (a === \"uint\") {\n    if (isUintType(b)) return result(b);\n    \
error();\n  }\n  if (b === \"uint\") {\n    if (isUintType(a)) return \
result(a);\n    error();\n  }\n  if (a === \"float\") {\n    if \
(isAllFloatType(b)) return result(b);\n    error();\n  }\n  if (b === \
\"float\") {\n    if (isAllFloatType(a)) return result(a);\n    error();\n  \
}\n  if (isIntType(a) || isUintType(a) || isIntType(b) || isUintType(b)) {\n  \
  if (a === b) return result(a);\n    error();\n  }\n  if (a === \"vec2\") \
{\n    if (b === \"vec2\" || isMat2(b)) return result(\"vec2\");\n    if (b \
=== \"mat3x2\") return result(\"vec3\");\n    if (b === \"mat4x2\") return \
result(\"vec4\");\n    error();\n  }\n  if (a === \"vec3\") {\n    if (b === \
\"mat2x3\") return result(\"vec2\");\n    if (b === \"vec3\" || isMat3(b)) \
return result(\"vec3\");\n    if (b === \"mat4x3\") return \
result(\"vec4\");\n    error();\n  }\n  if (a === \"vec4\") {\n    if (b === \
\"mat2x4\") return result(\"vec2\");\n    if (b === \"mat3x4\") return \
result(\"vec3\");\n    if (b === \"vec4\" || isMat4(b)) return \
result(\"vec4\");\n    error();\n  }\n  if (b === \"vec2\") {\n    if \
(isMat2(a)) return result(\"vec2\");\n    if (a === \"mat2x3\") return \
result(\"vec3\");\n    if (a === \"mat2x4\") return result(\"vec4\");\n    \
error();\n  }\n  if (b === \"vec3\") {\n    if (a === \"mat3x2\") return \
result(\"vec2\");\n    if (isMat3(a)) return result(\"vec3\");\n    if (a === \
\"mat3x4\") return result(\"vec4\");\n    error();\n  }\n  if (b === \
\"vec4\") {\n    if (a === \"mat4x2\") return result(\"vec2\");\n    if (a \
=== \"mat4x3\") return result(\"vec3\");\n    if (isMat4(a)) return \
result(\"vec4\");\n    error();\n  }\n  if (isMat2(a)) {\n    if (isMat2(b)) \
return result(\"mat2\");\n    if (b === \"mat3x2\") return \
result(\"mat3x2\");\n    if (b === \"mat4x2\") return result(\"mat4x2\");\n   \
 error();\n  }\n  if (a === \"mat2x3\") {\n    if (isMat2(b)) return \
result(\"mat2x3\");\n    if (b === \"mat3x2\") return result(\"mat3\");\n    \
if (b === \"mat4x2\") return result(\"mat4x3\");\n    error();\n  }\n  if (a \
=== \"mat2x4\") {\n    if (isMat2(b)) return result(\"mat2x4\");\n    if (b \
=== \"mat3x2\") return result(\"mat3x4\");\n    if (b === \"mat4x2\") return \
result(\"mat4\");\n    error();\n  }\n  if (a === \"mat3x2\") {\n    if (b \
=== \"mat2x3\") return result(\"mat2\");\n    if (isMat3(b)) return \
result(\"mat3x2\");\n    if (b === \"mat4x3\") return result(\"mat4x2\");\n   \
 error();\n  }\n  if (isMat3(a)) {\n    if (b === \"mat2x3\") return \
result(\"mat2x3\");\n    if (isMat3(b)) return result(\"mat3\");\n    if (b \
=== \"mat4x3\") return result(\"mat4x3\");\n    error();\n  }\n  if (a === \
\"mat3x4\") {\n    if (b === \"mat2x3\") return result(\"mat2x4\");\n    if \
(isMat3(b)) return result(\"mat3x4\");\n    if (b === \"mat4x3\") return \
result(\"mat4\");\n    error();\n  }\n  if (a === \"mat4x2\") {\n    if (b \
=== \"mat2x4\") return result(\"mat2\");\n    if (b === \"mat3x4\") return \
result(\"mat3x2\");\n    if (isMat4(b)) return result(\"mat4x2\");\n    \
error();\n  }\n  if (a === \"mat4x3\") {\n    if (b === \"mat2x4\") return \
result(\"mat2x3\");\n    if (b === \"mat3x4\") return result(\"mat3\");\n    \
if (isMat4(b)) return result(\"mat4x3\");\n    error();\n  }\n  if \
(isMat4(a)) {\n    if (b === \"mat2x4\") return result(\"mat2x4\");\n    if \
(b === \"mat3x4\") return result(\"mat3x4\");\n    if (isMat4(b)) return \
result(\"mat4\");\n    error();\n  }\n  throw new Error(`Invalid mul types: \
${a}, ${b}`);\n}\nfunction divOutputType(a, b) {\n  return addOutputType(a, \
b, \"div\");\n}\nfunction imodOutputType(a, b) {\n  if (a === b) return a;\n  \
if (a === \"int\") {\n    if (isIntType(b)) return b;\n  } else if (b === \
\"int\") {\n    if (isIntType(a)) return a;\n  } else if (a === \"uint\") {\n \
   if (isUintType(b)) return b;\n  } else if (b === \"uint\") {\n    if \
(isUintType(a)) return a;\n  }\n  throw new Error(`Invalid imod types: ${a}, \
${b}`);\n}\nfunction modOutputType(a, b) {\n  if (a === b || b === \"float\") \
return a;\n  throw new Error(`Invalid mod types: ${a}, ${b}`);\n}\nfunction \
modfOutputType(a) {\n  return a;\n}\nfunction negOutputType(a) {\n  return \
a;\n}\nfunction absOutputType(a) {\n  return a;\n}\nfunction \
signOutputType(a) {\n  return a;\n}\nfunction floorOutputType(a) {\n  return \
a;\n}\nfunction ceilOutputType(a) {\n  return a;\n}\nfunction \
truncOutputType(a) {\n  return a;\n}\nfunction roundOutputType(a) {\n  return \
a;\n}\nfunction fractOutputType(a) {\n  return a;\n}\nfunction \
powOutputType(a) {\n  return a;\n}\nfunction expOutputType(a) {\n  return \
a;\n}\nfunction exp2OutputType(a) {\n  return a;\n}\nfunction \
logOutputType(a) {\n  return a;\n}\nfunction log2OutputType(a) {\n  return \
a;\n}\nfunction sqrOutputType(a) {\n  return a;\n}\nfunction \
sqrtOutputType(a) {\n  return a;\n}\nfunction inversesqrtOutputType(a) {\n  \
return a;\n}\nfunction minOutputType(a, b, operation = \"min\") {\n  if (a \
=== b) return a;\n  if (b === \"float\") {\n    if (isFloatType(a)) return \
a;\n  } else if (b === \"int\") {\n    if (isIntType(a)) return a;\n  } else \
if (b === \"uint\") {\n    if (isUintType(a)) return a;\n  }\n  throw new \
Error(`Invalid ${operation} types: ${a}, ${b}`);\n}\nfunction \
maxOutputType(a, b) {\n  return minOutputType(a, b, \"max\");\n}\nfunction \
clampOutputType(a, b, _c) {\n  if (b === \"float\") {\n    if \
(isFloatType(a)) return a;\n  } else if (b === \"int\") {\n    if \
(isIntType(a)) return a;\n  } else if (b === \"uint\") {\n    if \
(isUintType(a)) return a;\n  }\n  throw new Error(`Invalid clamp types: ${a}, \
${b}`);\n}\nfunction mixOutputType(a, b, c) {\n  if (c === a) return a;\n  if \
(c === \"float\") return a;\n  if (c === \"bool\" && a === \"float\") return \
a;\n  if (c === \"bvec2\" && a === \"vec2\") return a;\n  if (c === \"bvec3\" \
&& a === \"vec3\") return a;\n  if (c === \"bvec4\" && a === \"vec4\") return \
a;\n  throw new Error(`Invalid mix types: ${a}, ${b}, ${c}`);\n}\nfunction \
stepOutputType(a, b) {\n  if (a === b || b === \"float\") return b;\n  throw \
new Error(`Invalid step types: ${a}, ${b}`);\n}\nfunction \
smoothstepOutputType(a, b, c) {\n  if (a === b) {\n    if (a === c || a === \
\"float\") return c;\n  }\n  throw new Error(`Invalid smoothstep types: ${a}, \
${b}, ${c}`);\n}\nfunction isNanOutputType(a, operation = \"isNan\") {\n  if \
(a === \"float\") return \"bool\";\n  if (a === \"vec2\") return \"bvec2\";\n \
 if (a === \"vec3\") return \"bvec3\";\n  if (a === \"vec4\") return \
\"bvec4\";\n  throw new Error(`Invalid ${operation} types: \
${a}`);\n}\nfunction isInfOutputType(a) {\n  return isNanOutputType(a, \
\"isInf\");\n}\nconst add = (a, b) => new Add({ a, b });\nconst sub = (a, b) \
=> new Sub({ a, b });\nconst mul = (a, b) => new Mul({ a, b });\nconst div = \
(a, b) => new Div({ a, b });\nconst imod = (a, b) => new IMod({ a, b \
});\nconst mod = (a, b) => new Mod({ a, b });\nconst modf = (a) => new Modf({ \
a }).outputs;\nconst neg = (a) => new Neg({ a });\nconst abs = (a) => new \
Abs({ a });\nconst sign = (a) => new Sign({ a });\nconst floor = (a) => new \
Floor({ a });\nconst ceil = (a) => new Ceil({ a });\nconst trunc = (a) => new \
Trunc({ a });\nconst round = (a) => new Round({ a });\nconst fract = (a) => \
new Fract({ a });\nconst pow = (a, b) => new Pow({ a, b });\nconst exp = (a) \
=> new Exp({ a });\nconst exp2 = (a) => new Exp2({ a });\nconst log = (a) => \
new Log({ a });\nconst log2 = (a) => new Log2({ a });\nconst sqr = (a) => new \
Sqr({ a });\nconst sqrt = (a) => new Sqrt({ a });\nconst inversesqrt = (a) => \
new InverseSqrt({ a });\nconst min = (a, b) => new Min({ a, b });\nconst max \
= (a, b) => new Max({ a, b });\nconst clamp = (a, min2, max2) => new Clamp({ \
a, min: min2, max: max2 });\nconst mix = (a, b, t) => new Mix({ a, b, t \
});\nconst step = (edge, x) => new Step({ edge, x });\nconst smoothstep = \
(edge0, edge1, x) => new Smoothstep({ edge0, edge1, x });\nconst isNan = (a) \
=> new IsNan({ a });\nconst isInf = (a) => new IsInf({ a });\nclass Add \
extends BinaryOp {\n  constructor({ a, b }) {\n    super({ a, b, outKey: \
\"sum\", outTypeFunc: addOutputType });\n    this.statements = ({ inputs, \
outputs }) => {\n      return [`${outputs.sum} = ${inputs.a} + \
${inputs.b};`];\n    };\n  }\n}\nclass Sub extends BinaryOp {\n  \
constructor({ a, b }) {\n    super({ a, b, outKey: \"difference\", \
outTypeFunc: subOutputType });\n    this.statements = ({ inputs, outputs }) \
=> {\n      return [`${outputs.difference} = ${inputs.a} - ${inputs.b};`];\n  \
  };\n  }\n}\nclass Mul extends BinaryOp {\n  constructor({ a, b }) {\n    \
super({ a, b, outKey: \"product\", outTypeFunc: mulOutputType });\n    \
this.statements = ({ inputs, outputs }) => {\n      return \
[`${outputs.product} = ${inputs.a} * ${inputs.b};`];\n    };\n  }\n}\nclass \
Div extends BinaryOp {\n  constructor({ a, b }) {\n    super({ a, b, outKey: \
\"quotient\", outTypeFunc: divOutputType });\n    this.statements = ({ \
inputs, outputs }) => {\n      return [`${outputs.quotient} = ${inputs.a} / \
${inputs.b};`];\n    };\n  }\n}\nclass IMod extends BinaryOp {\n  \
constructor({ a, b }) {\n    super({ a, b, outKey: \"remainder\", \
outTypeFunc: imodOutputType });\n    this.statements = ({ inputs, outputs }) \
=> {\n      return [`${outputs.remainder} = ${inputs.a} % ${inputs.b};`];\n   \
 };\n  }\n}\nclass Mod extends BinaryOp {\n  constructor({ a, b }) {\n    \
super({ a, b, outKey: \"remainder\", outTypeFunc: modOutputType });\n    \
this.statements = ({ inputs, outputs }) => {\n      return \
[`${outputs.remainder} = mod(${inputs.a}, ${inputs.b});`];\n    };\n  \
}\n}\nclass Modf extends Dyno {\n  constructor({ a }) {\n    const inTypes = \
{ a: valType(a) };\n    const outType = modfOutputType(inTypes.a);\n    const \
outTypes = {\n      fract: outType,\n      integer: outType\n    };\n    \
super({ inTypes, outTypes, inputs: { a } });\n    this.statements = ({ \
inputs, outputs }) => {\n      return [`${outputs.fract} = modf(${inputs.a}, \
${outputs.integer});`];\n    };\n  }\n}\nclass Neg extends UnaryOp {\n  \
constructor({ a }) {\n    super({ a, outKey: \"neg\", outTypeFunc: \
negOutputType });\n    this.statements = ({ inputs, outputs }) => {\n      \
return [`${outputs.neg} = -${inputs.a};`];\n    };\n  }\n}\nclass Abs extends \
UnaryOp {\n  constructor({ a }) {\n    super({ a, outKey: \"abs\", \
outTypeFunc: absOutputType });\n    this.statements = ({ inputs, outputs }) \
=> {\n      return [`${outputs.abs} = abs(${inputs.a});`];\n    };\n  \
}\n}\nclass Sign extends UnaryOp {\n  constructor({ a }) {\n    super({ a, \
outKey: \"sign\", outTypeFunc: signOutputType });\n    this.statements = ({ \
inputs, outputs }) => {\n      return [`${outputs.sign} = \
sign(${inputs.a});`];\n    };\n  }\n}\nclass Floor extends UnaryOp {\n  \
constructor({ a }) {\n    super({ a, outKey: \"floor\", outTypeFunc: \
floorOutputType });\n    this.statements = ({ inputs, outputs }) => {\n      \
return [`${outputs.floor} = floor(${inputs.a});`];\n    };\n  }\n}\nclass \
Ceil extends UnaryOp {\n  constructor({ a }) {\n    super({ a, outKey: \
\"ceil\", outTypeFunc: ceilOutputType });\n    this.statements = ({ inputs, \
outputs }) => {\n      return [`${outputs.ceil} = ceil(${inputs.a});`];\n    \
};\n  }\n}\nclass Trunc extends UnaryOp {\n  constructor({ a }) {\n    \
super({ a, outKey: \"trunc\", outTypeFunc: truncOutputType });\n    \
this.statements = ({ inputs, outputs }) => {\n      return [`${outputs.trunc} \
= trunc(${inputs.a});`];\n    };\n  }\n}\nclass Round extends UnaryOp {\n  \
constructor({ a }) {\n    super({ a, outKey: \"round\", outTypeFunc: \
roundOutputType });\n    this.statements = ({ inputs, outputs }) => {\n      \
return [`${outputs.round} = round(${inputs.a});`];\n    };\n  }\n}\nclass \
Fract extends UnaryOp {\n  constructor({ a }) {\n    super({ a, outKey: \
\"fract\", outTypeFunc: fractOutputType });\n    this.statements = ({ inputs, \
outputs }) => {\n      return [`${outputs.fract} = fract(${inputs.a});`];\n   \
 };\n  }\n}\nclass Pow extends BinaryOp {\n  constructor({ a, b }) {\n    \
super({ a, b, outKey: \"power\", outTypeFunc: powOutputType });\n    \
this.statements = ({ inputs, outputs }) => {\n      return [`${outputs.power} \
= pow(${inputs.a}, ${inputs.b});`];\n    };\n  }\n}\nclass Exp extends \
UnaryOp {\n  constructor({ a }) {\n    super({ a, outKey: \"exp\", \
outTypeFunc: expOutputType });\n    this.statements = ({ inputs, outputs }) \
=> {\n      return [`${outputs.exp} = exp(${inputs.a});`];\n    };\n  \
}\n}\nclass Exp2 extends UnaryOp {\n  constructor({ a }) {\n    super({ a, \
outKey: \"exp2\", outTypeFunc: exp2OutputType });\n    this.statements = ({ \
inputs, outputs }) => {\n      return [`${outputs.exp2} = \
exp2(${inputs.a});`];\n    };\n  }\n}\nclass Log extends UnaryOp {\n  \
constructor({ a }) {\n    super({ a, outKey: \"log\", outTypeFunc: \
logOutputType });\n    this.statements = ({ inputs, outputs }) => {\n      \
return [`${outputs.log} = log(${inputs.a});`];\n    };\n  }\n}\nclass Log2 \
extends UnaryOp {\n  constructor({ a }) {\n    super({ a, outKey: \"log2\", \
outTypeFunc: log2OutputType });\n    this.statements = ({ inputs, outputs }) \
=> {\n      return [`${outputs.log2} = log2(${inputs.a});`];\n    };\n  \
}\n}\nclass Sqr extends UnaryOp {\n  constructor({ a }) {\n    super({ a, \
outKey: \"sqr\", outTypeFunc: sqrOutputType });\n    this.statements = ({ \
inputs, outputs }) => {\n      return [`${outputs.sqr} = ${inputs.a} * \
${inputs.a};`];\n    };\n  }\n}\nclass Sqrt extends UnaryOp {\n  \
constructor({ a }) {\n    super({ a, outKey: \"sqrt\", outTypeFunc: \
sqrtOutputType });\n    this.statements = ({ inputs, outputs }) => {\n      \
return [`${outputs.sqrt} = sqrt(${inputs.a});`];\n    };\n  }\n}\nclass \
InverseSqrt extends UnaryOp {\n  constructor({ a }) {\n    super({ a, outKey: \
\"inversesqrt\", outTypeFunc: inversesqrtOutputType });\n    this.statements \
= ({ inputs, outputs }) => {\n      return [`${outputs.inversesqrt} = \
inversesqrt(${inputs.a});`];\n    };\n  }\n}\nclass Min extends BinaryOp {\n  \
constructor({ a, b }) {\n    super({ a, b, outKey: \"min\", outTypeFunc: \
minOutputType });\n    this.statements = ({ inputs, outputs }) => {\n      \
return [`${outputs.min} = min(${inputs.a}, ${inputs.b});`];\n    };\n  \
}\n}\nclass Max extends BinaryOp {\n  constructor({ a, b }) {\n    super({ a, \
b, outKey: \"max\", outTypeFunc: maxOutputType });\n    this.statements = ({ \
inputs, outputs }) => {\n      return [`${outputs.max} = max(${inputs.a}, \
${inputs.b});`];\n    };\n  }\n}\nclass Clamp extends TrinaryOp {\n  \
constructor({\n    a,\n    min: min2,\n    max: max2\n  }) {\n    super({\n   \
   a,\n      b: min2,\n      c: max2,\n      outKey: \"clamp\",\n      \
outTypeFunc: clampOutputType\n    });\n    this.statements = ({ inputs, \
outputs }) => {\n      const { a: a2, b: min3, c: max3 } = inputs;\n      \
return [`${outputs.clamp} = clamp(${a2}, ${min3}, ${max3});`];\n    };\n  \
}\n}\nclass Mix extends TrinaryOp {\n  constructor({ a, b, t }) {\n    \
super({ a, b, c: t, outKey: \"mix\", outTypeFunc: mixOutputType });\n    \
this.statements = ({ inputs, outputs }) => {\n      const { a: a2, b: b22, c: \
t2 } = inputs;\n      return [`${outputs.mix} = mix(${a2}, ${b22}, \
${t2});`];\n    };\n  }\n}\nclass Step extends BinaryOp {\n  constructor({ \
edge, x }) {\n    super({\n      a: edge,\n      b: x,\n      outKey: \
\"step\",\n      outTypeFunc: stepOutputType\n    });\n    this.statements = \
({ inputs, outputs }) => {\n      const { a: edge2, b: x2 } = inputs;\n      \
return [`${outputs.step} = step(${edge2}, ${x2});`];\n    };\n  }\n}\nclass \
Smoothstep extends TrinaryOp {\n  constructor({\n    edge0,\n    edge1,\n    \
x\n  }) {\n    super({\n      a: edge0,\n      b: edge1,\n      c: x,\n      \
outKey: \"smoothstep\",\n      outTypeFunc: smoothstepOutputType\n    });\n   \
 this.statements = ({ inputs, outputs }) => {\n      const { a: edge02, b: \
edge12, c: x2 } = inputs;\n      return [`${outputs.smoothstep} = \
smoothstep(${edge02}, ${edge12}, ${x2});`];\n    };\n  }\n}\nclass IsNan \
extends UnaryOp {\n  constructor({ a }) {\n    super({ a, outKey: \"isNan\", \
outTypeFunc: isNanOutputType });\n    this.statements = ({ inputs, outputs }) \
=> {\n      return [`${outputs.isNan} = isNan(${inputs.a});`];\n    };\n  \
}\n}\nclass IsInf extends UnaryOp {\n  constructor({ a }) {\n    super({ a, \
outKey: \"isInf\", outTypeFunc: isInfOutputType });\n    this.statements = ({ \
inputs, outputs }) => {\n      return [`${outputs.isInf} = \
isInf(${inputs.a});`];\n    };\n  }\n}\nconst and = (a, b) => new And({ a, b \
});\nconst or = (a, b) => new Or({ a, b });\nconst xor = (a, b) => new Xor({ \
a, b });\nconst not = (a) => new Not({ a });\nconst lessThan = (a, b) => new \
LessThan({ a, b });\nconst lessThanEqual = (a, b) => new LessThanEqual({ a, b \
});\nconst greaterThan = (a, b) => new GreaterThan({ a, b });\nconst \
greaterThanEqual = (a, b) => new GreaterThanEqual({ a, b });\nconst equal = \
(a, b) => new Equal({ a, b });\nconst notEqual = (a, b) => new NotEqual({ a, \
b });\nconst any = (a) => new Any({ a });\nconst all = (a) => new All({ a \
});\nconst select = (cond, t, f) => new Select({ cond, t, f });\nconst \
compXor = (a) => new CompXor({ a });\nclass And extends BinaryOp {\n  \
constructor({ a, b }) {\n    super({ a, b, outTypeFunc: (aType, bType) => \
aType, outKey: \"and\" });\n    this.statements = ({ inputs, outputs }) => \
{\n      if (this.outTypes.and === \"bool\") {\n        return \
[`${outputs.and} = ${inputs.a} && ${inputs.b};`];\n      }\n      return \
[`${outputs.and} = ${inputs.a} & ${inputs.b};`];\n    };\n  }\n}\nclass Or \
extends BinaryOp {\n  constructor({ a, b }) {\n    super({ a, b, outTypeFunc: \
(aType, bType) => aType, outKey: \"or\" });\n    this.statements = ({ inputs, \
outputs }) => {\n      if (this.outTypes.or === \"bool\") {\n        return \
[`${outputs.or} = ${inputs.a} || ${inputs.b};`];\n      }\n      return \
[`${outputs.or} = ${inputs.a} | ${inputs.b};`];\n    };\n  }\n}\nclass Xor \
extends BinaryOp {\n  constructor({ a, b }) {\n    super({ a, b, outTypeFunc: \
(aType, bType) => aType, outKey: \"xor\" });\n    this.statements = ({ \
inputs, outputs }) => {\n      if (this.outTypes.xor === \"bool\") {\n        \
return [`${outputs.xor} = ${inputs.a} ^^ ${inputs.b};`];\n      }\n      \
return [`${outputs.xor} = ${inputs.a} ^ ${inputs.b};`];\n    };\n  \
}\n}\nclass Not extends UnaryOp {\n  constructor({ a }) {\n    super({ a, \
outTypeFunc: (aType) => aType, outKey: \"not\" });\n    this.statements = ({ \
inputs, outputs }) => {\n      if (this.outTypes.not === \"bool\") {\n        \
return [`${outputs.not} = !${inputs.a};`];\n      }\n      return \
[`${outputs.not} = not(${inputs.a});`];\n    };\n  }\n}\nclass LessThan \
extends BinaryOp {\n  constructor({ a, b }) {\n    super({\n      a,\n      \
b,\n      outTypeFunc: (aType, bType) => compareOutputType(aType, \
\"lessThan\"),\n      outKey: \"lessThan\"\n    });\n    this.statements = ({ \
inputs, outputs }) => {\n      if (this.outTypes.lessThan === \"bool\") {\n   \
     return [`${outputs.lessThan} = ${inputs.a} < ${inputs.b};`];\n      }\n  \
    return [`${outputs.lessThan} = lessThan(${inputs.a}, ${inputs.b});`];\n   \
 };\n  }\n}\nclass LessThanEqual extends BinaryOp {\n  constructor({ a, b }) \
{\n    super({\n      a,\n      b,\n      outTypeFunc: (aType, bType) => \
compareOutputType(aType, \"lessThanEqual\"),\n      outKey: \
\"lessThanEqual\"\n    });\n    this.statements = ({ inputs, outputs }) => \
{\n      if (this.outTypes.lessThanEqual === \"bool\") {\n        return \
[`${outputs.lessThanEqual} = ${inputs.a} <= ${inputs.b};`];\n      }\n      \
return [\n        `${outputs.lessThanEqual} = lessThanEqual(${inputs.a}, \
${inputs.b});`\n      ];\n    };\n  }\n}\nclass GreaterThan extends BinaryOp \
{\n  constructor({ a, b }) {\n    super({\n      a,\n      b,\n      \
outTypeFunc: (aType, bType) => compareOutputType(aType, \"greaterThan\"),\n   \
   outKey: \"greaterThan\"\n    });\n    this.statements = ({ inputs, outputs \
}) => {\n      if (this.outTypes.greaterThan === \"bool\") {\n        return \
[`${outputs.greaterThan} = ${inputs.a} > ${inputs.b};`];\n      }\n      \
return [\n        `${outputs.greaterThan} = greaterThan(${inputs.a}, \
${inputs.b});`\n      ];\n    };\n  }\n}\nclass GreaterThanEqual extends \
BinaryOp {\n  constructor({ a, b }) {\n    super({\n      a,\n      b,\n      \
outTypeFunc: (aType, bType) => compareOutputType(aType, \
\"greaterThanEqual\"),\n      outKey: \"greaterThanEqual\"\n    });\n    \
this.statements = ({ inputs, outputs }) => {\n      if \
(this.outTypes.greaterThanEqual === \"bool\") {\n        return \
[`${outputs.greaterThanEqual} = ${inputs.a} >= ${inputs.b};`];\n      }\n     \
 return [\n        `${outputs.greaterThanEqual} = \
greaterThanEqual(${inputs.a}, ${inputs.b});`\n      ];\n    };\n  }\n}\nclass \
Equal extends BinaryOp {\n  constructor({ a, b }) {\n    super({ a, b, \
outTypeFunc: equalOutputType, outKey: \"equal\" });\n    this.statements = ({ \
inputs, outputs }) => {\n      if (this.outTypes.equal === \"bool\") {\n      \
  return [`${outputs.equal} = ${inputs.a} == ${inputs.b};`];\n      }\n      \
return [`${outputs.equal} = equal(${inputs.a}, ${inputs.b});`];\n    };\n  \
}\n}\nclass NotEqual extends BinaryOp {\n  constructor({ a, b }) {\n    \
super({ a, b, outTypeFunc: notEqualOutputType, outKey: \"notEqual\" });\n    \
this.statements = ({ inputs, outputs }) => {\n      if \
(this.outTypes.notEqual === \"bool\") {\n        return [`${outputs.notEqual} \
= ${inputs.a} != ${inputs.b};`];\n      }\n      return [`${outputs.notEqual} \
= notEqual(${inputs.a}, ${inputs.b});`];\n    };\n  }\n}\nclass Any extends \
UnaryOp {\n  constructor({ a }) {\n    super({ a, outTypeFunc: (aType) => \
\"bool\", outKey: \"any\" });\n    this.statements = ({ inputs, outputs }) => \
{\n      return [`${outputs.any} = any(${inputs.a});`];\n    };\n  \
}\n}\nclass All extends UnaryOp {\n  constructor({ a }) {\n    super({ a, \
outTypeFunc: (aType) => \"bool\", outKey: \"all\" });\n    this.statements = \
({ inputs, outputs }) => {\n      return [`${outputs.all} = \
all(${inputs.a});`];\n    };\n  }\n}\nclass Select extends TrinaryOp {\n  \
constructor({\n    cond,\n    t,\n    f\n  }) {\n    super({\n      a: \
cond,\n      b: t,\n      c: f,\n      outKey: \"select\",\n      \
outTypeFunc: (aType, bType, cType) => bType\n    });\n    this.statements = \
({ inputs, outputs }) => {\n      const { a: cond2, b: t2, c: f2 } = \
inputs;\n      return [`${outputs.select} = (${cond2}) ? (${t2}) : \
(${f2});`];\n    };\n  }\n}\nfunction compareOutputType(type, operator) {\n  \
if (isScalarType(type)) {\n    return \"bool\";\n  }\n  if (type === \
\"ivec2\" || type === \"uvec2\" || type === \"vec2\") {\n    return \
\"bvec2\";\n  }\n  if (type === \"ivec3\" || type === \"uvec3\" || type === \
\"vec3\") {\n    return \"bvec3\";\n  }\n  if (type === \"ivec4\" || type === \
\"uvec4\" || type === \"vec4\") {\n    return \"bvec4\";\n  }\n  throw new \
Error(`Invalid ${operator} type: ${type}`);\n}\nfunction \
equalOutputType(type, operator = \"equal\") {\n  if (isScalarType(type)) {\n  \
  return \"bool\";\n  }\n  if (isBoolType(type)) {\n    return type;\n  }\n  \
if (type === \"ivec2\" || type === \"uvec2\" || type === \"vec2\") {\n    \
return \"bvec2\";\n  }\n  if (type === \"ivec3\" || type === \"uvec3\" || \
type === \"vec3\") {\n    return \"bvec3\";\n  }\n  if (type === \"ivec4\" || \
type === \"uvec4\" || type === \"vec4\") {\n    return \"bvec4\";\n  }\n  \
throw new Error(`Invalid ${operator} type: ${type}`);\n}\nfunction \
notEqualOutputType(type) {\n  return equalOutputType(type, \
\"notEqual\");\n}\nfunction compXorOutputType(type) {\n  if \
(isBoolType(type)) {\n    return \"bool\";\n  }\n  if (isIntType(type)) {\n   \
 return \"int\";\n  }\n  if (isUintType(type)) {\n    return \"uint\";\n  }\n \
 throw new Error(`Invalid compXor type: ${type}`);\n}\nclass CompXor extends \
UnaryOp {\n  constructor({ a }) {\n    const outType = \
compXorOutputType(valType(a));\n    super({ a, outTypeFunc: (aType) => \
outType, outKey: \"compXor\" });\n    this.statements = ({ inputs, outputs }) \
=> {\n      if (isScalarType(this.outTypes.compXor)) {\n        return \
[`${outputs.compXor} = ${inputs.a};`];\n      }\n      const components = \
isVector2Type(outType) ? [\"x\", \"y\"] : isVector3Type(outType) ? [\"x\", \
\"y\", \"z\"] : [\"x\", \"y\", \"z\", \"w\"];\n      const operands = \
components.map((c) => `${inputs.a}.${c}`);\n      const operator = \
isBoolType(outType) ? \"^^\" : \"^\";\n      return [`${outputs.compXor} = \
${operands.join(` ${operator} `)};`];\n    };\n  }\n}\nconst bool = (value) \
=> new Bool({ value });\nconst int = (value) => new Int({ value });\nconst \
uint = (value) => new Uint({ value });\nconst float = (value) => new Float({ \
value });\nconst bvec2 = (value) => new BVec2({ value });\nconst bvec3 = \
(value) => new BVec3({ value });\nconst bvec4 = (value) => new BVec4({ value \
});\nconst ivec2 = (value) => new IVec2({ value });\nconst ivec3 = (value) => \
new IVec3({ value });\nconst ivec4 = (value) => new IVec4({ value });\nconst \
uvec2 = (value) => new UVec2({ value });\nconst uvec3 = (value) => new \
UVec3({ value });\nconst uvec4 = (value) => new UVec4({ value });\nconst vec2 \
= (value) => new Vec2({ value });\nconst vec3 = (value) => new Vec3({ value \
});\nconst vec4 = (value) => new Vec4({ value });\nconst mat2 = (value) => \
new Mat2({ value });\nconst mat3 = (value) => new Mat3({ value });\nconst \
mat4 = (value) => new Mat4({ value });\nconst floatBitsToInt = (value) => new \
FloatBitsToInt({ value });\nconst floatBitsToUint = (value) => new \
FloatBitsToUint({ value });\nconst intBitsToFloat = (value) => new \
IntBitsToFloat({ value });\nconst uintBitsToFloat = (value) => new \
UintBitsToFloat({ value });\nconst packSnorm2x16 = (value) => new \
PackSnorm2x16({ value });\nconst unpackSnorm2x16 = (value) => new \
UnpackSnorm2x16({ value });\nconst packUnorm2x16 = (value) => new \
PackUnorm2x16({ value });\nconst unpackUnorm2x16 = (value) => new \
UnpackUnorm2x16({ value });\nconst packHalf2x16 = (value) => new \
PackHalf2x16({ value });\nconst unpackHalf2x16 = (value) => new \
UnpackHalf2x16({ value });\nconst uintToRgba8 = (value) => new UintToRgba8({ \
value });\nclass SimpleCast extends UnaryOp {\n  constructor({\n    value,\n  \
  outType,\n    outKey\n  }) {\n    super({ a: value, outTypeFunc: () => \
outType, outKey });\n    this.statements = ({ inputs, outputs }) => [\n      \
`${outputs[outKey]} = ${typeLiteral(outType)}(${inputs.a});`\n    ];\n  \
}\n}\nclass Bool extends SimpleCast {\n  constructor({\n    value\n  }) {\n   \
 super({ value, outType: \"bool\", outKey: \"bool\" });\n  }\n}\nclass Int \
extends SimpleCast {\n  constructor({\n    value\n  }) {\n    super({ value, \
outType: \"int\", outKey: \"int\" });\n  }\n}\nclass Uint extends SimpleCast \
{\n  constructor({\n    value\n  }) {\n    super({ value, outType: \"uint\", \
outKey: \"uint\" });\n  }\n}\nclass Float extends SimpleCast {\n  \
constructor({\n    value\n  }) {\n    super({ value, outType: \"float\", \
outKey: \"float\" });\n  }\n}\nclass BVec2 extends SimpleCast {\n  \
constructor({\n    value\n  }) {\n    super({ value, outType: \"bvec2\", \
outKey: \"bvec2\" });\n  }\n}\nclass BVec3 extends SimpleCast {\n  \
constructor({\n    value\n  }) {\n    super({ value, outType: \"bvec3\", \
outKey: \"bvec3\" });\n  }\n}\nclass BVec4 extends SimpleCast {\n  \
constructor({\n    value\n  }) {\n    super({ value, outType: \"bvec4\", \
outKey: \"bvec4\" });\n  }\n}\nclass IVec2 extends SimpleCast {\n  \
constructor({\n    value\n  }) {\n    super({ value, outType: \"ivec2\", \
outKey: \"ivec2\" });\n  }\n}\nclass IVec3 extends SimpleCast {\n  \
constructor({\n    value\n  }) {\n    super({ value, outType: \"ivec3\", \
outKey: \"ivec3\" });\n  }\n}\nclass IVec4 extends SimpleCast {\n  \
constructor({\n    value\n  }) {\n    super({ value, outType: \"ivec4\", \
outKey: \"ivec4\" });\n  }\n}\nclass UVec2 extends SimpleCast {\n  \
constructor({\n    value\n  }) {\n    super({ value, outType: \"uvec2\", \
outKey: \"uvec2\" });\n  }\n}\nclass UVec3 extends SimpleCast {\n  \
constructor({\n    value\n  }) {\n    super({ value, outType: \"uvec3\", \
outKey: \"uvec3\" });\n  }\n}\nclass UVec4 extends SimpleCast {\n  \
constructor({\n    value\n  }) {\n    super({ value, outType: \"uvec4\", \
outKey: \"uvec4\" });\n  }\n}\nclass Vec2 extends SimpleCast {\n  \
constructor({\n    value\n  }) {\n    super({ value, outType: \"vec2\", \
outKey: \"vec2\" });\n  }\n}\nclass Vec3 extends SimpleCast {\n  \
constructor({\n    value\n  }) {\n    super({ value, outType: \"vec3\", \
outKey: \"vec3\" });\n  }\n}\nclass Vec4 extends SimpleCast {\n  \
constructor({\n    value\n  }) {\n    super({ value, outType: \"vec4\", \
outKey: \"vec4\" });\n  }\n}\nclass Mat2 extends SimpleCast {\n  \
constructor({\n    value\n  }) {\n    super({ value, outType: \"mat2\", \
outKey: \"mat2\" });\n  }\n}\nclass Mat3 extends SimpleCast {\n  \
constructor({\n    value\n  }) {\n    super({ value, outType: \"mat3\", \
outKey: \"mat3\" });\n  }\n}\nclass Mat4 extends SimpleCast {\n  \
constructor({\n    value\n  }) {\n    super({ value, outType: \"mat4\", \
outKey: \"mat4\" });\n  }\n}\nclass FloatBitsToInt extends UnaryOp {\n  \
constructor({ value }) {\n    super({ a: value, outKey: \"int\", outTypeFunc: \
() => \"int\" });\n    this.statements = ({ inputs, outputs }) => {\n      \
return [`${outputs.int} = floatBitsToInt(${inputs.a});`];\n    };\n  \
}\n}\nclass FloatBitsToUint extends UnaryOp {\n  constructor({ value }) {\n   \
 super({ a: value, outKey: \"uint\", outTypeFunc: () => \"uint\" });\n    \
this.statements = ({ inputs, outputs }) => {\n      return [`${outputs.uint} \
= floatBitsToUint(${inputs.a});`];\n    };\n  }\n}\nclass IntBitsToFloat \
extends UnaryOp {\n  constructor({ value }) {\n    super({ a: value, outKey: \
\"float\", outTypeFunc: () => \"float\" });\n    this.statements = ({ inputs, \
outputs }) => {\n      return [`${outputs.float} = \
intBitsToFloat(${inputs.a});`];\n    };\n  }\n}\nclass UintBitsToFloat \
extends UnaryOp {\n  constructor({ value }) {\n    super({ a: value, outKey: \
\"float\", outTypeFunc: () => \"float\" });\n    this.statements = ({ inputs, \
outputs }) => {\n      return [`${outputs.float} = \
uintBitsToFloat(${inputs.a});`];\n    };\n  }\n}\nclass PackSnorm2x16 extends \
UnaryOp {\n  constructor({ value }) {\n    super({ a: value, outKey: \
\"uint\", outTypeFunc: () => \"uint\" });\n    this.statements = ({ inputs, \
outputs }) => {\n      return [`${outputs.uint} = \
packSnorm2x16(${inputs.a});`];\n    };\n  }\n}\nclass UnpackSnorm2x16 extends \
UnaryOp {\n  constructor({ value }) {\n    super({ a: value, outKey: \
\"vec2\", outTypeFunc: () => \"vec2\" });\n    this.statements = ({ inputs, \
outputs }) => {\n      return [`${outputs.vec2} = \
unpackSnorm2x16(${inputs.a});`];\n    };\n  }\n}\nclass PackUnorm2x16 extends \
UnaryOp {\n  constructor({ value }) {\n    super({ a: value, outKey: \
\"uint\", outTypeFunc: () => \"uint\" });\n    this.statements = ({ inputs, \
outputs }) => {\n      return [`${outputs.uint} = \
packUnorm2x16(${inputs.a});`];\n    };\n  }\n}\nclass UnpackUnorm2x16 extends \
UnaryOp {\n  constructor({ value }) {\n    super({ a: value, outKey: \
\"vec2\", outTypeFunc: () => \"vec2\" });\n    this.statements = ({ inputs, \
outputs }) => {\n      return [`${outputs.vec2} = \
unpackUnorm2x16(${inputs.a});`];\n    };\n  }\n}\nclass PackHalf2x16 extends \
UnaryOp {\n  constructor({ value }) {\n    super({ a: value, outKey: \
\"uint\", outTypeFunc: () => \"uint\" });\n    this.statements = ({ inputs, \
outputs }) => {\n      return [`${outputs.uint} = \
packHalf2x16(${inputs.a});`];\n    };\n  }\n}\nclass UnpackHalf2x16 extends \
UnaryOp {\n  constructor({ value }) {\n    super({ a: value, outKey: \
\"vec2\", outTypeFunc: () => \"vec2\" });\n    this.statements = ({ inputs, \
outputs }) => {\n      return [`${outputs.vec2} = \
unpackHalf2x16(${inputs.a});`];\n    };\n  }\n}\nclass UintToRgba8 extends \
UnaryOp {\n  constructor({ value }) {\n    super({ a: value, outKey: \
\"rgba8\", outTypeFunc: () => \"vec4\" });\n    this.statements = ({ inputs, \
outputs }) => {\n      return [\n        `uvec4 uRgba = uvec4(${inputs.a} & \
0xffu, (${inputs.a} >> 8u) & 0xffu, (${inputs.a} >> 16u) & 0xffu, \
(${inputs.a} >> 24u) & 0xffu);`,\n        `${outputs.rgba8} = vec4(uRgba) / \
255.0;`\n      ];\n    };\n  }\n}\nconst length = (a) => new Length({ a \
});\nconst distance = (a, b) => new Distance({ a, b });\nconst dot = (a, b) \
=> new Dot({ a, b });\nconst cross = (a, b) => new Cross({ a, b });\nconst \
normalize = (a) => new Normalize({ a });\nconst faceforward = (a, b, c) => \
new FaceForward({ a, b, c });\nconst reflectVec = (incident, normal) => new \
ReflectVec({ incident, normal });\nconst refractVec = (incident, normal, eta) \
=> new RefractVec({ incident, normal, eta });\nconst split = (vector) => new \
Split({ vector });\nconst combine = ({\n  vector,\n  vectorType,\n  x,\n  \
y,\n  z,\n  w,\n  r,\n  g,\n  b,\n  a\n}) => new Combine({ vector, \
vectorType, x, y, z, w, r, g, b, a });\nconst projectH = (a) => new \
ProjectH({ a });\nconst extendVec = (a, b) => new ExtendVec({ a, b });\nconst \
swizzle = (a, select2) => new Swizzle({ vector: a, select: select2 });\nconst \
compMult = (a, b) => new CompMult({ a, b });\nconst outer = (a, b) => new \
Outer({ a, b });\nconst transpose = (a) => new Transpose({ a });\nconst \
determinant = (a) => new Determinant({ a });\nconst inverse = (a) => new \
Inverse({ a });\nclass Length extends UnaryOp {\n  constructor({ a }) {\n    \
super({ a, outTypeFunc: (aType) => \"float\", outKey: \"length\" });\n    \
this.statements = ({ inputs, outputs }) => [\n      `${outputs.length} = \
length(${inputs.a});`\n    ];\n  }\n}\nclass Distance extends BinaryOp {\n  \
constructor({ a, b }) {\n    super({ a, b, outKey: \"distance\", outTypeFunc: \
(aType, bType) => \"float\" });\n    this.statements = ({ inputs, outputs }) \
=> [\n      `${outputs.distance} = distance(${inputs.a}, ${inputs.b});`\n    \
];\n  }\n}\nclass Dot extends BinaryOp {\n  constructor({ a, b }) {\n    \
super({ a, b, outKey: \"dot\", outTypeFunc: (aType, bType) => \"float\" });\n \
   this.statements = ({ inputs, outputs }) => [\n      `${outputs.dot} = \
dot(${inputs.a}, ${inputs.b});`\n    ];\n  }\n}\nclass Cross extends BinaryOp \
{\n  constructor({ a, b }) {\n    super({ a, b, outKey: \"cross\", \
outTypeFunc: (aType, bType) => \"vec3\" });\n    this.statements = ({ inputs, \
outputs }) => [\n      `${outputs.cross} = cross(${inputs.a}, \
${inputs.b});`\n    ];\n  }\n}\nclass Normalize extends UnaryOp {\n  \
constructor({ a }) {\n    super({ a, outTypeFunc: (aType) => aType, outKey: \
\"normalize\" });\n    this.statements = ({ inputs, outputs }) => [\n      \
`${outputs.normalize} = normalize(${inputs.a});`\n    ];\n  }\n}\nfunction \
projectHOutputType(type) {\n  if (type === \"vec3\") {\n    return \
\"vec2\";\n  }\n  if (type === \"vec4\") {\n    return \"vec3\";\n  }\n  \
throw new Error(\"Invalid type\");\n}\nclass ProjectH extends UnaryOp {\n  \
constructor({ a }) {\n    super({\n      a,\n      outTypeFunc: (aType) => \
projectHOutputType(aType),\n      outKey: \"projected\"\n    });\n    \
this.statements = ({ inputs, outputs }) => {\n      if (this.inTypes.a === \
\"vec3\") {\n        return [`${outputs.projected} = ${inputs.a}.xy / \
${inputs.a}.z;`];\n      }\n      if (this.inTypes.a === \"vec4\") {\n        \
return [`${outputs.projected} = ${inputs.a}.xyz / ${inputs.a}.w;`];\n      \
}\n      throw new Error(\"Invalid type\");\n    };\n  }\n}\nfunction \
extendVecOutputType(type) {\n  if (type === \"float\") return \"vec2\";\n  if \
(type === \"vec2\") return \"vec3\";\n  if (type === \"vec3\") return \
\"vec4\";\n  throw new Error(\"Invalid type\");\n}\nclass ExtendVec extends \
BinaryOp {\n  constructor({ a, b }) {\n    const type = valType(a);\n    \
const outType = extendVecOutputType(type);\n    super({ a, b, outKey: \
\"extend\", outTypeFunc: () => outType });\n    this.statements = ({ inputs, \
outputs }) => [\n      `${outputs.extend} = ${outType}(${inputs.a}, \
${inputs.b});`\n    ];\n  }\n}\nclass FaceForward extends TrinaryOp {\n  \
constructor({ a, b, c }) {\n    super({\n      a,\n      b,\n      c,\n      \
outKey: \"forward\",\n      outTypeFunc: (aType, bType, cType) => aType\n    \
});\n    this.statements = ({ inputs, outputs }) => [\n      \
`${outputs.forward} = faceforward(${inputs.a}, ${inputs.b}, ${inputs.c});`\n  \
  ];\n  }\n}\nclass ReflectVec extends BinaryOp {\n  constructor({\n    \
incident,\n    normal\n  }) {\n    super({\n      a: incident,\n      b: \
normal,\n      outKey: \"reflection\",\n      outTypeFunc: (aType, bType) => \
aType\n    });\n    this.statements = ({ inputs, outputs }) => [\n      \
`${outputs.reflection} = reflect(${inputs.a}, ${inputs.b});`\n    ];\n  \
}\n}\nclass RefractVec extends TrinaryOp {\n  constructor({\n    incident,\n  \
  normal,\n    eta\n  }) {\n    super({\n      a: incident,\n      b: \
normal,\n      c: eta,\n      outKey: \"refraction\",\n      outTypeFunc: \
(aType, bType, cType) => aType\n    });\n    this.statements = ({ inputs, \
outputs }) => [\n      `${outputs.refraction} = refract(${inputs.a}, \
${inputs.b}, ${inputs.c});`\n    ];\n  }\n}\nclass CompMult extends BinaryOp \
{\n  constructor({ a, b }) {\n    super({ a, b, outKey: \"product\", \
outTypeFunc: (aType, bType) => aType });\n    this.statements = ({ inputs, \
outputs }) => [\n      `${outputs.product} = matrixCompMult(${a}, ${b});`\n   \
 ];\n  }\n}\nfunction outerOutputType(aType, bType) {\n  if (aType === \
\"vec2\") {\n    if (bType === \"vec2\") return \"mat2\";\n    if (bType === \
\"vec3\") return \"mat3x2\";\n    if (bType === \"vec4\") return \
\"mat4x2\";\n  }\n  if (aType === \"vec3\") {\n    if (bType === \"vec2\") \
return \"mat2x3\";\n    if (bType === \"vec3\") return \"mat3\";\n    if \
(bType === \"vec4\") return \"mat4x3\";\n  }\n  if (aType === \"vec4\") {\n   \
 if (bType === \"vec2\") return \"mat2x4\";\n    if (bType === \"vec3\") \
return \"mat3x4\";\n    if (bType === \"vec4\") return \"mat4\";\n  }\n  \
throw new Error(`Invalid outer type: ${aType}, ${bType}`);\n}\nclass Outer \
extends BinaryOp {\n  constructor({ a, b }) {\n    super({ a, b, outKey: \
\"outer\", outTypeFunc: outerOutputType });\n    this.statements = ({ inputs, \
outputs }) => [\n      `${outputs.outer} = outerProduct(${inputs.a}, \
${inputs.b});`\n    ];\n  }\n}\nfunction transposeOutputType(type) {\n  if \
(type === \"mat2\") return \"mat2\";\n  if (type === \"mat3\") return \
\"mat3\";\n  if (type === \"mat4\") return \"mat4\";\n  if (type === \
\"mat2x2\") return \"mat2x2\";\n  if (type === \"mat2x3\") return \
\"mat3x2\";\n  if (type === \"mat2x4\") return \"mat4x2\";\n  if (type === \
\"mat3x2\") return \"mat2x3\";\n  if (type === \"mat3x3\") return \
\"mat3x3\";\n  if (type === \"mat3x4\") return \"mat4x3\";\n  if (type === \
\"mat4x2\") return \"mat2x4\";\n  if (type === \"mat4x3\") return \
\"mat3x4\";\n  if (type === \"mat4x4\") return \"mat4x4\";\n  throw new \
Error(`Invalid transpose type: ${type}`);\n}\nclass Transpose extends UnaryOp \
{\n  constructor({ a }) {\n    super({ a, outKey: \"transpose\", outTypeFunc: \
transposeOutputType });\n    this.statements = ({ inputs, outputs }) => [\n   \
   `${outputs.transpose} = transpose(${inputs.a});`\n    ];\n  }\n}\nclass \
Determinant extends UnaryOp {\n  constructor({ a }) {\n    super({ a, outKey: \
\"det\", outTypeFunc: (aType) => \"float\" });\n    this.statements = ({ \
inputs, outputs }) => [\n      `${outputs.det} = determinant(${inputs.a});`\n \
   ];\n  }\n}\nclass Inverse extends UnaryOp {\n  constructor({ a }) {\n    \
super({ a, outKey: \"inverse\", outTypeFunc: (aType) => aType });\n    \
this.statements = ({ inputs, outputs }) => [\n      `${outputs.inverse} = \
inverse(${a});`\n    ];\n  }\n}\nfunction splitOutTypes(type) {\n  const \
result = (value) => value;\n  switch (type) {\n    case \"vec2\":\n      \
return result({ x: \"float\", y: \"float\", r: \"float\", g: \"float\" });\n  \
  case \"vec3\":\n      return result({\n        x: \"float\",\n        y: \
\"float\",\n        z: \"float\",\n        r: \"float\",\n        g: \
\"float\",\n        b: \"float\"\n      });\n    case \"vec4\":\n      return \
result({\n        x: \"float\",\n        y: \"float\",\n        z: \
\"float\",\n        w: \"float\",\n        r: \"float\",\n        g: \
\"float\",\n        b: \"float\",\n        a: \"float\"\n      });\n    case \
\"ivec2\":\n      return result({ x: \"int\", y: \"int\", r: \"int\", g: \
\"int\" });\n    case \"ivec3\":\n      return result({\n        x: \
\"int\",\n        y: \"int\",\n        z: \"int\",\n        r: \"int\",\n     \
   g: \"int\",\n        b: \"int\"\n      });\n    case \"ivec4\":\n      \
return result({\n        x: \"int\",\n        y: \"int\",\n        z: \
\"int\",\n        w: \"int\",\n        r: \"int\",\n        g: \"int\",\n     \
   b: \"int\",\n        a: \"int\"\n      });\n    case \"uvec2\":\n      \
return result({ x: \"uint\", y: \"uint\", r: \"uint\", g: \"uint\" });\n    \
case \"uvec3\":\n      return result({\n        x: \"uint\",\n        y: \
\"uint\",\n        z: \"uint\",\n        r: \"uint\",\n        g: \"uint\",\n \
       b: \"uint\"\n      });\n    case \"uvec4\":\n      return result({\n   \
     x: \"uint\",\n        y: \"uint\",\n        z: \"uint\",\n        w: \
\"uint\",\n        r: \"uint\",\n        g: \"uint\",\n        b: \"uint\",\n \
       a: \"uint\"\n      });\n    default:\n      throw new Error(`Invalid \
vector type: ${type}`);\n  }\n}\nclass Split extends Dyno {\n  constructor({ \
vector }) {\n    const type = valType(vector);\n    const inTypes = { vector: \
type };\n    const outTypes = splitOutTypes(inTypes.vector);\n    super({ \
inTypes, outTypes, inputs: { vector } });\n    this.statements = ({ inputs, \
outputs }) => {\n      const { x, y, z, w, r, g, b, a } = outputs;\n      \
const { vector: vector2 } = inputs;\n      return [\n        x ? `${x} = \
${vector2}.x;` : null,\n        y ? `${y} = ${vector2}.y;` : null,\n        z \
? `${z} = ${vector2}.z;` : null,\n        w ? `${w} = ${vector2}.w;` : \
null,\n        r ? `${r} = ${vector2}.r;` : null,\n        g ? `${g} = \
${vector2}.g;` : null,\n        b ? `${b} = ${vector2}.b;` : null,\n        a \
? `${a} = ${vector2}.a;` : null\n      ].filter(Boolean);\n    };\n  \
}\n}\nclass Combine extends Dyno {\n  constructor({\n    vector,\n    \
vectorType,\n    x,\n    y,\n    z,\n    w,\n    r,\n    g,\n    b,\n    a\n  \
}) {\n    if (!vector && !vectorType) {\n      throw new Error(\"Either \
vector or vectorType must be provided\");\n    }\n    const vType = \
vectorType ?? valType(vector);\n    const elType = \
vectorElementType(vType);\n    const dim = vectorDim(vType);\n    const \
inTypes = {\n      vector: vType,\n      x: elType,\n      y: elType,\n      \
r: elType,\n      g: elType\n    };\n    const inputs = { vector, x, y, r, g \
};\n    if (dim >= 3) {\n      Object.assign(inTypes, { z: elType, b: elType \
});\n      Object.assign(inputs, { z, b });\n    }\n    if (dim >= 4) {\n     \
 Object.assign(inTypes, { w: elType, a: elType });\n      \
Object.assign(inputs, { w, a });\n    }\n    super({ inTypes, outTypes: { \
vector: vType }, inputs });\n    this.statements = ({ inputs: inputs2, \
outputs }) => {\n      const { vector: vector2 } = outputs;\n      const {\n  \
      vector: input,\n        x: x2,\n        y: y2,\n        z: z2,\n        \
w: w2,\n        r: r2,\n        g: g2,\n        b: b22,\n        a: a2\n      \
} = inputs2;\n      const statements = [\n        `${vector2}.x = ${x2 ?? r2 \
?? (input ? `${input}.x` : literalZero(elType))};`,\n        `${vector2}.y = \
${y2 ?? g2 ?? (input ? `${input}.y` : literalZero(elType))};`\n      ];\n     \
 if (dim >= 3)\n        statements.push(\n          `${vector2}.z = ${z2 ?? \
b22 ?? (input ? `${input}.z` : literalZero(elType))};`\n        );\n      if \
(dim >= 4)\n        statements.push(\n          `${vector2}.w = ${w2 ?? a2 ?? \
(input ? `${input}.w` : literalZero(elType))};`\n        );\n      return \
statements;\n    };\n  }\n  dynoOut() {\n    return new DynoOutput(\n      \
this,\n      \"vector\"\n    );\n  }\n}\nfunction swizzleOutputType(type, \
swizzle2) {\n  let result = null;\n  if (isFloatType(type)) {\n    result = \
swizzle2.length === 1 ? \"float\" : swizzle2.length === 2 ? \"vec2\" : \
swizzle2.length === 3 ? \"vec3\" : swizzle2.length === 4 ? \"vec4\" : null;\n \
 } else if (isIntType(type)) {\n    result = swizzle2.length === 1 ? \"int\" \
: swizzle2.length === 2 ? \"ivec2\" : swizzle2.length === 3 ? \"ivec3\" : \
swizzle2.length === 4 ? \"ivec4\" : null;\n  } else if (isUintType(type)) {\n \
   result = swizzle2.length === 1 ? \"uint\" : swizzle2.length === 2 ? \
\"uvec2\" : swizzle2.length === 3 ? \"uvec3\" : swizzle2.length === 4 ? \
\"uvec4\" : null;\n  }\n  if (result == null) {\n    throw new Error(`Invalid \
swizzle: ${swizzle2}`);\n  }\n  return result;\n}\nclass Swizzle extends \
UnaryOp {\n  constructor({ vector, select: select2 }) {\n    super({\n      \
a: vector,\n      outKey: \"swizzle\",\n      outTypeFunc: (aType) => \
swizzleOutputType(aType, select2)\n    });\n    this.statements = ({ inputs, \
outputs }) => [\n      `${outputs.swizzle} = ${inputs.a}.${select2};`\n    \
];\n  }\n}\nconst remapIndex = (index, from, to) => {\n  return new \
DynoRemapIndex({ index, from, to });\n};\nconst pcgMix = (value) => {\n  \
return new PcgMix({ value });\n};\nconst pcgNext = (state) => {\n  return new \
PcgNext({ state });\n};\nconst pcgHash = (state) => {\n  return new PcgHash({ \
state });\n};\nconst hash = (value) => {\n  return new Hash({ value \
});\n};\nconst hash2 = (value) => {\n  return new Hash2({ value \
});\n};\nconst hash3 = (value) => {\n  return new Hash3({ value \
});\n};\nconst hash4 = (value) => {\n  return new Hash4({ value \
});\n};\nconst hashFloat = (value) => {\n  return new HashFloat({ value \
});\n};\nconst hashVec2 = (value) => {\n  return new HashVec2({ value \
});\n};\nconst hashVec3 = (value) => {\n  return new HashVec3({ value \
});\n};\nconst hashVec4 = (value) => {\n  return new HashVec4({ value \
});\n};\nconst normalizedDepth = (z, zNear, zFar) => {\n  return new \
NormalizedDepth({ z, zNear, zFar }).outputs.depth;\n};\nclass DynoRemapIndex \
extends Dyno {\n  constructor({\n    from,\n    to,\n    index\n  }) {\n    \
super({\n      inTypes: { from: \"int\", to: \"int\", index: \"int\" },\n     \
 outTypes: { index: \"int\" },\n      inputs: { from, to, index },\n      \
statements: ({ inputs, outputs }) => {\n        return [\n          \
`${outputs.index} = ${inputs.index} - ${inputs.from} + ${inputs.to};`\n       \
 ];\n      }\n    });\n  }\n  dynoOut() {\n    return new DynoOutput(this, \
\"index\");\n  }\n}\nclass PcgNext extends Dyno {\n  constructor({ state }) \
{\n    const type = valType(state);\n    super({\n      inTypes: { state: \
type },\n      outTypes: { state: \"uint\" },\n      inputs: { state },\n     \
 globals: () => [\n        unindent(`\n          uint pcg_next(uint state) \
{\n            return state * 747796405u + 2891336453u;\n          }\n        \
`)\n      ],\n      statements: ({ inputs, outputs }) => {\n        const \
toUint = type === \"uint\" ? `${inputs.state}` : type === \"int\" ? \
`uint(${inputs.state})` : `floatBitsToUint(${inputs.state})`;\n        return \
[`${outputs.state} = pcg_next(${toUint});`];\n      }\n    });\n  }\n  \
dynoOut() {\n    return new DynoOutput(this, \"state\");\n  }\n}\nclass \
PcgHash extends Dyno {\n  constructor({ state }) {\n    super({\n      \
inTypes: { state: \"uint\" },\n      outTypes: { hash: \"uint\" },\n      \
inputs: { state },\n      globals: () => [\n        unindent(`\n          \
uint pcg_hash(uint state) {\n            uint hash = ((state >> ((state >> \
28u) + 4u)) ^ state) * 277803737u;\n            return (hash >> 22u) ^ \
hash;\n          }\n        `)\n      ],\n      statements: ({ inputs, \
outputs }) => [\n        `${outputs.hash} = pcg_hash(${inputs.state});`\n     \
 ]\n    });\n  }\n  dynoOut() {\n    return new DynoOutput(this, \"hash\");\n \
 }\n}\nclass PcgMix extends Dyno {\n  constructor({ value }) {\n    const \
type = valType(value);\n    const tempType = sameSizeUvec(type);\n    \
super({\n      inTypes: { value: type },\n      outTypes: { state: \"uint\" \
},\n      inputs: { value },\n      globals: () => [\n        unindent(`\n    \
      uint pcg_mix(uint value) {\n            return value;\n          }\n    \
      uint pcg_mix(uvec2 value) {\n            return value.x + 0x9e3779b9u * \
value.y;\n          }\n          uint pcg_mix(uvec3 value) {\n            \
return value.x + 0x9e3779b9u * value.y + 0x85ebca6bu * value.z;\n          \
}\n          uint pcg_mix(uvec4 value) {\n            return value.x + \
0x9e3779b9u * value.y + 0x85ebca6bu * value.z + 0xc2b2ae35u * value.w;\n      \
    }\n        `)\n      ],\n      statements: ({ inputs, outputs }) => {\n   \
     const toUvec = isUintType(type) ? `${inputs.value}` : isIntType(type) ? \
`${tempType}(${inputs.value})` : `floatBitsToUint(${inputs.value})`;\n        \
return [\n          `${tempType} bits = ${toUvec};`,\n          \
`${outputs.state} = pcg_mix(bits);`\n        ];\n      }\n    });\n  }\n  \
dynoOut() {\n    return new DynoOutput(this, \"state\");\n  }\n}\nclass Hash \
extends DynoBlock {\n  constructor({ value }) {\n    super({\n      inTypes: \
{ value: valType(value) },\n      outTypes: { hash: \"uint\" },\n      \
inputs: { value },\n      construct: ({ value: value2 }) => {\n        if \
(!value2) {\n          throw new Error(\"value is required\");\n        }\n   \
     let state = new PcgMix({ value: value2 }).outputs.state;\n        state \
= new PcgNext({ state }).outputs.state;\n        return new PcgHash({ state \
}).outputs;\n      }\n    });\n  }\n  dynoOut() {\n    return new \
DynoOutput(this, \"hash\");\n  }\n}\nclass Hash2 extends DynoBlock {\n  \
constructor({ value }) {\n    super({\n      inTypes: { value: valType(value) \
},\n      outTypes: { hash: \"uvec2\" },\n      inputs: { value },\n      \
construct: ({ value: value2 }) => {\n        if (!value2) {\n          throw \
new Error(\"value is required\");\n        }\n        let state = new \
PcgMix({ value: value2 }).outputs.state;\n        state = new PcgNext({ state \
}).outputs.state;\n        const x = new PcgHash({ state }).outputs.hash;\n   \
     state = new PcgNext({ state }).outputs.state;\n        const y = new \
PcgHash({ state }).outputs.hash;\n        return { hash: combine({ \
vectorType: \"uvec2\", x, y }) };\n      }\n    });\n  }\n  dynoOut() {\n    \
return new DynoOutput(this, \"hash\");\n  }\n}\nclass Hash3 extends DynoBlock \
{\n  constructor({ value }) {\n    super({\n      inTypes: { value: \
valType(value) },\n      outTypes: { hash: \"uvec3\" },\n      inputs: { \
value },\n      construct: ({ value: value2 }) => {\n        if (!value2) {\n \
         throw new Error(\"value is required\");\n        }\n        let \
state = new PcgMix({ value: value2 }).outputs.state;\n        state = new \
PcgNext({ state }).outputs.state;\n        const x = new PcgHash({ state \
}).outputs.hash;\n        state = new PcgNext({ state }).outputs.state;\n     \
   const y = new PcgHash({ state }).outputs.hash;\n        state = new \
PcgNext({ state }).outputs.state;\n        const z = new PcgHash({ state \
}).outputs.hash;\n        return { hash: combine({ vectorType: \"uvec3\", x, \
y, z }) };\n      }\n    });\n  }\n  dynoOut() {\n    return new \
DynoOutput(this, \"hash\");\n  }\n}\nclass Hash4 extends DynoBlock {\n  \
constructor({ value }) {\n    super({\n      inTypes: { value: valType(value) \
},\n      outTypes: { hash: \"uvec4\" },\n      inputs: { value },\n      \
construct: ({ value: value2 }) => {\n        if (!value2) {\n          throw \
new Error(\"value is required\");\n        }\n        let state = new \
PcgMix({ value: value2 }).outputs.state;\n        state = new PcgNext({ state \
}).outputs.state;\n        const x = new PcgHash({ state }).outputs.hash;\n   \
     state = new PcgNext({ state }).outputs.state;\n        const y = new \
PcgHash({ state }).outputs.hash;\n        state = new PcgNext({ state \
}).outputs.state;\n        const z = new PcgHash({ state }).outputs.hash;\n   \
     state = new PcgNext({ state }).outputs.state;\n        const w = new \
PcgHash({ state }).outputs.hash;\n        return { hash: combine({ \
vectorType: \"uvec4\", x, y, z, w }) };\n      }\n    });\n  }\n  dynoOut() \
{\n    return new DynoOutput(this, \"hash\");\n  }\n}\nclass HashFloat \
extends DynoBlock {\n  constructor({ value }) {\n    super({\n      inTypes: \
{ value: valType(value) },\n      outTypes: { hash: \"float\" },\n      \
inputs: { value },\n      construct: ({ value: value2 }) => {\n        if \
(!value2) {\n          throw new Error(\"value is required\");\n        }\n   \
     const word = hash(value2);\n        return { hash: mul(float(word), \
dynoConst(\"float\", 1 / 2 ** 32)) };\n      }\n    });\n  }\n  dynoOut() {\n \
   return new DynoOutput(this, \"hash\");\n  }\n}\nclass HashVec2 extends \
DynoBlock {\n  constructor({ value }) {\n    super({\n      inTypes: { value: \
valType(value) },\n      outTypes: { hash: \"vec2\" },\n      inputs: { value \
},\n      construct: ({ value: value2 }) => {\n        if (!value2) {\n       \
   throw new Error(\"value is required\");\n        }\n        const words = \
hash2(value2);\n        return { hash: mul(vec2(words), dynoConst(\"float\", \
1 / 2 ** 32)) };\n      }\n    });\n  }\n  dynoOut() {\n    return new \
DynoOutput(this, \"hash\");\n  }\n}\nclass HashVec3 extends DynoBlock {\n  \
constructor({ value }) {\n    super({\n      inTypes: { value: valType(value) \
},\n      outTypes: { hash: \"vec3\" },\n      inputs: { value },\n      \
construct: ({ value: value2 }) => {\n        if (!value2) {\n          throw \
new Error(\"value is required\");\n        }\n        const words = \
hash3(value2);\n        return { hash: mul(vec3(words), dynoConst(\"float\", \
1 / 2 ** 32)) };\n      }\n    });\n  }\n  dynoOut() {\n    return new \
DynoOutput(this, \"hash\");\n  }\n}\nclass HashVec4 extends DynoBlock {\n  \
constructor({ value }) {\n    super({\n      inTypes: { value: valType(value) \
},\n      outTypes: { hash: \"vec4\" },\n      inputs: { value },\n      \
construct: ({ value: value2 }) => {\n        if (!value2) {\n          throw \
new Error(\"value is required\");\n        }\n        const words = \
hash4(value2);\n        return { hash: mul(vec4(words), dynoConst(\"float\", \
1 / 2 ** 32)) };\n      }\n    });\n  }\n  dynoOut() {\n    return new \
DynoOutput(this, \"hash\");\n  }\n}\nclass NormalizedDepth extends Dyno {\n  \
constructor({\n    z,\n    zNear,\n    zFar\n  }) {\n    super({\n      \
inTypes: { z: \"float\", zNear: \"float\", zFar: \"float\" },\n      \
outTypes: { depth: \"float\" },\n      inputs: { z, zNear, zFar },\n      \
statements: ({ inputs, outputs }) => [\n        `float clamped = \
clamp(${inputs.z}, ${inputs.zNear}, ${inputs.zFar});`,\n        \
`${outputs.depth} = (log2(clamped + 1.0) - log2(${inputs.zNear} + 1.0)) / \
(log2(${inputs.zFar} + 1.0) - log2(${inputs.zNear} + 1.0));`\n      ]\n    \
});\n  }\n  dynoOut() {\n    return new DynoOutput(this, \"depth\");\n  \
}\n}\nconst transformPos = (position, {\n  scale,\n  scales,\n  rotate,\n  \
translate\n}) => {\n  return new TransformPosition({ position, scale, scales, \
rotate, translate }).outputs.position;\n};\nconst transformDir = (dir, {\n  \
scale,\n  scales,\n  rotate\n}) => {\n  return new TransformDir({ dir, scale, \
scales, rotate }).outputs.dir;\n};\nconst transformQuat = (quaternion, { \
rotate }) => {\n  return new TransformQuaternion({ quaternion, rotate \
}).outputs.quaternion;\n};\nclass TransformPosition extends Dyno {\n  \
constructor({\n    position,\n    scale,\n    scales,\n    rotate,\n    \
translate\n  }) {\n    super({\n      inTypes: {\n        position: \
\"vec3\",\n        scale: \"float\",\n        scales: \"vec3\",\n        \
rotate: \"vec4\",\n        translate: \"vec3\"\n      },\n      outTypes: { \
position: \"vec3\" },\n      inputs: { position, scale, scales, rotate, \
translate },\n      statements: ({ inputs, outputs }) => {\n        const { \
position: position2 } = outputs;\n        if (!position2) {\n          return \
[];\n        }\n        const { scale: scale2, scales: scales2, rotate: \
rotate2, translate: translate2 } = inputs;\n        return [\n          \
`${position2} = ${inputs.position ?? \"vec3(0.0, 0.0, 0.0)\"};`,\n          \
!scale2 ? null : `${position2} *= ${scale2};`,\n          !scales2 ? null : \
`${position2} *= ${scales2};`,\n          !rotate2 ? null : `${position2} = \
quatVec(${rotate2}, ${position2});`,\n          !translate2 ? null : \
`${position2} += ${translate2};`\n        ].filter(Boolean);\n      }\n    \
});\n  }\n}\nclass TransformDir extends Dyno {\n  constructor({\n    dir,\n   \
 scale,\n    scales,\n    rotate\n  }) {\n    super({\n      inTypes: { dir: \
\"vec3\", scale: \"float\", scales: \"vec3\", rotate: \"vec4\" },\n      \
outTypes: { dir: \"vec3\" },\n      inputs: { dir, scale, scales, rotate },\n \
     statements: ({ inputs, outputs }) => {\n        const { dir: dir2 } = \
outputs;\n        if (!dir2) {\n          return [];\n        }\n        \
const { scale: scale2, scales: scales2, rotate: rotate2 } = inputs;\n        \
return [\n          `${dir2} = ${inputs.dir ?? \"vec3(0.0, 0.0, 0.0)\"};`,\n  \
        !scale2 ? null : `${dir2} *= ${scale2};`,\n          !scales2 ? null \
: `${dir2} *= ${scales2};`,\n          !rotate2 ? null : `${dir2} = \
quatVec(${rotate2}, ${dir2});`\n        ].filter(Boolean);\n      }\n    \
});\n  }\n}\nclass TransformQuaternion extends Dyno {\n  constructor({\n    \
quaternion,\n    rotate\n  }) {\n    super({\n      inTypes: { quaternion: \
\"vec4\", rotate: \"vec4\" },\n      outTypes: { quaternion: \"vec4\" },\n    \
  inputs: { quaternion, rotate },\n      statements: ({ inputs, outputs }) => \
{\n        const { quaternion: quaternion2 } = outputs;\n        if \
(!quaternion2) {\n          return [];\n        }\n        return [\n         \
 `${quaternion2} = ${inputs.quaternion ?? \"vec4(0.0, 0.0, 0.0, 1.0)\"};`,\n  \
        !rotate ? null : `${quaternion2} = quatQuat(${inputs.rotate}, \
${quaternion2});`\n        ].filter(Boolean);\n      }\n    });\n  \
}\n}\nconst dynoIf = () => {\n  throw new Error(\"Not \
implemented\");\n};\nconst dynoSwitch = () => {\n  throw new Error(\"Not \
implemented\");\n};\nconst dynoFor = () => {\n  throw new Error(\"Not \
implemented\");\n};\nconst comment = () => {\n  throw new Error(\"Not \
implemented\");\n};\nconst arrayIndex = () => {\n  throw new Error(\"Not \
implemented\");\n};\nconst arrayLength = () => {\n  throw new Error(\"Not \
implemented\");\n};\nconst textureSize = (texture2, lod) => new TextureSize({ \
texture: texture2, lod });\nconst texture = (texture2, coord, bias) => new \
Texture({ texture: texture2, coord, bias });\nconst texelFetch = (texture2, \
coord, lod) => new TexelFetch({ texture: texture2, coord, lod });\nclass \
TextureSize extends Dyno {\n  constructor({ texture: texture2, lod }) {\n    \
const textureType = valType(texture2);\n    super({\n      inTypes: { \
texture: textureType, lod: \"int\" },\n      outTypes: { size: \
textureSizeType(textureType) },\n      inputs: { texture: texture2, lod },\n  \
    statements: ({ inputs, outputs }) => [\n        `${outputs.size} = \
textureSize(${inputs.texture}, ${inputs.lod ?? \"0\"});`\n      ]\n    });\n  \
}\n  dynoOut() {\n    return new DynoOutput(this, \"size\");\n  }\n}\nclass \
Texture extends Dyno {\n  constructor({\n    texture: texture2,\n    coord,\n \
   bias\n  }) {\n    const textureType = valType(texture2);\n    super({\n    \
  inTypes: {\n        texture: textureType,\n        coord: \
textureCoordType(textureType),\n        bias: \"float\"\n      },\n      \
outTypes: { sample: textureReturnType(textureType) },\n      inputs: { \
texture: texture2, coord, bias },\n      statements: ({ inputs, outputs }) => \
[\n        `${outputs.sample} = texture(${inputs.texture}, \
${inputs.coord}${inputs.bias ? `, ${inputs.bias}` : \"\"});`\n      ]\n    \
});\n  }\n  dynoOut() {\n    return new DynoOutput(this, \"sample\");\n  \
}\n}\nclass TexelFetch extends Dyno {\n  constructor({\n    texture: \
texture2,\n    coord,\n    lod\n  }) {\n    const textureType = \
valType(texture2);\n    super({\n      inTypes: {\n        texture: \
textureType,\n        coord: textureSizeType(textureType),\n        lod: \
\"int\"\n      },\n      outTypes: { texel: textureReturnType(textureType) \
},\n      inputs: { texture: texture2, coord, lod },\n      statements: ({ \
inputs, outputs }) => [\n        `${outputs.texel} = \
texelFetch(${inputs.texture}, ${inputs.coord}, ${inputs.lod ?? \"0\"});`\n    \
  ]\n    });\n  }\n  dynoOut() {\n    return new DynoOutput(this, \
\"texel\");\n  }\n}\nfunction textureSizeType(textureType) {\n  switch \
(textureType) {\n    case \"sampler2D\":\n    case \"usampler2D\":\n    case \
\"isampler2D\":\n    case \"samplerCube\":\n    case \"usamplerCube\":\n    \
case \"isamplerCube\":\n    case \"sampler2DShadow\":\n    case \
\"samplerCubeShadow\":\n      return \"ivec2\";\n    case \"sampler3D\":\n    \
case \"usampler3D\":\n    case \"isampler3D\":\n    case \
\"sampler2DArray\":\n    case \"usampler2DArray\":\n    case \
\"isampler2DArray\":\n    case \"sampler2DArrayShadow\":\n      return \
\"ivec3\";\n    default:\n      throw new Error(`Invalid texture type: \
${textureType}`);\n  }\n}\nfunction textureCoordType(textureType) {\n  switch \
(textureType) {\n    case \"sampler2D\":\n    case \"usampler2D\":\n    case \
\"isampler2D\":\n      return \"vec2\";\n    case \"sampler3D\":\n    case \
\"usampler3D\":\n    case \"isampler3D\":\n    case \"samplerCube\":\n    \
case \"usamplerCube\":\n    case \"isamplerCube\":\n    case \
\"sampler2DArray\":\n    case \"usampler2DArray\":\n    case \
\"isampler2DArray\":\n    case \"sampler2DShadow\":\n      return \"vec3\";\n \
   case \"samplerCubeShadow\":\n    case \"sampler2DArrayShadow\":\n      \
return \"vec4\";\n    default:\n      throw new Error(`Invalid texture type: \
${textureType}`);\n  }\n}\nfunction textureReturnType(textureType) {\n  \
switch (textureType) {\n    case \"sampler2D\":\n    case \
\"sampler2DArray\":\n    case \"sampler3D\":\n    case \"samplerCube\":\n    \
case \"sampler2DShadow\":\n      return \"vec4\";\n    case \"usampler2D\":\n \
   case \"usampler2DArray\":\n    case \"usampler3D\":\n    case \
\"usamplerCube\":\n      return \"uvec4\";\n    case \"isampler2D\":\n    \
case \"isampler2DArray\":\n    case \"isampler3D\":\n    case \
\"isamplerCube\":\n      return \"ivec4\";\n    case \"samplerCubeShadow\":\n \
   case \"sampler2DArrayShadow\":\n      return \"float\";\n    default:\n    \
  throw new Error(`Invalid texture type: ${textureType}`);\n  }\n}\nconst \
radians = (degrees2) => new Radians({ degrees: degrees2 });\nconst degrees = \
(radians2) => new Degrees({ radians: radians2 });\nconst sin = (radians2) => \
new Sin({ radians: radians2 });\nconst cos = (radians2) => new Cos({ radians: \
radians2 });\nconst tan = (radians2) => new Tan({ radians: radians2 \
});\nconst asin = (sin2) => new Asin({ sin: sin2 });\nconst acos = (cos2) => \
new Acos({ cos: cos2 });\nconst atan = (tan2) => new Atan({ tan: tan2 \
});\nconst atan2 = (y, x) => new Atan2({ y, x });\nconst sinh = (x) => new \
Sinh({ x });\nconst cosh = (x) => new Cosh({ x });\nconst tanh = (x) => new \
Tanh({ x });\nconst asinh = (x) => new Asinh({ x });\nconst acosh = (x) => \
new Acosh({ x });\nconst atanh = (x) => new Atanh({ x });\nclass Radians \
extends UnaryOp {\n  constructor({ degrees: degrees2 }) {\n    super({ a: \
degrees2, outTypeFunc: (aType) => aType, outKey: \"radians\" });\n    \
this.statements = ({ inputs, outputs }) => [\n      `${outputs.radians} = \
radians(${inputs.a});`\n    ];\n  }\n}\nclass Degrees extends UnaryOp {\n  \
constructor({ radians: radians2 }) {\n    super({ a: radians2, outTypeFunc: \
(aType) => aType, outKey: \"degrees\" });\n    this.statements = ({ inputs, \
outputs }) => [\n      `${outputs.degrees} = degrees(${inputs.a});`\n    ];\n \
 }\n}\nclass Sin extends UnaryOp {\n  constructor({ radians: radians2 }) {\n  \
  super({ a: radians2, outTypeFunc: (aType) => aType, outKey: \"sin\" });\n   \
 this.statements = ({ inputs, outputs }) => [\n      `${outputs.sin} = \
sin(${inputs.a});`\n    ];\n  }\n}\nclass Cos extends UnaryOp {\n  \
constructor({ radians: radians2 }) {\n    super({ a: radians2, outTypeFunc: \
(aType) => aType, outKey: \"cos\" });\n    this.statements = ({ inputs, \
outputs }) => [\n      `${outputs.cos} = cos(${inputs.a});`\n    ];\n  \
}\n}\nclass Tan extends UnaryOp {\n  constructor({ radians: radians2 }) {\n   \
 super({ a: radians2, outTypeFunc: (aType) => aType, outKey: \"tan\" });\n    \
this.statements = ({ inputs, outputs }) => [\n      `${outputs.tan} = \
tan(${inputs.a});`\n    ];\n  }\n}\nclass Asin extends UnaryOp {\n  \
constructor({ sin: sin2 }) {\n    super({ a: sin2, outTypeFunc: (aType) => \
aType, outKey: \"asin\" });\n    this.statements = ({ inputs, outputs }) => \
[\n      `${outputs.asin} = asin(${inputs.a});`\n    ];\n  }\n}\nclass Acos \
extends UnaryOp {\n  constructor({ cos: cos2 }) {\n    super({ a: cos2, \
outTypeFunc: (aType) => aType, outKey: \"acos\" });\n    this.statements = ({ \
inputs, outputs }) => [\n      `${outputs.acos} = acos(${inputs.a});`\n    \
];\n  }\n}\nclass Atan extends UnaryOp {\n  constructor({ tan: tan2 }) {\n    \
super({ a: tan2, outTypeFunc: (aType) => aType, outKey: \"atan\" });\n    \
this.statements = ({ inputs, outputs }) => [\n      `${outputs.atan} = \
atan(${inputs.a});`\n    ];\n  }\n}\nclass Atan2 extends BinaryOp {\n  \
constructor({ y, x }) {\n    super({\n      a: y,\n      b: x,\n      \
outTypeFunc: (aType, bType) => aType,\n      outKey: \"atan2\"\n    });\n    \
this.statements = ({ inputs, outputs }) => [\n      `${outputs.atan2} = \
atan2(${inputs.a}, ${inputs.b});`\n    ];\n  }\n}\nclass Sinh extends UnaryOp \
{\n  constructor({ x }) {\n    super({ a: x, outTypeFunc: (aType) => aType, \
outKey: \"sinh\" });\n    this.statements = ({ inputs, outputs }) => [\n      \
`${outputs.sinh} = sinh(${inputs.a});`\n    ];\n  }\n}\nclass Cosh extends \
UnaryOp {\n  constructor({ x }) {\n    super({ a: x, outTypeFunc: (aType) => \
aType, outKey: \"cosh\" });\n    this.statements = ({ inputs, outputs }) => \
[\n      `${outputs.cosh} = cosh(${inputs.a});`\n    ];\n  }\n}\nclass Tanh \
extends UnaryOp {\n  constructor({ x }) {\n    super({ a: x, outTypeFunc: \
(aType) => aType, outKey: \"tanh\" });\n    this.statements = ({ inputs, \
outputs }) => [\n      `${outputs.tanh} = tanh(${inputs.a});`\n    ];\n  \
}\n}\nclass Asinh extends UnaryOp {\n  constructor({ x }) {\n    super({ a: \
x, outTypeFunc: (aType) => aType, outKey: \"asinh\" });\n    this.statements \
= ({ inputs, outputs }) => [\n      `${outputs.asinh} = \
asinh(${inputs.a});`\n    ];\n  }\n}\nclass Acosh extends UnaryOp {\n  \
constructor({ x }) {\n    super({ a: x, outTypeFunc: (aType) => aType, \
outKey: \"acosh\" });\n    this.statements = ({ inputs, outputs }) => [\n     \
 `${outputs.acosh} = acosh(${inputs.a});`\n    ];\n  }\n}\nclass Atanh \
extends UnaryOp {\n  constructor({ x }) {\n    super({ a: x, outTypeFunc: \
(aType) => aType, outKey: \"atanh\" });\n    this.statements = ({ inputs, \
outputs }) => [\n      `${outputs.atanh} = atanh(${inputs.a});`\n    ];\n  \
}\n}\nconst dyno = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ \
Object.defineProperty({\n  __proto__: null,\n  Abs,\n  Acos,\n  Acosh,\n  \
Add,\n  All,\n  And,\n  Any,\n  Asin,\n  Asinh,\n  Atan,\n  Atan2,\n  \
Atanh,\n  BVec2,\n  BVec3,\n  BVec4,\n  BinaryOp,\n  Bool,\n  Ceil,\n  \
Clamp,\n  Combine,\n  CombineGsplat,\n  CompMult,\n  CompXor,\n  \
Compilation,\n  Cos,\n  Cosh,\n  Cross,\n  Degrees,\n  Determinant,\n  \
Distance,\n  Div,\n  Dot,\n  Dyno,\n  DynoBlock,\n  DynoBool,\n  DynoBvec2,\n \
 DynoBvec3,\n  DynoBvec4,\n  DynoConst,\n  DynoFloat,\n  DynoInt,\n  \
DynoIsampler2D,\n  DynoIsampler2DArray,\n  DynoIsampler3D,\n  \
DynoIsamplerCube,\n  DynoIvec2,\n  DynoIvec3,\n  DynoIvec4,\n  DynoLiteral,\n \
 DynoMat2,\n  DynoMat2x2,\n  DynoMat2x3,\n  DynoMat2x4,\n  DynoMat3,\n  \
DynoMat3x2,\n  DynoMat3x3,\n  DynoMat3x4,\n  DynoMat4,\n  DynoMat4x2,\n  \
DynoMat4x3,\n  DynoMat4x4,\n  DynoOutput,\n  DynoProgram,\n  \
DynoProgramTemplate,\n  DynoRemapIndex,\n  DynoSampler2D,\n  \
DynoSampler2DArray,\n  DynoSampler2DArrayShadow,\n  DynoSampler2DShadow,\n  \
DynoSampler3D,\n  DynoSamplerCube,\n  DynoSamplerCubeShadow,\n  DynoUint,\n  \
DynoUniform,\n  DynoUsampler2D,\n  DynoUsampler2DArray,\n  DynoUsampler3D,\n  \
DynoUsamplerCube,\n  DynoUvec2,\n  DynoUvec3,\n  DynoUvec4,\n  DynoValue,\n  \
DynoVec2,\n  DynoVec3,\n  DynoVec4,\n  Equal,\n  Exp,\n  Exp2,\n  \
ExtendVec,\n  FaceForward,\n  Float,\n  FloatBitsToInt,\n  FloatBitsToUint,\n \
 Floor,\n  Fract,\n  GreaterThan,\n  GreaterThanEqual,\n  Gsplat,\n  \
GsplatNormal,\n  Hash,\n  Hash2,\n  Hash3,\n  Hash4,\n  HashFloat,\n  \
HashVec2,\n  HashVec3,\n  HashVec4,\n  IMod,\n  IVec2,\n  IVec3,\n  IVec4,\n  \
Int,\n  IntBitsToFloat,\n  Inverse,\n  InverseSqrt,\n  IsInf,\n  IsNan,\n  \
Length,\n  LessThan,\n  LessThanEqual,\n  Log,\n  Log2,\n  Mat2,\n  Mat3,\n  \
Mat4,\n  Max,\n  Min,\n  Mix,\n  Mod,\n  Modf,\n  Mul,\n  Neg,\n  \
Normalize,\n  NormalizedDepth,\n  Not,\n  NotEqual,\n  NumPackedSplats,\n  \
Or,\n  Outer,\n  OutputPackedSplat,\n  OutputRgba8,\n  PackHalf2x16,\n  \
PackSnorm2x16,\n  PackUnorm2x16,\n  PcgHash,\n  PcgMix,\n  PcgNext,\n  Pow,\n \
 ProjectH,\n  Radians,\n  ReadPackedSplat,\n  ReadPackedSplatRange,\n  \
ReflectVec,\n  RefractVec,\n  Round,\n  Select,\n  Sign,\n  SimpleCast,\n  \
Sin,\n  Sinh,\n  Smoothstep,\n  Split,\n  SplitGsplat,\n  Sqr,\n  Sqrt,\n  \
Step,\n  Sub,\n  Swizzle,\n  TPackedSplats,\n  Tan,\n  Tanh,\n  TexelFetch,\n \
 Texture,\n  TextureSize,\n  TransformDir,\n  TransformGsplat,\n  \
TransformPosition,\n  TransformQuaternion,\n  Transpose,\n  TrinaryOp,\n  \
Trunc,\n  UVec2,\n  UVec3,\n  UVec4,\n  Uint,\n  UintBitsToFloat,\n  \
UintToRgba8,\n  UnaryOp,\n  UnpackHalf2x16,\n  UnpackSnorm2x16,\n  \
UnpackUnorm2x16,\n  Vec2,\n  Vec3,\n  Vec4,\n  Xor,\n  abs,\n  acos,\n  \
acosh,\n  add,\n  all,\n  and,\n  any,\n  arrayIndex,\n  arrayLength,\n  \
asin,\n  asinh,\n  atan,\n  atan2,\n  atanh,\n  bool,\n  bvec2,\n  bvec3,\n  \
bvec4,\n  ceil,\n  clamp,\n  combine,\n  combineGsplat,\n  comment,\n  \
compMult,\n  compXor,\n  cos,\n  cosh,\n  cross,\n  defineGsplat,\n  \
defineGsplatNormal,\n  definePackedSplats,\n  degrees,\n  determinant,\n  \
distance,\n  div,\n  dot,\n  dyno: dyno$1,\n  dynoBlock,\n  dynoBool,\n  \
dynoBvec2,\n  dynoBvec3,\n  dynoBvec4,\n  dynoConst,\n  dynoDeclare,\n  \
dynoFloat,\n  dynoFor,\n  dynoIf,\n  dynoInt,\n  dynoIsampler2D,\n  \
dynoIsampler2DArray,\n  dynoIsampler3D,\n  dynoIsamplerCube,\n  dynoIvec2,\n  \
dynoIvec3,\n  dynoIvec4,\n  dynoLiteral,\n  dynoMat2,\n  dynoMat2x2,\n  \
dynoMat2x3,\n  dynoMat2x4,\n  dynoMat3,\n  dynoMat3x2,\n  dynoMat3x3,\n  \
dynoMat3x4,\n  dynoMat4,\n  dynoMat4x2,\n  dynoMat4x3,\n  dynoMat4x4,\n  \
dynoSampler2D,\n  dynoSampler2DArray,\n  dynoSampler2DArrayShadow,\n  \
dynoSampler2DShadow,\n  dynoSampler3D,\n  dynoSamplerCube,\n  \
dynoSamplerCubeShadow,\n  dynoSwitch,\n  dynoUint,\n  dynoUsampler2D,\n  \
dynoUsampler2DArray,\n  dynoUsampler3D,\n  dynoUsamplerCube,\n  dynoUvec2,\n  \
dynoUvec3,\n  dynoUvec4,\n  dynoVec2,\n  dynoVec3,\n  dynoVec4,\n  equal,\n  \
exp,\n  exp2,\n  extendVec,\n  faceforward,\n  float,\n  floatBitsToInt,\n  \
floatBitsToUint,\n  floor,\n  fract,\n  greaterThan,\n  greaterThanEqual,\n  \
gsplatNormal,\n  hash,\n  hash2,\n  hash3,\n  hash4,\n  hashFloat,\n  \
hashVec2,\n  hashVec3,\n  hashVec4,\n  imod,\n  int,\n  intBitsToFloat,\n  \
inverse,\n  inversesqrt,\n  isAllFloatType,\n  isBoolType,\n  isFloatType,\n  \
isInf,\n  isIntType,\n  isMat2,\n  isMat3,\n  isMat4,\n  isMatFloatType,\n  \
isNan,\n  isScalarType,\n  isUintType,\n  isVector2Type,\n  isVector3Type,\n  \
isVector4Type,\n  isVectorType,\n  ivec2,\n  ivec3,\n  ivec4,\n  length,\n  \
lessThan,\n  lessThanEqual,\n  literalNegOne,\n  literalOne,\n  \
literalZero,\n  log,\n  log2,\n  mat2,\n  mat3,\n  mat4,\n  max,\n  min,\n  \
mix,\n  mod,\n  modf,\n  mul,\n  neg,\n  normalize,\n  normalizedDepth,\n  \
not,\n  notEqual,\n  numPackedSplats,\n  numberAsFloat,\n  numberAsInt,\n  \
numberAsUint,\n  or,\n  outer,\n  outputPackedSplat,\n  outputRgba8,\n  \
packHalf2x16,\n  packSnorm2x16,\n  packUnorm2x16,\n  pcgHash,\n  pcgMix,\n  \
pcgNext,\n  pow,\n  projectH,\n  radians,\n  readPackedSplat,\n  \
readPackedSplatRange,\n  reflectVec,\n  refractVec,\n  remapIndex,\n  \
round,\n  sameSizeIvec,\n  sameSizeUvec,\n  sameSizeVec,\n  select,\n  \
sign,\n  sin,\n  sinh,\n  smoothstep,\n  split,\n  splitGsplat,\n  sqr,\n  \
sqrt,\n  step,\n  sub,\n  swizzle,\n  tan,\n  tanh,\n  texelFetch,\n  \
texture,\n  textureSize,\n  transformDir,\n  transformGsplat,\n  \
transformPos,\n  transformQuat,\n  transpose,\n  trunc,\n  typeLiteral,\n  \
uint,\n  uintBitsToFloat,\n  uintToRgba8,\n  uniform,\n  unindent,\n  \
unindentLines,\n  unpackHalf2x16,\n  unpackSnorm2x16,\n  unpackUnorm2x16,\n  \
uvec2,\n  uvec3,\n  uvec4,\n  valType,\n  vec2,\n  vec3,\n  vec4,\n  \
vectorDim,\n  vectorElementType,\n  xor\n}, Symbol.toStringTag, { value: \
\"Module\" }));\nvar computeVec4_default = \"precision highp \
float;\\nprecision highp int;\\nprecision highp sampler2D;\\nprecision highp \
usampler2D;\\nprecision highp isampler2D;\\nprecision highp \
sampler2DArray;\\nprecision highp usampler2DArray;\\nprecision highp \
isampler2DArray;\\nprecision highp sampler3D;\\nprecision highp \
usampler3D;\\nprecision highp isampler3D;\\n\\n#include \
<splatDefines>\\n\\nuniform uint targetLayer;\\nuniform int \
targetBase;\\nuniform int targetCount;\\n\\nout vec4 target;\\n\\n{{ GLOBALS \
}}\\n\\nvoid computeReadback(int index) {\\n    {{ STATEMENTS \
}}\\n}\\n\\nvoid main() {\\n    int targetIndex = int(targetLayer << \
SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + \
int(gl_FragCoord.x);\\n    int index = targetIndex - targetBase;\\n\\n    if \
((index >= 0) && (index < targetCount)) {\\n        \
computeReadback(index);\\n    } else {\\n        target = vec4(0.0, 0.0, 0.0, \
0.0);\\n    }\\n}\";\nconst _Readback = class _Readback {\n  constructor({ \
renderer } = {}) {\n    this.renderer = renderer;\n    this.capacity = 0;\n   \
 this.count = 0;\n  }\n  dispose() {\n    if (this.target) {\n      \
this.target.dispose();\n      this.target = void 0;\n    }\n  }\n  // Ensure \
we have a buffer large enough for the readback of count indices.\n  // Pass \
in previous bufer of the desired type.\n  ensureBuffer(count, buffer) {\n    \
const roundedCount = Math.ceil(Math.max(1, count) / SPLAT_TEX_WIDTH) * \
SPLAT_TEX_WIDTH;\n    const bytes = roundedCount * 4;\n    if \
(buffer.byteLength >= bytes) {\n      return buffer;\n    }\n    const \
newBuffer = new ArrayBuffer(bytes);\n    if (buffer instanceof ArrayBuffer) \
{\n      return newBuffer;\n    }\n    const ctor = buffer.constructor;\n    \
return new ctor(newBuffer);\n  }\n  // Ensure our render target is large \
enough for the readback of capacity indices.\n  ensureCapacity(capacity) {\n  \
  const { width, height, depth, maxSplats } = getTextureSize(capacity);\n    \
if (!this.target || maxSplats > this.capacity) {\n      this.dispose();\n     \
 this.capacity = maxSplats;\n      this.target = new \
THREE.WebGLArrayRenderTarget(width, height, depth, {\n        depthBuffer: \
false,\n        stencilBuffer: false,\n        generateMipmaps: false,\n      \
  magFilter: THREE.NearestFilter,\n        minFilter: THREE.NearestFilter\n   \
   });\n      this.target.texture.format = THREE.RGBAFormat;\n      \
this.target.texture.type = THREE.UnsignedByteType;\n      \
this.target.texture.internalFormat = \"RGBA8\";\n      \
this.target.scissorTest = true;\n    }\n  }\n  // Get a program and \
THREE.RawShaderMaterial for a given Rgba8Readback,\n  // generating it if \
necessary and caching the result.\n  prepareProgramMaterial(reader) {\n    \
let program = _Readback.readbackProgram.get(reader);\n    if (!program) {\n   \
   const graph = dynoBlock(\n        { index: \"int\" },\n        { rgba8: \
\"vec4\" },\n        ({ index }) => {\n          reader.inputs.index = \
index;\n          const rgba8 = new OutputRgba8({ rgba8: reader.outputs.rgba8 \
});\n          return { rgba8 };\n        }\n      );\n      if \
(!_Readback.programTemplate) {\n        _Readback.programTemplate = new \
DynoProgramTemplate(computeVec4_default);\n      }\n      program = new \
DynoProgram({\n        graph,\n        inputs: { index: \"index\" },\n        \
outputs: { rgba8: \"target\" },\n        template: \
_Readback.programTemplate\n      });\n      Object.assign(program.uniforms, \
{\n        targetLayer: { value: 0 },\n        targetBase: { value: 0 },\n    \
    targetCount: { value: 0 }\n      });\n      \
_Readback.readbackProgram.set(reader, program);\n    }\n    const material = \
program.prepareMaterial();\n    _Readback.fullScreenQuad.material = \
material;\n    return { program, material };\n  }\n  \
saveRenderState(renderer) {\n    return {\n      xrEnabled: \
renderer.xr.enabled,\n      autoClear: renderer.autoClear\n    };\n  }\n  \
resetRenderState(renderer, state) {\n    renderer.setRenderTarget(null);\n    \
renderer.xr.enabled = state.xrEnabled;\n    renderer.autoClear = \
state.autoClear;\n  }\n  process({\n    count,\n    material\n  }) {\n    \
const renderer = this.renderer;\n    if (!renderer) {\n      throw new \
Error(\"No renderer\");\n    }\n    if (!this.target) {\n      throw new \
Error(\"No target\");\n    }\n    const layerSize = SPLAT_TEX_WIDTH * \
SPLAT_TEX_HEIGHT;\n    material.uniforms.targetBase.value = 0;\n    \
material.uniforms.targetCount.value = count;\n    let baseIndex = 0;\n    \
while (baseIndex < count) {\n      const layer = Math.floor(baseIndex / \
layerSize);\n      const layerBase = layer * layerSize;\n      const \
layerYEnd = Math.min(\n        SPLAT_TEX_HEIGHT,\n        Math.ceil((count - \
layerBase) / SPLAT_TEX_WIDTH)\n      );\n      \
material.uniforms.targetLayer.value = layer;\n      \
this.target.scissor.set(0, 0, SPLAT_TEX_WIDTH, layerYEnd);\n      \
renderer.setRenderTarget(this.target, layer);\n      renderer.xr.enabled = \
false;\n      renderer.autoClear = false;\n      \
_Readback.fullScreenQuad.render(renderer);\n      baseIndex += \
SPLAT_TEX_WIDTH * layerYEnd;\n    }\n    this.count = count;\n  }\n  async \
read({\n    readback\n  }) {\n    const renderer = this.renderer;\n    if \
(!renderer) {\n      throw new Error(\"No renderer\");\n    }\n    if \
(!this.target) {\n      throw new Error(\"No target\");\n    }\n    const \
roundedCount = Math.ceil(this.count / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n   \
 if (readback.byteLength < roundedCount * 4) {\n      throw new Error(\n      \
  `Readback buffer too small: ${readback.byteLength} < ${roundedCount * 4}`\n \
     );\n    }\n    const readbackUint8 = new Uint8Array(\n      readback \
instanceof ArrayBuffer ? readback : readback.buffer\n    );\n    const \
layerSize = SPLAT_TEX_WIDTH * SPLAT_TEX_HEIGHT;\n    let baseIndex = 0;\n    \
const promises = [];\n    while (baseIndex < this.count) {\n      const layer \
= Math.floor(baseIndex / layerSize);\n      const layerBase = layer * \
layerSize;\n      const layerYEnd = Math.min(\n        SPLAT_TEX_HEIGHT,\n    \
    Math.ceil((this.count - layerBase) / SPLAT_TEX_WIDTH)\n      );\n      \
renderer.setRenderTarget(this.target, layer);\n      const readbackSize = \
SPLAT_TEX_WIDTH * layerYEnd * 4;\n      const subReadback = \
readbackUint8.subarray(\n        layerBase * 4,\n        layerBase * 4 + \
readbackSize\n      );\n      const promise = renderer == null ? void 0 : \
renderer.readRenderTargetPixelsAsync(\n        this.target,\n        0,\n     \
   0,\n        SPLAT_TEX_WIDTH,\n        layerYEnd,\n        subReadback\n    \
  );\n      promises.push(promise);\n      baseIndex += SPLAT_TEX_WIDTH * \
layerYEnd;\n    }\n    return Promise.all(promises).then(() => readback);\n  \
}\n  // Perform render operation to run the Rgba8Readback program\n  // but \
don't perform the readback yet.\n  render({\n    reader,\n    count,\n    \
renderer\n  }) {\n    this.renderer = renderer || this.renderer;\n    if \
(!this.renderer) {\n      throw new Error(\"No renderer\");\n    }\n    \
this.ensureCapacity(count);\n    const { program, material } = \
this.prepareProgramMaterial(reader);\n    program.update();\n    const \
renderState = this.saveRenderState(this.renderer);\n    this.process({ count, \
material });\n    this.resetRenderState(this.renderer, renderState);\n  }\n  \
// Perform a readback of the render target, returning a buffer of the\n  // \
given type.\n  async readback({\n    readback\n  }) {\n    if \
(!this.renderer) {\n      throw new Error(\"No renderer\");\n    }\n    const \
renderState = this.saveRenderState(this.renderer);\n    const promise = \
this.read({ readback });\n    this.resetRenderState(this.renderer, \
renderState);\n    return promise;\n  }\n  // Perform a render and readback \
operation for the given Rgba8Readback,\n  // and readback buffer (call \
ensureBuffer first).\n  async renderReadback({\n    reader,\n    count,\n    \
renderer,\n    readback\n  }) {\n    this.renderer = renderer || \
this.renderer;\n    if (!this.renderer) {\n      throw new Error(\"No \
renderer\");\n    }\n    this.ensureCapacity(count);\n    const { program, \
material } = this.prepareProgramMaterial(reader);\n    program.update();\n    \
const renderState = this.saveRenderState(this.renderer);\n    this.process({ \
count, material });\n    const promise = this.read({ readback });\n    \
this.resetRenderState(this.renderer, renderState);\n    return promise;\n  \
}\n  getTexture() {\n    var _a2;\n    return (_a2 = this.target) == null ? \
void 0 : _a2.texture;\n  }\n};\n_Readback.programTemplate = \
null;\n_Readback.readbackProgram = /* @__PURE__ */ new \
Map();\n_Readback.fullScreenQuad = new FullScreenQuad(\n  new \
THREE.RawShaderMaterial({ visible: false })\n);\nlet Readback = \
_Readback;\nconst _RgbaArray = class _RgbaArray {\n  constructor(options = \
{}) {\n    this.capacity = 0;\n    this.count = 0;\n    this.array = null;\n  \
  this.readback = null;\n    this.source = null;\n    this.needsUpdate = \
true;\n    this.dyno = new DynoUniform({\n      key: \"rgbaArray\",\n      \
type: TRgbaArray,\n      globals: () => [defineRgbaArray],\n      value: {\n  \
      texture: _RgbaArray.getEmpty(),\n        count: 0\n      },\n      \
update: (value) => {\n        var _a2;\n        value.texture = ((_a2 = \
this.readback) == null ? void 0 : _a2.getTexture()) ?? this.source ?? \
_RgbaArray.getEmpty();\n        value.count = this.count;\n        return \
value;\n      }\n    });\n    if (options.array) {\n      this.array = \
options.array;\n      this.capacity = Math.floor(this.array.length / 4);\n    \
  this.capacity = Math.floor(this.capacity / SPLAT_TEX_WIDTH) * \
SPLAT_TEX_WIDTH;\n      this.count = Math.min(\n        this.capacity,\n      \
  options.count ?? Number.POSITIVE_INFINITY\n      );\n    } else {\n      \
this.capacity = options.capacity ?? 0;\n      this.count = 0;\n    }\n  }\n  \
// Free up resources\n  dispose() {\n    if (this.readback) {\n      \
this.readback.dispose();\n      this.readback = null;\n    }\n    if \
(this.source) {\n      this.source.dispose();\n      this.source = null;\n    \
}\n  }\n  // Ensure that our array is large enough to hold capacity RGBA8 \
values.\n  ensureCapacity(capacity) {\n    var _a2;\n    if (!this.array || \
capacity > (((_a2 = this.array) == null ? void 0 : _a2.length) ?? 0) / 4) {\n \
     this.capacity = getTextureSize(capacity).maxSplats;\n      const \
newArray2 = new Uint8Array(this.capacity * 4);\n      if (this.array) {\n     \
   newArray2.set(this.array);\n      }\n      this.array = newArray2;\n    \
}\n    return this.array;\n  }\n  // Get the THREE.DataArrayTexture from \
either the readback or the source.\n  getTexture() {\n    var _a2;\n    let \
texture2 = (_a2 = this.readback) == null ? void 0 : _a2.getTexture();\n    if \
(this.source || this.array) {\n      texture2 = this.maybeUpdateSource();\n   \
 }\n    return texture2 ?? _RgbaArray.getEmpty();\n  }\n  // Create or get a \
THREE.DataArrayTexture from the data array.\n  maybeUpdateSource() {\n    if \
(!this.array) {\n      throw new Error(\"No array\");\n    }\n    if \
(this.needsUpdate || !this.source) {\n      this.needsUpdate = false;\n      \
if (this.source) {\n        const { width, height, depth } = \
this.source.image;\n        if (this.capacity !== width * height * depth) {\n \
         this.source.dispose();\n          this.source = null;\n        }\n   \
   }\n      if (!this.source) {\n        const { width, height, depth } = \
getTextureSize(this.capacity);\n        this.source = new \
THREE.DataArrayTexture(\n          this.array,\n          width,\n          \
height,\n          depth\n        );\n        this.source.format = \
THREE.RGBAFormat;\n        this.source.type = THREE.UnsignedByteType;\n       \
 this.source.internalFormat = \"RGBA8\";\n        this.source.needsUpdate = \
true;\n      } else if (this.array.buffer !== this.source.image.data.buffer) \
{\n        this.source.image.data = new Uint8Array(this.array.buffer);\n      \
}\n      this.source.needsUpdate = true;\n    }\n    return this.source;\n  \
}\n  // Generate the RGBA8 values from a Rgba8Readback dyno program.\n  \
render({\n    reader,\n    count,\n    renderer\n  }) {\n    if \
(!this.readback) {\n      this.readback = new Readback({ renderer });\n    \
}\n    this.readback.render({ reader, count, renderer });\n    this.capacity \
= this.readback.capacity;\n    this.count = this.readback.count;\n  }\n  // \
Extract the RGBA8 values from a PackedSplats collection.\n  \
fromPackedSplats({\n    packedSplats,\n    base,\n    count,\n    renderer\n  \
}) {\n    const { dynoSplats, dynoBase, dynoCount, reader } = \
_RgbaArray.makeDynos();\n    dynoSplats.packedSplats = packedSplats;\n    \
dynoBase.value = base;\n    dynoCount.value = count;\n    this.render({ \
reader, count, renderer });\n    return this;\n  }\n  // Read back the RGBA8 \
values from the readback buffer.\n  async read() {\n    if (!this.readback) \
{\n      throw new Error(\"No readback\");\n    }\n    if (!this.array || \
this.array.length < this.count * 4) {\n      this.array = new \
Uint8Array(this.capacity * 4);\n    }\n    const result = await \
this.readback.readback({ readback: this.array });\n    return \
result.subarray(0, this.count * 4);\n  }\n  // Can be used where you need an \
uninitialized THREE.DataArrayTexture like\n  // a uniform you will update \
with the result of this.getTexture() later.\n  static getEmpty() {\n    if \
(!_RgbaArray.emptySource) {\n      const emptyArray = new Uint8Array(1 * \
4);\n      _RgbaArray.emptySource = new THREE.DataArrayTexture(emptyArray, 1, \
1, 1);\n      _RgbaArray.emptySource.format = THREE.RGBAFormat;\n      \
_RgbaArray.emptySource.type = THREE.UnsignedByteType;\n      \
_RgbaArray.emptySource.internalFormat = \"RGBA8\";\n      \
_RgbaArray.emptySource.needsUpdate = true;\n    }\n    return \
_RgbaArray.emptySource;\n  }\n  // Create a dyno program that can extract \
RGBA8 values from a PackedSplats\n  static makeDynos() {\n    if \
(!_RgbaArray.dynos) {\n      const dynoSplats = new DynoPackedSplats();\n     \
 const dynoBase = new DynoInt({ value: 0 });\n      const dynoCount = new \
DynoInt({ value: 0 });\n      const reader = dynoBlock(\n        { index: \
\"int\" },\n        { rgba8: \"vec4\" },\n        ({ index }) => {\n          \
if (!index) {\n            throw new Error(\"index is undefined\");\n         \
 }\n          index = add(index, dynoBase);\n          const gsplat = \
readPackedSplatRange(\n            dynoSplats,\n            index,\n          \
  dynoBase,\n            dynoCount\n          );\n          return { rgba8: \
splitGsplat(gsplat).outputs.rgba };\n        }\n      );\n      \
_RgbaArray.dynos = { dynoSplats, dynoBase, dynoCount, reader };\n    }\n    \
return _RgbaArray.dynos;\n  }\n};\n_RgbaArray.emptySource = \
null;\n_RgbaArray.dynos = null;\nlet RgbaArray = _RgbaArray;\nconst \
TRgbaArray = { type: \"RgbaArray\" };\nconst defineRgbaArray = unindent(`\n  \
struct RgbaArray {\n    sampler2DArray texture;\n    int count;\n  \
};\n`);\nfunction readRgbaArray(rgba, index) {\n  const dyno2 = new Dyno({\n  \
  inTypes: { rgba: TRgbaArray, index: \"int\" },\n    outTypes: { rgba: \
\"vec4\" },\n    inputs: { rgba, index },\n    globals: () => \
[defineRgbaArray],\n    statements: ({ inputs, outputs }) => \
unindentLines(`\n        if ((index >= 0) && (index < ${inputs.rgba}.count)) \
{\n          ${outputs.rgba} = texelFetch(${inputs.rgba}.texture, \
splatTexCoord(index), 0);\n        } else {\n          ${outputs.rgba} = \
vec4(0.0, 0.0, 0.0, 0.0);\n        }\n      `)\n  });\n  return \
dyno2.outputs.rgba;\n}\nvar SplatEditSdfType = /* @__PURE__ */ \
((SplatEditSdfType2) => {\n  SplatEditSdfType2[\"ALL\"] = \"all\";\n  \
SplatEditSdfType2[\"PLANE\"] = \"plane\";\n  SplatEditSdfType2[\"SPHERE\"] = \
\"sphere\";\n  SplatEditSdfType2[\"BOX\"] = \"box\";\n  \
SplatEditSdfType2[\"ELLIPSOID\"] = \"ellipsoid\";\n  \
SplatEditSdfType2[\"CYLINDER\"] = \"cylinder\";\n  \
SplatEditSdfType2[\"CAPSULE\"] = \"capsule\";\n  \
SplatEditSdfType2[\"INFINITE_CONE\"] = \"infinite_cone\";\n  return \
SplatEditSdfType2;\n})(SplatEditSdfType || {});\nfunction \
sdfTypeToNumber(type) {\n  switch (type) {\n    case \"all\":\n      return \
0;\n    case \"plane\":\n      return 1;\n    case \"sphere\":\n      return \
2;\n    case \"box\":\n      return 3;\n    case \"ellipsoid\":\n      return \
4;\n    case \"cylinder\":\n      return 5;\n    case \"capsule\":\n      \
return 6;\n    case \"infinite_cone\":\n      return 7;\n    default:\n      \
throw new Error(`Unknown SDF type: ${type}`);\n  }\n}\nvar \
SplatEditRgbaBlendMode = /* @__PURE__ */ ((SplatEditRgbaBlendMode2) => {\n  \
SplatEditRgbaBlendMode2[\"MULTIPLY\"] = \"multiply\";\n  \
SplatEditRgbaBlendMode2[\"SET_RGB\"] = \"set_rgb\";\n  \
SplatEditRgbaBlendMode2[\"ADD_RGBA\"] = \"add_rgba\";\n  return \
SplatEditRgbaBlendMode2;\n})(SplatEditRgbaBlendMode || {});\nfunction \
rgbaBlendModeToNumber(mode) {\n  switch (mode) {\n    case \"multiply\":\n    \
  return 0;\n    case \"set_rgb\":\n      return 1;\n    case \"add_rgba\":\n \
     return 2;\n    default:\n      throw new Error(`Unknown blend mode: \
${mode}`);\n  }\n}\nclass SplatEditSdf extends THREE.Object3D {\n  \
constructor(options = {}) {\n    super();\n    const { type, invert, opacity, \
color, displace, radius } = options;\n    this.type = type ?? \"sphere\";\n   \
 this.invert = invert ?? false;\n    this.opacity = opacity ?? 1;\n    \
this.color = color ?? new THREE.Color(1, 1, 1);\n    this.displace = displace \
?? new THREE.Vector3(0, 0, 0);\n    this.radius = radius ?? 0;\n  }\n}\nconst \
_SplatEdit = class _SplatEdit extends THREE.Object3D {\n  constructor(options \
= {}) {\n    const {\n      name,\n      rgbaBlendMode = \"multiply\",\n      \
sdfSmooth = 0,\n      softEdge = 0,\n      invert = false,\n      sdfs = \
null\n    } = options;\n    super();\n    this.rgbaBlendMode = \
rgbaBlendMode;\n    this.sdfSmooth = sdfSmooth;\n    this.softEdge = \
softEdge;\n    this.invert = invert;\n    this.sdfs = sdfs;\n    \
this.ordering = _SplatEdit.nextOrdering++;\n    this.name = name ?? `Edit \
${this.ordering}`;\n  }\n  addSdf(sdf) {\n    if (this.sdfs == null) {\n      \
this.sdfs = [];\n    }\n    if (!this.sdfs.includes(sdf)) {\n      \
this.sdfs.push(sdf);\n    }\n  }\n  removeSdf(sdf) {\n    if (this.sdfs == \
null) {\n      return;\n    }\n    this.sdfs = this.sdfs.filter((s) => s !== \
sdf);\n  }\n};\n_SplatEdit.nextOrdering = 1;\nlet SplatEdit = \
_SplatEdit;\nclass SplatEdits {\n  constructor({ maxSdfs, maxEdits }) {\n    \
this.maxSdfs = Math.max(16, maxSdfs ?? 0);\n    this.numSdfs = 0;\n    \
this.sdfData = new Uint32Array(this.maxSdfs * 8 * 4);\n    this.sdfFloatData \
= new Float32Array(this.sdfData.buffer);\n    this.sdfTexture = \
this.newSdfTexture(this.sdfData, this.maxSdfs);\n    this.dynoSdfArray = new \
DynoUniform({\n      key: \"sdfArray\",\n      type: SdfArray,\n      \
globals: () => [defineSdfArray],\n      value: {\n        numSdfs: 0,\n       \
 sdfTexture: this.sdfTexture\n      },\n      update: (uniform2) => {\n       \
 uniform2.numSdfs = this.numSdfs;\n        uniform2.sdfTexture = \
this.sdfTexture;\n        return uniform2;\n      }\n    });\n    \
this.maxEdits = Math.max(16, maxEdits ?? 0);\n    this.numEdits = 0;\n    \
this.editData = new Uint32Array(this.maxEdits * 4);\n    this.editFloatData = \
new Float32Array(this.editData.buffer);\n    this.dynoNumEdits = new \
DynoInt({ value: 0 });\n    this.dynoEdits = this.newEdits(this.editData, \
this.maxEdits);\n  }\n  newSdfTexture(data, maxSdfs) {\n    const texture2 = \
new THREE.DataTexture(\n      data,\n      8,\n      maxSdfs,\n      \
THREE.RGBAIntegerFormat,\n      THREE.UnsignedIntType\n    );\n    \
texture2.internalFormat = \"RGBA32UI\";\n    texture2.needsUpdate = true;\n   \
 return texture2;\n  }\n  newEdits(data, maxEdits) {\n    return new \
DynoUniform({\n      key: \"edits\",\n      type: \"uvec4\",\n      count: \
maxEdits,\n      globals: () => [defineEdit],\n      value: data\n    });\n  \
}\n  // Ensure our SDF texture and edits uniform array have enough \
capacity.\n  // Reallocate if not.\n  ensureCapacity({\n    maxSdfs,\n    \
maxEdits\n  }) {\n    let dynoUpdated = false;\n    if (maxSdfs > \
this.sdfTexture.image.height) {\n      this.sdfTexture.dispose();\n      \
this.maxSdfs = Math.max(this.maxSdfs * 2, maxSdfs);\n      this.sdfData = new \
Uint32Array(this.maxSdfs * 8 * 4);\n      this.sdfFloatData = new \
Float32Array(this.sdfData.buffer);\n      this.sdfTexture = \
this.newSdfTexture(this.sdfData, this.maxSdfs);\n    }\n    if (maxEdits > \
(this.dynoEdits.count ?? 0)) {\n      this.maxEdits = Math.max(this.maxEdits \
* 2, maxEdits);\n      this.editData = new Uint32Array(this.maxEdits * 4);\n  \
    this.editFloatData = new Float32Array(this.editData.buffer);\n      \
this.dynoEdits = this.newEdits(this.editData, this.maxEdits);\n      \
dynoUpdated = true;\n    }\n    return dynoUpdated;\n  }\n  \
updateEditData(offset, value) {\n    const updated = this.editData[offset] \
!== value;\n    this.editData[offset] = value;\n    return updated;\n  }\n  \
updateEditFloatData(offset, value) {\n    tempFloat32[0] = value;\n    const \
updated = this.editFloatData[offset] !== tempFloat32[0];\n    if (updated) \
{\n      this.editFloatData[offset] = tempFloat32[0];\n    }\n    return \
updated;\n  }\n  encodeEdit(editIndex, {\n    sdfFirst,\n    sdfCount,\n    \
invert,\n    rgbaBlendMode,\n    softEdge,\n    sdfSmooth\n  }) {\n    const \
base = editIndex * 4;\n    let updated = false;\n    updated = \
this.updateEditData(base + 0, rgbaBlendMode | (invert ? 1 << 8 : 0)) || \
updated;\n    updated = this.updateEditData(base + 1, sdfFirst | sdfCount << \
16) || updated;\n    updated = this.updateEditFloatData(base + 2, softEdge) \
|| updated;\n    updated = this.updateEditFloatData(base + 3, sdfSmooth) || \
updated;\n    return updated;\n  }\n  updateSdfData(offset, value) {\n    \
const updated = this.sdfData[offset] !== value;\n    this.sdfData[offset] = \
value;\n    return updated;\n  }\n  updateSdfFloatData(offset, value) {\n    \
tempFloat32[0] = value;\n    const updated = this.sdfFloatData[offset] !== \
tempFloat32[0];\n    if (updated) {\n      this.sdfFloatData[offset] = \
tempFloat32[0];\n    }\n    return updated;\n  }\n  encodeSdf(sdfIndex, {\n   \
 sdfType,\n    invert,\n    center,\n    quaternion,\n    scale,\n    sizes\n \
 }, values) {\n    const base = sdfIndex * (8 * 4);\n    const flags = \
sdfType | (invert ? 1 << 8 : 0);\n    let updated = false;\n    updated = \
this.updateSdfFloatData(base + 0, (center == null ? void 0 : center.x) ?? 0) \
|| updated;\n    updated = this.updateSdfFloatData(base + 1, (center == null \
? void 0 : center.y) ?? 0) || updated;\n    updated = \
this.updateSdfFloatData(base + 2, (center == null ? void 0 : center.z) ?? 0) \
|| updated;\n    updated = this.updateSdfData(base + 3, flags) || updated;\n  \
  updated = this.updateSdfFloatData(base + 4, (quaternion == null ? void 0 : \
quaternion.x) ?? 0) || updated;\n    updated = this.updateSdfFloatData(base + \
5, (quaternion == null ? void 0 : quaternion.y) ?? 0) || updated;\n    \
updated = this.updateSdfFloatData(base + 6, (quaternion == null ? void 0 : \
quaternion.z) ?? 0) || updated;\n    updated = this.updateSdfFloatData(base + \
7, (quaternion == null ? void 0 : quaternion.w) ?? 0) || updated;\n    \
updated = this.updateSdfFloatData(base + 8, (scale == null ? void 0 : \
scale.x) ?? 0) || updated;\n    updated = this.updateSdfFloatData(base + 9, \
(scale == null ? void 0 : scale.y) ?? 0) || updated;\n    updated = \
this.updateSdfFloatData(base + 10, (scale == null ? void 0 : scale.z) ?? 0) \
|| updated;\n    updated = this.updateSdfData(base + 11, 0) || updated;\n    \
updated = this.updateSdfFloatData(base + 12, (sizes == null ? void 0 : \
sizes.x) ?? 0) || updated;\n    updated = this.updateSdfFloatData(base + 13, \
(sizes == null ? void 0 : sizes.y) ?? 0) || updated;\n    updated = \
this.updateSdfFloatData(base + 14, (sizes == null ? void 0 : sizes.z) ?? 0) \
|| updated;\n    updated = this.updateSdfFloatData(base + 15, (sizes == null \
? void 0 : sizes.w) ?? 0) || updated;\n    const nValues = Math.min(4, \
values.length);\n    for (let i = 0; i < nValues; ++i) {\n      const vBase = \
base + 16 + i * 4;\n      updated = this.updateSdfFloatData(vBase + 0, \
values[i].x) || updated;\n      updated = this.updateSdfFloatData(vBase + 1, \
values[i].y) || updated;\n      updated = this.updateSdfFloatData(vBase + 2, \
values[i].z) || updated;\n      updated = this.updateSdfFloatData(vBase + 3, \
values[i].w) || updated;\n    }\n    return updated;\n  }\n  // Update the \
SDFs and edits from an array of SplatEdits and their\n  // associated \
SplatEditSdfs, updating it for the dyno shader program.\n  update(edits) {\n  \
  const sdfCount = edits.reduce((total, { sdfs }) => total + sdfs.length, \
0);\n    const dynoUpdated = this.ensureCapacity({\n      maxEdits: \
edits.length,\n      maxSdfs: sdfCount\n    });\n    const values = [new \
THREE.Vector4(), new THREE.Vector4()];\n    const center = new \
THREE.Vector3();\n    const quaternion = new THREE.Quaternion();\n    const \
scale = new THREE.Vector3();\n    const sizes = new THREE.Vector4();\n    let \
sdfIndex = 0;\n    let updated = dynoUpdated;\n    if (edits.length !== \
this.dynoNumEdits.value) {\n      this.dynoNumEdits.value = edits.length;\n   \
   this.numEdits = edits.length;\n      updated = true;\n    }\n    for \
(const [editIndex, { edit, sdfs }] of edits.entries()) {\n      updated = \
this.encodeEdit(editIndex, {\n        sdfFirst: sdfIndex,\n        sdfCount: \
sdfs.length,\n        invert: edit.invert,\n        rgbaBlendMode: \
rgbaBlendModeToNumber(edit.rgbaBlendMode),\n        softEdge: \
edit.softEdge,\n        sdfSmooth: edit.sdfSmooth\n      }) || updated;\n     \
 let sdfUpdated = false;\n      for (const sdf of sdfs) {\n        \
sizes.set(sdf.scale.x, sdf.scale.y, sdf.scale.z, sdf.radius);\n        \
sdf.scale.setScalar(1);\n        sdf.updateMatrixWorld();\n        const \
worldToSdf = sdf.matrixWorld.clone().invert();\n        \
worldToSdf.decompose(center, quaternion, scale);\n        \
sdf.scale.set(sizes.x, sizes.y, sizes.z);\n        sdf.updateMatrixWorld();\n \
       values[0].set(sdf.color.r, sdf.color.g, sdf.color.b, sdf.opacity);\n   \
     values[1].set(sdf.displace.x, sdf.displace.y, sdf.displace.z, 1);\n      \
  sdfUpdated = this.encodeSdf(\n          sdfIndex,\n          {\n            \
sdfType: sdfTypeToNumber(sdf.type),\n            invert: sdf.invert,\n        \
    center,\n            quaternion,\n            scale,\n            sizes\n \
         },\n          values\n        ) || sdfUpdated;\n        sdfIndex += \
1;\n      }\n      this.numSdfs = sdfIndex;\n      if (sdfUpdated) {\n        \
this.sdfTexture.needsUpdate = true;\n      }\n      updated || (updated = \
sdfUpdated);\n    }\n    return { updated, dynoUpdated };\n  }\n  // Modify a \
Gsplat in a dyno shader program using the current edits and SDFs.\n  \
modify(gsplat) {\n    return applyGsplatRgbaDisplaceEdits(\n      gsplat,\n   \
   this.dynoSdfArray,\n      this.dynoNumEdits,\n      this.dynoEdits\n    \
);\n  }\n}\nconst SdfArray = { type: \"SdfArray\" };\nconst defineSdfArray = \
unindent(`\n  struct SdfArray {\n    int numSdfs;\n    usampler2D \
sdfTexture;\n  };\n\n  void unpackSdfArray(\n    usampler2D sdfTexture, int \
sdfIndex, out uint flags,\n    out vec3 center, out vec4 quaternion, out vec3 \
scale, out vec4 sizes,\n    int numValues, out vec4 values[4]\n  ) {\n    \
uvec4 temp = texelFetch(sdfTexture, ivec2(0, sdfIndex), 0);\n    flags = \
temp.w;\n    center = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), \
uintBitsToFloat(temp.z));\n\n    temp = texelFetch(sdfTexture, ivec2(1, \
sdfIndex), 0);\n    quaternion = vec4(uintBitsToFloat(temp.x), \
uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), \
uintBitsToFloat(temp.w));\n\n    temp = texelFetch(sdfTexture, ivec2(2, \
sdfIndex), 0);\n    scale = vec3(uintBitsToFloat(temp.x), \
uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));\n\n    temp = \
texelFetch(sdfTexture, ivec2(3, sdfIndex), 0);\n    sizes = \
vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), \
uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n\n    for (int i = 0; i < \
numValues; ++i) {\n      temp = texelFetch(sdfTexture, ivec2(4 + i, \
sdfIndex), 0);\n      values[i] = vec4(uintBitsToFloat(temp.x), \
uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n \
   }\n  }\n\n  const uint SDF_FLAG_TYPE = 0xFFu;\n  const uint \
SDF_FLAG_INVERT = 1u << 8u;\n\n  const uint SDF_TYPE_ALL = 0u;\n  const uint \
SDF_TYPE_PLANE = 1u;\n  const uint SDF_TYPE_SPHERE = 2u;\n  const uint \
SDF_TYPE_BOX = 3u;\n  const uint SDF_TYPE_ELLIPSOID = 4u;\n  const uint \
SDF_TYPE_CYLINDER = 5u;\n  const uint SDF_TYPE_CAPSULE = 6u;\n  const uint \
SDF_TYPE_INFINITE_CONE = 7u;\n\n  float evaluateSdfArray(\n    usampler2D \
sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,\n    float \
smoothK, int numValues, out vec4 outValues[4]\n  ) {\n    float distanceAccum \
= (smoothK == 0.0) ? 1.0 / 0.0 : 0.0;\n    float maxExp = -1.0 / 0.0;\n    \
for (int i = 0; i < numValues; ++i) {\n        outValues[i] = vec4(0.0);\n    \
}\n\n    uint flags;\n    vec3 center, scale;\n    vec4 quaternion, sizes;\n  \
  vec4 values[4];\n\n    int sdfLast = min(sdfFirst + sdfCount, numSdfs);\n   \
 for (int index = sdfFirst; index < sdfLast; ++index) {\n      \
unpackSdfArray(sdfTexture, index, flags, center, quaternion, scale, sizes, \
numValues, values);\n      uint sdfType = flags & SDF_FLAG_TYPE;\n      vec3 \
sdfPos = quatVec(quaternion, pos * scale) + center;\n\n      float \
distance;\n      switch (sdfType) {\n        case SDF_TYPE_ALL:\n          \
distance = -1.0 / 0.0;\n          break;\n        case SDF_TYPE_PLANE: {\n    \
      distance = sdfPos.z;\n          break;\n        }\n        case \
SDF_TYPE_SPHERE: {\n          distance = length(sdfPos) - sizes.w;\n          \
break;\n        }\n        case SDF_TYPE_BOX: {\n          vec3 q = \
abs(sdfPos) - sizes.xyz + sizes.w;\n          distance = length(max(q, 0.0)) \
+ min(max(q.x, max(q.y, q.z)), 0.0) - sizes.w;\n          break;\n        }\n \
       case SDF_TYPE_ELLIPSOID: {\n          vec3 sizes = sizes.xyz;\n        \
  float k0 = length(sdfPos / sizes);\n          float k1 = length(sdfPos / \
dot(sizes, sizes));\n          distance = k0 * (k0 - 1.0) / k1;\n          \
break;\n        }\n        case SDF_TYPE_CYLINDER: {\n          vec2 d = \
abs(vec2(length(sdfPos.xz), sdfPos.y)) - sizes.wy;\n          distance = \
min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n          break;\n        }\n \
       case SDF_TYPE_CAPSULE: {\n          sdfPos.y -= clamp(sdfPos.y, -0.5 * \
sizes.y, 0.5 * sizes.y);\n          distance = length(sdfPos) - sizes.w;\n    \
      break;\n        }\n        case SDF_TYPE_INFINITE_CONE: {\n          \
float angle = 0.25 * PI * sizes.w;\n          vec2 c = vec2(sin(angle), \
cos(angle));\n          vec2 q = vec2(length(sdfPos.xy), -sdfPos.z);\n        \
  float d = length(q - c * max(dot(q, c), 0.0));\n          distance = d * \
(((q.x * c.y - q.y * c.x) < 0.0) ? -1.0 : 1.0);\n          break;\n        \
}\n      }\n\n      if ((flags & SDF_FLAG_INVERT) != 0u) {\n        distance \
= -distance;\n      }\n\n      if (smoothK == 0.0) {\n        if (distance < \
distanceAccum) {\n          distanceAccum = distance;\n          for (int i = \
0; i < numValues; ++i) {\n            outValues[i] = values[i];\n          \
}\n        }\n      } else {\n        float scaledDistance = -distance / \
smoothK;\n        if (scaledDistance > maxExp) {\n          float scale = \
exp(maxExp - scaledDistance);\n          distanceAccum *= scale;\n          \
for (int i = 0; i < numValues; ++i) {\n            outValues[i] *= scale;\n   \
       }\n          maxExp = scaledDistance;\n        }\n\n        float \
weight = exp(scaledDistance - maxExp);\n        distanceAccum += weight;\n    \
    for (int i = 0; i < numValues; ++i) {\n          outValues[i] += weight * \
values[i];\n        }\n      }\n    }\n\n    if (smoothK == 0.0) {\n      \
return distanceAccum;\n    } else {\n      // Very distant SDFs may result in \
0 accumulation\n      if (distanceAccum == 0.0) {\n        return 1.0 / \
0.0;\n      }\n      for (int i = 0; i < numValues; ++i) {\n        \
outValues[i] /= distanceAccum;\n      }\n      return (-log(distanceAccum) - \
maxExp) * smoothK;\n    }\n  }\n\n  float modulateSdfArray(\n    usampler2D \
sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,\n    float \
smoothK, int numValues, out vec4 values[4],\n    float softEdge, bool \
invert\n  ) {\n    float distance = evaluateSdfArray(sdfTexture, numSdfs, \
sdfFirst, sdfCount, pos, smoothK, numValues, values);\n    if (invert) {\n    \
  distance = -distance;\n    }\n\n    return (softEdge == 0.0) ? ((distance < \
0.0) ? 1.0 : 0.0)\n      : clamp(-distance / softEdge + 0.5, 0.0, 1.0);\n  \
}\n`);\nconst defineEdit = unindent(`\n  const uint EDIT_FLAG_BLEND = \
0xFFu;\n  const uint EDIT_BLEND_MULTIPLY = 0u;\n  const uint \
EDIT_BLEND_SET_RGB = 1u;\n  const uint EDIT_BLEND_ADD_RGBA = 2u;\n  const \
uint EDIT_FLAG_INVERT = 0x100u;\n\n  void decodeEdit(\n    uvec4 packedEdit, \
out int sdfFirst, out int sdfCount,\n    out bool invert, out uint \
rgbaBlendMode, out float softEdge, out float sdfSmooth\n  ) {\n    \
rgbaBlendMode = packedEdit.x & EDIT_FLAG_BLEND;\n    invert = (packedEdit.x & \
EDIT_FLAG_INVERT) != 0u;\n\n    sdfFirst = int(packedEdit.y & 0xFFFFu);\n    \
sdfCount = int(packedEdit.y >> 16u);\n\n    softEdge = \
uintBitsToFloat(packedEdit.z);\n    sdfSmooth = \
uintBitsToFloat(packedEdit.w);\n  }\n\n  void applyRgbaDisplaceEdit(\n    \
usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, inout vec3 \
pos,\n    float smoothK, float softEdge, bool invert, uint rgbaBlendMode, \
inout vec4 rgba\n  ) {\n    vec4 values[4];\n    float modulate = \
modulateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, 2, \
values, softEdge, invert);\n    // On Android, moving values[0] is necessary \
to work around a compiler bug.\n    vec4 sdfRgba = values[0];\n    vec4 \
sdfDisplaceScale = values[1];\n\n    vec4 target;\n    switch (rgbaBlendMode) \
{\n      case EDIT_BLEND_MULTIPLY:\n        target = rgba * sdfRgba;\n        \
break;\n      case EDIT_BLEND_SET_RGB:\n        target = vec4(sdfRgba.rgb, \
rgba.a * sdfRgba.a);\n        break;\n      case EDIT_BLEND_ADD_RGBA:\n       \
 target = rgba + sdfRgba;\n        break;\n      default:\n        // Debug \
output if blend mode not set\n        target = vec4(fract(pos), 1.0);\n    \
}\n    rgba = mix(rgba, target, modulate);\n    pos += sdfDisplaceScale.xyz * \
modulate;\n  }\n\n  void applyPackedRgbaDisplaceEdit(uvec4 packedEdit, \
usampler2D sdfTexture, int numSdfs, inout vec3 pos, inout vec4 rgba) {\n    \
int sdfFirst, sdfCount;\n    bool invert;\n    uint rgbaBlendMode;\n    float \
softEdge, sdfSmooth;\n    decodeEdit(packedEdit, sdfFirst, sdfCount, invert, \
rgbaBlendMode, softEdge, sdfSmooth);\n    applyRgbaDisplaceEdit(sdfTexture, \
numSdfs, sdfFirst, sdfCount, pos, sdfSmooth, softEdge, invert, rgbaBlendMode, \
rgba);\n  }\n`);\nfunction applyGsplatRgbaDisplaceEdits(gsplat, sdfArray, \
numEdits, rgbaDisplaceEdits) {\n  const dyno2 = new Dyno({\n    inTypes: {\n  \
    gsplat: Gsplat,\n      sdfArray: SdfArray,\n      numEdits: \"int\",\n    \
  rgbaDisplaceEdits: \"uvec4\"\n    },\n    outTypes: { gsplat: Gsplat },\n   \
 globals: () => [defineSdfArray, defineEdit],\n    inputs: { gsplat, \
sdfArray, numEdits, rgbaDisplaceEdits },\n    statements: ({ inputs, outputs \
}) => {\n      const { sdfArray: sdfArray2, numEdits: numEdits2, \
rgbaDisplaceEdits: rgbaDisplaceEdits2 } = inputs;\n      const { gsplat: \
gsplat2 } = outputs;\n      return unindentLines(`\n        ${gsplat2} = \
${inputs.gsplat};\n        if (isGsplatActive(${gsplat2}.flags)) {\n          \
for (int editIndex = 0; editIndex < ${numEdits2}; ++editIndex) {\n            \
applyPackedRgbaDisplaceEdit(\n              ${rgbaDisplaceEdits2}[editIndex], \
${sdfArray2}.sdfTexture, ${sdfArray2}.numSdfs,\n              \
${gsplat2}.center, ${gsplat2}.rgba\n            );\n          }\n        }\n  \
    `);\n    }\n  });\n  return dyno2.outputs.gsplat;\n}\nconst tempFloat32 = \
new Float32Array(1);\nclass SplatModifier {\n  constructor(modifier) {\n    \
this.modifier = modifier;\n    this.cache = /* @__PURE__ */ new Map();\n  }\n \
 apply(generator) {\n    let modified = this.cache.get(generator);\n    if \
(!modified) {\n      modified = dynoBlock(\n        { index: \"int\" },\n     \
   { gsplat: Gsplat },\n        ({ index }) => {\n          const { gsplat } \
= generator.apply({ index });\n          return this.modifier.apply({ gsplat \
});\n        }\n      );\n      this.cache.set(generator, modified);\n    }\n \
   return modified;\n  }\n}\nclass SplatTransformer {\n  // Create the dyno \
uniforms that parameterize the transform, setting them\n  // to initial \
values that are different from any valid transform.\n  constructor() {\n    \
this.scale = new DynoFloat({ value: Number.NEGATIVE_INFINITY });\n    \
this.rotate = new DynoVec4({\n      value: new THREE.Quaternion(\n        \
Number.POSITIVE_INFINITY,\n        Number.POSITIVE_INFINITY,\n        \
Number.POSITIVE_INFINITY,\n        Number.POSITIVE_INFINITY\n      )\n    \
});\n    this.translate = new DynoVec3({\n      value: new THREE.Vector3(\n   \
     Number.POSITIVE_INFINITY,\n        Number.POSITIVE_INFINITY,\n        \
Number.POSITIVE_INFINITY\n      )\n    });\n  }\n  // Apply the transform to \
a Vec3 position in a dyno program.\n  apply(position) {\n    return \
transformPos(position, {\n      scale: this.scale,\n      rotate: \
this.rotate,\n      translate: this.translate\n    });\n  }\n  applyDir(dir) \
{\n    return transformDir(dir, {\n      rotate: this.rotate\n    });\n  }\n  \
// Apply the transform to a Gsplat in a dyno program.\n  applyGsplat(gsplat) \
{\n    return transformGsplat(gsplat, {\n      scale: this.scale,\n      \
rotate: this.rotate,\n      translate: this.translate\n    });\n  }\n  // \
Update the uniforms to match the given transform matrix.\n  \
updateFromMatrix(transform) {\n    const scale = new THREE.Vector3();\n    \
const quaternion = new THREE.Quaternion();\n    const position = new \
THREE.Vector3();\n    transform.decompose(position, quaternion, scale);\n    \
const newScale = (scale.x + scale.y + scale.z) / 3;\n    let updated = \
false;\n    if (newScale !== this.scale.value) {\n      this.scale.value = \
newScale;\n      updated = true;\n    }\n    if \
(!position.equals(this.translate.value)) {\n      \
this.translate.value.copy(position);\n      updated = true;\n    }\n    if \
(!quaternion.equals(this.rotate.value)) {\n      \
this.rotate.value.copy(quaternion);\n      updated = true;\n    }\n    return \
updated;\n  }\n  // Update this transform to match the object's to-world \
transform.\n  update(object) {\n    object.updateMatrixWorld();\n    return \
this.updateFromMatrix(object.matrixWorld);\n  }\n}\nclass SplatGenerator \
extends THREE.Object3D {\n  constructor({\n    numSplats,\n    generator,\n   \
 construct,\n    update\n  }) {\n    super();\n    this.numSplats = numSplats \
?? 0;\n    this.generator = generator;\n    this.frameUpdate = update;\n    \
this.version = 0;\n    if (construct) {\n      const constructed = \
construct(this);\n      Object.assign(this, constructed);\n    }\n  }\n  \
updateVersion() {\n    this.version += 1;\n  }\n  set needsUpdate(value) {\n  \
  if (value) {\n      this.updateVersion();\n    }\n  }\n}\nconst _SplatMesh \
= class _SplatMesh extends SplatGenerator {\n  constructor(options = {}) {\n  \
  const transform = new SplatTransformer();\n    const viewToWorld = new \
SplatTransformer();\n    const worldToView = new SplatTransformer();\n    \
const viewToObject = new SplatTransformer();\n    const recolor = new \
DynoVec4({\n      value: new THREE.Vector4(\n        \
Number.NEGATIVE_INFINITY,\n        Number.NEGATIVE_INFINITY,\n        \
Number.NEGATIVE_INFINITY,\n        Number.NEGATIVE_INFINITY\n      )\n    \
});\n    const time = new DynoFloat({ value: 0 });\n    const deltaTime = new \
DynoFloat({ value: 0 });\n    const context = {\n      transform,\n      \
viewToWorld,\n      worldToView,\n      viewToObject,\n      recolor,\n      \
time,\n      deltaTime\n    };\n    super({\n      update: ({ time: time2, \
deltaTime: deltaTime2, viewToWorld: viewToWorld2, globalEdits }) => \
this.update({ time: time2, deltaTime: deltaTime2, viewToWorld: viewToWorld2, \
globalEdits })\n    });\n    this.isInitialized = false;\n    this.recolor = \
new THREE.Color(1, 1, 1);\n    this.opacity = 1;\n    this.enableViewToObject \
= false;\n    this.enableViewToWorld = false;\n    this.enableWorldToView = \
false;\n    this.skinning = null;\n    this.edits = null;\n    \
this.rgbaDisplaceEdits = null;\n    this.splatRgba = null;\n    this.maxSh = \
3;\n    this.packedSplats = options.packedSplats ?? new PackedSplats();\n    \
this.packedSplats.splatEncoding = options.splatEncoding ?? {\n      \
...DEFAULT_SPLAT_ENCODING\n    };\n    this.numSplats = \
this.packedSplats.numSplats;\n    this.editable = options.editable ?? true;\n \
   this.onFrame = options.onFrame;\n    this.context = context;\n    \
this.objectModifier = options.objectModifier;\n    this.worldModifier = \
options.worldModifier;\n    this.updateGenerator();\n    if (options.url || \
options.fileBytes || options.constructSplats || options.packedSplats && \
!options.packedSplats.isInitialized) {\n      this.initialized = \
this.asyncInitialize(options).then(async () => {\n        \
this.updateGenerator();\n        this.isInitialized = true;\n        if \
(options.onLoad) {\n          const maybePromise = options.onLoad(this);\n    \
      if (maybePromise instanceof Promise) {\n            await \
maybePromise;\n          }\n        }\n        return this;\n      });\n    } \
else {\n      this.isInitialized = true;\n      this.initialized = \
Promise.resolve(this);\n      if (options.onLoad) {\n        const \
maybePromise = options.onLoad(this);\n        if (maybePromise instanceof \
Promise) {\n          this.initialized = maybePromise.then(() => this);\n     \
   }\n      }\n    }\n    this.add(createRendererDetectionMesh());\n  }\n  \
async asyncInitialize(options) {\n    const {\n      url,\n      fileBytes,\n \
     fileType,\n      fileName,\n      maxSplats,\n      constructSplats,\n   \
   splatEncoding\n    } = options;\n    if (url || fileBytes || \
constructSplats) {\n      const packedSplatsOptions = {\n        url,\n       \
 fileBytes,\n        fileType,\n        fileName,\n        maxSplats,\n       \
 construct: constructSplats,\n        splatEncoding\n      };\n      \
this.packedSplats.reinitialize(packedSplatsOptions);\n    }\n    if \
(this.packedSplats) {\n      await this.packedSplats.initialized;\n      \
this.numSplats = this.packedSplats.numSplats;\n      \
this.updateGenerator();\n    }\n  }\n  static async staticInitialize() {\n    \
await __wbg_init();\n    _SplatMesh.isStaticInitialized = true;\n  }\n  // \
Creates a new Gsplat with the provided parameters (all values in \"float\" \
space,\n  // i.e. 0-1 for opacity and color) and adds it to the end of the \
packedSplats,\n  // increasing numSplats by 1. If necessary, reallocates the \
buffer with an exponential\n  // doubling strategy to fit the new data, so \
it's fairly efficient to just\n  // pushSplat(...) each Gsplat you want to \
create in a loop.\n  pushSplat(center, scales, quaternion, opacity, color) \
{\n    this.packedSplats.pushSplat(center, scales, quaternion, opacity, \
color);\n  }\n  // This method iterates over all Gsplats in this instance's \
packedSplats,\n  // invoking the provided callback with index: number in \
0..=(this.numSplats-1) and\n  // center: THREE.Vector3, scales: \
THREE.Vector3, quaternion: THREE.Quaternion,\n  // opacity: number (0..1), \
and color: THREE.Color (rgb values in 0..1).\n  // Note that the objects \
passed in as center etc. are the same for every callback\n  // invocation: \
these objects are reused for efficiency. Changing these values has\n  // no \
effect as they are decoded/unpacked copies of the underlying data. To \
update\n  // the packedSplats, call .packedSplats.setSplat(index, center, \
scales,\n  // quaternion, opacity, color).\n  forEachSplat(callback) {\n    \
this.packedSplats.forEachSplat(callback);\n  }\n  // Call this when you are \
finished with the SplatMesh and want to free\n  // any buffers it holds (via \
packedSplats).\n  dispose() {\n    this.packedSplats.dispose();\n  }\n  // \
Returns axis-aligned bounding box of the SplatMesh. If centers_only is \
true,\n  // only the centers of the splats are used to compute the bounding \
box.\n  // IMPORTANT: This should only be called after the SplatMesh is \
initialized.\n  getBoundingBox(centers_only = true) {\n    if \
(!this.initialized) {\n      throw new Error(\n        \"Cannot get bounding \
box before SplatMesh is initialized\"\n      );\n    }\n    const minVec = \
new THREE.Vector3(\n      Number.POSITIVE_INFINITY,\n      \
Number.POSITIVE_INFINITY,\n      Number.POSITIVE_INFINITY\n    );\n    const \
maxVec = new THREE.Vector3(\n      Number.NEGATIVE_INFINITY,\n      \
Number.NEGATIVE_INFINITY,\n      Number.NEGATIVE_INFINITY\n    );\n    const \
corners = new THREE.Vector3();\n    const signs = [-1, 1];\n    \
this.packedSplats.forEachSplat(\n      (_index, center, scales, quaternion, \
_opacity, _color) => {\n        if (centers_only) {\n          \
minVec.min(center);\n          maxVec.max(center);\n        } else {\n        \
  for (const x of signs) {\n            for (const y of signs) {\n            \
  for (const z of signs) {\n                corners.set(x * scales.x, y * \
scales.y, z * scales.z);\n                \
corners.applyQuaternion(quaternion);\n                corners.add(center);\n  \
              minVec.min(corners);\n                maxVec.max(corners);\n    \
          }\n            }\n          }\n        }\n      }\n    );\n    \
const box = new THREE.Box3(minVec, maxVec);\n    return box;\n  }\n  \
constructGenerator(context) {\n    const { transform, viewToObject, recolor } \
= context;\n    const generator = dynoBlock(\n      { index: \"int\" },\n     \
 { gsplat: Gsplat },\n      ({ index }) => {\n        if (!index) {\n         \
 throw new Error(\"index is undefined\");\n        }\n        let gsplat = \
readPackedSplat(this.packedSplats.dyno, index);\n        if (this.maxSh >= 1) \
{\n          const { sh1Texture, sh2Texture, sh3Texture } = \
this.ensureShTextures();\n          if (sh1Texture) {\n            let \
rescaleSh = function(sNorm, minMax) {\n              const { x: min2, y: max2 \
} = split(minMax).outputs;\n              const mid = mul(add(min2, max2), \
dynoConst(\"float\", 0.5));\n              const scale = mul(sub(max2, min2), \
dynoConst(\"float\", 0.5));\n              return add(mid, mul(sNorm, \
scale));\n            };\n            const viewCenterInObject = \
viewToObject.translate;\n            const { center } = \
splitGsplat(gsplat).outputs;\n            const viewDir = \
normalize(sub(center, viewCenterInObject));\n            const sh1Snorm = \
evaluateSH1(gsplat, sh1Texture, viewDir);\n            let rgb = \
rescaleSh(sh1Snorm, this.packedSplats.dynoSh1MinMax);\n            if \
(this.maxSh >= 2 && sh2Texture) {\n              const sh2Snorm = \
evaluateSH2(gsplat, sh2Texture, viewDir);\n              rgb = add(\n         \
       rgb,\n                rescaleSh(sh2Snorm, \
this.packedSplats.dynoSh2MinMax)\n              );\n            }\n           \
 if (this.maxSh >= 3 && sh3Texture) {\n              const sh3Snorm = \
evaluateSH3(gsplat, sh3Texture, viewDir);\n              rgb = add(\n         \
       rgb,\n                rescaleSh(sh3Snorm, \
this.packedSplats.dynoSh3MinMax)\n              );\n            }\n           \
 let { rgba } = splitGsplat(gsplat).outputs;\n            rgba = add(rgba, \
extendVec(rgb, dynoConst(\"float\", 0)));\n            gsplat = \
combineGsplat({ gsplat, rgba });\n          }\n        }\n        if \
(this.splatRgba) {\n          const rgba = readRgbaArray(this.splatRgba.dyno, \
index);\n          gsplat = combineGsplat({ gsplat, rgba });\n        }\n     \
   if (this.skinning) {\n          gsplat = this.skinning.modify(gsplat);\n   \
     }\n        if (this.objectModifier) {\n          gsplat = \
this.objectModifier.apply({ gsplat }).gsplat;\n        }\n        gsplat = \
transform.applyGsplat(gsplat);\n        const recolorRgba = mul(recolor, \
splitGsplat(gsplat).outputs.rgba);\n        gsplat = combineGsplat({ gsplat, \
rgba: recolorRgba });\n        if (this.rgbaDisplaceEdits) {\n          \
gsplat = this.rgbaDisplaceEdits.modify(gsplat);\n        }\n        if \
(this.worldModifier) {\n          gsplat = this.worldModifier.apply({ gsplat \
}).gsplat;\n        }\n        return { gsplat };\n      }\n    );\n    \
this.generator = generator;\n  }\n  // Call this whenever something changes \
in the Gsplat processing pipeline,\n  // for example changing maxSh or \
updating objectModifier or worldModifier.\n  // Compiled generators are \
cached for efficiency and re-use when the same\n  // pipeline structure \
emerges after successive changes.\n  updateGenerator() {\n    \
this.constructGenerator(this.context);\n  }\n  // This is called \
automatically by SparkRenderer and you should not have to\n  // call it. It \
updates parameters for the generated pipeline and calls\n  // \
updateGenerator() if the pipeline needs to change.\n  update({\n    time,\n   \
 viewToWorld,\n    deltaTime,\n    globalEdits\n  }) {\n    var _a2;\n    \
this.numSplats = this.packedSplats.numSplats;\n    this.context.time.value = \
time;\n    this.context.deltaTime.value = deltaTime;\n    \
_SplatMesh.dynoTime.value = time;\n    const { transform, viewToObject, \
recolor } = this.context;\n    let updated = transform.update(this);\n    if \
(this.context.viewToWorld.updateFromMatrix(viewToWorld) && \
this.enableViewToWorld) {\n      updated = true;\n    }\n    const \
worldToView = viewToWorld.clone().invert();\n    if \
(this.context.worldToView.updateFromMatrix(worldToView) && \
this.enableWorldToView) {\n      updated = true;\n    }\n    const \
objectToWorld = new THREE.Matrix4().compose(\n      \
transform.translate.value,\n      transform.rotate.value,\n      new \
THREE.Vector3().setScalar(transform.scale.value)\n    );\n    const \
worldToObject = objectToWorld.invert();\n    const viewToObjectMatrix = \
worldToObject.multiply(viewToWorld);\n    if \
(viewToObject.updateFromMatrix(viewToObjectMatrix) && \
(this.enableViewToObject || this.packedSplats.extra.sh1)) {\n      updated = \
true;\n    }\n    const newRecolor = new THREE.Vector4(\n      \
this.recolor.r,\n      this.recolor.g,\n      this.recolor.b,\n      \
this.opacity\n    );\n    if (!newRecolor.equals(recolor.value)) {\n      \
recolor.value.copy(newRecolor);\n      updated = true;\n    }\n    const \
edits = this.editable ? (this.edits ?? []).concat(globalEdits) : [];\n    if \
(this.editable && !this.edits) {\n      this.traverseVisible((node) => {\n    \
    if (node instanceof SplatEdit) {\n          edits.push(node);\n        \
}\n      });\n    }\n    edits.sort((a, b) => a.ordering - b.ordering);\n    \
const editsSdfs = edits.map((edit) => {\n      if (edit.sdfs != null) {\n     \
   return { edit, sdfs: edit.sdfs };\n      }\n      const sdfs = [];\n      \
edit.traverseVisible((node) => {\n        if (node instanceof SplatEditSdf) \
{\n          sdfs.push(node);\n        }\n      });\n      return { edit, \
sdfs };\n    });\n    if (editsSdfs.length > 0 && !this.rgbaDisplaceEdits) \
{\n      const edits2 = editsSdfs.length;\n      const sdfs = \
editsSdfs.reduce(\n        (total, edit) => total + edit.sdfs.length,\n       \
 0\n      );\n      this.rgbaDisplaceEdits = new SplatEdits({\n        \
maxEdits: edits2,\n        maxSdfs: sdfs\n      });\n      \
this.updateGenerator();\n    }\n    if (this.rgbaDisplaceEdits) {\n      \
const editResult = this.rgbaDisplaceEdits.update(editsSdfs);\n      updated \
|| (updated = editResult.updated);\n      if (editResult.dynoUpdated) {\n     \
   this.updateGenerator();\n      }\n    }\n    if (updated) {\n      \
this.updateVersion();\n    }\n    (_a2 = this.onFrame) == null ? void 0 : \
_a2.call(this, { mesh: this, time, deltaTime });\n  }\n  // This method \
conforms to the standard THREE.Raycaster API, performing object-ray\n  // \
intersections using this method to populate the provided intersects[] array\n \
 // with each intersection point.\n  raycast(raycaster, intersects) {\n    \
var _a2, _b2;\n    if (!this.packedSplats.packedArray || \
!this.packedSplats.numSplats) {\n      return;\n    }\n    const { near, far, \
ray } = raycaster;\n    const worldToMesh = \
this.matrixWorld.clone().invert();\n    const worldToMeshRot = new \
THREE.Matrix3().setFromMatrix4(worldToMesh);\n    const origin = \
ray.origin.clone().applyMatrix4(worldToMesh);\n    const direction = \
ray.direction.clone().applyMatrix3(worldToMeshRot);\n    const scales = new \
THREE.Vector3();\n    worldToMesh.decompose(new THREE.Vector3(), new \
THREE.Quaternion(), scales);\n    (scales.x * scales.y * scales.z) ** (1 / \
3);\n    const RAYCAST_ELLIPSOID = true;\n    const distances = \
raycast_splats(\n      origin.x,\n      origin.y,\n      origin.z,\n      \
direction.x,\n      direction.y,\n      direction.z,\n      near,\n      \
far,\n      this.packedSplats.numSplats,\n      \
this.packedSplats.packedArray,\n      RAYCAST_ELLIPSOID,\n      ((_a2 = \
this.packedSplats.splatEncoding) == null ? void 0 : _a2.lnScaleMin) ?? \
LN_SCALE_MIN,\n      ((_b2 = this.packedSplats.splatEncoding) == null ? void \
0 : _b2.lnScaleMax) ?? LN_SCALE_MAX\n    );\n    for (const distance2 of \
distances) {\n      const point = \
ray.direction.clone().multiplyScalar(distance2).add(ray.origin);\n      \
intersects.push({\n        distance: distance2,\n        point,\n        \
object: this\n      });\n    }\n  }\n  ensureShTextures() {\n    if \
(!this.packedSplats.extra.sh1) {\n      return {};\n    }\n    let sh1Texture \
= this.packedSplats.extra.sh1Texture;\n    if (!sh1Texture) {\n      let sh1 \
= this.packedSplats.extra.sh1;\n      const { width, height, depth, maxSplats \
} = getTextureSize(\n        sh1.length / 2\n      );\n      if (sh1.length < \
maxSplats * 2) {\n        const newSh1 = new Uint32Array(maxSplats * 2);\n    \
    newSh1.set(sh1);\n        this.packedSplats.extra.sh1 = newSh1;\n        \
sh1 = newSh1;\n      }\n      const texture2 = new \
THREE.DataArrayTexture(sh1, width, height, depth);\n      texture2.format = \
THREE.RGIntegerFormat;\n      texture2.type = THREE.UnsignedIntType;\n      \
texture2.internalFormat = \"RG32UI\";\n      texture2.needsUpdate = true;\n   \
   sh1Texture = new DynoUsampler2DArray({\n        value: texture2,\n        \
key: \"sh1\"\n      });\n      this.packedSplats.extra.sh1Texture = \
sh1Texture;\n    }\n    if (!this.packedSplats.extra.sh2) {\n      return { \
sh1Texture };\n    }\n    let sh2Texture = \
this.packedSplats.extra.sh2Texture;\n    if (!sh2Texture) {\n      let sh2 = \
this.packedSplats.extra.sh2;\n      const { width, height, depth, maxSplats } \
= getTextureSize(\n        sh2.length / 4\n      );\n      if (sh2.length < \
maxSplats * 4) {\n        const newSh2 = new Uint32Array(maxSplats * 4);\n    \
    newSh2.set(sh2);\n        this.packedSplats.extra.sh2 = newSh2;\n        \
sh2 = newSh2;\n      }\n      const texture2 = new \
THREE.DataArrayTexture(sh2, width, height, depth);\n      texture2.format = \
THREE.RGBAIntegerFormat;\n      texture2.type = THREE.UnsignedIntType;\n      \
texture2.internalFormat = \"RGBA32UI\";\n      texture2.needsUpdate = true;\n \
     sh2Texture = new DynoUsampler2DArray({\n        value: texture2,\n       \
 key: \"sh2\"\n      });\n      this.packedSplats.extra.sh2Texture = \
sh2Texture;\n    }\n    if (!this.packedSplats.extra.sh3) {\n      return { \
sh1Texture, sh2Texture };\n    }\n    let sh3Texture = \
this.packedSplats.extra.sh3Texture;\n    if (!sh3Texture) {\n      let sh3 = \
this.packedSplats.extra.sh3;\n      const { width, height, depth, maxSplats } \
= getTextureSize(\n        sh3.length / 4\n      );\n      if (sh3.length < \
maxSplats * 4) {\n        const newSh3 = new Uint32Array(maxSplats * 4);\n    \
    newSh3.set(sh3);\n        this.packedSplats.extra.sh3 = newSh3;\n        \
sh3 = newSh3;\n      }\n      const texture2 = new \
THREE.DataArrayTexture(sh3, width, height, depth);\n      texture2.format = \
THREE.RGBAIntegerFormat;\n      texture2.type = THREE.UnsignedIntType;\n      \
texture2.internalFormat = \"RGBA32UI\";\n      texture2.needsUpdate = true;\n \
     sh3Texture = new DynoUsampler2DArray({\n        value: texture2,\n       \
 key: \"sh3\"\n      });\n      this.packedSplats.extra.sh3Texture = \
sh3Texture;\n    }\n    return { sh1Texture, sh2Texture, sh3Texture };\n  \
}\n};\n_SplatMesh.staticInitialized = \
_SplatMesh.staticInitialize();\n_SplatMesh.isStaticInitialized = \
false;\n_SplatMesh.dynoTime = new DynoFloat({ value: 0 });\nlet SplatMesh = \
_SplatMesh;\nconst defineEvaluateSH1 = unindent(`\n  vec3 evaluateSH1(Gsplat \
gsplat, usampler2DArray sh1, vec3 viewDir) {\n    // Extract sint7 values \
packed into 2 x uint32\n    uvec2 packed = texelFetch(sh1, \
splatTexCoord(gsplat.index), 0).rg;\n    vec3 sh1_0 = vec3(ivec3(\n      \
int(packed.x << 25u) >> 25,\n      int(packed.x << 18u) >> 25,\n      \
int(packed.x << 11u) >> 25\n    )) / 63.0;\n    vec3 sh1_1 = vec3(ivec3(\n    \
  int(packed.x << 4u) >> 25,\n      int((packed.x >> 3u) | (packed.y << 29u)) \
>> 25,\n      int(packed.y << 22u) >> 25\n    )) / 63.0;\n    vec3 sh1_2 = \
vec3(ivec3(\n      int(packed.y << 15u) >> 25,\n      int(packed.y << 8u) >> \
25,\n      int(packed.y << 1u) >> 25\n    )) / 63.0;\n\n    return sh1_0 * \
(-0.4886025 * viewDir.y)\n      + sh1_1 * (0.4886025 * viewDir.z)\n      + \
sh1_2 * (-0.4886025 * viewDir.x);\n  }\n`);\nconst defineEvaluateSH2 = \
unindent(`\n  vec3 evaluateSH2(Gsplat gsplat, usampler2DArray sh2, vec3 \
viewDir) {\n    // Extract sint8 values packed into 4 x uint32\n    uvec4 \
packed = texelFetch(sh2, splatTexCoord(gsplat.index), 0);\n    vec3 sh2_0 = \
vec3(ivec3(\n      int(packed.x << 24u) >> 24,\n      int(packed.x << 16u) >> \
24,\n      int(packed.x << 8u) >> 24\n    )) / 127.0;\n    vec3 sh2_1 = \
vec3(ivec3(\n      int(packed.x) >> 24,\n      int(packed.y << 24u) >> 24,\n  \
    int(packed.y << 16u) >> 24\n    )) / 127.0;\n    vec3 sh2_2 = \
vec3(ivec3(\n      int(packed.y << 8u) >> 24,\n      int(packed.y) >> 24,\n   \
   int(packed.z << 24u) >> 24\n    )) / 127.0;\n    vec3 sh2_3 = \
vec3(ivec3(\n      int(packed.z << 16u) >> 24,\n      int(packed.z << 8u) >> \
24,\n      int(packed.z) >> 24\n    )) / 127.0;\n    vec3 sh2_4 = \
vec3(ivec3(\n      int(packed.w << 24u) >> 24,\n      int(packed.w << 16u) >> \
24,\n      int(packed.w << 8u) >> 24\n    )) / 127.0;\n\n    return sh2_0 * \
(1.0925484 * viewDir.x * viewDir.y)\n      + sh2_1 * (-1.0925484 * viewDir.y \
* viewDir.z)\n      + sh2_2 * (0.3153915 * (2.0 * viewDir.z * viewDir.z - \
viewDir.x * viewDir.x - viewDir.y * viewDir.y))\n      + sh2_3 * (-1.0925484 \
* viewDir.x * viewDir.z)\n      + sh2_4 * (0.5462742 * (viewDir.x * viewDir.x \
- viewDir.y * viewDir.y));\n  }\n`);\nconst defineEvaluateSH3 = unindent(`\n  \
vec3 evaluateSH3(Gsplat gsplat, usampler2DArray sh3, vec3 viewDir) {\n    // \
Extract sint6 values packed into 4 x uint32\n    uvec4 packed = \
texelFetch(sh3, splatTexCoord(gsplat.index), 0);\n    vec3 sh3_0 = \
vec3(ivec3(\n      int(packed.x << 26u) >> 26,\n      int(packed.x << 20u) >> \
26,\n      int(packed.x << 14u) >> 26\n    )) / 31.0;\n    vec3 sh3_1 = \
vec3(ivec3(\n      int(packed.x << 8u) >> 26,\n      int(packed.x << 2u) >> \
26,\n      int((packed.x >> 4u) | (packed.y << 28u)) >> 26\n    )) / 31.0;\n  \
  vec3 sh3_2 = vec3(ivec3(\n      int(packed.y << 22u) >> 26,\n      \
int(packed.y << 16u) >> 26,\n      int(packed.y << 10u) >> 26\n    )) / \
31.0;\n    vec3 sh3_3 = vec3(ivec3(\n      int(packed.y << 4u) >> 26,\n      \
int((packed.y >> 2u) | (packed.z << 30u)) >> 26,\n      int(packed.z << 24u) \
>> 26\n    )) / 31.0;\n    vec3 sh3_4 = vec3(ivec3(\n      int(packed.z << \
18u) >> 26,\n      int(packed.z << 12u) >> 26,\n      int(packed.z << 6u) >> \
26\n    )) / 31.0;\n    vec3 sh3_5 = vec3(ivec3(\n      int(packed.z) >> \
26,\n      int(packed.w << 26u) >> 26,\n      int(packed.w << 20u) >> 26\n    \
)) / 31.0;\n    vec3 sh3_6 = vec3(ivec3(\n      int(packed.w << 14u) >> 26,\n \
     int(packed.w << 8u) >> 26,\n      int(packed.w << 2u) >> 26\n    )) / \
31.0;\n\n    float xx = viewDir.x * viewDir.x;\n    float yy = viewDir.y * \
viewDir.y;\n    float zz = viewDir.z * viewDir.z;\n    float xy = viewDir.x * \
viewDir.y;\n    float yz = viewDir.y * viewDir.z;\n    float zx = viewDir.z * \
viewDir.x;\n\n    return sh3_0 * (-0.5900436 * viewDir.y * (3.0 * xx - yy))\n \
     + sh3_1 * (2.8906114 * xy * viewDir.z) +\n      + sh3_2 * (-0.4570458 * \
viewDir.y * (4.0 * zz - xx - yy))\n      + sh3_3 * (0.3731763 * viewDir.z * \
(2.0 * zz - 3.0 * xx - 3.0 * yy))\n      + sh3_4 * (-0.4570458 * viewDir.x * \
(4.0 * zz - xx - yy))\n      + sh3_5 * (1.4453057 * viewDir.z * (xx - yy))\n  \
    + sh3_6 * (-0.5900436 * viewDir.x * (xx - 3.0 * yy));\n  }\n`);\nfunction \
evaluateSH1(gsplat, sh1, viewDir) {\n  return dyno$1({\n    inTypes: { \
gsplat: Gsplat, sh1: \"usampler2DArray\", viewDir: \"vec3\" },\n    outTypes: \
{ rgb: \"vec3\" },\n    inputs: { gsplat, sh1, viewDir },\n    globals: () => \
[defineGsplat, defineEvaluateSH1],\n    statements: ({ inputs, outputs }) => \
{\n      const statements = unindentLines(`\n        if \
(isGsplatActive(${inputs.gsplat}.flags)) {\n          ${outputs.rgb} = \
evaluateSH1(${inputs.gsplat}, ${inputs.sh1}, ${inputs.viewDir});\n        } \
else {\n          ${outputs.rgb} = vec3(0.0);\n        }\n      `);\n      \
return statements;\n    }\n  }).outputs.rgb;\n}\nfunction evaluateSH2(gsplat, \
sh2, viewDir) {\n  return dyno$1({\n    inTypes: { gsplat: Gsplat, sh2: \
\"usampler2DArray\", viewDir: \"vec3\" },\n    outTypes: { rgb: \"vec3\" },\n \
   inputs: { gsplat, sh2, viewDir },\n    globals: () => [defineGsplat, \
defineEvaluateSH2],\n    statements: ({ inputs, outputs }) => \
unindentLines(`\n        if (isGsplatActive(${inputs.gsplat}.flags)) {\n      \
    ${outputs.rgb} = evaluateSH2(${inputs.gsplat}, ${inputs.sh2}, \
${inputs.viewDir});\n        } else {\n          ${outputs.rgb} = \
vec3(0.0);\n        }\n      `)\n  }).outputs.rgb;\n}\nfunction \
evaluateSH3(gsplat, sh3, viewDir) {\n  return dyno$1({\n    inTypes: { \
gsplat: Gsplat, sh3: \"usampler2DArray\", viewDir: \"vec3\" },\n    outTypes: \
{ rgb: \"vec3\" },\n    inputs: { gsplat, sh3, viewDir },\n    globals: () => \
[defineGsplat, defineEvaluateSH3],\n    statements: ({ inputs, outputs }) => \
unindentLines(`\n        if (isGsplatActive(${inputs.gsplat}.flags)) {\n      \
    ${outputs.rgb} = evaluateSH3(${inputs.gsplat}, ${inputs.sh3}, \
${inputs.viewDir});\n        } else {\n          ${outputs.rgb} = \
vec3(0.0);\n        }\n      `)\n  }).outputs.rgb;\n}\nconst EMPTY_GEOMETRY$1 \
= new THREE.BufferGeometry();\nconst EMPTY_MATERIAL = new \
THREE.ShaderMaterial();\nfunction createRendererDetectionMesh() {\n  const \
mesh = new THREE.Mesh(EMPTY_GEOMETRY$1, EMPTY_MATERIAL);\n  \
mesh.frustumCulled = false;\n  mesh.onBeforeRender = function(renderer, \
scene) {\n    if (!scene.isScene) {\n      this.removeFromParent();\n      \
return;\n    }\n    let hasSparkRenderer = false;\n    scene.traverse((c) => \
{\n      if (c instanceof SparkRenderer) {\n        hasSparkRenderer = \
true;\n      }\n    });\n    if (!hasSparkRenderer) {\n      scene.add(new \
SparkRenderer({ renderer }));\n    }\n    this.removeFromParent();\n  };\n  \
return mesh;\n}\nconst PLY_PROPERTY_TYPES = [\n  \"char\",\n  \"uchar\",\n  \
\"short\",\n  \"ushort\",\n  \"int\",\n  \"uint\",\n  \"float\",\n  \
\"double\"\n];\nconst _PlyReader = class _PlyReader {\n  // Create a \
PlyReader from a Uint8Array/ArrayBuffer, no parsing done yet\n  constructor({ \
fileBytes }) {\n    this.header = \"\";\n    this.littleEndian = true;\n    \
this.elements = {};\n    this.comments = [];\n    this.data = null;\n    \
this.numSplats = 0;\n    this.fileBytes = fileBytes instanceof ArrayBuffer ? \
new Uint8Array(fileBytes) : fileBytes;\n  }\n  // Identify and parse the PLY \
text header (assumed to be <64KB in size).\n  // this.elements will contain \
all the elements in the file, typically\n  // \"vertex\" contains the Gsplat \
data.\n  async parseHeader() {\n    const bufferStream = new \
ReadableStream({\n      start: (controller) => {\n        \
controller.enqueue(this.fileBytes.slice(0, 65536));\n        \
controller.close();\n      }\n    });\n    const decoder = \
bufferStream.pipeThrough(new TextDecoderStream()).getReader();\n    \
this.header = \"\";\n    const headerTerminator = \"end_header\\n\";\n    \
while (true) {\n      const { value, done } = await decoder.read();\n      if \
(done) {\n        throw new Error(\"Failed to read header\");\n      }\n      \
this.header += value;\n      const endHeader = \
this.header.indexOf(headerTerminator);\n      if (endHeader >= 0) {\n        \
this.header = this.header.slice(0, endHeader + headerTerminator.length);\n    \
    break;\n      }\n    }\n    const headerLen = new \
TextEncoder().encode(this.header).length;\n    this.data = new \
DataView(this.fileBytes.buffer, headerLen);\n    this.elements = {};\n    let \
curElement = null;\n    this.comments = [];\n    \
this.header.trim().split(\"\\n\").forEach((line, lineIndex) => {\n      const \
trimmedLine = line.trim();\n      if (lineIndex === 0) {\n        if \
(trimmedLine !== \"ply\") {\n          throw new Error(\"Invalid PLY \
header\");\n        }\n        return;\n      }\n      if (trimmedLine.length \
=== 0) {\n        return;\n      }\n      const fields = trimmedLine.split(\" \
\");\n      switch (fields[0]) {\n        case \"format\":\n          if \
(fields[1] === \"binary_little_endian\") {\n            this.littleEndian = \
true;\n          } else if (fields[1] === \"binary_big_endian\") {\n          \
  this.littleEndian = false;\n          } else {\n            throw new \
Error(`Unsupported PLY format: ${fields[1]}`);\n          }\n          if \
(fields[2] !== \"1.0\") {\n            throw new Error(`Unsupported PLY \
version: ${fields[2]}`);\n          }\n          break;\n        case \
\"end_header\":\n          break;\n        case \"comment\":\n          \
this.comments.push(trimmedLine.slice(\"comment \".length));\n          \
break;\n        case \"element\": {\n          const name = fields[1];\n      \
    curElement = {\n            name,\n            count: \
Number.parseInt(fields[2]),\n            properties: {}\n          };\n       \
   this.elements[name] = curElement;\n          break;\n        }\n        \
case \"property\":\n          if (curElement == null) {\n            throw \
new Error(\"Property must be inside an element\");\n          }\n          if \
(fields[1] === \"list\") {\n            curElement.properties[fields[4]] = \
{\n              isList: true,\n              type: fields[3],\n              \
countType: fields[2]\n            };\n          } else {\n            \
curElement.properties[fields[2]] = {\n              isList: false,\n          \
    type: fields[1]\n            };\n          }\n          break;\n      }\n \
   });\n    if (this.elements.vertex) {\n      this.numSplats = \
this.elements.vertex.count;\n    }\n  }\n  parseData(elementCallback) {\n    \
let offset = 0;\n    const data = this.data;\n    if (data == null) {\n      \
throw new Error(\"No data to parse\");\n    }\n    for (const elementName in \
this.elements) {\n      const element = this.elements[elementName];\n      \
const { count, properties } = element;\n      const item = \
createEmptyItem(properties);\n      const parseFn = createParseFn(properties, \
this.littleEndian);\n      const callback = elementCallback(element) ?? (() \
=> {\n      });\n      for (let index = 0; index < count; index++) {\n        \
offset = parseFn(data, offset, item);\n        callback(index, item);\n      \
}\n    }\n  }\n  // Parse all the Gsplat data in the PLY file in go, invoking \
the given\n  // callbacks for each Gsplat.\n  parseSplats(splatCallback, \
shCallback) {\n    if (this.elements.vertex == null) {\n      throw new \
Error(\"No vertex element found\");\n    }\n    let isSuperSplat = false;\n   \
 const ssChunks = [];\n    let numSh = 0;\n    let sh1Props = [];\n    let \
sh2Props = [];\n    let sh3Props = [];\n    let sh1 = void 0;\n    let sh2 = \
void 0;\n    let sh3 = void 0;\n    function prepareSh() {\n      const \
num_f_rest = NUM_SH_TO_NUM_F_REST[numSh];\n      sh1Props = new \
Array(3).fill(null).flatMap((_, k) => [0, 1, 2].map((_2, d) => k + d * \
num_f_rest / 3));\n      sh2Props = new Array(5).fill(null).flatMap(\n        \
(_, k) => [0, 1, 2].map((_2, d) => 3 + k + d * num_f_rest / 3)\n      );\n    \
  sh3Props = new Array(7).fill(null).flatMap(\n        (_, k) => [0, 1, \
2].map((_2, d) => 8 + k + d * num_f_rest / 3)\n      );\n      sh1 = numSh >= \
1 ? new Float32Array(3 * 3) : void 0;\n      sh2 = numSh >= 2 ? new \
Float32Array(5 * 3) : void 0;\n      sh3 = numSh >= 3 ? new Float32Array(7 * \
3) : void 0;\n    }\n    function ssShCallback(index, item) {\n      if \
(!sh1) {\n        throw new Error(\"Missing sh1\");\n      }\n      const sh \
= item.f_rest;\n      for (let i = 0; i < sh1Props.length; i++) {\n        \
sh1[i] = sh[sh1Props[i]] * 8 / 255 - 4;\n      }\n      if (sh2) {\n        \
for (let i = 0; i < sh2Props.length; i++) {\n          sh2[i] = \
sh[sh2Props[i]] * 8 / 255 - 4;\n        }\n      }\n      if (sh3) {\n        \
for (let i = 0; i < sh3Props.length; i++) {\n          sh3[i] = \
sh[sh3Props[i]] * 8 / 255 - 4;\n        }\n      }\n      shCallback == null \
? void 0 : shCallback(index, sh1, sh2, sh3);\n    }\n    function \
initSuperSplat(element) {\n      const {\n        min_x,\n        min_y,\n    \
    min_z,\n        max_x,\n        max_y,\n        max_z,\n        \
min_scale_x,\n        min_scale_y,\n        min_scale_z,\n        \
max_scale_x,\n        max_scale_y,\n        max_scale_z\n      } = \
element.properties;\n      if (!min_x || !min_y || !min_z || !max_x || !max_y \
|| !max_z || !min_scale_x || !min_scale_y || !min_scale_z || !max_scale_x || \
!max_scale_y || !max_scale_z) {\n        throw new Error(\"Missing PLY chunk \
properties\");\n      }\n      isSuperSplat = true;\n      return (index, \
item) => {\n        const {\n          min_x: min_x2,\n          min_y: \
min_y2,\n          min_z: min_z2,\n          max_x: max_x2,\n          max_y: \
max_y2,\n          max_z: max_z2,\n          min_scale_x: min_scale_x2,\n     \
     min_scale_y: min_scale_y2,\n          min_scale_z: min_scale_z2,\n       \
   max_scale_x: max_scale_x2,\n          max_scale_y: max_scale_y2,\n         \
 max_scale_z: max_scale_z2,\n          min_r,\n          min_g,\n          \
min_b,\n          max_r,\n          max_g,\n          max_b\n        } = \
item;\n        ssChunks.push({\n          min_x: min_x2,\n          min_y: \
min_y2,\n          min_z: min_z2,\n          max_x: max_x2,\n          max_y: \
max_y2,\n          max_z: max_z2,\n          min_scale_x: min_scale_x2,\n     \
     min_scale_y: min_scale_y2,\n          min_scale_z: min_scale_z2,\n       \
   max_scale_x: max_scale_x2,\n          max_scale_y: max_scale_y2,\n         \
 max_scale_z: max_scale_z2,\n          min_r,\n          min_g,\n          \
min_b,\n          max_r,\n          max_g,\n          max_b\n        });\n    \
  };\n    }\n    function decodeSuperSplat(element) {\n      if (shCallback \
&& element.name === \"sh\") {\n        numSh = \
getNumSh(element.properties);\n        prepareSh();\n        return \
ssShCallback;\n      }\n      if (element.name !== \"vertex\") {\n        \
return null;\n      }\n      const { packed_position, packed_rotation, \
packed_scale, packed_color } = element.properties;\n      if \
(!packed_position || !packed_rotation || !packed_scale || !packed_color) {\n  \
      throw new Error(\n          \"Missing PLY properties: packed_position, \
packed_rotation, packed_scale, packed_color\"\n        );\n      }\n      \
const SQRT2 = Math.sqrt(2);\n      return (index, item) => {\n        const \
chunk = ssChunks[index >>> 8];\n        if (chunk == null) {\n          throw \
new Error(\"Missing PLY chunk\");\n        }\n        const {\n          \
min_x,\n          min_y,\n          min_z,\n          max_x,\n          \
max_y,\n          max_z,\n          min_scale_x,\n          min_scale_y,\n    \
      min_scale_z,\n          max_scale_x,\n          max_scale_y,\n          \
max_scale_z,\n          min_r,\n          min_g,\n          min_b,\n          \
max_r,\n          max_g,\n          max_b\n        } = chunk;\n        const \
{ packed_position: packed_position2, packed_rotation: packed_rotation2, \
packed_scale: packed_scale2, packed_color: packed_color2 } = item;\n        \
const x = (packed_position2 >>> 21 & 2047) / 2047 * (max_x - min_x) + \
min_x;\n        const y = (packed_position2 >>> 11 & 1023) / 1023 * (max_y - \
min_y) + min_y;\n        const z = (packed_position2 & 2047) / 2047 * (max_z \
- min_z) + min_z;\n        const r0 = ((packed_rotation2 >>> 20 & 1023) / \
1023 - 0.5) * SQRT2;\n        const r1 = ((packed_rotation2 >>> 10 & 1023) / \
1023 - 0.5) * SQRT2;\n        const r2 = ((packed_rotation2 & 1023) / 1023 - \
0.5) * SQRT2;\n        const rr = Math.sqrt(Math.max(0, 1 - r0 * r0 - r1 * r1 \
- r2 * r2));\n        const rOrder = packed_rotation2 >>> 30;\n        const \
quatX = rOrder === 0 ? r0 : rOrder === 1 ? rr : r1;\n        const quatY = \
rOrder <= 1 ? r1 : rOrder === 2 ? rr : r2;\n        const quatZ = rOrder <= 2 \
? r2 : rr;\n        const quatW = rOrder === 0 ? rr : r0;\n        const \
scaleX = Math.exp(\n          (packed_scale2 >>> 21 & 2047) / 2047 * \
(max_scale_x - min_scale_x) + min_scale_x\n        );\n        const scaleY = \
Math.exp(\n          (packed_scale2 >>> 11 & 1023) / 1023 * (max_scale_y - \
min_scale_y) + min_scale_y\n        );\n        const scaleZ = Math.exp(\n    \
      (packed_scale2 & 2047) / 2047 * (max_scale_z - min_scale_z) + \
min_scale_z\n        );\n        const r = (packed_color2 >>> 24 & 255) / 255 \
* ((max_r ?? 1) - (min_r ?? 0)) + (min_r ?? 0);\n        const g = \
(packed_color2 >>> 16 & 255) / 255 * ((max_g ?? 1) - (min_g ?? 0)) + (min_g \
?? 0);\n        const b = (packed_color2 >>> 8 & 255) / 255 * ((max_b ?? 1) - \
(min_b ?? 0)) + (min_b ?? 0);\n        const opacity = (packed_color2 & 255) \
/ 255;\n        splatCallback(\n          index,\n          x,\n          \
y,\n          z,\n          scaleX,\n          scaleY,\n          scaleZ,\n   \
       quatX,\n          quatY,\n          quatZ,\n          quatW,\n         \
 opacity,\n          r,\n          g,\n          b\n        );\n      };\n    \
}\n    const elementCallback = (element) => {\n      if (element.name === \
\"chunk\") {\n        return initSuperSplat(element);\n      }\n      if \
(isSuperSplat) {\n        return decodeSuperSplat(element);\n      }\n      \
if (element.name !== \"vertex\") {\n        return null;\n      }\n      \
const {\n        x,\n        y,\n        z,\n        scale_0,\n        \
scale_1,\n        scale_2,\n        rot_0,\n        rot_1,\n        rot_2,\n  \
      rot_3,\n        opacity,\n        f_dc_0,\n        f_dc_1,\n        \
f_dc_2,\n        red,\n        green,\n        blue,\n        alpha\n      } \
= element.properties;\n      if (!x || !y || !z) {\n        throw new \
Error(\"Missing PLY properties: x, y, z\");\n      }\n      const hasScales = \
scale_0 && scale_1 && scale_2;\n      const hasRots = rot_0 && rot_1 && rot_2 \
&& rot_3;\n      const alphaDiv = alpha != null ? FIELD_SCALE[alpha.type] : \
1;\n      const redDiv = red != null ? FIELD_SCALE[red.type] : 1;\n      \
const greenDiv = green != null ? FIELD_SCALE[green.type] : 1;\n      const \
blueDiv = blue != null ? FIELD_SCALE[blue.type] : 1;\n      numSh = \
getNumSh(element.properties);\n      prepareSh();\n      return (index, item) \
=> {\n        const scaleX = hasScales ? Math.exp(item.scale_0) : \
_PlyReader.defaultPointScale;\n        const scaleY = hasScales ? \
Math.exp(item.scale_1) : _PlyReader.defaultPointScale;\n        const scaleZ \
= hasScales ? Math.exp(item.scale_2) : _PlyReader.defaultPointScale;\n        \
const quatX = hasRots ? item.rot_1 : 0;\n        const quatY = hasRots ? \
item.rot_2 : 0;\n        const quatZ = hasRots ? item.rot_3 : 0;\n        \
const quatW = hasRots ? item.rot_0 : 1;\n        const op = opacity != null ? \
1 / (1 + Math.exp(-item.opacity)) : alpha != null ? item.alpha / alphaDiv : \
1;\n        const r = f_dc_0 != null ? item.f_dc_0 * SH_C0$1 + 0.5 : red != \
null ? item.red / redDiv : 1;\n        const g = f_dc_1 != null ? item.f_dc_1 \
* SH_C0$1 + 0.5 : green != null ? item.green / greenDiv : 1;\n        const b \
= f_dc_2 != null ? item.f_dc_2 * SH_C0$1 + 0.5 : blue != null ? item.blue / \
blueDiv : 1;\n        splatCallback(\n          index,\n          item.x,\n   \
       item.y,\n          item.z,\n          scaleX,\n          scaleY,\n     \
     scaleZ,\n          quatX,\n          quatY,\n          quatZ,\n          \
quatW,\n          op,\n          r,\n          g,\n          b\n        );\n  \
      if (shCallback && sh1) {\n          const sh = item.f_rest;\n          \
if (sh1) {\n            for (let i = 0; i < sh1Props.length; i++) {\n         \
     sh1[i] = sh[sh1Props[i]];\n            }\n          }\n          if \
(sh2) {\n            for (let i = 0; i < sh2Props.length; i++) {\n            \
  sh2[i] = sh[sh2Props[i]];\n            }\n          }\n          if (sh3) \
{\n            for (let i = 0; i < sh3Props.length; i++) {\n              \
sh3[i] = sh[sh3Props[i]];\n            }\n          }\n          \
shCallback(index, sh1, sh2, sh3);\n        }\n      };\n    };\n    \
this.parseData(elementCallback);\n  }\n  // Inject RGBA values into original \
PLY file, which can be used to modify\n  // the color/opacity of the Gsplats \
and write out the modified PLY file.\n  injectRgba(rgba) {\n    let offset = \
0;\n    const data = this.data;\n    if (data == null) {\n      throw new \
Error(\"No parsed data\");\n    }\n    if (rgba.length !== this.numSplats * \
4) {\n      throw new Error(\"Invalid RGBA array length\");\n    }\n    for \
(const elementName in this.elements) {\n      const element = \
this.elements[elementName];\n      const { count, properties } = element;\n   \
   const parsers = [];\n      let rgbaOffset = 0;\n      const isVertex = \
elementName === \"vertex\";\n      if (isVertex) {\n        for (const name \
of [\"opacity\", \"f_dc_0\", \"f_dc_1\", \"f_dc_2\"]) {\n          if \
(!properties[name] || properties[name].type !== \"float\") {\n            \
throw new Error(`Can't injectRgba due to property: ${name}`);\n          }\n  \
      }\n      }\n      for (const [propertyName, property] of \
Object.entries(properties)) {\n        if (!property.isList) {\n          if \
(isVertex) {\n            if (propertyName === \"f_dc_0\" || propertyName === \
\"f_dc_1\" || propertyName === \"f_dc_2\") {\n              const component = \
Number.parseInt(\n                propertyName.slice(\"f_dc_\".length)\n      \
        );\n              parsers.push(() => {\n                const value = \
(rgba[rgbaOffset + component] / 255 - 0.5) / SH_C0$1;\n                \
SET_FIELD[property.type](\n                  data,\n                  \
offset,\n                  this.littleEndian,\n                  value\n      \
          );\n              });\n            } else if (propertyName === \
\"opacity\") {\n              parsers.push(() => {\n                const \
value = Math.max(\n                  -100,\n                  Math.min(\n     \
               100,\n                    -Math.log(1 / (rgba[rgbaOffset + 3] \
/ 255) - 1)\n                  )\n                );\n                \
SET_FIELD[property.type](\n                  data,\n                  \
offset,\n                  this.littleEndian,\n                  value\n      \
          );\n              });\n            }\n          }\n          \
parsers.push(() => {\n            offset += FIELD_BYTES[property.type];\n     \
     });\n        } else {\n          parsers.push(() => {\n            const \
length2 = PARSE_FIELD[property.countType](\n              data,\n             \
 offset,\n              this.littleEndian\n            );\n            offset \
+= FIELD_BYTES[property.countType];\n            offset += length2 * \
FIELD_BYTES[property.type];\n          });\n        }\n      }\n      for \
(let index = 0; index < count; index++) {\n        for (const parser of \
parsers) {\n          parser();\n        }\n        if (isVertex) {\n         \
 rgbaOffset += 4;\n        }\n      }\n    }\n  \
}\n};\n_PlyReader.defaultPointScale = 1e-3;\nlet PlyReader = \
_PlyReader;\nconst SH_C0$1 = 0.28209479177387814;\nconst PARSE_FIELD = {\n  \
char: (data, offset, littleEndian) => {\n    return data.getInt8(offset);\n  \
},\n  uchar: (data, offset, littleEndian) => {\n    return \
data.getUint8(offset);\n  },\n  short: (data, offset, littleEndian) => {\n    \
return data.getInt16(offset, littleEndian);\n  },\n  ushort: (data, offset, \
littleEndian) => {\n    return data.getUint16(offset, littleEndian);\n  },\n  \
int: (data, offset, littleEndian) => {\n    return data.getInt32(offset, \
littleEndian);\n  },\n  uint: (data, offset, littleEndian) => {\n    return \
data.getUint32(offset, littleEndian);\n  },\n  float: (data, offset, \
littleEndian) => {\n    return data.getFloat32(offset, littleEndian);\n  },\n \
 double: (data, offset, littleEndian) => {\n    return \
data.getFloat64(offset, littleEndian);\n  }\n};\nconst SET_FIELD = {\n  char: \
(data, offset, littleEndian, value) => {\n    data.setInt8(offset, value);\n  \
},\n  uchar: (data, offset, littleEndian, value) => {\n    \
data.setUint8(offset, value);\n  },\n  short: (data, offset, littleEndian, \
value) => {\n    data.setInt16(offset, value, littleEndian);\n  },\n  ushort: \
(data, offset, littleEndian, value) => {\n    data.setUint16(offset, value, \
littleEndian);\n  },\n  int: (data, offset, littleEndian, value) => {\n    \
data.setInt32(offset, value, littleEndian);\n  },\n  uint: (data, offset, \
littleEndian, value) => {\n    data.setUint32(offset, value, littleEndian);\n \
 },\n  float: (data, offset, littleEndian, value) => {\n    \
data.setFloat32(offset, value, littleEndian);\n  },\n  double: (data, offset, \
littleEndian, value) => {\n    data.setFloat64(offset, value, \
littleEndian);\n  }\n};\nconst FIELD_BYTES = {\n  char: 1,\n  uchar: 1,\n  \
short: 2,\n  ushort: 2,\n  int: 4,\n  uint: 4,\n  float: 4,\n  double: \
8\n};\nconst FIELD_SCALE = {\n  char: 127,\n  uchar: 255,\n  short: 32767,\n  \
ushort: 65535,\n  int: 2147483647,\n  uint: 4294967295,\n  float: 1,\n  \
double: 1\n};\nconst NUM_F_REST_TO_NUM_SH = {\n  0: 0,\n  9: 1,\n  24: 2,\n  \
45: 3\n};\nconst NUM_SH_TO_NUM_F_REST = {\n  0: 0,\n  1: 9,\n  2: 24,\n  3: \
45\n};\nconst F_REST_REGEX = /^f_rest_([0-9]{1,2})$/;\nfunction \
createEmptyItem(properties) {\n  const item = {};\n  for (const \
[propertyName, property] of Object.entries(properties)) {\n    if \
(F_REST_REGEX.test(propertyName)) {\n      item.f_rest = new \
Array(getNumSh(properties));\n    } else {\n      item[propertyName] = \
property.isList ? [] : 0;\n    }\n  }\n  return item;\n}\nfunction \
createParseFn(properties, littleEndian) {\n  if (safeToCompile(properties)) \
{\n    return createCompiledParserFn(properties, littleEndian);\n  }\n  \
return createDynamicParserFn(properties, littleEndian);\n}\nconst \
UNSAFE_EVAL_ALLOWED = (() => {\n  try {\n    new Function(\"return 42;\");\n  \
} catch (e) {\n    return false;\n  }\n  return true;\n})();\nconst \
PROPERTY_NAME_REGEX = /^[a-zA-Z0-9_]+$/;\nfunction safeToCompile(properties) \
{\n  if (!UNSAFE_EVAL_ALLOWED) {\n    return false;\n  }\n  for (const \
[propertyName, property] of Object.entries(properties)) {\n    if \
(!PROPERTY_NAME_REGEX.test(propertyName)) {\n      return false;\n    }\n    \
if (property.isList && !PLY_PROPERTY_TYPES.includes(property.countType)) {\n  \
    return false;\n    }\n    if \
(!PLY_PROPERTY_TYPES.includes(property.type)) {\n      return false;\n    }\n \
 }\n  return true;\n}\nfunction createCompiledParserFn(properties, \
littleEndian) {\n  const parserSrc = [\"let list;\"];\n  for (const \
[propertyName, property] of Object.entries(properties)) {\n    const \
fRestMatch = propertyName.match(F_REST_REGEX);\n    if (fRestMatch) {\n      \
const fRestIndex = +fRestMatch[1];\n      parserSrc.push(\n        /*js*/\n   \
     `\n        item.f_rest[${fRestIndex}] = \
PARSE_FIELD['${property.type}'](data, offset, ${littleEndian});\n        \
offset += ${FIELD_BYTES[property.type]};\n      `\n      );\n    } else if \
(!property.isList) {\n      parserSrc.push(\n        /*js*/\n        `\n      \
  item['${propertyName}'] = PARSE_FIELD['${property.type}'](data, offset, \
${littleEndian});\n        offset += ${FIELD_BYTES[property.type]};\n      \
`\n      );\n    } else {\n      parserSrc.push(\n        /*js*/\n        `\n \
       list = item['${propertyName}'];\n        list.length = \
PARSE_FIELD['${property.countType}'](data, offset, ${littleEndian});\n        \
offset += ${FIELD_BYTES[property.countType]};\n        for (let i = 0; i < \
list.length; i++) {\n          list[i] = \
PARSE_FIELD['${property.type}'](data, offset, ${littleEndian});\n          \
offset += ${FIELD_BYTES[property.type]};\n        }\n      `\n      );\n    \
}\n  }\n  parserSrc.push(\"return offset;\");\n  const fn = new Function(\n   \
 \"data\",\n    \"offset\",\n    \"item\",\n    \"PARSE_FIELD\",\n    \
parserSrc.join(\"\\n\")\n  );\n  return (data, offset, item) => fn(data, \
offset, item, PARSE_FIELD);\n}\nfunction createDynamicParserFn(properties, \
littleEndian) {\n  const parsers = [];\n  for (const [propertyName, property] \
of Object.entries(properties)) {\n    const fRestMatch = \
propertyName.match(F_REST_REGEX);\n    if (fRestMatch) {\n      const \
fRestIndex = +fRestMatch[1];\n      parsers.push(\n        (data, offset, \
item) => {\n          item.f_rest[fRestIndex] = PARSE_FIELD[property.type](\n \
           data,\n            offset,\n            littleEndian\n          \
);\n          return offset + FIELD_BYTES[property.type];\n        }\n      \
);\n    } else if (!property.isList) {\n      parsers.push(\n        (data, \
offset, item) => {\n          item[propertyName] = \
PARSE_FIELD[property.type](\n            data,\n            offset,\n         \
   littleEndian\n          );\n          return offset + \
FIELD_BYTES[property.type];\n        }\n      );\n    } else {\n      \
parsers.push(\n        (data, offset, item) => {\n          const list = \
item[propertyName];\n          list.length = \
PARSE_FIELD[property.countType](\n            data,\n            offset,\n    \
        littleEndian\n          );\n          let currentOffset = offset + \
FIELD_BYTES[property.countType];\n          for (let i = 0; i < list.length; \
i++) {\n            list[i] = PARSE_FIELD[property.type](\n              \
data,\n              currentOffset,\n              littleEndian\n            \
);\n            currentOffset += FIELD_BYTES[property.type];\n          }\n   \
       return currentOffset;\n        }\n      );\n    }\n  }\n  return \
(data, offset, item) => {\n    let currentOffset = offset;\n    for (let \
parserIndex = 0; parserIndex < parsers.length; parserIndex++) {\n      \
currentOffset = parsers[parserIndex](data, currentOffset, item);\n    }\n    \
return currentOffset;\n  };\n}\nfunction getNumSh(properties) {\n  let \
num_f_rest = 0;\n  while (properties[`f_rest_${num_f_rest}`]) {\n    \
num_f_rest += 1;\n  }\n  const numSh = NUM_F_REST_TO_NUM_SH[num_f_rest];\n  \
if (numSh == null) {\n    throw new Error(`Unsupported number of SH \
coefficients: ${num_f_rest}`);\n  }\n  return numSh;\n}\nconst jsContent = \
'(function() {\\n  \"use strict\";\\n  let wasm;\\n  const cachedTextDecoder \
= typeof TextDecoder !== \"undefined\" ? new TextDecoder(\"utf-8\", { \
ignoreBOM: true, fatal: true }) : { decode: () => {\\n    throw \
Error(\"TextDecoder not available\");\\n  } };\\n  if (typeof TextDecoder !== \
\"undefined\") {\\n    cachedTextDecoder.decode();\\n  }\\n  let \
cachedUint8ArrayMemory0 = null;\\n  function getUint8ArrayMemory0() {\\n    \
if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength \
=== 0) {\\n      cachedUint8ArrayMemory0 = new \
Uint8Array(wasm.memory.buffer);\\n    }\\n    return \
cachedUint8ArrayMemory0;\\n  }\\n  function getStringFromWasm0(ptr, len) {\\n \
   ptr = ptr >>> 0;\\n    return \
cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));\\n \
 }\\n  function sort_splats(num_splats, readback, ordering) {\\n    const ret \
= wasm.sort_splats(num_splats, readback, ordering);\\n    return ret >>> \
0;\\n  }\\n  function sort32_splats(num_splats, readback, ordering) {\\n    \
const ret = wasm.sort32_splats(num_splats, readback, ordering);\\n    return \
ret >>> 0;\\n  }\\n  async function __wbg_load(module, imports) {\\n    if \
(typeof Response === \"function\" && module instanceof Response) {\\n      if \
(typeof WebAssembly.instantiateStreaming === \"function\") {\\n        try \
{\\n          return await WebAssembly.instantiateStreaming(module, \
imports);\\n        } catch (e) {\\n          if \
(module.headers.get(\"Content-Type\") != \"application/wasm\") {\\n           \
 console.warn(\"`WebAssembly.instantiateStreaming` failed because your server \
does not serve Wasm with `application/wasm` MIME type. Falling back to \
`WebAssembly.instantiate` which is slower. Original error:\\\\n\", e);\\n     \
     } else {\\n            throw e;\\n          }\\n        }\\n      }\\n   \
   const bytes = await module.arrayBuffer();\\n      return await \
WebAssembly.instantiate(bytes, imports);\\n    } else {\\n      const \
instance = await WebAssembly.instantiate(module, imports);\\n      if \
(instance instanceof WebAssembly.Instance) {\\n        return { instance, \
module };\\n      } else {\\n        return instance;\\n      }\\n    }\\n  \
}\\n  function __wbg_get_imports() {\\n    const imports = {};\\n    \
imports.wbg = {};\\n    imports.wbg.__wbg_buffer_609cc3eee51ed158 = \
function(arg0) {\\n      const ret = arg0.buffer;\\n      return ret;\\n    \
};\\n    imports.wbg.__wbg_length_3b4f022188ae8db6 = function(arg0) {\\n      \
const ret = arg0.length;\\n      return ret;\\n    };\\n    \
imports.wbg.__wbg_length_6ca527665d89694d = function(arg0) {\\n      const \
ret = arg0.length;\\n      return ret;\\n    };\\n    \
imports.wbg.__wbg_length_8cfd2c6409af88ad = function(arg0) {\\n      const \
ret = arg0.length;\\n      return ret;\\n    };\\n    \
imports.wbg.__wbg_new_9fee97a409b32b68 = function(arg0) {\\n      const ret = \
new Uint16Array(arg0);\\n      return ret;\\n    };\\n    \
imports.wbg.__wbg_new_e3b321dcfef89fc7 = function(arg0) {\\n      const ret = \
new Uint32Array(arg0);\\n      return ret;\\n    };\\n    \
imports.wbg.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354 = \
function(arg0, arg1, arg2) {\\n      const ret = new Float32Array(arg0, arg1 \
>>> 0, arg2 >>> 0);\\n      return ret;\\n    };\\n    \
imports.wbg.__wbg_newwithbyteoffsetandlength_f1dead44d1fc7212 = \
function(arg0, arg1, arg2) {\\n      const ret = new Uint32Array(arg0, arg1 \
>>> 0, arg2 >>> 0);\\n      return ret;\\n    };\\n    \
imports.wbg.__wbg_newwithlength_5a5efe313cfd59f1 = function(arg0) {\\n      \
const ret = new Float32Array(arg0 >>> 0);\\n      return ret;\\n    };\\n    \
imports.wbg.__wbg_set_10bad9bee0e9c58b = function(arg0, arg1, arg2) {\\n      \
arg0.set(arg1, arg2 >>> 0);\\n    };\\n    \
imports.wbg.__wbg_set_d23661d19148b229 = function(arg0, arg1, arg2) {\\n      \
arg0.set(arg1, arg2 >>> 0);\\n    };\\n    \
imports.wbg.__wbg_set_f4f1f0daa30696fc = function(arg0, arg1, arg2) {\\n      \
arg0.set(arg1, arg2 >>> 0);\\n    };\\n    \
imports.wbg.__wbg_subarray_3aaeec89bb2544f0 = function(arg0, arg1, arg2) {\\n \
     const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);\\n      return \
ret;\\n    };\\n    imports.wbg.__wbg_subarray_769e1e0f81bb259b = \
function(arg0, arg1, arg2) {\\n      const ret = arg0.subarray(arg1 >>> 0, \
arg2 >>> 0);\\n      return ret;\\n    };\\n    \
imports.wbg.__wbindgen_init_externref_table = function() {\\n      const \
table = wasm.__wbindgen_export_0;\\n      const offset = table.grow(4);\\n    \
  table.set(0, void 0);\\n      table.set(offset + 0, void 0);\\n      \
table.set(offset + 1, null);\\n      table.set(offset + 2, true);\\n      \
table.set(offset + 3, false);\\n    };\\n    imports.wbg.__wbindgen_memory = \
function() {\\n      const ret = wasm.memory;\\n      return ret;\\n    };\\n \
   imports.wbg.__wbindgen_throw = function(arg0, arg1) {\\n      throw new \
Error(getStringFromWasm0(arg0, arg1));\\n    };\\n    return imports;\\n  \
}\\n  function __wbg_finalize_init(instance, module) {\\n    wasm = \
instance.exports;\\n    __wbg_init.__wbindgen_wasm_module = module;\\n    \
cachedUint8ArrayMemory0 = null;\\n    wasm.__wbindgen_start();\\n    return \
wasm;\\n  }\\n  async function __wbg_init(module_or_path) {\\n    if (wasm \
!== void 0) return wasm;\\n    if (typeof module_or_path !== \"undefined\") \
{\\n      if (Object.getPrototypeOf(module_or_path) === Object.prototype) \
{\\n        ({ module_or_path } = module_or_path);\\n      } else {\\n        \
console.warn(\"using deprecated parameters for the initialization function; \
pass a single object instead\");\\n      }\\n    }\\n    if (typeof \
module_or_path === \"undefined\") {\\n      module_or_path = new \
URL(\"data:application/wasm;base64,AGFzbQEAAAABzAEeYAJ/fwF/YAJ/fwBgA39/fwF/YA\
N/f38AYAF/AX9gAX8AYANvf38Bb2AFf39/f38Bf2AFf39/f38AYAFvAW9gA29vfwBgAW8Bf2AAAGA\
AAX9gBH9/f38AYAR/f39/AX9gA39vbwF/YAF/AW9gAAFvYAF9AX1gBn9/f39/fwBgDX19fX19fX19\
f29/fX0Bb2AGf39/f39/AX9gBX9/fX9/AGAEf31/fwBgBX9/fH9/AGAEf3x/fwBgBX9/fn9/AGAEf\
35/fwBgAn19AX0C8gQRA3diZx1fX3diZ19idWZmZXJfNjA5Y2MzZWVlNTFlZDE1OAAJA3diZxpfX3\
diZ19uZXdfOWZlZTk3YTQwOWIzMmI2OAAJA3diZxpfX3diZ19zZXRfZjRmMWYwZGFhMzA2OTZmYwA\
KA3diZx1fX3diZ19sZW5ndGhfOGNmZDJjNjQwOWFmODhhZAALA3diZzFfX3diZ19uZXd3aXRoYnl0\
ZW9mZnNldGFuZGxlbmd0aF9mMWRlYWQ0NGQxZmM3MjEyAAYDd2JnGl9fd2JnX25ld19lM2IzMjFkY\
2ZlZjg5ZmM3AAkDd2JnGl9fd2JnX3NldF9kMjM2NjFkMTkxNDhiMjI5AAoDd2JnHV9fd2JnX2xlbm\
d0aF82Y2E1Mjc2NjVkODk2OTRkAAsDd2JnMV9fd2JnX25ld3dpdGhieXRlb2Zmc2V0YW5kbGVuZ3R\
oX2U2YjdlNjlhY2Q0YzczNTQABgN3YmcaX193Ymdfc2V0XzEwYmFkOWJlZTBlOWM1OGIACgN3Ymcd\
X193YmdfbGVuZ3RoXzNiNGYwMjIxODhhZThkYjYACwN3YmcfX193Ymdfc3ViYXJyYXlfNzY5ZTFlM\
GY4MWJiMjU5YgAGA3diZx9fX3diZ19zdWJhcnJheV8zYWFlZWM4OWJiMjU0NGYwAAYDd2JnJF9fd2\
JnX25ld3dpdGhsZW5ndGhfNWE1ZWZlMzEzY2ZkNTlmMQARA3diZxBfX3diaW5kZ2VuX3Rocm93AAE\
Dd2JnEV9fd2JpbmRnZW5fbWVtb3J5ABIDd2JnH19fd2JpbmRnZW5faW5pdF9leHRlcm5yZWZfdGFi\
bGUADANeXQQAAQcFAgMCEwEBAA0BAwEAAA0BAwgIAwEBBRQBAw4AAwEDAgwMAgABAQcDABUBFhcIG\
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\
4EccSABQf+B/AdxakGBgARsQRB2IARqDwsgAUUEQEEADwsgAUEDcSEDAkAgAUEESQRADAELIAFBfH\
EhBQNAIAQgACACaiIBLAAAQb9/SmogAUEBaiwAAEG/f0pqIAFBAmosAABBv39KaiABQQNqLAAAQb9\
/SmohBCAFIAJBBGoiAkcNAAsLIANFDQAgACACaiEBA0AgBCABLAAAQb9/SmohBCABQQFqIQEgA0EB\
ayIDDQALCyAEC4oGAQZ/IAAoAggiAyABSQRAIAEgAyICayIEIAAoAgAgAmtLBEAgACACIARBBEEEE\
CYgACgCCCECCyAAKAIEIgYgAkECdGohBSAEQQJPBEAgASADQX9zakECdCIHBEAgBUEAIAf8CwALIA\
EgAmpBAnQgA0ECdGsgBmpBBGshBSACIARqQQFrIQILIAVBADYCACAAIAJBAWo2AggLIAAoAhQiAyA\
BSQRAIAEgAyICayIEIAAoAgwgAmtLBEAgAEEMaiACIARBBEEEECYgACgCFCECCyAAKAIQIgYgAkEC\
dGohBSAEQQJPBEAgASADQX9zakECdCIHBEAgBUEAIAf8CwALIAEgAmpBAnQgA0ECdGsgBmpBBGshB\
SACIARqQQFrIQILIAVBADYCACAAIAJBAWo2AhQLIAAoAjgiAyABSQRAIAEgAyICayIEIAAoAjAgAm\
tLBEAgAEEwaiACIARBBEEEECYgACgCOCECCyAAKAI0IgYgAkECdGohBSAEQQJPBEAgASADQX9zakE\
CdCIHBEAgBUEAIAf8CwALIAEgAmpBAnQgA0ECdGsgBmpBBGshBSACIARqQQFrIQILIAVBADYCACAA\
IAJBAWo2AjgLIAAoAiAiA0H//wNNBEAgAyEBQYCABCADayICIAAoAhggA2tLBEAgAEEYaiADIAJBB\
EEEECYgACgCICEBCyAAKAIcIgUgAUECdCIEaiECIANB//8DRwRAQfz/DyADQQJ0IgZrIgcEQCACQQ\
AgB/wLAAsgBCAGayAFakH8/w9qIQIgASADa0H//wNqIQELIAJBADYCACAAIAFBAWo2AiALIAAoAiw\
iA0H//wNNBEAgAyEBQYCABCADayICIAAoAiQgA2tLBEAgAEEkaiADIAJBBEEEECYgACgCLCEBCyAA\
KAIoIgUgAUECdCIEaiECIANB//8DRwRAQfz/DyADQQJ0IgZrIgcEQCACQQAgB/wLAAsgBCAGayAFa\
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\
zYCCCANIAo2AgQgDSAANgIAIA0gDUEEaiIAKAIAEG02AgwgDSANQQhqNgIcIA0gDTYCGCANIAA2Ah\
QgDSANQQxqNgIQIA1BEGohACMAQdAAayIIJAACQAJAAkACQAJAQQBBjIbAACgCABEEACIPBEAgDyg\
CAA0BIAAoAgwhFiAAKAIIIQogACgCACEDIA9BfzYCACAAKAIEIQAgD0EEaiILIAMoAgAQEyAIIABB\
ACAKKAIAEGE2AgggCigCACIAIA8oAgwiCUsNAiAIQQhqIA8oAgggABAzIAhBDGohFSADKAIAIQAgC\
igCACETIwBBMGsiDiQAIAsgABATAkAgCygCCCIAIBNPBEAgCygCBCEKIAsoAhwhAwJAIAsoAiAiDE\
UNACAMQQJ0IgBFDQAgA0EAIAD8CwALIAsoAighFAJAIAsoAiwiEEUNACAQQQJ0IgBFDQAgFEEAIAD\
8CwALIBNBAnQhCSATBEAgCSEEIAohAANAAkAgACgCACIGQYCAgPwHTw0AIAwgBkF/cyIFQf//A3Ei\
BksEQCADIAZBAnRqIgYgBigCAEEBajYCACAQIAVBEHYiBksEQCAUIAZBAnRqIgYgBigCAEEBajYCA\
AwCCyAGIBBB3InAABAxAAsgBiAMQcyJwAAQMQALIABBBGohACAEQQRrIgQNAAsLAkAgDEUEQEEAIQ\
QMAQsgDEEBa0H/////A3EiAEEBaiIEQQdxIQUCQCAAQQdJBEBBACEEIAMhAAwBCyAEQfj///8HcSE\
GQQAhBCADIQADQCAAKAIAIQcgACAENgIAIABBBGoiESgCACESIBEgBCAHaiIENgIAIABBCGoiBygC\
ACERIAcgBCASaiIENgIAIABBDGoiBygCACESIAcgBCARaiIENgIAIABBEGoiBygCACERIAcgBCASa\
iIENgIAIABBFGoiBygCACESIAcgBCARaiIENgIAIABBGGoiBygCACERIAcgBCASaiIENgIAIABBHG\
oiBygCACESIAcgBCARaiIENgIAIAQgEmohBCAAQSBqIQAgBkEIayIGDQALCyAFRQ0AA0AgACgCACE\
GIAAgBDYCACAAQQRqIQAgBCAGaiEEIAVBAWsiBQ0ACwsgDiAENgIEIBMEQCAJIApqIREgCkEEaiEG\
IBNBAWtB/////wNxQQFqIRIgCygCNCEXIAsoAjghB0EAIQUgCiEJA0AgBiEAAkAgCSgCACIJQYCAg\
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\
3I2AgQgByAHKAIEQQFyNgIEIAEgAxAaDAkLQciZwAAoAgAgBGoiBCABSw0HCyADEBEiAUUNASADQX\
xBeCAFKAIAIgJBA3EbIAJBeHFqIgIgAiADSxsiAgRAIAEgACAC/AoAAAsgABAVIAEMCAsgAyABIAE\
gA0sbIgIEQCAIIAAgAvwKAAALIAUoAgAiAkF4cSIDIAFBBEEIIAJBA3EiAhtqSQ0DIAJBACADIAlL\
Gw0EIAAQFQsgCAwGC0HQi8AAQYCMwAAQOgALQZCMwABBwIzAABA6AAtB0IvAAEGAjMAAEDoAC0GQj\
MAAQcCMwAAQOgALIAUgASAGQQFxckECcjYCACABIAJqIgIgBCABayIBQQFyNgIEQciZwAAgATYCAE\
HQmcAAIAI2AgAgAAwBCyAACwsWACAAKAIAIAEgAiAAKAIEKAIMEQIAC4UCAQN/QfCVwAAoAgBFBEA\
CQAJAAn8CQCAARQ0AIAAoAgAgAEEANgIAQQFxRQ0AIAAoAhAhAiAAKAIMIQEgACgCCCEDIAAoAgQM\
AQsCQEGAgMAAEBEiAEUNACAAQQRrLQAAQQNxRQ0AIABBAEGAgMAA/AsACyAAIgFFDQFBgIAQIQJBg\
IAQIQNBAAshAEGAlsAAIAI2AgBB9JXAACAANgIAQfyVwAAoAgAhAkH8lcAAIAE2AgBB+JXAACgCAC\
EAQfiVwAAgAzYCAEHwlcAAKAIAQfCVwABBATYCAEUgAEVyRQRAIAIgAEECdBBgCwwBC0EEQYCAwAB\
B+IXAABBMAAsLQfSVwAALxAQBEX9BrJXAACgCAEUEQAJAIAAEQCAAKAJAIQEgACgCPCECIAAoAjgh\
AyAAKAI0IQQgACgCMCEFIAAoAiwhBiAAKAIoIQcgACgCJCEIIAAoAiAhCSAAKAIcIQogACgCGCELI\
AAoAhQhDCAAKAIQIQ0gACgCDCEOIAAoAgghDyAAKAIEIRAgACgCACAAQQA2AgBBAXENAQtBBCECQQ\
AhAUEAIQNBACEEQQQhBUEAIQZBACEHQQQhCEEAIQlBACEKQQQhC0EAIQxBACENQQQhDkEAIQ9BACE\
QC0HslcAAIAE2AgBB4JXAACAENgIAQdSVwAAgBzYCAEHIlcAAIAo2AgBBvJXAACANNgIAQbCVwAAg\
EDYCAEHolcAAKAIAIQdB6JXAACACNgIAQeSVwAAoAgAhAEHklcAAIAM2AgBB3JXAACgCACEKQdyVw\
AAgBTYCAEHYlcAAKAIAIQFB2JXAACAGNgIAQdCVwAAoAgAhBUHQlcAAIAg2AgBBzJXAACgCACECQc\
yVwAAgCTYCAEHElcAAKAIAIQZBxJXAACALNgIAQcCVwAAoAgAhA0HAlcAAIAw2AgBBuJXAACgCACE\
IQbiVwAAgDjYCAEG0lcAAKAIAIQRBtJXAACAPNgIAQayVwAAoAgAhCUGslcAAQQE2AgACQCAJRQ0A\
IAQEQCAIIARBAnQQYAsgAwRAIAYgA0ECdBBgCyACBEAgBSACQQJ0EGALIAEEQCAKIAFBAnQQYAsgA\
EUNACAHIABBAnQQYAsLQbCVwAAL8gIBCX9BgJXAACgCAEUEQAJ/AkAgAEUNACAAKAIAIABBADYCAE\
EBcUUNACAAKAIoIQEgACgCJCEHIAAoAiAhAiAAKAIcIQMgACgCGCEIIAAoAhQhBCAAKAIQIQUgACg\
CDCEJIAAoAgghBiAAKAIEDAELQQIhCUEEIQdBACEBQQQhCEEACyEAQaiVwAAgATYCAEGclcAAIAM2\
AgBBkJXAACAFNgIAQYSVwAAgADYCAEGklcAAKAIAIQVBpJXAACAHNgIAQaCVwAAoAgAhAEGglcAAI\
AI2AgBBmJXAACgCACEBQZiVwAAgCDYCAEGUlcAAKAIAIQJBlJXAACAENgIAQYyVwAAoAgAhBEGMlc\
AAIAk2AgBBiJXAACgCACEDQYiVwAAgBjYCAEGAlcAAKAIAIQZBgJXAAEEBNgIAAkAgBkUNACADBEA\
gBCADQQF0EGALIAIEQCABIAJBAnQQYAsgAEUNACAFIABBAnQQYAsLQYSVwAALFAAgACgCACABIAAo\
AgQoAgwRAAALFAIBbwF/EA8hABAdIgEgACYBIAELEAAgASAAKAIEIAAoAggQFgsZAAJ/IAFBCU8EQ\
CABIAAQHAwBCyAAEBELCyAAIABC356dmJy3lrgCNwMIIABCoe2sjPn0nLgHNwMACyIAIABC7bqtts\
2F1PXjADcDCCAAQviCmb2V7sbFuX83AwALEwAgAEGAjsAANgIEIAAgATYCAAsQACABIAAoAgAgACg\
CBBBRCxAAIAEgACgCACAAKAIEEBYLEAAgASgCACABKAIEIAAQGAsOACAAJQEgASUBIAIQBgtbAQJ/\
AkACQCAAQQRrKAIAIgJBeHEiA0EEQQggAkEDcSICGyABak8EQCACQQAgAyABQSdqSxsNASAAEBUMA\
gtB0IvAAEGAjMAAEDoAC0GQjMAAQcCMwAAQOgALCx0BAW8gACgCACUBIAEgAhAMIQMQHSIAIAMmAS\
AAC2oBAX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQQI2AgwgA0G0lMAANgIIIANCAjcCFCADIAN\
BBGqtQoCAgIDQAIQ3AyggAyADrUKAgICA0ACENwMgIAMgA0EgajYCECADQQhqIAIQPwALCQAgACAB\
EA4ACw0AIABBuIvAACABEBgLDAAgACABKQIANwMACw0AIABB0I7AACABEBgLDQAgAUHIjsAAQQUQU\
QsZACAAIAFBkJbAACgCACIAQRQgABsRAQAACw0AIAFBpJDAAEEYEBYLoAIBA38gACgCACEAIwBBkA\
FrIgMkAAJ/AkAgASgCCCICQYCAgBBxRQRAIAJBgICAIHENASADQQhqIAAoAgAgA0EQahAfIAFBAUE\
AIAMoAgggAygCDBAUDAILIAAoAgAhAkEAIQADQCAAIANqQY8BaiACQQ9xIgRBMHIgBEHXAGogBEEK\
SRs6AAAgAEEBayEAIAJBD0sgAkEEdiECDQALIAFBt5LAAEECIAAgA2pBkAFqQQAgAGsQFAwBCyAAK\
AIAIQJBACEAA0AgACADakGPAWogAkEPcSIEQTByIARBN2ogBEEKSRs6AAAgAEEBayEAIAJBD0sgAk\
EEdiECDQALIAFBt5LAAEECIAAgA2pBkAFqQQAgAGsQFAsgA0GQAWokAAsJACAAQQA2AgALCAAgACU\
BEAMLCAAgACUBEAcLC/UUAwBBgIDAAAuhD3NwYXJrLWludGVybmFsLXJzL3NyYy9yYXljYXN0LnJz\
AHNwYXJrLWludGVybmFsLXJzL3NyYy9zb3J0LnJzAGxpYnJhcnkvYWxsb2Mvc3JjL2ZtdC5ycwAva\
G9tZS9ydW5uZXIvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2Yj\
ViNTU3Zi93YXNtLWJpbmRnZW4tMC4yLjEwMC9zcmMvY29udmVydC9zbGljZXMucnMAL3J1c3RjLzI\
5NDgzODgzZWVkNjlkNWZiNGRiMDE5NjRjZGYyYWY0ZDg2ZTljYjIvbGlicmFyeS9zdGQvc3JjL3Ro\
cmVhZC9sb2NhbC5ycwBsaWJyYXJ5L2FsbG9jL3NyYy9zdHJpbmcucnMAL3J1c3RjLzI5NDgzODgzZ\
WVkNjlkNWZiNGRiMDE5NjRjZGYyYWY0ZDg2ZTljYjIvbGlicmFyeS9hbGxvYy9zcmMvc2xpY2Uucn\
MAL3J1c3RjLzI5NDgzODgzZWVkNjlkNWZiNGRiMDE5NjRjZGYyYWY0ZDg2ZTljYjIvbGlicmFyeS9\
hbGxvYy9zcmMvcmF3X3ZlYy9tb2QucnMAL3J1c3QvZGVwcy9kbG1hbGxvYy0wLjIuOS9zcmMvZGxt\
YWxsb2MucnMAbGlicmFyeS9zdGQvc3JjL2FsbG9jLnJzAHNwYXJrLWludGVybmFsLXJzL3NyYy9sa\
WIucnMAL2hvbWUvcnVubmVyLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5ND\
ljZjhjNmI1YjU1N2YvanMtc3lzLTAuMy43Ny9zcmMvbGliLnJzAC9ob21lL3J1bm5lci8uY2FyZ28\
vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL29uY2VfY2VsbC0x\
LjIxLjMvc3JjL2xpYi5ycwAAAHwBEABRAAAALgIAABEAAAAQAhAAHQAAABEAAAA9AAAAAQAAAAIAA\
AADAAAAxQAQAFAAAAAZAQAAGQAAAMUAEABQAAAAGAIAACYAAAAxARAASwAAAMEBAAAdAAAAAAAQAC\
EAAAAqAAAAFwAAAAAAEAAhAAAAeAAAABcAAAAAABAAIQAAAH4AAAAcAAAAAAAQACEAAACAAAAAHAA\
AAAAAEAAhAAAAhQAAACAAAAAQAhAAHQAAAB0AAAAzAAAAEAIQAB0AAAAoAAAALQAAAAEAAAAAAAAA\
EAIQAB0AAAA6AAAAMwAAABACEAAdAAAARQAAAC0AAAAQAhAAHQAAAF4AAAAoAAAAIQAQAB4AAAAbA\
AAAHQAAAEV4cGVjdGVkICBhY3RpdmUgc3BsYXRzIGJ1dCBnb3Qg/AMQAAkAAAAFBBAAFwAAACEAEA\
AeAAAAMwAAAB0AAAAhABAAHgAAADMAAAAVAAAAIQAQAB4AAAAkAAAAFAAAACEAEAAeAAAAdAAAABk\
AAAAhABAAHgAAAKcAAAATAAAAIQAQAB4AAACfAAAAEwAAACEAEAAeAAAAogAAAB0AAAAhABAAHgAA\
AKIAAAARAAAAIQAQAB4AAACQAAAAIAAAACEAEAAeAAAAkAAAABQAAAAhABAAHgAAAHwAAAAYAAAAI\
QAQAB4AAAB9AAAAGAAAAC0CEABbAAAA+xgAAAEAAABYABAAbQAAACQBAAAOAAAAY2xvc3VyZSBpbn\
Zva2VkIHJlY3Vyc2l2ZWx5IG9yIGFmdGVyIGJlaW5nIGRyb3BwZWRMYXp5IGluc3RhbmNlIGhhcyB\
wcmV2aW91c2x5IGJlZW4gcG9pc29uZWQ+BRAAKgAAAIgCEABeAAAACAMAABkAAAByZWVudHJhbnQg\
aW5pdAAAgAUQAA4AAACIAhAAXgAAAHoCAAANAAAAfAEQAFEAAAAuAgAAEQAAABUAAAAMAAAABAAAA\
BYAAAAXAAAAGAAAAGFzc2VydGlvbiBmYWlsZWQ6IHBzaXplID49IHNpemUgKyBtaW5fb3ZlcmhlYW\
QAAM0BEAAqAAAAsAQAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA8PSBzaXplICsgbWF4X29\
2ZXJoZWFkAADNARAAKgAAALYEAAANAAAAQWNjZXNzRXJyb3JjYW5ub3QgYWNjZXNzIGEgVGhyZWFk\
IExvY2FsIFN0b3JhZ2UgdmFsdWUgZHVyaW5nIG9yIGFmdGVyIGRlc3RydWN0aW9uOiAAWwYQAEgAA\
ABtZW1vcnkgYWxsb2NhdGlvbiBvZiAgYnl0ZXMgZmFpbGVkAACsBhAAFQAAAMEGEAANAAAA9wEQAB\
kAAABkAQAACQAAABUAAAAMAAAABAAAABkAAAAAAAAACAAAAAQAAAAaAAAAAAAAAAgAAAAEAAAAGwA\
AABwAAAAdAAAAHgAAAB8AAAAQAAAABAAAACAAAAAhAAAAIgAAACMAAABFcnJvcgAAACQAAAAMAAAA\
BAAAACUAAAAmAAAAJwAAAGNhcGFjaXR5IG92ZXJmbG93AAAAaAcQABEAAACsARAAIQAAAC4CAAARA\
AAAFQEQABwAAADoAQAAFwBBrI/AAAu4BQEAAAAoAAAAYSBmb3JtYXR0aW5nIHRyYWl0IGltcGxlbW\
VudGF0aW9uIHJldHVybmVkIGFuIGVycm9yIHdoZW4gdGhlIHVuZGVybHlpbmcgc3RyZWFtIGRpZCB\
ub3QAAD8AEAAZAAAAigIAAA4AAAABAAAAAAAAAFJlZkNlbGwgYWxyZWFkeSBib3Jyb3dlZGluZGV4\
IG91dCBvZiBib3VuZHM6IHRoZSBsZW4gaXMgIGJ1dCB0aGUgaW5kZXggaXMgAAA8CBAAIAAAAFwIE\
AASAAAAAAAAAAQAAAAEAAAALQAAAD09IT1tYXRjaGVzYXNzZXJ0aW9uIGBsZWZ0ICByaWdodGAgZm\
FpbGVkCiAgbGVmdDogCiByaWdodDogAJsIEAAQAAAAqwgQABcAAADCCBAACQAAACByaWdodGAgZmF\
pbGVkOiAKICBsZWZ0OiAAAACbCBAAEAAAAOQIEAAQAAAA9AgQAAkAAADCCBAACQAAADogAAABAAAA\
AAAAACAJEAACAAAAfSB9MHgwMDAxMDIwMzA0MDUwNjA3MDgwOTEwMTExMjEzMTQxNTE2MTcxODE5M\
jAyMTIyMjMyNDI1MjYyNzI4MjkzMDMxMzIzMzM0MzUzNjM3MzgzOTQwNDE0MjQzNDQ0NTQ2NDc0OD\
Q5NTA1MTUyNTM1NDU1NTY1NzU4NTk2MDYxNjI2MzY0NjU2NjY3Njg2OTcwNzE3MjczNzQ3NTc2Nzc\
3ODc5ODA4MTgyODM4NDg1ODY4Nzg4ODk5MDkxOTI5Mzk0OTU5Njk3OTg5OSBvdXQgb2YgcmFuZ2Ug\
Zm9yIHNsaWNlIG9mIGxlbmd0aCByYW5nZSBlbmQgaW5kZXggACMKEAAQAAAAAQoQACIAAACQCBAAk\
ggQAJQIEAACAAAAAgAAAAcAAAAAAAA/AAAAvwBB/JTAAAsBEgB8CXByb2R1Y2VycwIIbGFuZ3VhZ2\
UBBFJ1c3QADHByb2Nlc3NlZC1ieQMFcnVzdGMdMS44OS4wICgyOTQ4Mzg4M2UgMjAyNS0wOC0wNCk\
Gd2FscnVzBjAuMjMuMwx3YXNtLWJpbmRnZW4TMC4yLjEwMCAoMjQwNWVjMmI0KQBrD3RhcmdldF9m\
ZWF0dXJlcwYrD211dGFibGUtZ2xvYmFscysTbm9udHJhcHBpbmctZnB0b2ludCsLYnVsay1tZW1vc\
nkrCHNpZ24tZXh0Kw9yZWZlcmVuY2UtdHlwZXMrCm11bHRpdmFsdWU=\", \
self.location.href);\\n    }\\n    const imports = __wbg_get_imports();\\n    \
if (typeof module_or_path === \"string\" || typeof Request === \"function\" \
&& module_or_path instanceof Request || typeof URL === \"function\" && \
module_or_path instanceof URL) {\\n      module_or_path = \
fetch(module_or_path);\\n    }\\n    const { instance, module } = await \
__wbg_load(await module_or_path, imports);\\n    return \
__wbg_finalize_init(instance, module);\\n  }\\n  var ch2 = {};\\n  var wk = \
function(c, id, msg, transfer, cb) {\\n    var w = new Worker(ch2[id] || \
(ch2[id] = URL.createObjectURL(new Blob([\\n      c + \
\\';addEventListener(\"error\",function(e){e=e.error;postMessage({$e$:[e.mess\
age,e.code,e.stack]})})\\'\\n    ], { type: \"text/javascript\" }))));\\n    \
w.onmessage = function(e) {\\n      var d = e.data, ed = d.$e$;\\n      if \
(ed) {\\n        var err2 = new Error(ed[0]);\\n        err2[\"code\"] = \
ed[1];\\n        err2.stack = ed[2];\\n        cb(err2, null);\\n      } \
else\\n        cb(null, d);\\n    };\\n    w.postMessage(msg, transfer);\\n   \
 return w;\\n  };\\n  var u8 = Uint8Array, u16 = Uint16Array, i32 = \
Int32Array;\\n  var fleb = new u8([\\n    0,\\n    0,\\n    0,\\n    0,\\n    \
0,\\n    0,\\n    0,\\n    0,\\n    1,\\n    1,\\n    1,\\n    1,\\n    2,\\n \
   2,\\n    2,\\n    2,\\n    3,\\n    3,\\n    3,\\n    3,\\n    4,\\n    \
4,\\n    4,\\n    4,\\n    5,\\n    5,\\n    5,\\n    5,\\n    0,\\n    /* \
unused */\\n    0,\\n    0,\\n    /* impossible */\\n    0\\n  ]);\\n  var \
fdeb = new u8([\\n    0,\\n    0,\\n    0,\\n    0,\\n    1,\\n    1,\\n    \
2,\\n    2,\\n    3,\\n    3,\\n    4,\\n    4,\\n    5,\\n    5,\\n    6,\\n \
   6,\\n    7,\\n    7,\\n    8,\\n    8,\\n    9,\\n    9,\\n    10,\\n    \
10,\\n    11,\\n    11,\\n    12,\\n    12,\\n    13,\\n    13,\\n    /* \
unused */\\n    0,\\n    0\\n  ]);\\n  var clim = new u8([16, 17, 18, 0, 8, \
7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\\n  var freb = function(eb, \
start) {\\n    var b = new u16(31);\\n    for (var i2 = 0; i2 < 31; ++i2) \
{\\n      b[i2] = start += 1 << eb[i2 - 1];\\n    }\\n    var r = new \
i32(b[30]);\\n    for (var i2 = 1; i2 < 30; ++i2) {\\n      for (var j = \
b[i2]; j < b[i2 + 1]; ++j) {\\n        r[j] = j - b[i2] << 5 | i2;\\n      \
}\\n    }\\n    return { b, r };\\n  };\\n  var _a = freb(fleb, 2), fl = \
_a.b, revfl = _a.r;\\n  fl[28] = 258, revfl[258] = 28;\\n  var _b = \
freb(fdeb, 0), fd = _b.b;\\n  var rev = new u16(32768);\\n  for (var i = 0; i \
< 32768; ++i) {\\n    var x = (i & 43690) >> 1 | (i & 21845) << 1;\\n    x = \
(x & 52428) >> 2 | (x & 13107) << 2;\\n    x = (x & 61680) >> 4 | (x & 3855) \
<< 4;\\n    rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;\\n  }\\n  var \
hMap = function(cd, mb, r) {\\n    var s = cd.length;\\n    var i2 = 0;\\n    \
var l = new u16(mb);\\n    for (; i2 < s; ++i2) {\\n      if (cd[i2])\\n      \
  ++l[cd[i2] - 1];\\n    }\\n    var le = new u16(mb);\\n    for (i2 = 1; i2 \
< mb; ++i2) {\\n      le[i2] = le[i2 - 1] + l[i2 - 1] << 1;\\n    }\\n    var \
co;\\n    if (r) {\\n      co = new u16(1 << mb);\\n      var rvb = 15 - \
mb;\\n      for (i2 = 0; i2 < s; ++i2) {\\n        if (cd[i2]) {\\n          \
var sv = i2 << 4 | cd[i2];\\n          var r_1 = mb - cd[i2];\\n          var \
v = le[cd[i2] - 1]++ << r_1;\\n          for (var m = v | (1 << r_1) - 1; v \
<= m; ++v) {\\n            co[rev[v] >> rvb] = sv;\\n          }\\n        \
}\\n      }\\n    } else {\\n      co = new u16(s);\\n      for (i2 = 0; i2 < \
s; ++i2) {\\n        if (cd[i2]) {\\n          co[i2] = rev[le[cd[i2] - 1]++] \
>> 15 - cd[i2];\\n        }\\n      }\\n    }\\n    return co;\\n  };\\n  var \
flt = new u8(288);\\n  for (var i = 0; i < 144; ++i)\\n    flt[i] = 8;\\n  \
for (var i = 144; i < 256; ++i)\\n    flt[i] = 9;\\n  for (var i = 256; i < \
280; ++i)\\n    flt[i] = 7;\\n  for (var i = 280; i < 288; ++i)\\n    flt[i] \
= 8;\\n  var fdt = new u8(32);\\n  for (var i = 0; i < 32; ++i)\\n    fdt[i] \
= 5;\\n  var flrm = /* @__PURE__ */ hMap(flt, 9, 1);\\n  var fdrm = /* \
@__PURE__ */ hMap(fdt, 5, 1);\\n  var max = function(a) {\\n    var m = \
a[0];\\n    for (var i2 = 1; i2 < a.length; ++i2) {\\n      if (a[i2] > m)\\n \
       m = a[i2];\\n    }\\n    return m;\\n  };\\n  var bits = function(d, \
p, m) {\\n    var o = p / 8 | 0;\\n    return (d[o] | d[o + 1] << 8) >> (p & \
7) & m;\\n  };\\n  var bits16 = function(d, p) {\\n    var o = p / 8 | 0;\\n  \
  return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);\\n  };\\n  var \
shft = function(p) {\\n    return (p + 7) / 8 | 0;\\n  };\\n  var slc = \
function(v, s, e) {\\n    if (s == null || s < 0)\\n      s = 0;\\n    if (e \
== null || e > v.length)\\n      e = v.length;\\n    return new \
u8(v.subarray(s, e));\\n  };\\n  var ec = [\\n    \"unexpected EOF\",\\n    \
\"invalid block type\",\\n    \"invalid length/literal\",\\n    \"invalid \
distance\",\\n    \"stream finished\",\\n    \"no stream handler\",\\n    \
,\\n    \"no callback\",\\n    \"invalid UTF-8 data\",\\n    \"extra field \
too long\",\\n    \"date not in range 1980-2099\",\\n    \"filename too \
long\",\\n    \"stream finishing\",\\n    \"invalid zip data\"\\n    // \
determined by unknown compression method\\n  ];\\n  var err = function(ind, \
msg, nt) {\\n    var e = new Error(msg || ec[ind]);\\n    e.code = ind;\\n    \
if (Error.captureStackTrace)\\n      Error.captureStackTrace(e, err);\\n    \
if (!nt)\\n      throw e;\\n    return e;\\n  };\\n  var inflt = \
function(dat, st, buf, dict) {\\n    var sl = dat.length, dl = dict ? \
dict.length : 0;\\n    if (!sl || st.f && !st.l)\\n      return buf || new \
u8(0);\\n    var noBuf = !buf;\\n    var resize = noBuf || st.i != 2;\\n    \
var noSt = st.i;\\n    if (noBuf)\\n      buf = new u8(sl * 3);\\n    var \
cbuf = function(l2) {\\n      var bl = buf.length;\\n      if (l2 > bl) {\\n  \
      var nbuf = new u8(Math.max(bl * 2, l2));\\n        nbuf.set(buf);\\n    \
    buf = nbuf;\\n      }\\n    };\\n    var final = st.f || 0, pos = st.p || \
0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\\n    var \
tbts = sl * 8;\\n    do {\\n      if (!lm) {\\n        final = bits(dat, pos, \
1);\\n        var type = bits(dat, pos + 1, 3);\\n        pos += 3;\\n        \
if (!type) {\\n          var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] \
<< 8, t = s + l;\\n          if (t > sl) {\\n            if (noSt)\\n         \
     err(0);\\n            break;\\n          }\\n          if (resize)\\n    \
        cbuf(bt + l);\\n          buf.set(dat.subarray(s, t), bt);\\n         \
 st.b = bt += l, st.p = pos = t * 8, st.f = final;\\n          continue;\\n   \
     } else if (type == 1)\\n          lm = flrm, dm = fdrm, lbt = 9, dbt = \
5;\\n        else if (type == 2) {\\n          var hLit = bits(dat, pos, 31) \
+ 257, hcLen = bits(dat, pos + 10, 15) + 4;\\n          var tl = hLit + \
bits(dat, pos + 5, 31) + 1;\\n          pos += 14;\\n          var ldt = new \
u8(tl);\\n          var clt = new u8(19);\\n          for (var i2 = 0; i2 < \
hcLen; ++i2) {\\n            clt[clim[i2]] = bits(dat, pos + i2 * 3, 7);\\n   \
       }\\n          pos += hcLen * 3;\\n          var clb = max(clt), clbmsk \
= (1 << clb) - 1;\\n          var clm = hMap(clt, clb, 1);\\n          for \
(var i2 = 0; i2 < tl; ) {\\n            var r = clm[bits(dat, pos, \
clbmsk)];\\n            pos += r & 15;\\n            var s = r >> 4;\\n       \
     if (s < 16) {\\n              ldt[i2++] = s;\\n            } else {\\n   \
           var c = 0, n = 0;\\n              if (s == 16)\\n                n \
= 3 + bits(dat, pos, 3), pos += 2, c = ldt[i2 - 1];\\n              else if \
(s == 17)\\n                n = 3 + bits(dat, pos, 7), pos += 3;\\n           \
   else if (s == 18)\\n                n = 11 + bits(dat, pos, 127), pos += \
7;\\n              while (n--)\\n                ldt[i2++] = c;\\n            \
}\\n          }\\n          var lt = ldt.subarray(0, hLit), dt = \
ldt.subarray(hLit);\\n          lbt = max(lt);\\n          dbt = max(dt);\\n  \
        lm = hMap(lt, lbt, 1);\\n          dm = hMap(dt, dbt, 1);\\n        } \
else\\n          err(1);\\n        if (pos > tbts) {\\n          if (noSt)\\n \
           err(0);\\n          break;\\n        }\\n      }\\n      if \
(resize)\\n        cbuf(bt + 131072);\\n      var lms = (1 << lbt) - 1, dms = \
(1 << dbt) - 1;\\n      var lpos = pos;\\n      for (; ; lpos = pos) {\\n     \
   var c = lm[bits16(dat, pos) & lms], sym = c >> 4;\\n        pos += c & \
15;\\n        if (pos > tbts) {\\n          if (noSt)\\n            \
err(0);\\n          break;\\n        }\\n        if (!c)\\n          \
err(2);\\n        if (sym < 256)\\n          buf[bt++] = sym;\\n        else \
if (sym == 256) {\\n          lpos = pos, lm = null;\\n          break;\\n    \
    } else {\\n          var add = sym - 254;\\n          if (sym > 264) {\\n \
           var i2 = sym - 257, b = fleb[i2];\\n            add = bits(dat, \
pos, (1 << b) - 1) + fl[i2];\\n            pos += b;\\n          }\\n         \
 var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;\\n          if (!d)\\n    \
        err(3);\\n          pos += d & 15;\\n          var dt = fd[dsym];\\n  \
        if (dsym > 3) {\\n            var b = fdeb[dsym];\\n            dt += \
bits16(dat, pos) & (1 << b) - 1, pos += b;\\n          }\\n          if (pos \
> tbts) {\\n            if (noSt)\\n              err(0);\\n            \
break;\\n          }\\n          if (resize)\\n            cbuf(bt + \
131072);\\n          var end = bt + add;\\n          if (bt < dt) {\\n        \
    var shift = dl - dt, dend = Math.min(dt, end);\\n            if (shift + \
bt < 0)\\n              err(3);\\n            for (; bt < dend; ++bt)\\n      \
        buf[bt] = dict[shift + bt];\\n          }\\n          for (; bt < \
end; ++bt)\\n            buf[bt] = buf[bt - dt];\\n        }\\n      }\\n     \
 st.l = lm, st.p = lpos, st.b = bt, st.f = final;\\n      if (lm)\\n        \
final = 1, st.m = lbt, st.d = dm, st.n = dbt;\\n    } while (!final);\\n    \
return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);\\n  \
};\\n  var et = /* @__PURE__ */ new u8(0);\\n  var mrg = function(a, b) {\\n  \
  var o = {};\\n    for (var k in a)\\n      o[k] = a[k];\\n    for (var k in \
b)\\n      o[k] = b[k];\\n    return o;\\n  };\\n  var wcln = function(fn, \
fnStr, td2) {\\n    var dt = fn();\\n    var st = fn.toString();\\n    var ks \
= st.slice(st.indexOf(\"[\") + 1, st.lastIndexOf(\"]\")).replace(/\\\\s+/g, \
\"\").split(\",\");\\n    for (var i2 = 0; i2 < dt.length; ++i2) {\\n      \
var v = dt[i2], k = ks[i2];\\n      if (typeof v == \"function\") {\\n        \
fnStr += \";\" + k + \"=\";\\n        var st_1 = v.toString();\\n        if \
(v.prototype) {\\n          if (st_1.indexOf(\"[native code]\") != -1) {\\n   \
         var spInd = st_1.indexOf(\" \", 8) + 1;\\n            fnStr += \
st_1.slice(spInd, st_1.indexOf(\"(\", spInd));\\n          } else {\\n        \
    fnStr += st_1;\\n            for (var t in v.prototype)\\n              \
fnStr += \";\" + k + \".prototype.\" + t + \"=\" + \
v.prototype[t].toString();\\n          }\\n        } else\\n          fnStr \
+= st_1;\\n      } else\\n        td2[k] = v;\\n    }\\n    return fnStr;\\n  \
};\\n  var ch = [];\\n  var cbfs = function(v) {\\n    var tl = [];\\n    for \
(var k in v) {\\n      if (v[k].buffer) {\\n        tl.push((v[k] = new \
v[k].constructor(v[k])).buffer);\\n      }\\n    }\\n    return tl;\\n  };\\n \
 var wrkr = function(fns, init, id, cb) {\\n    if (!ch[id]) {\\n      var \
fnStr = \"\", td_1 = {}, m = fns.length - 1;\\n      for (var i2 = 0; i2 < m; \
++i2)\\n        fnStr = wcln(fns[i2], fnStr, td_1);\\n      ch[id] = { c: \
wcln(fns[m], fnStr, td_1), e: td_1 };\\n    }\\n    var td2 = mrg({}, \
ch[id].e);\\n    return wk(ch[id].c + \";onmessage=function(e){for(var k in \
e.data)self[k]=e.data[k];onmessage=\" + init.toString() + \"}\", id, td2, \
cbfs(td2), cb);\\n  };\\n  var bInflt = function() {\\n    return [u8, u16, \
i32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, \
shft, slc, err, inflt, inflateSync, pbf, gopt];\\n  };\\n  var pbf = \
function(msg) {\\n    return postMessage(msg, [msg.buffer]);\\n  };\\n  var \
gopt = function(o) {\\n    return o && {\\n      out: o.size && new \
u8(o.size),\\n      dictionary: o.dictionary\\n    };\\n  };\\n  var cbify = \
function(dat, opts, fns, init, id, cb) {\\n    var w = wrkr(fns, init, id, \
function(err2, dat2) {\\n      w.terminate();\\n      cb(err2, dat2);\\n    \
});\\n    w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);\\n    \
return function() {\\n      w.terminate();\\n    };\\n  };\\n  var b2 = \
function(d, b) {\\n    return d[b] | d[b + 1] << 8;\\n  };\\n  var b4 = \
function(d, b) {\\n    return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + \
3] << 24) >>> 0;\\n  };\\n  var b8 = function(d, b) {\\n    return b4(d, b) + \
b4(d, b + 4) * 4294967296;\\n  };\\n  var gzs = function(d) {\\n    if (d[0] \
!= 31 || d[1] != 139 || d[2] != 8)\\n      err(6, \"invalid gzip data\");\\n  \
  var flg = d[3];\\n    var st = 10;\\n    if (flg & 4)\\n      st += (d[10] \
| d[11] << 8) + 2;\\n    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > \
0; zs -= !d[st++])\\n      ;\\n    return st + (flg & 2);\\n  };\\n  var \
Inflate = /* @__PURE__ */ function() {\\n    function Inflate2(opts, cb) {\\n \
     if (typeof opts == \"function\")\\n        cb = opts, opts = {};\\n      \
this.ondata = cb;\\n      var dict = opts && opts.dictionary && \
opts.dictionary.subarray(-32768);\\n      this.s = { i: 0, b: dict ? \
dict.length : 0 };\\n      this.o = new u8(32768);\\n      this.p = new \
u8(0);\\n      if (dict)\\n        this.o.set(dict);\\n    }\\n    \
Inflate2.prototype.e = function(c) {\\n      if (!this.ondata)\\n        \
err(5);\\n      if (this.d)\\n        err(4);\\n      if (!this.p.length)\\n  \
      this.p = c;\\n      else if (c.length) {\\n        var n = new \
u8(this.p.length + c.length);\\n        n.set(this.p), n.set(c, \
this.p.length), this.p = n;\\n      }\\n    };\\n    Inflate2.prototype.c = \
function(final) {\\n      this.s.i = +(this.d = final || false);\\n      var \
bts = this.s.b;\\n      var dt = inflt(this.p, this.s, this.o);\\n      \
this.ondata(slc(dt, bts, this.s.b), this.d);\\n      this.o = slc(dt, \
this.s.b - 32768), this.s.b = this.o.length;\\n      this.p = slc(this.p, \
this.s.p / 8 | 0), this.s.p &= 7;\\n    };\\n    Inflate2.prototype.push = \
function(chunk, final) {\\n      this.e(chunk), this.c(final);\\n    };\\n    \
return Inflate2;\\n  }();\\n  function inflate(data, opts, cb) {\\n    if \
(!cb)\\n      cb = opts, opts = {};\\n    if (typeof cb != \"function\")\\n   \
   err(7);\\n    return cbify(data, opts, [\\n      bInflt\\n    ], \
function(ev) {\\n      return pbf(inflateSync(ev.data[0], \
gopt(ev.data[1])));\\n    }, 1, cb);\\n  }\\n  function inflateSync(data, \
opts) {\\n    return inflt(data, { i: 2 }, opts && opts.out, opts && \
opts.dictionary);\\n  }\\n  var Gunzip = /* @__PURE__ */ function() {\\n    \
function Gunzip2(opts, cb) {\\n      this.v = 1;\\n      this.r = 0;\\n      \
Inflate.call(this, opts, cb);\\n    }\\n    Gunzip2.prototype.push = \
function(chunk, final) {\\n      Inflate.prototype.e.call(this, chunk);\\n    \
  this.r += chunk.length;\\n      if (this.v) {\\n        var p = \
this.p.subarray(this.v - 1);\\n        var s = p.length > 3 ? gzs(p) : 4;\\n  \
      if (s > p.length) {\\n          if (!final)\\n            return;\\n    \
    } else if (this.v > 1 && this.onmember) {\\n          \
this.onmember(this.r - p.length);\\n        }\\n        this.p = \
p.subarray(s), this.v = 0;\\n      }\\n      Inflate.prototype.c.call(this, \
final);\\n      if (this.s.f && !this.s.l && !final) {\\n        this.v = \
shft(this.s.p) + 9;\\n        this.s = { i: 0 };\\n        this.o = new \
u8(0);\\n        this.push(new u8(0), final);\\n      }\\n    };\\n    return \
Gunzip2;\\n  }();\\n  var td = typeof TextDecoder != \"undefined\" && /* \
@__PURE__ */ new TextDecoder();\\n  try {\\n    td.decode(et, { stream: true \
});\\n  } catch (e) {\\n  }\\n  var dutf8 = function(d) {\\n    for (var r = \
\"\", i2 = 0; ; ) {\\n      var c = d[i2++];\\n      var eb = (c > 127) + (c \
> 223) + (c > 239);\\n      if (i2 + eb > d.length)\\n        return { s: r, \
r: slc(d, i2 - 1) };\\n      if (!eb)\\n        r += \
String.fromCharCode(c);\\n      else if (eb == 3) {\\n        c = ((c & 15) \
<< 18 | (d[i2++] & 63) << 12 | (d[i2++] & 63) << 6 | d[i2++] & 63) - 65536, r \
+= String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);\\n      } else if \
(eb & 1)\\n        r += String.fromCharCode((c & 31) << 6 | d[i2++] & 63);\\n \
     else\\n        r += String.fromCharCode((c & 15) << 12 | (d[i2++] & 63) \
<< 6 | d[i2++] & 63);\\n    }\\n  };\\n  function strFromU8(dat, latin1) {\\n \
   if (latin1) {\\n      var r = \"\";\\n      for (var i2 = 0; i2 < \
dat.length; i2 += 16384)\\n        r += String.fromCharCode.apply(null, \
dat.subarray(i2, i2 + 16384));\\n      return r;\\n    } else if (td) {\\n    \
  return td.decode(dat);\\n    } else {\\n      var _a2 = dutf8(dat), s = \
_a2.s, r = _a2.r;\\n      if (r.length)\\n        err(8);\\n      return \
s;\\n    }\\n  }\\n  var slzh = function(d, b) {\\n    return b + 30 + b2(d, \
b + 26) + b2(d, b + 28);\\n  };\\n  var zh = function(d, b, z) {\\n    var \
fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, \
b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\\n    var _a2 = z && \
bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = \
_a2[0], su = _a2[1], off = _a2[2];\\n    return [b2(d, b + 10), sc, su, fn, \
es + b2(d, b + 30) + b2(d, b + 32), off];\\n  };\\n  var z64e = function(d, \
b) {\\n    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))\\n      ;\\n    \
return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];\\n  };\\n  var mt = \
typeof queueMicrotask == \"function\" ? queueMicrotask : typeof setTimeout == \
\"function\" ? setTimeout : function(fn) {\\n    fn();\\n  };\\n  function \
unzip(data, opts, cb) {\\n    if (!cb)\\n      cb = opts, opts = {};\\n    if \
(typeof cb != \"function\")\\n      err(7);\\n    var term = [];\\n    var \
tAll = function() {\\n      for (var i3 = 0; i3 < term.length; ++i3)\\n       \
 term[i3]();\\n    };\\n    var files = {};\\n    var cbd = function(a, b) \
{\\n      mt(function() {\\n        cb(a, b);\\n      });\\n    };\\n    \
mt(function() {\\n      cbd = cb;\\n    });\\n    var e = data.length - \
22;\\n    for (; b4(data, e) != 101010256; --e) {\\n      if (!e || \
data.length - e > 65558) {\\n        cbd(err(13, 0, 1), null);\\n        \
return tAll;\\n      }\\n    }\\n    var lft = b2(data, e + 8);\\n    if \
(lft) {\\n      var c = lft;\\n      var o = b4(data, e + 16);\\n      var z \
= o == 4294967295 || c == 65535;\\n      if (z) {\\n        var ze = b4(data, \
e - 12);\\n        z = b4(data, ze) == 101075792;\\n        if (z) {\\n       \
   c = lft = b4(data, ze + 32);\\n          o = b4(data, ze + 48);\\n        \
}\\n      }\\n      var fltr = opts && opts.filter;\\n      var _loop_3 = \
function(i3) {\\n        var _a2 = zh(data, o, z), c_1 = _a2[0], sc = _a2[1], \
su = _a2[2], fn = _a2[3], no = _a2[4], off = _a2[5], b = slzh(data, off);\\n  \
      o = no;\\n        var cbl = function(e2, d) {\\n          if (e2) {\\n  \
          tAll();\\n            cbd(e2, null);\\n          } else {\\n        \
    if (d)\\n              files[fn] = d;\\n            if (!--lft)\\n        \
      cbd(null, files);\\n          }\\n        };\\n        if (!fltr || \
fltr({\\n          name: fn,\\n          size: sc,\\n          originalSize: \
su,\\n          compression: c_1\\n        })) {\\n          if (!c_1)\\n     \
       cbl(null, slc(data, b, b + sc));\\n          else if (c_1 == 8) {\\n   \
         var infl = data.subarray(b, b + sc);\\n            if (su < 524288 \
|| sc > 0.8 * su) {\\n              try {\\n                cbl(null, \
inflateSync(infl, { out: new u8(su) }));\\n              } catch (e2) {\\n    \
            cbl(e2, null);\\n              }\\n            } else\\n          \
    term.push(inflate(infl, { size: su }, cbl));\\n          } else\\n        \
    cbl(err(14, \"unknown compression type \" + c_1, 1), null);\\n        } \
else\\n          cbl(null, null);\\n      };\\n      for (var i2 = 0; i2 < c; \
++i2) {\\n        _loop_3(i2);\\n      }\\n    } else\\n      cbd(null, \
{});\\n    return tAll;\\n  }\\n  function unzipSync(data, opts) {\\n    var \
files = {};\\n    var e = data.length - 22;\\n    for (; b4(data, e) != \
101010256; --e) {\\n      if (!e || data.length - e > 65558)\\n        \
err(13);\\n    }\\n    var c = b2(data, e + 8);\\n    if (!c)\\n      return \
{};\\n    var o = b4(data, e + 16);\\n    var z = o == 4294967295 || c == \
65535;\\n    if (z) {\\n      var ze = b4(data, e - 12);\\n      z = b4(data, \
ze) == 101075792;\\n      if (z) {\\n        c = b4(data, ze + 32);\\n        \
o = b4(data, ze + 48);\\n      }\\n    }\\n    var fltr = opts && \
opts.filter;\\n    for (var i2 = 0; i2 < c; ++i2) {\\n      var _a2 = \
zh(data, o, z), c_2 = _a2[0], sc = _a2[1], su = _a2[2], fn = _a2[3], no = \
_a2[4], off = _a2[5], b = slzh(data, off);\\n      o = no;\\n      if (!fltr \
|| fltr({\\n        name: fn,\\n        size: sc,\\n        originalSize: \
su,\\n        compression: c_2\\n      })) {\\n        if (!c_2)\\n          \
files[fn] = slc(data, b, b + sc);\\n        else if (c_2 == 8)\\n          \
files[fn] = inflateSync(data.subarray(b, b + sc), { out: new u8(su) });\\n    \
    else\\n          err(14, \"unknown compression type \" + c_2);\\n      \
}\\n    }\\n    return files;\\n  }\\n  /**\\n   * @license\\n   * Copyright \
2010-2025 Three.js Authors\\n   * SPDX-License-Identifier: MIT\\n   */\\n  \
const REVISION = \"178\";\\n  const NoColorSpace = \"\";\\n  const \
SRGBColorSpace = \"srgb\";\\n  const LinearSRGBColorSpace = \
\"srgb-linear\";\\n  const LinearTransfer = \"linear\";\\n  const \
SRGBTransfer = \"srgb\";\\n  function clamp(value, min, max2) {\\n    return \
Math.max(min, Math.min(max2, value));\\n  }\\n  function euclideanModulo(n, \
m) {\\n    return (n % m + m) % m;\\n  }\\n  function lerp(x2, y, t) {\\n    \
return (1 - t) * x2 + t * y;\\n  }\\n  class Quaternion {\\n    /**\\n     * \
Constructs a new quaternion.\\n     *\\n     * @param {number} [x=0] - The x \
value of this quaternion.\\n     * @param {number} [y=0] - The y value of \
this quaternion.\\n     * @param {number} [z=0] - The z value of this \
quaternion.\\n     * @param {number} [w=1] - The w value of this \
quaternion.\\n     */\\n    constructor(x2 = 0, y = 0, z = 0, w = 1) {\\n     \
 this.isQuaternion = true;\\n      this._x = x2;\\n      this._y = y;\\n      \
this._z = z;\\n      this._w = w;\\n    }\\n    /**\\n     * Interpolates \
between two quaternions via SLERP. This implementation assumes the\\n     * \
quaternion data are managed  in flat arrays.\\n     *\\n     * @param \
{Array<number>} dst - The destination array.\\n     * @param {number} \
dstOffset - An offset into the destination array.\\n     * @param \
{Array<number>} src0 - The source array of the first quaternion.\\n     * \
@param {number} srcOffset0 - An offset into the first source array.\\n     * \
@param {Array<number>} src1 -  The source array of the second quaternion.\\n  \
   * @param {number} srcOffset1 - An offset into the second source array.\\n  \
   * @param {number} t - The interpolation factor in the range `[0,1]`.\\n    \
 * @see {@link Quaternion#slerp}\\n     */\\n    static slerpFlat(dst, \
dstOffset, src0, srcOffset0, src1, srcOffset1, t) {\\n      let x0 = \
src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], \
w0 = src0[srcOffset0 + 3];\\n      const x1 = src1[srcOffset1 + 0], y1 = \
src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + \
3];\\n      if (t === 0) {\\n        dst[dstOffset + 0] = x0;\\n        \
dst[dstOffset + 1] = y0;\\n        dst[dstOffset + 2] = z0;\\n        \
dst[dstOffset + 3] = w0;\\n        return;\\n      }\\n      if (t === 1) \
{\\n        dst[dstOffset + 0] = x1;\\n        dst[dstOffset + 1] = y1;\\n    \
    dst[dstOffset + 2] = z1;\\n        dst[dstOffset + 3] = w1;\\n        \
return;\\n      }\\n      if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== \
z1) {\\n        let s = 1 - t;\\n        const cos = x0 * x1 + y0 * y1 + z0 * \
z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;\\n        if \
(sqrSin > Number.EPSILON) {\\n          const sin = Math.sqrt(sqrSin), len = \
Math.atan2(sin, cos * dir);\\n          s = Math.sin(s * len) / sin;\\n       \
   t = Math.sin(t * len) / sin;\\n        }\\n        const tDir = t * \
dir;\\n        x0 = x0 * s + x1 * tDir;\\n        y0 = y0 * s + y1 * tDir;\\n \
       z0 = z0 * s + z1 * tDir;\\n        w0 = w0 * s + w1 * tDir;\\n        \
if (s === 1 - t) {\\n          const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 \
* z0 + w0 * w0);\\n          x0 *= f;\\n          y0 *= f;\\n          z0 *= \
f;\\n          w0 *= f;\\n        }\\n      }\\n      dst[dstOffset] = x0;\\n \
     dst[dstOffset + 1] = y0;\\n      dst[dstOffset + 2] = z0;\\n      \
dst[dstOffset + 3] = w0;\\n    }\\n    /**\\n     * Multiplies two \
quaternions. This implementation assumes the quaternion data are managed\\n   \
  * in flat arrays.\\n     *\\n     * @param {Array<number>} dst - The \
destination array.\\n     * @param {number} dstOffset - An offset into the \
destination array.\\n     * @param {Array<number>} src0 - The source array of \
the first quaternion.\\n     * @param {number} srcOffset0 - An offset into \
the first source array.\\n     * @param {Array<number>} src1 -  The source \
array of the second quaternion.\\n     * @param {number} srcOffset1 - An \
offset into the second source array.\\n     * @return {Array<number>} The \
destination array.\\n     * @see {@link Quaternion#multiplyQuaternions}.\\n   \
  */\\n    static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, \
src1, srcOffset1) {\\n      const x0 = src0[srcOffset0];\\n      const y0 = \
src0[srcOffset0 + 1];\\n      const z0 = src0[srcOffset0 + 2];\\n      const \
w0 = src0[srcOffset0 + 3];\\n      const x1 = src1[srcOffset1];\\n      const \
y1 = src1[srcOffset1 + 1];\\n      const z1 = src1[srcOffset1 + 2];\\n      \
const w1 = src1[srcOffset1 + 3];\\n      dst[dstOffset] = x0 * w1 + w0 * x1 + \
y0 * z1 - z0 * y1;\\n      dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - \
x0 * z1;\\n      dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * \
x1;\\n      dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;\\n    \
  return dst;\\n    }\\n    /**\\n     * The x value of this quaternion.\\n   \
  *\\n     * @type {number}\\n     * @default 0\\n     */\\n    get x() {\\n  \
    return this._x;\\n    }\\n    set x(value) {\\n      this._x = value;\\n  \
    this._onChangeCallback();\\n    }\\n    /**\\n     * The y value of this \
quaternion.\\n     *\\n     * @type {number}\\n     * @default 0\\n     */\\n \
   get y() {\\n      return this._y;\\n    }\\n    set y(value) {\\n      \
this._y = value;\\n      this._onChangeCallback();\\n    }\\n    /**\\n     * \
The z value of this quaternion.\\n     *\\n     * @type {number}\\n     * \
@default 0\\n     */\\n    get z() {\\n      return this._z;\\n    }\\n    \
set z(value) {\\n      this._z = value;\\n      this._onChangeCallback();\\n  \
  }\\n    /**\\n     * The w value of this quaternion.\\n     *\\n     * \
@type {number}\\n     * @default 1\\n     */\\n    get w() {\\n      return \
this._w;\\n    }\\n    set w(value) {\\n      this._w = value;\\n      \
this._onChangeCallback();\\n    }\\n    /**\\n     * Sets the quaternion \
components.\\n     *\\n     * @param {number} x - The x value of this \
quaternion.\\n     * @param {number} y - The y value of this quaternion.\\n   \
  * @param {number} z - The z value of this quaternion.\\n     * @param \
{number} w - The w value of this quaternion.\\n     * @return {Quaternion} A \
reference to this quaternion.\\n     */\\n    set(x2, y, z, w) {\\n      \
this._x = x2;\\n      this._y = y;\\n      this._z = z;\\n      this._w = \
w;\\n      this._onChangeCallback();\\n      return this;\\n    }\\n    \
/**\\n     * Returns a new quaternion with copied values from this \
instance.\\n     *\\n     * @return {Quaternion} A clone of this instance.\\n \
    */\\n    clone() {\\n      return new this.constructor(this._x, this._y, \
this._z, this._w);\\n    }\\n    /**\\n     * Copies the values of the given \
quaternion to this instance.\\n     *\\n     * @param {Quaternion} quaternion \
- The quaternion to copy.\\n     * @return {Quaternion} A reference to this \
quaternion.\\n     */\\n    copy(quaternion) {\\n      this._x = \
quaternion.x;\\n      this._y = quaternion.y;\\n      this._z = \
quaternion.z;\\n      this._w = quaternion.w;\\n      \
this._onChangeCallback();\\n      return this;\\n    }\\n    /**\\n     * \
Sets this quaternion from the rotation specified by the given\\n     * Euler \
angles.\\n     *\\n     * @param {Euler} euler - The Euler angles.\\n     * \
@param {boolean} [update=true] - Whether the internal `onChange` callback \
should be executed or not.\\n     * @return {Quaternion} A reference to this \
quaternion.\\n     */\\n    setFromEuler(euler, update = true) {\\n      \
const x2 = euler._x, y = euler._y, z = euler._z, order = euler._order;\\n     \
 const cos = Math.cos;\\n      const sin = Math.sin;\\n      const c1 = \
cos(x2 / 2);\\n      const c2 = cos(y / 2);\\n      const c3 = cos(z / 2);\\n \
     const s1 = sin(x2 / 2);\\n      const s2 = sin(y / 2);\\n      const s3 \
= sin(z / 2);\\n      switch (order) {\\n        case \"XYZ\":\\n          \
this._x = s1 * c2 * c3 + c1 * s2 * s3;\\n          this._y = c1 * s2 * c3 - \
s1 * c2 * s3;\\n          this._z = c1 * c2 * s3 + s1 * s2 * c3;\\n          \
this._w = c1 * c2 * c3 - s1 * s2 * s3;\\n          break;\\n        case \
\"YXZ\":\\n          this._x = s1 * c2 * c3 + c1 * s2 * s3;\\n          \
this._y = c1 * s2 * c3 - s1 * c2 * s3;\\n          this._z = c1 * c2 * s3 - \
s1 * s2 * c3;\\n          this._w = c1 * c2 * c3 + s1 * s2 * s3;\\n          \
break;\\n        case \"ZXY\":\\n          this._x = s1 * c2 * c3 - c1 * s2 * \
s3;\\n          this._y = c1 * s2 * c3 + s1 * c2 * s3;\\n          this._z = \
c1 * c2 * s3 + s1 * s2 * c3;\\n          this._w = c1 * c2 * c3 - s1 * s2 * \
s3;\\n          break;\\n        case \"ZYX\":\\n          this._x = s1 * c2 \
* c3 - c1 * s2 * s3;\\n          this._y = c1 * s2 * c3 + s1 * c2 * s3;\\n    \
      this._z = c1 * c2 * s3 - s1 * s2 * c3;\\n          this._w = c1 * c2 * \
c3 + s1 * s2 * s3;\\n          break;\\n        case \"YZX\":\\n          \
this._x = s1 * c2 * c3 + c1 * s2 * s3;\\n          this._y = c1 * s2 * c3 + \
s1 * c2 * s3;\\n          this._z = c1 * c2 * s3 - s1 * s2 * c3;\\n          \
this._w = c1 * c2 * c3 - s1 * s2 * s3;\\n          break;\\n        case \
\"XZY\":\\n          this._x = s1 * c2 * c3 - c1 * s2 * s3;\\n          \
this._y = c1 * s2 * c3 - s1 * c2 * s3;\\n          this._z = c1 * c2 * s3 + \
s1 * s2 * c3;\\n          this._w = c1 * c2 * c3 + s1 * s2 * s3;\\n          \
break;\\n        default:\\n          console.warn(\"THREE.Quaternion: \
.setFromEuler() encountered an unknown order: \" + order);\\n      }\\n      \
if (update === true) this._onChangeCallback();\\n      return this;\\n    \
}\\n    /**\\n     * Sets this quaternion from the given axis and angle.\\n   \
  *\\n     * @param {Vector3} axis - The normalized axis.\\n     * @param \
{number} angle - The angle in radians.\\n     * @return {Quaternion} A \
reference to this quaternion.\\n     */\\n    setFromAxisAngle(axis, angle) \
{\\n      const halfAngle = angle / 2, s = Math.sin(halfAngle);\\n      \
this._x = axis.x * s;\\n      this._y = axis.y * s;\\n      this._z = axis.z \
* s;\\n      this._w = Math.cos(halfAngle);\\n      \
this._onChangeCallback();\\n      return this;\\n    }\\n    /**\\n     * \
Sets this quaternion from the given rotation matrix.\\n     *\\n     * @param \
{Matrix4} m - A 4x4 matrix of which the upper 3x3 of matrix is a pure \
rotation matrix (i.e. unscaled).\\n     * @return {Quaternion} A reference to \
this quaternion.\\n     */\\n    setFromRotationMatrix(m) {\\n      const te \
= m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = \
te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 \
+ m33;\\n      if (trace > 0) {\\n        const s = 0.5 / Math.sqrt(trace + \
1);\\n        this._w = 0.25 / s;\\n        this._x = (m32 - m23) * s;\\n     \
   this._y = (m13 - m31) * s;\\n        this._z = (m21 - m12) * s;\\n      } \
else if (m11 > m22 && m11 > m33) {\\n        const s = 2 * Math.sqrt(1 + m11 \
- m22 - m33);\\n        this._w = (m32 - m23) / s;\\n        this._x = 0.25 * \
s;\\n        this._y = (m12 + m21) / s;\\n        this._z = (m13 + m31) / \
s;\\n      } else if (m22 > m33) {\\n        const s = 2 * Math.sqrt(1 + m22 \
- m11 - m33);\\n        this._w = (m13 - m31) / s;\\n        this._x = (m12 + \
m21) / s;\\n        this._y = 0.25 * s;\\n        this._z = (m23 + m32) / \
s;\\n      } else {\\n        const s = 2 * Math.sqrt(1 + m33 - m11 - \
m22);\\n        this._w = (m21 - m12) / s;\\n        this._x = (m13 + m31) / \
s;\\n        this._y = (m23 + m32) / s;\\n        this._z = 0.25 * s;\\n      \
}\\n      this._onChangeCallback();\\n      return this;\\n    }\\n    /**\\n \
    * Sets this quaternion to the rotation required to rotate the direction \
vector\\n     * `vFrom` to the direction vector `vTo`.\\n     *\\n     * \
@param {Vector3} vFrom - The first (normalized) direction vector.\\n     * \
@param {Vector3} vTo - The second (normalized) direction vector.\\n     * \
@return {Quaternion} A reference to this quaternion.\\n     */\\n    \
setFromUnitVectors(vFrom, vTo) {\\n      let r = vFrom.dot(vTo) + 1;\\n      \
if (r < 1e-8) {\\n        r = 0;\\n        if (Math.abs(vFrom.x) > \
Math.abs(vFrom.z)) {\\n          this._x = -vFrom.y;\\n          this._y = \
vFrom.x;\\n          this._z = 0;\\n          this._w = r;\\n        } else \
{\\n          this._x = 0;\\n          this._y = -vFrom.z;\\n          \
this._z = vFrom.y;\\n          this._w = r;\\n        }\\n      } else {\\n   \
     this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;\\n        this._y = vFrom.z \
* vTo.x - vFrom.x * vTo.z;\\n        this._z = vFrom.x * vTo.y - vFrom.y * \
vTo.x;\\n        this._w = r;\\n      }\\n      return this.normalize();\\n   \
 }\\n    /**\\n     * Returns the angle between this quaternion and the given \
one in radians.\\n     *\\n     * @param {Quaternion} q - The quaternion to \
compute the angle with.\\n     * @return {number} The angle in radians.\\n    \
 */\\n    angleTo(q) {\\n      return 2 * \
Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));\\n    }\\n    /**\\n     * \
Rotates this quaternion by a given angular step to the given quaternion.\\n   \
  * The method ensures that the final quaternion will not overshoot `q`.\\n   \
  *\\n     * @param {Quaternion} q - The target quaternion.\\n     * @param \
{number} step - The angular step in radians.\\n     * @return {Quaternion} A \
reference to this quaternion.\\n     */\\n    rotateTowards(q, step) {\\n     \
 const angle = this.angleTo(q);\\n      if (angle === 0) return this;\\n      \
const t = Math.min(1, step / angle);\\n      this.slerp(q, t);\\n      return \
this;\\n    }\\n    /**\\n     * Sets this quaternion to the identity \
quaternion; that is, to the\\n     * quaternion that represents \"no \
rotation\".\\n     *\\n     * @return {Quaternion} A reference to this \
quaternion.\\n     */\\n    identity() {\\n      return this.set(0, 0, 0, \
1);\\n    }\\n    /**\\n     * Inverts this quaternion via {@link \
Quaternion#conjugate}. The\\n     * quaternion is assumed to have unit \
length.\\n     *\\n     * @return {Quaternion} A reference to this \
quaternion.\\n     */\\n    invert() {\\n      return this.conjugate();\\n    \
}\\n    /**\\n     * Returns the rotational conjugate of this quaternion. The \
conjugate of a\\n     * quaternion represents the same rotation in the \
opposite direction about\\n     * the rotational axis.\\n     *\\n     * \
@return {Quaternion} A reference to this quaternion.\\n     */\\n    \
conjugate() {\\n      this._x *= -1;\\n      this._y *= -1;\\n      this._z \
*= -1;\\n      this._onChangeCallback();\\n      return this;\\n    }\\n    \
/**\\n     * Calculates the dot product of this quaternion and the given \
one.\\n     *\\n     * @param {Quaternion} v - The quaternion to compute the \
dot product with.\\n     * @return {number} The result of the dot product.\\n \
    */\\n    dot(v) {\\n      return this._x * v._x + this._y * v._y + \
this._z * v._z + this._w * v._w;\\n    }\\n    /**\\n     * Computes the \
squared Euclidean length (straight-line length) of this quaternion,\\n     * \
considered as a 4 dimensional vector. This can be useful if you are comparing \
the\\n     * lengths of two quaternions, as this is a slightly more efficient \
calculation than\\n     * {@link Quaternion#length}.\\n     *\\n     * \
@return {number} The squared Euclidean length.\\n     */\\n    lengthSq() \
{\\n      return this._x * this._x + this._y * this._y + this._z * this._z + \
this._w * this._w;\\n    }\\n    /**\\n     * Computes the Euclidean length \
(straight-line length) of this quaternion,\\n     * considered as a 4 \
dimensional vector.\\n     *\\n     * @return {number} The Euclidean \
length.\\n     */\\n    length() {\\n      return Math.sqrt(this._x * this._x \
+ this._y * this._y + this._z * this._z + this._w * this._w);\\n    }\\n    \
/**\\n     * Normalizes this quaternion - that is, calculated the quaternion \
that performs\\n     * the same rotation as this one, but has a length equal \
to `1`.\\n     *\\n     * @return {Quaternion} A reference to this \
quaternion.\\n     */\\n    normalize() {\\n      let l = this.length();\\n   \
   if (l === 0) {\\n        this._x = 0;\\n        this._y = 0;\\n        \
this._z = 0;\\n        this._w = 1;\\n      } else {\\n        l = 1 / l;\\n  \
      this._x = this._x * l;\\n        this._y = this._y * l;\\n        \
this._z = this._z * l;\\n        this._w = this._w * l;\\n      }\\n      \
this._onChangeCallback();\\n      return this;\\n    }\\n    /**\\n     * \
Multiplies this quaternion by the given one.\\n     *\\n     * @param \
{Quaternion} q - The quaternion.\\n     * @return {Quaternion} A reference to \
this quaternion.\\n     */\\n    multiply(q) {\\n      return \
this.multiplyQuaternions(this, q);\\n    }\\n    /**\\n     * Pre-multiplies \
this quaternion by the given one.\\n     *\\n     * @param {Quaternion} q - \
The quaternion.\\n     * @return {Quaternion} A reference to this \
quaternion.\\n     */\\n    premultiply(q) {\\n      return \
this.multiplyQuaternions(q, this);\\n    }\\n    /**\\n     * Multiplies the \
given quaternions and stores the result in this instance.\\n     *\\n     * \
@param {Quaternion} a - The first quaternion.\\n     * @param {Quaternion} b \
- The second quaternion.\\n     * @return {Quaternion} A reference to this \
quaternion.\\n     */\\n    multiplyQuaternions(a, b) {\\n      const qax = \
a._x, qay = a._y, qaz = a._z, qaw = a._w;\\n      const qbx = b._x, qby = \
b._y, qbz = b._z, qbw = b._w;\\n      this._x = qax * qbw + qaw * qbx + qay * \
qbz - qaz * qby;\\n      this._y = qay * qbw + qaw * qby + qaz * qbx - qax * \
qbz;\\n      this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\\n      \
this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\\n      \
this._onChangeCallback();\\n      return this;\\n    }\\n    /**\\n     * \
Performs a spherical linear interpolation between quaternions.\\n     *\\n    \
 * @param {Quaternion} qb - The target quaternion.\\n     * @param {number} t \
- The interpolation factor in the closed interval `[0, 1]`.\\n     * @return \
{Quaternion} A reference to this quaternion.\\n     */\\n    slerp(qb, t) \
{\\n      if (t === 0) return this;\\n      if (t === 1) return \
this.copy(qb);\\n      const x2 = this._x, y = this._y, z = this._z, w = \
this._w;\\n      let cosHalfTheta = w * qb._w + x2 * qb._x + y * qb._y + z * \
qb._z;\\n      if (cosHalfTheta < 0) {\\n        this._w = -qb._w;\\n        \
this._x = -qb._x;\\n        this._y = -qb._y;\\n        this._z = -qb._z;\\n  \
      cosHalfTheta = -cosHalfTheta;\\n      } else {\\n        \
this.copy(qb);\\n      }\\n      if (cosHalfTheta >= 1) {\\n        this._w = \
w;\\n        this._x = x2;\\n        this._y = y;\\n        this._z = z;\\n   \
     return this;\\n      }\\n      const sqrSinHalfTheta = 1 - cosHalfTheta \
* cosHalfTheta;\\n      if (sqrSinHalfTheta <= Number.EPSILON) {\\n        \
const s = 1 - t;\\n        this._w = s * w + t * this._w;\\n        this._x = \
s * x2 + t * this._x;\\n        this._y = s * y + t * this._y;\\n        \
this._z = s * z + t * this._z;\\n        this.normalize();\\n        return \
this;\\n      }\\n      const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);\\n   \
   const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);\\n      const \
ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * \
halfTheta) / sinHalfTheta;\\n      this._w = w * ratioA + this._w * \
ratioB;\\n      this._x = x2 * ratioA + this._x * ratioB;\\n      this._y = y \
* ratioA + this._y * ratioB;\\n      this._z = z * ratioA + this._z * \
ratioB;\\n      this._onChangeCallback();\\n      return this;\\n    }\\n    \
/**\\n     * Performs a spherical linear interpolation between the given \
quaternions\\n     * and stores the result in this quaternion.\\n     *\\n    \
 * @param {Quaternion} qa - The source quaternion.\\n     * @param \
{Quaternion} qb - The target quaternion.\\n     * @param {number} t - The \
interpolation factor in the closed interval `[0, 1]`.\\n     * @return \
{Quaternion} A reference to this quaternion.\\n     */\\n    \
slerpQuaternions(qa, qb, t) {\\n      return this.copy(qa).slerp(qb, t);\\n   \
 }\\n    /**\\n     * Sets this quaternion to a uniformly random, normalized \
quaternion.\\n     *\\n     * @return {Quaternion} A reference to this \
quaternion.\\n     */\\n    random() {\\n      const theta1 = 2 * Math.PI * \
Math.random();\\n      const theta2 = 2 * Math.PI * Math.random();\\n      \
const x0 = Math.random();\\n      const r1 = Math.sqrt(1 - x0);\\n      const \
r2 = Math.sqrt(x0);\\n      return this.set(\\n        r1 * \
Math.sin(theta1),\\n        r1 * Math.cos(theta1),\\n        r2 * \
Math.sin(theta2),\\n        r2 * Math.cos(theta2)\\n      );\\n    }\\n    \
/**\\n     * Returns `true` if this quaternion is equal with the given \
one.\\n     *\\n     * @param {Quaternion} quaternion - The quaternion to \
test for equality.\\n     * @return {boolean} Whether this quaternion is \
equal with the given one.\\n     */\\n    equals(quaternion) {\\n      return \
quaternion._x === this._x && quaternion._y === this._y && quaternion._z === \
this._z && quaternion._w === this._w;\\n    }\\n    /**\\n     * Sets this \
quaternion\\'s components from the given array.\\n     *\\n     * @param \
{Array<number>} array - An array holding the quaternion component values.\\n  \
   * @param {number} [offset=0] - The offset into the array.\\n     * @return \
{Quaternion} A reference to this quaternion.\\n     */\\n    fromArray(array, \
offset = 0) {\\n      this._x = array[offset];\\n      this._y = array[offset \
+ 1];\\n      this._z = array[offset + 2];\\n      this._w = array[offset + \
3];\\n      this._onChangeCallback();\\n      return this;\\n    }\\n    \
/**\\n     * Writes the components of this quaternion to the given array. If \
no array is provided,\\n     * the method returns a new instance.\\n     *\\n \
    * @param {Array<number>} [array=[]] - The target array holding the \
quaternion components.\\n     * @param {number} [offset=0] - Index of the \
first element in the array.\\n     * @return {Array<number>} The quaternion \
components.\\n     */\\n    toArray(array = [], offset = 0) {\\n      \
array[offset] = this._x;\\n      array[offset + 1] = this._y;\\n      \
array[offset + 2] = this._z;\\n      array[offset + 3] = this._w;\\n      \
return array;\\n    }\\n    /**\\n     * Sets the components of this \
quaternion from the given buffer attribute.\\n     *\\n     * @param \
{BufferAttribute} attribute - The buffer attribute holding quaternion \
data.\\n     * @param {number} index - The index into the attribute.\\n     * \
@return {Quaternion} A reference to this quaternion.\\n     */\\n    \
fromBufferAttribute(attribute, index) {\\n      this._x = \
attribute.getX(index);\\n      this._y = attribute.getY(index);\\n      \
this._z = attribute.getZ(index);\\n      this._w = attribute.getW(index);\\n  \
    this._onChangeCallback();\\n      return this;\\n    }\\n    /**\\n     * \
This methods defines the serialization result of this class. Returns the\\n   \
  * numerical elements of this quaternion in an array of format `[x, y, z, \
w]`.\\n     *\\n     * @return {Array<number>} The serialized quaternion.\\n  \
   */\\n    toJSON() {\\n      return this.toArray();\\n    }\\n    \
_onChange(callback) {\\n      this._onChangeCallback = callback;\\n      \
return this;\\n    }\\n    _onChangeCallback() {\\n    }\\n    \
*[Symbol.iterator]() {\\n      yield this._x;\\n      yield this._y;\\n      \
yield this._z;\\n      yield this._w;\\n    }\\n  }\\n  class Vector3 {\\n    \
/**\\n     * Constructs a new 3D vector.\\n     *\\n     * @param {number} \
[x=0] - The x value of this vector.\\n     * @param {number} [y=0] - The y \
value of this vector.\\n     * @param {number} [z=0] - The z value of this \
vector.\\n     */\\n    constructor(x2 = 0, y = 0, z = 0) {\\n      \
Vector3.prototype.isVector3 = true;\\n      this.x = x2;\\n      this.y = \
y;\\n      this.z = z;\\n    }\\n    /**\\n     * Sets the vector \
components.\\n     *\\n     * @param {number} x - The value of the x \
component.\\n     * @param {number} y - The value of the y component.\\n     \
* @param {number} z - The value of the z component.\\n     * @return \
{Vector3} A reference to this vector.\\n     */\\n    set(x2, y, z) {\\n      \
if (z === void 0) z = this.z;\\n      this.x = x2;\\n      this.y = y;\\n     \
 this.z = z;\\n      return this;\\n    }\\n    /**\\n     * Sets the vector \
components to the same value.\\n     *\\n     * @param {number} scalar - The \
value to set for all vector components.\\n     * @return {Vector3} A \
reference to this vector.\\n     */\\n    setScalar(scalar) {\\n      this.x \
= scalar;\\n      this.y = scalar;\\n      this.z = scalar;\\n      return \
this;\\n    }\\n    /**\\n     * Sets the vector\\'s x component to the given \
value\\n     *\\n     * @param {number} x - The value to set.\\n     * \
@return {Vector3} A reference to this vector.\\n     */\\n    setX(x2) {\\n   \
   this.x = x2;\\n      return this;\\n    }\\n    /**\\n     * Sets the \
vector\\'s y component to the given value\\n     *\\n     * @param {number} y \
- The value to set.\\n     * @return {Vector3} A reference to this vector.\\n \
    */\\n    setY(y) {\\n      this.y = y;\\n      return this;\\n    }\\n    \
/**\\n     * Sets the vector\\'s z component to the given value\\n     *\\n   \
  * @param {number} z - The value to set.\\n     * @return {Vector3} A \
reference to this vector.\\n     */\\n    setZ(z) {\\n      this.z = z;\\n    \
  return this;\\n    }\\n    /**\\n     * Allows to set a vector component \
with an index.\\n     *\\n     * @param {number} index - The component index. \
`0` equals to x, `1` equals to y, `2` equals to z.\\n     * @param {number} \
value - The value to set.\\n     * @return {Vector3} A reference to this \
vector.\\n     */\\n    setComponent(index, value) {\\n      switch (index) \
{\\n        case 0:\\n          this.x = value;\\n          break;\\n        \
case 1:\\n          this.y = value;\\n          break;\\n        case 2:\\n   \
       this.z = value;\\n          break;\\n        default:\\n          \
throw new Error(\"index is out of range: \" + index);\\n      }\\n      \
return this;\\n    }\\n    /**\\n     * Returns the value of the vector \
component which matches the given index.\\n     *\\n     * @param {number} \
index - The component index. `0` equals to x, `1` equals to y, `2` equals to \
z.\\n     * @return {number} A vector component value.\\n     */\\n    \
getComponent(index) {\\n      switch (index) {\\n        case 0:\\n          \
return this.x;\\n        case 1:\\n          return this.y;\\n        case \
2:\\n          return this.z;\\n        default:\\n          throw new \
Error(\"index is out of range: \" + index);\\n      }\\n    }\\n    /**\\n    \
 * Returns a new vector with copied values from this instance.\\n     *\\n    \
 * @return {Vector3} A clone of this instance.\\n     */\\n    clone() {\\n   \
   return new this.constructor(this.x, this.y, this.z);\\n    }\\n    /**\\n  \
   * Copies the values of the given vector to this instance.\\n     *\\n     \
* @param {Vector3} v - The vector to copy.\\n     * @return {Vector3} A \
reference to this vector.\\n     */\\n    copy(v) {\\n      this.x = v.x;\\n  \
    this.y = v.y;\\n      this.z = v.z;\\n      return this;\\n    }\\n    \
/**\\n     * Adds the given vector to this instance.\\n     *\\n     * @param \
{Vector3} v - The vector to add.\\n     * @return {Vector3} A reference to \
this vector.\\n     */\\n    add(v) {\\n      this.x += v.x;\\n      this.y \
+= v.y;\\n      this.z += v.z;\\n      return this;\\n    }\\n    /**\\n     \
* Adds the given scalar value to all components of this instance.\\n     *\\n \
    * @param {number} s - The scalar to add.\\n     * @return {Vector3} A \
reference to this vector.\\n     */\\n    addScalar(s) {\\n      this.x += \
s;\\n      this.y += s;\\n      this.z += s;\\n      return this;\\n    }\\n  \
  /**\\n     * Adds the given vectors and stores the result in this \
instance.\\n     *\\n     * @param {Vector3} a - The first vector.\\n     * \
@param {Vector3} b - The second vector.\\n     * @return {Vector3} A \
reference to this vector.\\n     */\\n    addVectors(a, b) {\\n      this.x = \
a.x + b.x;\\n      this.y = a.y + b.y;\\n      this.z = a.z + b.z;\\n      \
return this;\\n    }\\n    /**\\n     * Adds the given vector scaled by the \
given factor to this instance.\\n     *\\n     * @param {Vector3|Vector4} v - \
The vector.\\n     * @param {number} s - The factor that scales `v`.\\n     * \
@return {Vector3} A reference to this vector.\\n     */\\n    \
addScaledVector(v, s) {\\n      this.x += v.x * s;\\n      this.y += v.y * \
s;\\n      this.z += v.z * s;\\n      return this;\\n    }\\n    /**\\n     * \
Subtracts the given vector from this instance.\\n     *\\n     * @param \
{Vector3} v - The vector to subtract.\\n     * @return {Vector3} A reference \
to this vector.\\n     */\\n    sub(v) {\\n      this.x -= v.x;\\n      \
this.y -= v.y;\\n      this.z -= v.z;\\n      return this;\\n    }\\n    \
/**\\n     * Subtracts the given scalar value from all components of this \
instance.\\n     *\\n     * @param {number} s - The scalar to subtract.\\n    \
 * @return {Vector3} A reference to this vector.\\n     */\\n    subScalar(s) \
{\\n      this.x -= s;\\n      this.y -= s;\\n      this.z -= s;\\n      \
return this;\\n    }\\n    /**\\n     * Subtracts the given vectors and \
stores the result in this instance.\\n     *\\n     * @param {Vector3} a - \
The first vector.\\n     * @param {Vector3} b - The second vector.\\n     * \
@return {Vector3} A reference to this vector.\\n     */\\n    subVectors(a, \
b) {\\n      this.x = a.x - b.x;\\n      this.y = a.y - b.y;\\n      this.z = \
a.z - b.z;\\n      return this;\\n    }\\n    /**\\n     * Multiplies the \
given vector with this instance.\\n     *\\n     * @param {Vector3} v - The \
vector to multiply.\\n     * @return {Vector3} A reference to this vector.\\n \
    */\\n    multiply(v) {\\n      this.x *= v.x;\\n      this.y *= v.y;\\n   \
   this.z *= v.z;\\n      return this;\\n    }\\n    /**\\n     * Multiplies \
the given scalar value with all components of this instance.\\n     *\\n     \
* @param {number} scalar - The scalar to multiply.\\n     * @return {Vector3} \
A reference to this vector.\\n     */\\n    multiplyScalar(scalar) {\\n      \
this.x *= scalar;\\n      this.y *= scalar;\\n      this.z *= scalar;\\n      \
return this;\\n    }\\n    /**\\n     * Multiplies the given vectors and \
stores the result in this instance.\\n     *\\n     * @param {Vector3} a - \
The first vector.\\n     * @param {Vector3} b - The second vector.\\n     * \
@return {Vector3} A reference to this vector.\\n     */\\n    \
multiplyVectors(a, b) {\\n      this.x = a.x * b.x;\\n      this.y = a.y * \
b.y;\\n      this.z = a.z * b.z;\\n      return this;\\n    }\\n    /**\\n    \
 * Applies the given Euler rotation to this vector.\\n     *\\n     * @param \
{Euler} euler - The Euler angles.\\n     * @return {Vector3} A reference to \
this vector.\\n     */\\n    applyEuler(euler) {\\n      return \
this.applyQuaternion(_quaternion$4.setFromEuler(euler));\\n    }\\n    /**\\n \
    * Applies a rotation specified by an axis and an angle to this vector.\\n \
    *\\n     * @param {Vector3} axis - A normalized vector representing the \
rotation axis.\\n     * @param {number} angle - The angle in radians.\\n     \
* @return {Vector3} A reference to this vector.\\n     */\\n    \
applyAxisAngle(axis, angle) {\\n      return \
this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));\\n    }\\n \
   /**\\n     * Multiplies this vector with the given 3x3 matrix.\\n     *\\n \
    * @param {Matrix3} m - The 3x3 matrix.\\n     * @return {Vector3} A \
reference to this vector.\\n     */\\n    applyMatrix3(m) {\\n      const x2 \
= this.x, y = this.y, z = this.z;\\n      const e = m.elements;\\n      \
this.x = e[0] * x2 + e[3] * y + e[6] * z;\\n      this.y = e[1] * x2 + e[4] * \
y + e[7] * z;\\n      this.z = e[2] * x2 + e[5] * y + e[8] * z;\\n      \
return this;\\n    }\\n    /**\\n     * Multiplies this vector by the given \
normal matrix and normalizes\\n     * the result.\\n     *\\n     * @param \
{Matrix3} m - The normal matrix.\\n     * @return {Vector3} A reference to \
this vector.\\n     */\\n    applyNormalMatrix(m) {\\n      return \
this.applyMatrix3(m).normalize();\\n    }\\n    /**\\n     * Multiplies this \
vector (with an implicit 1 in the 4th dimension) by m, and\\n     * divides \
by perspective.\\n     *\\n     * @param {Matrix4} m - The matrix to \
apply.\\n     * @return {Vector3} A reference to this vector.\\n     */\\n    \
applyMatrix4(m) {\\n      const x2 = this.x, y = this.y, z = this.z;\\n      \
const e = m.elements;\\n      const w = 1 / (e[3] * x2 + e[7] * y + e[11] * z \
+ e[15]);\\n      this.x = (e[0] * x2 + e[4] * y + e[8] * z + e[12]) * w;\\n  \
    this.y = (e[1] * x2 + e[5] * y + e[9] * z + e[13]) * w;\\n      this.z = \
(e[2] * x2 + e[6] * y + e[10] * z + e[14]) * w;\\n      return this;\\n    \
}\\n    /**\\n     * Applies the given Quaternion to this vector.\\n     *\\n \
    * @param {Quaternion} q - The Quaternion.\\n     * @return {Vector3} A \
reference to this vector.\\n     */\\n    applyQuaternion(q) {\\n      const \
vx = this.x, vy = this.y, vz = this.z;\\n      const qx = q.x, qy = q.y, qz = \
q.z, qw = q.w;\\n      const tx = 2 * (qy * vz - qz * vy);\\n      const ty = \
2 * (qz * vx - qx * vz);\\n      const tz = 2 * (qx * vy - qy * vx);\\n      \
this.x = vx + qw * tx + qy * tz - qz * ty;\\n      this.y = vy + qw * ty + qz \
* tx - qx * tz;\\n      this.z = vz + qw * tz + qx * ty - qy * tx;\\n      \
return this;\\n    }\\n    /**\\n     * Projects this vector from world space \
into the camera\\'s normalized\\n     * device coordinate (NDC) space.\\n     \
*\\n     * @param {Camera} camera - The camera.\\n     * @return {Vector3} A \
reference to this vector.\\n     */\\n    project(camera) {\\n      return \
this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMa\
trix);\\n    }\\n    /**\\n     * Unprojects this vector from the camera\\'s \
normalized device coordinate (NDC)\\n     * space into world space.\\n     \
*\\n     * @param {Camera} camera - The camera.\\n     * @return {Vector3} A \
reference to this vector.\\n     */\\n    unproject(camera) {\\n      return \
this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixW\
orld);\\n    }\\n    /**\\n     * Transforms the direction of this vector by \
a matrix (the upper left 3 x 3\\n     * subset of the given 4x4 matrix and \
then normalizes the result.\\n     *\\n     * @param {Matrix4} m - The \
matrix.\\n     * @return {Vector3} A reference to this vector.\\n     */\\n   \
 transformDirection(m) {\\n      const x2 = this.x, y = this.y, z = \
this.z;\\n      const e = m.elements;\\n      this.x = e[0] * x2 + e[4] * y + \
e[8] * z;\\n      this.y = e[1] * x2 + e[5] * y + e[9] * z;\\n      this.z = \
e[2] * x2 + e[6] * y + e[10] * z;\\n      return this.normalize();\\n    }\\n \
   /**\\n     * Divides this instance by the given vector.\\n     *\\n     * \
@param {Vector3} v - The vector to divide.\\n     * @return {Vector3} A \
reference to this vector.\\n     */\\n    divide(v) {\\n      this.x /= \
v.x;\\n      this.y /= v.y;\\n      this.z /= v.z;\\n      return this;\\n    \
}\\n    /**\\n     * Divides this vector by the given scalar.\\n     *\\n     \
* @param {number} scalar - The scalar to divide.\\n     * @return {Vector3} A \
reference to this vector.\\n     */\\n    divideScalar(scalar) {\\n      \
return this.multiplyScalar(1 / scalar);\\n    }\\n    /**\\n     * If this \
vector\\'s x, y or z value is greater than the given vector\\'s x, y or z\\n  \
   * value, replace that value with the corresponding min value.\\n     *\\n  \
   * @param {Vector3} v - The vector.\\n     * @return {Vector3} A reference \
to this vector.\\n     */\\n    min(v) {\\n      this.x = Math.min(this.x, \
v.x);\\n      this.y = Math.min(this.y, v.y);\\n      this.z = \
Math.min(this.z, v.z);\\n      return this;\\n    }\\n    /**\\n     * If \
this vector\\'s x, y or z value is less than the given vector\\'s x, y or \
z\\n     * value, replace that value with the corresponding max value.\\n     \
*\\n     * @param {Vector3} v - The vector.\\n     * @return {Vector3} A \
reference to this vector.\\n     */\\n    max(v) {\\n      this.x = \
Math.max(this.x, v.x);\\n      this.y = Math.max(this.y, v.y);\\n      this.z \
= Math.max(this.z, v.z);\\n      return this;\\n    }\\n    /**\\n     * If \
this vector\\'s x, y or z value is greater than the max vector\\'s x, y or \
z\\n     * value, it is replaced by the corresponding value.\\n     * If this \
vector\\'s x, y or z value is less than the min vector\\'s x, y or z \
value,\\n     * it is replaced by the corresponding value.\\n     *\\n     * \
@param {Vector3} min - The minimum x, y and z values.\\n     * @param \
{Vector3} max - The maximum x, y and z values in the desired range.\\n     * \
@return {Vector3} A reference to this vector.\\n     */\\n    clamp(min, \
max2) {\\n      this.x = clamp(this.x, min.x, max2.x);\\n      this.y = \
clamp(this.y, min.y, max2.y);\\n      this.z = clamp(this.z, min.z, \
max2.z);\\n      return this;\\n    }\\n    /**\\n     * If this vector\\'s \
x, y or z values are greater than the max value, they are\\n     * replaced \
by the max value.\\n     * If this vector\\'s x, y or z values are less than \
the min value, they are\\n     * replaced by the min value.\\n     *\\n     * \
@param {number} minVal - The minimum value the components will be clamped \
to.\\n     * @param {number} maxVal - The maximum value the components will \
be clamped to.\\n     * @return {Vector3} A reference to this vector.\\n     \
*/\\n    clampScalar(minVal, maxVal) {\\n      this.x = clamp(this.x, minVal, \
maxVal);\\n      this.y = clamp(this.y, minVal, maxVal);\\n      this.z = \
clamp(this.z, minVal, maxVal);\\n      return this;\\n    }\\n    /**\\n     \
* If this vector\\'s length is greater than the max value, it is replaced \
by\\n     * the max value.\\n     * If this vector\\'s length is less than \
the min value, it is replaced by the\\n     * min value.\\n     *\\n     * \
@param {number} min - The minimum value the vector length will be clamped \
to.\\n     * @param {number} max - The maximum value the vector length will \
be clamped to.\\n     * @return {Vector3} A reference to this vector.\\n     \
*/\\n    clampLength(min, max2) {\\n      const length = this.length();\\n    \
  return this.divideScalar(length || 1).multiplyScalar(clamp(length, min, \
max2));\\n    }\\n    /**\\n     * The components of this vector are rounded \
down to the nearest integer value.\\n     *\\n     * @return {Vector3} A \
reference to this vector.\\n     */\\n    floor() {\\n      this.x = \
Math.floor(this.x);\\n      this.y = Math.floor(this.y);\\n      this.z = \
Math.floor(this.z);\\n      return this;\\n    }\\n    /**\\n     * The \
components of this vector are rounded up to the nearest integer value.\\n     \
*\\n     * @return {Vector3} A reference to this vector.\\n     */\\n    \
ceil() {\\n      this.x = Math.ceil(this.x);\\n      this.y = \
Math.ceil(this.y);\\n      this.z = Math.ceil(this.z);\\n      return \
this;\\n    }\\n    /**\\n     * The components of this vector are rounded to \
the nearest integer value\\n     *\\n     * @return {Vector3} A reference to \
this vector.\\n     */\\n    round() {\\n      this.x = \
Math.round(this.x);\\n      this.y = Math.round(this.y);\\n      this.z = \
Math.round(this.z);\\n      return this;\\n    }\\n    /**\\n     * The \
components of this vector are rounded towards zero (up if negative,\\n     * \
down if positive) to an integer value.\\n     *\\n     * @return {Vector3} A \
reference to this vector.\\n     */\\n    roundToZero() {\\n      this.x = \
Math.trunc(this.x);\\n      this.y = Math.trunc(this.y);\\n      this.z = \
Math.trunc(this.z);\\n      return this;\\n    }\\n    /**\\n     * Inverts \
this vector - i.e. sets x = -x, y = -y and z = -z.\\n     *\\n     * @return \
{Vector3} A reference to this vector.\\n     */\\n    negate() {\\n      \
this.x = -this.x;\\n      this.y = -this.y;\\n      this.z = -this.z;\\n      \
return this;\\n    }\\n    /**\\n     * Calculates the dot product of the \
given vector with this instance.\\n     *\\n     * @param {Vector3} v - The \
vector to compute the dot product with.\\n     * @return {number} The result \
of the dot product.\\n     */\\n    dot(v) {\\n      return this.x * v.x + \
this.y * v.y + this.z * v.z;\\n    }\\n    // TODO lengthSquared?\\n    \
/**\\n     * Computes the square of the Euclidean length (straight-line \
length) from\\n     * (0, 0, 0) to (x, y, z). If you are comparing the \
lengths of vectors, you should\\n     * compare the length squared instead as \
it is slightly more efficient to calculate.\\n     *\\n     * @return \
{number} The square length of this vector.\\n     */\\n    lengthSq() {\\n    \
  return this.x * this.x + this.y * this.y + this.z * this.z;\\n    }\\n    \
/**\\n     * Computes the  Euclidean length (straight-line length) from (0, \
0, 0) to (x, y, z).\\n     *\\n     * @return {number} The length of this \
vector.\\n     */\\n    length() {\\n      return Math.sqrt(this.x * this.x + \
this.y * this.y + this.z * this.z);\\n    }\\n    /**\\n     * Computes the \
Manhattan length of this vector.\\n     *\\n     * @return {number} The \
length of this vector.\\n     */\\n    manhattanLength() {\\n      return \
Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);\\n    }\\n    /**\\n  \
   * Converts this vector to a unit vector - that is, sets it equal to a \
vector\\n     * with the same direction as this one, but with a vector length \
of `1`.\\n     *\\n     * @return {Vector3} A reference to this vector.\\n    \
 */\\n    normalize() {\\n      return this.divideScalar(this.length() || \
1);\\n    }\\n    /**\\n     * Sets this vector to a vector with the same \
direction as this one, but\\n     * with the specified length.\\n     *\\n    \
 * @param {number} length - The new length of this vector.\\n     * @return \
{Vector3} A reference to this vector.\\n     */\\n    setLength(length) {\\n  \
    return this.normalize().multiplyScalar(length);\\n    }\\n    /**\\n     \
* Linearly interpolates between the given vector and this instance, where\\n  \
   * alpha is the percent distance along the line - alpha = 0 will be this\\n \
    * vector, and alpha = 1 will be the given one.\\n     *\\n     * @param \
{Vector3} v - The vector to interpolate towards.\\n     * @param {number} \
alpha - The interpolation factor, typically in the closed interval `[0, \
1]`.\\n     * @return {Vector3} A reference to this vector.\\n     */\\n    \
lerp(v, alpha) {\\n      this.x += (v.x - this.x) * alpha;\\n      this.y += \
(v.y - this.y) * alpha;\\n      this.z += (v.z - this.z) * alpha;\\n      \
return this;\\n    }\\n    /**\\n     * Linearly interpolates between the \
given vectors, where alpha is the percent\\n     * distance along the line - \
alpha = 0 will be first vector, and alpha = 1 will\\n     * be the second \
one. The result is stored in this instance.\\n     *\\n     * @param \
{Vector3} v1 - The first vector.\\n     * @param {Vector3} v2 - The second \
vector.\\n     * @param {number} alpha - The interpolation factor, typically \
in the closed interval `[0, 1]`.\\n     * @return {Vector3} A reference to \
this vector.\\n     */\\n    lerpVectors(v1, v2, alpha) {\\n      this.x = \
v1.x + (v2.x - v1.x) * alpha;\\n      this.y = v1.y + (v2.y - v1.y) * \
alpha;\\n      this.z = v1.z + (v2.z - v1.z) * alpha;\\n      return this;\\n \
   }\\n    /**\\n     * Calculates the cross product of the given vector with \
this instance.\\n     *\\n     * @param {Vector3} v - The vector to compute \
the cross product with.\\n     * @return {Vector3} The result of the cross \
product.\\n     */\\n    cross(v) {\\n      return this.crossVectors(this, \
v);\\n    }\\n    /**\\n     * Calculates the cross product of the given \
vectors and stores the result\\n     * in this instance.\\n     *\\n     * \
@param {Vector3} a - The first vector.\\n     * @param {Vector3} b - The \
second vector.\\n     * @return {Vector3} A reference to this vector.\\n     \
*/\\n    crossVectors(a, b) {\\n      const ax = a.x, ay = a.y, az = a.z;\\n  \
    const bx = b.x, by = b.y, bz = b.z;\\n      this.x = ay * bz - az * \
by;\\n      this.y = az * bx - ax * bz;\\n      this.z = ax * by - ay * \
bx;\\n      return this;\\n    }\\n    /**\\n     * Projects this vector onto \
the given one.\\n     *\\n     * @param {Vector3} v - The vector to project \
to.\\n     * @return {Vector3} A reference to this vector.\\n     */\\n    \
projectOnVector(v) {\\n      const denominator = v.lengthSq();\\n      if \
(denominator === 0) return this.set(0, 0, 0);\\n      const scalar = \
v.dot(this) / denominator;\\n      return \
this.copy(v).multiplyScalar(scalar);\\n    }\\n    /**\\n     * Projects this \
vector onto a plane by subtracting this\\n     * vector projected onto the \
plane\\'s normal from this vector.\\n     *\\n     * @param {Vector3} \
planeNormal - The plane normal.\\n     * @return {Vector3} A reference to \
this vector.\\n     */\\n    projectOnPlane(planeNormal) {\\n      \
_vector$c.copy(this).projectOnVector(planeNormal);\\n      return \
this.sub(_vector$c);\\n    }\\n    /**\\n     * Reflects this vector off a \
plane orthogonal to the given normal vector.\\n     *\\n     * @param \
{Vector3} normal - The (normalized) normal vector.\\n     * @return {Vector3} \
A reference to this vector.\\n     */\\n    reflect(normal) {\\n      return \
this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));\\n    \
}\\n    /**\\n     * Returns the angle between the given vector and this \
instance in radians.\\n     *\\n     * @param {Vector3} v - The vector to \
compute the angle with.\\n     * @return {number} The angle in radians.\\n    \
 */\\n    angleTo(v) {\\n      const denominator = Math.sqrt(this.lengthSq() \
* v.lengthSq());\\n      if (denominator === 0) return Math.PI / 2;\\n      \
const theta = this.dot(v) / denominator;\\n      return \
Math.acos(clamp(theta, -1, 1));\\n    }\\n    /**\\n     * Computes the \
distance from the given vector to this instance.\\n     *\\n     * @param \
{Vector3} v - The vector to compute the distance to.\\n     * @return \
{number} The distance.\\n     */\\n    distanceTo(v) {\\n      return \
Math.sqrt(this.distanceToSquared(v));\\n    }\\n    /**\\n     * Computes the \
squared distance from the given vector to this instance.\\n     * If you are \
just comparing the distance with another distance, you should compare\\n     \
* the distance squared instead as it is slightly more efficient to \
calculate.\\n     *\\n     * @param {Vector3} v - The vector to compute the \
squared distance to.\\n     * @return {number} The squared distance.\\n     \
*/\\n    distanceToSquared(v) {\\n      const dx = this.x - v.x, dy = this.y \
- v.y, dz = this.z - v.z;\\n      return dx * dx + dy * dy + dz * dz;\\n    \
}\\n    /**\\n     * Computes the Manhattan distance from the given vector to \
this instance.\\n     *\\n     * @param {Vector3} v - The vector to compute \
the Manhattan distance to.\\n     * @return {number} The Manhattan \
distance.\\n     */\\n    manhattanDistanceTo(v) {\\n      return \
Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);\\n  \
  }\\n    /**\\n     * Sets the vector components from the given spherical \
coordinates.\\n     *\\n     * @param {Spherical} s - The spherical \
coordinates.\\n     * @return {Vector3} A reference to this vector.\\n     \
*/\\n    setFromSpherical(s) {\\n      return \
this.setFromSphericalCoords(s.radius, s.phi, s.theta);\\n    }\\n    /**\\n   \
  * Sets the vector components from the given spherical coordinates.\\n     \
*\\n     * @param {number} radius - The radius.\\n     * @param {number} phi \
- The phi angle in radians.\\n     * @param {number} theta - The theta angle \
in radians.\\n     * @return {Vector3} A reference to this vector.\\n     \
*/\\n    setFromSphericalCoords(radius, phi, theta) {\\n      const \
sinPhiRadius = Math.sin(phi) * radius;\\n      this.x = sinPhiRadius * \
Math.sin(theta);\\n      this.y = Math.cos(phi) * radius;\\n      this.z = \
sinPhiRadius * Math.cos(theta);\\n      return this;\\n    }\\n    /**\\n     \
* Sets the vector components from the given cylindrical coordinates.\\n     \
*\\n     * @param {Cylindrical} c - The cylindrical coordinates.\\n     * \
@return {Vector3} A reference to this vector.\\n     */\\n    \
setFromCylindrical(c) {\\n      return \
this.setFromCylindricalCoords(c.radius, c.theta, c.y);\\n    }\\n    /**\\n   \
  * Sets the vector components from the given cylindrical coordinates.\\n     \
*\\n     * @param {number} radius - The radius.\\n     * @param {number} \
theta - The theta angle in radians.\\n     * @param {number} y - The y \
value.\\n     * @return {Vector3} A reference to this vector.\\n     */\\n    \
setFromCylindricalCoords(radius, theta, y) {\\n      this.x = radius * \
Math.sin(theta);\\n      this.y = y;\\n      this.z = radius * \
Math.cos(theta);\\n      return this;\\n    }\\n    /**\\n     * Sets the \
vector components to the position elements of the\\n     * given \
transformation matrix.\\n     *\\n     * @param {Matrix4} m - The 4x4 \
matrix.\\n     * @return {Vector3} A reference to this vector.\\n     */\\n   \
 setFromMatrixPosition(m) {\\n      const e = m.elements;\\n      this.x = \
e[12];\\n      this.y = e[13];\\n      this.z = e[14];\\n      return \
this;\\n    }\\n    /**\\n     * Sets the vector components to the scale \
elements of the\\n     * given transformation matrix.\\n     *\\n     * \
@param {Matrix4} m - The 4x4 matrix.\\n     * @return {Vector3} A reference \
to this vector.\\n     */\\n    setFromMatrixScale(m) {\\n      const sx = \
this.setFromMatrixColumn(m, 0).length();\\n      const sy = \
this.setFromMatrixColumn(m, 1).length();\\n      const sz = \
this.setFromMatrixColumn(m, 2).length();\\n      this.x = sx;\\n      this.y \
= sy;\\n      this.z = sz;\\n      return this;\\n    }\\n    /**\\n     * \
Sets the vector components from the specified matrix column.\\n     *\\n     \
* @param {Matrix4} m - The 4x4 matrix.\\n     * @param {number} index - The \
column index.\\n     * @return {Vector3} A reference to this vector.\\n     \
*/\\n    setFromMatrixColumn(m, index) {\\n      return \
this.fromArray(m.elements, index * 4);\\n    }\\n    /**\\n     * Sets the \
vector components from the specified matrix column.\\n     *\\n     * @param \
{Matrix3} m - The 3x3 matrix.\\n     * @param {number} index - The column \
index.\\n     * @return {Vector3} A reference to this vector.\\n     */\\n    \
setFromMatrix3Column(m, index) {\\n      return this.fromArray(m.elements, \
index * 3);\\n    }\\n    /**\\n     * Sets the vector components from the \
given Euler angles.\\n     *\\n     * @param {Euler} e - The Euler angles to \
set.\\n     * @return {Vector3} A reference to this vector.\\n     */\\n    \
setFromEuler(e) {\\n      this.x = e._x;\\n      this.y = e._y;\\n      \
this.z = e._z;\\n      return this;\\n    }\\n    /**\\n     * Sets the \
vector components from the RGB components of the\\n     * given color.\\n     \
*\\n     * @param {Color} c - The color to set.\\n     * @return {Vector3} A \
reference to this vector.\\n     */\\n    setFromColor(c) {\\n      this.x = \
c.r;\\n      this.y = c.g;\\n      this.z = c.b;\\n      return this;\\n    \
}\\n    /**\\n     * Returns `true` if this vector is equal with the given \
one.\\n     *\\n     * @param {Vector3} v - The vector to test for \
equality.\\n     * @return {boolean} Whether this vector is equal with the \
given one.\\n     */\\n    equals(v) {\\n      return v.x === this.x && v.y \
=== this.y && v.z === this.z;\\n    }\\n    /**\\n     * Sets this vector\\'s \
x value to be `array[ offset ]`, y value to be `array[ offset + 1 ]`\\n     * \
and z value to be `array[ offset + 2 ]`.\\n     *\\n     * @param \
{Array<number>} array - An array holding the vector component values.\\n     \
* @param {number} [offset=0] - The offset into the array.\\n     * @return \
{Vector3} A reference to this vector.\\n     */\\n    fromArray(array, offset \
= 0) {\\n      this.x = array[offset];\\n      this.y = array[offset + 1];\\n \
     this.z = array[offset + 2];\\n      return this;\\n    }\\n    /**\\n    \
 * Writes the components of this vector to the given array. If no array is \
provided,\\n     * the method returns a new instance.\\n     *\\n     * \
@param {Array<number>} [array=[]] - The target array holding the vector \
components.\\n     * @param {number} [offset=0] - Index of the first element \
in the array.\\n     * @return {Array<number>} The vector components.\\n     \
*/\\n    toArray(array = [], offset = 0) {\\n      array[offset] = this.x;\\n \
     array[offset + 1] = this.y;\\n      array[offset + 2] = this.z;\\n      \
return array;\\n    }\\n    /**\\n     * Sets the components of this vector \
from the given buffer attribute.\\n     *\\n     * @param {BufferAttribute} \
attribute - The buffer attribute holding vector data.\\n     * @param \
{number} index - The index into the attribute.\\n     * @return {Vector3} A \
reference to this vector.\\n     */\\n    fromBufferAttribute(attribute, \
index) {\\n      this.x = attribute.getX(index);\\n      this.y = \
attribute.getY(index);\\n      this.z = attribute.getZ(index);\\n      return \
this;\\n    }\\n    /**\\n     * Sets each component of this vector to a \
pseudo-random value between `0` and\\n     * `1`, excluding `1`.\\n     *\\n  \
   * @return {Vector3} A reference to this vector.\\n     */\\n    random() \
{\\n      this.x = Math.random();\\n      this.y = Math.random();\\n      \
this.z = Math.random();\\n      return this;\\n    }\\n    /**\\n     * Sets \
this vector to a uniformly random point on a unit sphere.\\n     *\\n     * \
@return {Vector3} A reference to this vector.\\n     */\\n    \
randomDirection() {\\n      const theta = Math.random() * Math.PI * 2;\\n     \
 const u = Math.random() * 2 - 1;\\n      const c = Math.sqrt(1 - u * u);\\n  \
    this.x = c * Math.cos(theta);\\n      this.y = u;\\n      this.z = c * \
Math.sin(theta);\\n      return this;\\n    }\\n    *[Symbol.iterator]() {\\n \
     yield this.x;\\n      yield this.y;\\n      yield this.z;\\n    }\\n  \
}\\n  const _vector$c = /* @__PURE__ */ new Vector3();\\n  const \
_quaternion$4 = /* @__PURE__ */ new Quaternion();\\n  class Matrix3 {\\n    \
/**\\n     * Constructs a new 3x3 matrix. The arguments are supposed to be\\n \
    * in row-major order. If no arguments are provided, the constructor\\n    \
 * initializes the matrix as an identity matrix.\\n     *\\n     * @param \
{number} [n11] - 1-1 matrix element.\\n     * @param {number} [n12] - 1-2 \
matrix element.\\n     * @param {number} [n13] - 1-3 matrix element.\\n     * \
@param {number} [n21] - 2-1 matrix element.\\n     * @param {number} [n22] - \
2-2 matrix element.\\n     * @param {number} [n23] - 2-3 matrix element.\\n   \
  * @param {number} [n31] - 3-1 matrix element.\\n     * @param {number} \
[n32] - 3-2 matrix element.\\n     * @param {number} [n33] - 3-3 matrix \
element.\\n     */\\n    constructor(n11, n12, n13, n21, n22, n23, n31, n32, \
n33) {\\n      Matrix3.prototype.isMatrix3 = true;\\n      this.elements = \
[\\n        1,\\n        0,\\n        0,\\n        0,\\n        1,\\n        \
0,\\n        0,\\n        0,\\n        1\\n      ];\\n      if (n11 !== void \
0) {\\n        this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);\\n      \
}\\n    }\\n    /**\\n     * Sets the elements of the matrix.The arguments \
are supposed to be\\n     * in row-major order.\\n     *\\n     * @param \
{number} [n11] - 1-1 matrix element.\\n     * @param {number} [n12] - 1-2 \
matrix element.\\n     * @param {number} [n13] - 1-3 matrix element.\\n     * \
@param {number} [n21] - 2-1 matrix element.\\n     * @param {number} [n22] - \
2-2 matrix element.\\n     * @param {number} [n23] - 2-3 matrix element.\\n   \
  * @param {number} [n31] - 3-1 matrix element.\\n     * @param {number} \
[n32] - 3-2 matrix element.\\n     * @param {number} [n33] - 3-3 matrix \
element.\\n     * @return {Matrix3} A reference to this matrix.\\n     */\\n  \
  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {\\n      const te = \
this.elements;\\n      te[0] = n11;\\n      te[1] = n21;\\n      te[2] = \
n31;\\n      te[3] = n12;\\n      te[4] = n22;\\n      te[5] = n32;\\n      \
te[6] = n13;\\n      te[7] = n23;\\n      te[8] = n33;\\n      return \
this;\\n    }\\n    /**\\n     * Sets this matrix to the 3x3 identity \
matrix.\\n     *\\n     * @return {Matrix3} A reference to this matrix.\\n    \
 */\\n    identity() {\\n      this.set(\\n        1,\\n        0,\\n        \
0,\\n        0,\\n        1,\\n        0,\\n        0,\\n        0,\\n        \
1\\n      );\\n      return this;\\n    }\\n    /**\\n     * Copies the \
values of the given matrix to this instance.\\n     *\\n     * @param \
{Matrix3} m - The matrix to copy.\\n     * @return {Matrix3} A reference to \
this matrix.\\n     */\\n    copy(m) {\\n      const te = this.elements;\\n   \
   const me = m.elements;\\n      te[0] = me[0];\\n      te[1] = me[1];\\n    \
  te[2] = me[2];\\n      te[3] = me[3];\\n      te[4] = me[4];\\n      te[5] \
= me[5];\\n      te[6] = me[6];\\n      te[7] = me[7];\\n      te[8] = \
me[8];\\n      return this;\\n    }\\n    /**\\n     * Extracts the basis of \
this matrix into the three axis vectors provided.\\n     *\\n     * @param \
{Vector3} xAxis - The basis\\'s x axis.\\n     * @param {Vector3} yAxis - The \
basis\\'s y axis.\\n     * @param {Vector3} zAxis - The basis\\'s z axis.\\n  \
   * @return {Matrix3} A reference to this matrix.\\n     */\\n    \
extractBasis(xAxis, yAxis, zAxis) {\\n      xAxis.setFromMatrix3Column(this, \
0);\\n      yAxis.setFromMatrix3Column(this, 1);\\n      \
zAxis.setFromMatrix3Column(this, 2);\\n      return this;\\n    }\\n    \
/**\\n     * Set this matrix to the upper 3x3 matrix of the given 4x4 \
matrix.\\n     *\\n     * @param {Matrix4} m - The 4x4 matrix.\\n     * \
@return {Matrix3} A reference to this matrix.\\n     */\\n    \
setFromMatrix4(m) {\\n      const me = m.elements;\\n      this.set(\\n       \
 me[0],\\n        me[4],\\n        me[8],\\n        me[1],\\n        \
me[5],\\n        me[9],\\n        me[2],\\n        me[6],\\n        me[10]\\n \
     );\\n      return this;\\n    }\\n    /**\\n     * Post-multiplies this \
matrix by the given 3x3 matrix.\\n     *\\n     * @param {Matrix3} m - The \
matrix to multiply with.\\n     * @return {Matrix3} A reference to this \
matrix.\\n     */\\n    multiply(m) {\\n      return \
this.multiplyMatrices(this, m);\\n    }\\n    /**\\n     * Pre-multiplies \
this matrix by the given 3x3 matrix.\\n     *\\n     * @param {Matrix3} m - \
The matrix to multiply with.\\n     * @return {Matrix3} A reference to this \
matrix.\\n     */\\n    premultiply(m) {\\n      return \
this.multiplyMatrices(m, this);\\n    }\\n    /**\\n     * Multiples the \
given 3x3 matrices and stores the result\\n     * in this matrix.\\n     *\\n \
    * @param {Matrix3} a - The first matrix.\\n     * @param {Matrix3} b - \
The second matrix.\\n     * @return {Matrix3} A reference to this matrix.\\n  \
   */\\n    multiplyMatrices(a, b) {\\n      const ae = a.elements;\\n      \
const be = b.elements;\\n      const te = this.elements;\\n      const a11 = \
ae[0], a12 = ae[3], a13 = ae[6];\\n      const a21 = ae[1], a22 = ae[4], a23 \
= ae[7];\\n      const a31 = ae[2], a32 = ae[5], a33 = ae[8];\\n      const \
b11 = be[0], b12 = be[3], b13 = be[6];\\n      const b21 = be[1], b22 = \
be[4], b23 = be[7];\\n      const b31 = be[2], b32 = be[5], b33 = be[8];\\n   \
   te[0] = a11 * b11 + a12 * b21 + a13 * b31;\\n      te[3] = a11 * b12 + a12 \
* b22 + a13 * b32;\\n      te[6] = a11 * b13 + a12 * b23 + a13 * b33;\\n      \
te[1] = a21 * b11 + a22 * b21 + a23 * b31;\\n      te[4] = a21 * b12 + a22 * \
b22 + a23 * b32;\\n      te[7] = a21 * b13 + a22 * b23 + a23 * b33;\\n      \
te[2] = a31 * b11 + a32 * b21 + a33 * b31;\\n      te[5] = a31 * b12 + a32 * \
b22 + a33 * b32;\\n      te[8] = a31 * b13 + a32 * b23 + a33 * b33;\\n      \
return this;\\n    }\\n    /**\\n     * Multiplies every component of the \
matrix by the given scalar.\\n     *\\n     * @param {number} s - The \
scalar.\\n     * @return {Matrix3} A reference to this matrix.\\n     */\\n   \
 multiplyScalar(s) {\\n      const te = this.elements;\\n      te[0] *= s;\\n \
     te[3] *= s;\\n      te[6] *= s;\\n      te[1] *= s;\\n      te[4] *= \
s;\\n      te[7] *= s;\\n      te[2] *= s;\\n      te[5] *= s;\\n      te[8] \
*= s;\\n      return this;\\n    }\\n    /**\\n     * Computes and returns \
the determinant of this matrix.\\n     *\\n     * @return {number} The \
determinant.\\n     */\\n    determinant() {\\n      const te = \
this.elements;\\n      const a = te[0], b = te[1], c = te[2], d = te[3], e = \
te[4], f = te[5], g = te[6], h = te[7], i2 = te[8];\\n      return a * e * i2 \
- a * f * h - b * d * i2 + b * f * g + c * d * h - c * e * g;\\n    }\\n    \
/**\\n     * Inverts this matrix, using the [analytic method]{@link \
https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution}.\\n     * \
You can not invert with a determinant of zero. If you attempt this, the \
method produces\\n     * a zero matrix instead.\\n     *\\n     * @return \
{Matrix3} A reference to this matrix.\\n     */\\n    invert() {\\n      \
const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], \
n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * \
n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, \
det = n11 * t11 + n21 * t12 + n31 * t13;\\n      if (det === 0) return \
this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);\\n      const detInv = 1 / det;\\n      \
te[0] = t11 * detInv;\\n      te[1] = (n31 * n23 - n33 * n21) * detInv;\\n    \
  te[2] = (n32 * n21 - n31 * n22) * detInv;\\n      te[3] = t12 * detInv;\\n  \
    te[4] = (n33 * n11 - n31 * n13) * detInv;\\n      te[5] = (n31 * n12 - \
n32 * n11) * detInv;\\n      te[6] = t13 * detInv;\\n      te[7] = (n21 * n13 \
- n23 * n11) * detInv;\\n      te[8] = (n22 * n11 - n21 * n12) * detInv;\\n   \
   return this;\\n    }\\n    /**\\n     * Transposes this matrix in \
place.\\n     *\\n     * @return {Matrix3} A reference to this matrix.\\n     \
*/\\n    transpose() {\\n      let tmp;\\n      const m = this.elements;\\n   \
   tmp = m[1];\\n      m[1] = m[3];\\n      m[3] = tmp;\\n      tmp = \
m[2];\\n      m[2] = m[6];\\n      m[6] = tmp;\\n      tmp = m[5];\\n      \
m[5] = m[7];\\n      m[7] = tmp;\\n      return this;\\n    }\\n    /**\\n    \
 * Computes the normal matrix which is the inverse transpose of the upper\\n  \
   * left 3x3 portion of the given 4x4 matrix.\\n     *\\n     * @param \
{Matrix4} matrix4 - The 4x4 matrix.\\n     * @return {Matrix3} A reference to \
this matrix.\\n     */\\n    getNormalMatrix(matrix4) {\\n      return \
this.setFromMatrix4(matrix4).invert().transpose();\\n    }\\n    /**\\n     * \
Transposes this matrix into the supplied array, and returns itself \
unchanged.\\n     *\\n     * @param {Array<number>} r - An array to store the \
transposed matrix elements.\\n     * @return {Matrix3} A reference to this \
matrix.\\n     */\\n    transposeIntoArray(r) {\\n      const m = \
this.elements;\\n      r[0] = m[0];\\n      r[1] = m[3];\\n      r[2] = \
m[6];\\n      r[3] = m[1];\\n      r[4] = m[4];\\n      r[5] = m[7];\\n      \
r[6] = m[2];\\n      r[7] = m[5];\\n      r[8] = m[8];\\n      return \
this;\\n    }\\n    /**\\n     * Sets the UV transform matrix from offset, \
repeat, rotation, and center.\\n     *\\n     * @param {number} tx - Offset \
x.\\n     * @param {number} ty - Offset y.\\n     * @param {number} sx - \
Repeat x.\\n     * @param {number} sy - Repeat y.\\n     * @param {number} \
rotation - Rotation, in radians. Positive values rotate counterclockwise.\\n  \
   * @param {number} cx - Center x of rotation.\\n     * @param {number} cy - \
Center y of rotation\\n     * @return {Matrix3} A reference to this \
matrix.\\n     */\\n    setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {\\n \
     const c = Math.cos(rotation);\\n      const s = Math.sin(rotation);\\n   \
   this.set(\\n        sx * c,\\n        sx * s,\\n        -sx * (c * cx + s \
* cy) + cx + tx,\\n        -sy * s,\\n        sy * c,\\n        -sy * (-s * \
cx + c * cy) + cy + ty,\\n        0,\\n        0,\\n        1\\n      );\\n   \
   return this;\\n    }\\n    /**\\n     * Scales this matrix with the given \
scalar values.\\n     *\\n     * @param {number} sx - The amount to scale in \
the X axis.\\n     * @param {number} sy - The amount to scale in the Y \
axis.\\n     * @return {Matrix3} A reference to this matrix.\\n     */\\n    \
scale(sx, sy) {\\n      this.premultiply(_m3.makeScale(sx, sy));\\n      \
return this;\\n    }\\n    /**\\n     * Rotates this matrix by the given \
angle.\\n     *\\n     * @param {number} theta - The rotation in radians.\\n  \
   * @return {Matrix3} A reference to this matrix.\\n     */\\n    \
rotate(theta) {\\n      this.premultiply(_m3.makeRotation(-theta));\\n      \
return this;\\n    }\\n    /**\\n     * Translates this matrix by the given \
scalar values.\\n     *\\n     * @param {number} tx - The amount to translate \
in the X axis.\\n     * @param {number} ty - The amount to translate in the Y \
axis.\\n     * @return {Matrix3} A reference to this matrix.\\n     */\\n    \
translate(tx, ty) {\\n      this.premultiply(_m3.makeTranslation(tx, ty));\\n \
     return this;\\n    }\\n    // for 2D Transforms\\n    /**\\n     * Sets \
this matrix as a 2D translation transform.\\n     *\\n     * @param \
{number|Vector2} x - The amount to translate in the X axis or alternatively a \
translation vector.\\n     * @param {number} y - The amount to translate in \
the Y axis.\\n     * @return {Matrix3} A reference to this matrix.\\n     \
*/\\n    makeTranslation(x2, y) {\\n      if (x2.isVector2) {\\n        \
this.set(\\n          1,\\n          0,\\n          x2.x,\\n          0,\\n   \
       1,\\n          x2.y,\\n          0,\\n          0,\\n          1\\n    \
    );\\n      } else {\\n        this.set(\\n          1,\\n          0,\\n  \
        x2,\\n          0,\\n          1,\\n          y,\\n          0,\\n    \
      0,\\n          1\\n        );\\n      }\\n      return this;\\n    }\\n \
   /**\\n     * Sets this matrix as a 2D rotational transformation.\\n     \
*\\n     * @param {number} theta - The rotation in radians.\\n     * @return \
{Matrix3} A reference to this matrix.\\n     */\\n    makeRotation(theta) \
{\\n      const c = Math.cos(theta);\\n      const s = Math.sin(theta);\\n    \
  this.set(\\n        c,\\n        -s,\\n        0,\\n        s,\\n        \
c,\\n        0,\\n        0,\\n        0,\\n        1\\n      );\\n      \
return this;\\n    }\\n    /**\\n     * Sets this matrix as a 2D scale \
transform.\\n     *\\n     * @param {number} x - The amount to scale in the X \
axis.\\n     * @param {number} y - The amount to scale in the Y axis.\\n     \
* @return {Matrix3} A reference to this matrix.\\n     */\\n    makeScale(x2, \
y) {\\n      this.set(\\n        x2,\\n        0,\\n        0,\\n        \
0,\\n        y,\\n        0,\\n        0,\\n        0,\\n        1\\n      \
);\\n      return this;\\n    }\\n    /**\\n     * Returns `true` if this \
matrix is equal with the given one.\\n     *\\n     * @param {Matrix3} matrix \
- The matrix to test for equality.\\n     * @return {boolean} Whether this \
matrix is equal with the given one.\\n     */\\n    equals(matrix) {\\n      \
const te = this.elements;\\n      const me = matrix.elements;\\n      for \
(let i2 = 0; i2 < 9; i2++) {\\n        if (te[i2] !== me[i2]) return \
false;\\n      }\\n      return true;\\n    }\\n    /**\\n     * Sets the \
elements of the matrix from the given array.\\n     *\\n     * @param \
{Array<number>} array - The matrix elements in column-major order.\\n     * \
@param {number} [offset=0] - Index of the first element in the array.\\n     \
* @return {Matrix3} A reference to this matrix.\\n     */\\n    \
fromArray(array, offset = 0) {\\n      for (let i2 = 0; i2 < 9; i2++) {\\n    \
    this.elements[i2] = array[i2 + offset];\\n      }\\n      return this;\\n \
   }\\n    /**\\n     * Writes the elements of this matrix to the given \
array. If no array is provided,\\n     * the method returns a new \
instance.\\n     *\\n     * @param {Array<number>} [array=[]] - The target \
array holding the matrix elements in column-major order.\\n     * @param \
{number} [offset=0] - Index of the first element in the array.\\n     * \
@return {Array<number>} The matrix elements in column-major order.\\n     \
*/\\n    toArray(array = [], offset = 0) {\\n      const te = \
this.elements;\\n      array[offset] = te[0];\\n      array[offset + 1] = \
te[1];\\n      array[offset + 2] = te[2];\\n      array[offset + 3] = \
te[3];\\n      array[offset + 4] = te[4];\\n      array[offset + 5] = \
te[5];\\n      array[offset + 6] = te[6];\\n      array[offset + 7] = \
te[7];\\n      array[offset + 8] = te[8];\\n      return array;\\n    }\\n    \
/**\\n     * Returns a matrix with copied values from this instance.\\n     \
*\\n     * @return {Matrix3} A clone of this instance.\\n     */\\n    \
clone() {\\n      return new this.constructor().fromArray(this.elements);\\n  \
  }\\n  }\\n  const _m3 = /* @__PURE__ */ new Matrix3();\\n  const _cache = \
{};\\n  function warnOnce(message) {\\n    if (message in _cache) return;\\n  \
  _cache[message] = true;\\n    console.warn(message);\\n  }\\n  const \
LINEAR_REC709_TO_XYZ = /* @__PURE__ */ new Matrix3().set(\\n    0.4123908,\\n \
   0.3575843,\\n    0.1804808,\\n    0.212639,\\n    0.7151687,\\n    \
0.0721923,\\n    0.0193308,\\n    0.1191948,\\n    0.9505322\\n  );\\n  const \
XYZ_TO_LINEAR_REC709 = /* @__PURE__ */ new Matrix3().set(\\n    3.2409699,\\n \
   -1.5373832,\\n    -0.4986108,\\n    -0.9692436,\\n    1.8759675,\\n    \
0.0415551,\\n    0.0556301,\\n    -0.203977,\\n    1.0569715\\n  );\\n  \
function createColorManagement() {\\n    const ColorManagement2 = {\\n      \
enabled: true,\\n      workingColorSpace: LinearSRGBColorSpace,\\n      \
/**\\n       * Implementations of supported color spaces.\\n       *\\n       \
* Required:\\n       *\t- primaries: chromaticity coordinates [ rx ry gx gy \
bx by ]\\n       *\t- whitePoint: reference white [ x y ]\\n       *\t- \
transfer: transfer function (pre-defined)\\n       *\t- toXYZ: Matrix3 RGB to \
XYZ transform\\n       *\t- fromXYZ: Matrix3 XYZ to RGB transform\\n       \
*\t- luminanceCoefficients: RGB luminance coefficients\\n       *\\n       * \
Optional:\\n       *  - outputColorSpaceConfig: { drawingBufferColorSpace: \
ColorSpace }\\n       *  - workingColorSpaceConfig: { unpackColorSpace: \
ColorSpace }\\n       *\\n       * Reference:\\n       * - \
https://www.russellcottrell.com/photo/matrixCalculator.htm\\n       */\\n     \
 spaces: {},\\n      convert: function(color, sourceColorSpace, \
targetColorSpace) {\\n        if (this.enabled === false || sourceColorSpace \
=== targetColorSpace || !sourceColorSpace || !targetColorSpace) {\\n          \
return color;\\n        }\\n        if \
(this.spaces[sourceColorSpace].transfer === SRGBTransfer) {\\n          \
color.r = SRGBToLinear(color.r);\\n          color.g = \
SRGBToLinear(color.g);\\n          color.b = SRGBToLinear(color.b);\\n        \
}\\n        if (this.spaces[sourceColorSpace].primaries !== \
this.spaces[targetColorSpace].primaries) {\\n          \
color.applyMatrix3(this.spaces[sourceColorSpace].toXYZ);\\n          \
color.applyMatrix3(this.spaces[targetColorSpace].fromXYZ);\\n        }\\n     \
   if (this.spaces[targetColorSpace].transfer === SRGBTransfer) {\\n          \
color.r = LinearToSRGB(color.r);\\n          color.g = \
LinearToSRGB(color.g);\\n          color.b = LinearToSRGB(color.b);\\n        \
}\\n        return color;\\n      },\\n      workingToColorSpace: \
function(color, targetColorSpace) {\\n        return this.convert(color, \
this.workingColorSpace, targetColorSpace);\\n      },\\n      \
colorSpaceToWorking: function(color, sourceColorSpace) {\\n        return \
this.convert(color, sourceColorSpace, this.workingColorSpace);\\n      },\\n  \
    getPrimaries: function(colorSpace) {\\n        return \
this.spaces[colorSpace].primaries;\\n      },\\n      getTransfer: \
function(colorSpace) {\\n        if (colorSpace === NoColorSpace) return \
LinearTransfer;\\n        return this.spaces[colorSpace].transfer;\\n      \
},\\n      getLuminanceCoefficients: function(target, colorSpace = \
this.workingColorSpace) {\\n        return \
target.fromArray(this.spaces[colorSpace].luminanceCoefficients);\\n      \
},\\n      define: function(colorSpaces) {\\n        \
Object.assign(this.spaces, colorSpaces);\\n      },\\n      // Internal \
APIs\\n      _getMatrix: function(targetMatrix, sourceColorSpace, \
targetColorSpace) {\\n        return \
targetMatrix.copy(this.spaces[sourceColorSpace].toXYZ).multiply(this.spaces[t\
argetColorSpace].fromXYZ);\\n      },\\n      _getDrawingBufferColorSpace: \
function(colorSpace) {\\n        return \
this.spaces[colorSpace].outputColorSpaceConfig.drawingBufferColorSpace;\\n    \
  },\\n      _getUnpackColorSpace: function(colorSpace = \
this.workingColorSpace) {\\n        return \
this.spaces[colorSpace].workingColorSpaceConfig.unpackColorSpace;\\n      \
},\\n      // Deprecated\\n      fromWorkingColorSpace: function(color, \
targetColorSpace) {\\n        warnOnce(\"THREE.ColorManagement: \
.fromWorkingColorSpace() has been renamed to .workingToColorSpace().\");\\n   \
     return ColorManagement2.workingToColorSpace(color, targetColorSpace);\\n \
     },\\n      toWorkingColorSpace: function(color, sourceColorSpace) {\\n   \
     warnOnce(\"THREE.ColorManagement: .toWorkingColorSpace() has been \
renamed to .colorSpaceToWorking().\");\\n        return \
ColorManagement2.colorSpaceToWorking(color, sourceColorSpace);\\n      }\\n   \
 };\\n    const REC709_PRIMARIES = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06];\\n    \
const REC709_LUMINANCE_COEFFICIENTS = [0.2126, 0.7152, 0.0722];\\n    const \
D65 = [0.3127, 0.329];\\n    ColorManagement2.define({\\n      \
[LinearSRGBColorSpace]: {\\n        primaries: REC709_PRIMARIES,\\n        \
whitePoint: D65,\\n        transfer: LinearTransfer,\\n        toXYZ: \
LINEAR_REC709_TO_XYZ,\\n        fromXYZ: XYZ_TO_LINEAR_REC709,\\n        \
luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,\\n        \
workingColorSpaceConfig: { unpackColorSpace: SRGBColorSpace },\\n        \
outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }\\n      \
},\\n      [SRGBColorSpace]: {\\n        primaries: REC709_PRIMARIES,\\n      \
  whitePoint: D65,\\n        transfer: SRGBTransfer,\\n        toXYZ: \
LINEAR_REC709_TO_XYZ,\\n        fromXYZ: XYZ_TO_LINEAR_REC709,\\n        \
luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,\\n        \
outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }\\n      \
}\\n    });\\n    return ColorManagement2;\\n  }\\n  const ColorManagement = \
/* @__PURE__ */ createColorManagement();\\n  function SRGBToLinear(c) {\\n    \
return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + \
0.0521327014, 2.4);\\n  }\\n  function LinearToSRGB(c) {\\n    return c < \
31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;\\n  }\\n  class \
Box3 {\\n    /**\\n     * Constructs a new bounding box.\\n     *\\n     * \
@param {Vector3} [min=(Infinity,Infinity,Infinity)] - A vector representing \
the lower boundary of the box.\\n     * @param {Vector3} \
[max=(-Infinity,-Infinity,-Infinity)] - A vector representing the upper \
boundary of the box.\\n     */\\n    constructor(min = new Vector3(Infinity, \
Infinity, Infinity), max2 = new Vector3(-Infinity, -Infinity, -Infinity)) \
{\\n      this.isBox3 = true;\\n      this.min = min;\\n      this.max = \
max2;\\n    }\\n    /**\\n     * Sets the lower and upper boundaries of this \
box.\\n     * Please note that this method only copies the values from the \
given objects.\\n     *\\n     * @param {Vector3} min - The lower boundary of \
the box.\\n     * @param {Vector3} max - The upper boundary of the box.\\n    \
 * @return {Box3} A reference to this bounding box.\\n     */\\n    set(min, \
max2) {\\n      this.min.copy(min);\\n      this.max.copy(max2);\\n      \
return this;\\n    }\\n    /**\\n     * Sets the upper and lower bounds of \
this box so it encloses the position data\\n     * in the given array.\\n     \
*\\n     * @param {Array<number>} array - An array holding 3D position \
data.\\n     * @return {Box3} A reference to this bounding box.\\n     */\\n  \
  setFromArray(array) {\\n      this.makeEmpty();\\n      for (let i2 = 0, il \
= array.length; i2 < il; i2 += 3) {\\n        \
this.expandByPoint(_vector$b.fromArray(array, i2));\\n      }\\n      return \
this;\\n    }\\n    /**\\n     * Sets the upper and lower bounds of this box \
so it encloses the position data\\n     * in the given buffer attribute.\\n   \
  *\\n     * @param {BufferAttribute} attribute - A buffer attribute holding \
3D position data.\\n     * @return {Box3} A reference to this bounding \
box.\\n     */\\n    setFromBufferAttribute(attribute) {\\n      \
this.makeEmpty();\\n      for (let i2 = 0, il = attribute.count; i2 < il; \
i2++) {\\n        this.expandByPoint(_vector$b.fromBufferAttribute(attribute, \
i2));\\n      }\\n      return this;\\n    }\\n    /**\\n     * Sets the \
upper and lower bounds of this box so it encloses the position data\\n     * \
in the given array.\\n     *\\n     * @param {Array<Vector3>} points - An \
array holding 3D position data as instances of {@link Vector3}.\\n     * \
@return {Box3} A reference to this bounding box.\\n     */\\n    \
setFromPoints(points) {\\n      this.makeEmpty();\\n      for (let i2 = 0, il \
= points.length; i2 < il; i2++) {\\n        \
this.expandByPoint(points[i2]);\\n      }\\n      return this;\\n    }\\n    \
/**\\n     * Centers this box on the given center vector and sets this \
box\\'s width, height and\\n     * depth to the given size values.\\n     \
*\\n     * @param {Vector3} center - The center of the box.\\n     * @param \
{Vector3} size - The x, y and z dimensions of the box.\\n     * @return \
{Box3} A reference to this bounding box.\\n     */\\n    \
setFromCenterAndSize(center, size) {\\n      const halfSize = \
_vector$b.copy(size).multiplyScalar(0.5);\\n      \
this.min.copy(center).sub(halfSize);\\n      \
this.max.copy(center).add(halfSize);\\n      return this;\\n    }\\n    \
/**\\n     * Computes the world-axis-aligned bounding box for the given 3D \
object\\n     * (including its children), accounting for the object\\'s, and \
children\\'s,\\n     * world transforms. The function may result in a larger \
box than strictly necessary.\\n     *\\n     * @param {Object3D} object - The \
3D object to compute the bounding box for.\\n     * @param {boolean} \
[precise=false] - If set to `true`, the method computes the smallest\\n     * \
world-axis-aligned bounding box at the expense of more computation.\\n     * \
@return {Box3} A reference to this bounding box.\\n     */\\n    \
setFromObject(object, precise = false) {\\n      this.makeEmpty();\\n      \
return this.expandByObject(object, precise);\\n    }\\n    /**\\n     * \
Returns a new box with copied values from this instance.\\n     *\\n     * \
@return {Box3} A clone of this instance.\\n     */\\n    clone() {\\n      \
return new this.constructor().copy(this);\\n    }\\n    /**\\n     * Copies \
the values of the given box to this instance.\\n     *\\n     * @param {Box3} \
box - The box to copy.\\n     * @return {Box3} A reference to this bounding \
box.\\n     */\\n    copy(box) {\\n      this.min.copy(box.min);\\n      \
this.max.copy(box.max);\\n      return this;\\n    }\\n    /**\\n     * Makes \
this box empty which means in encloses a zero space in 3D.\\n     *\\n     * \
@return {Box3} A reference to this bounding box.\\n     */\\n    makeEmpty() \
{\\n      this.min.x = this.min.y = this.min.z = Infinity;\\n      this.max.x \
= this.max.y = this.max.z = -Infinity;\\n      return this;\\n    }\\n    \
/**\\n     * Returns true if this box includes zero points within its \
bounds.\\n     * Note that a box with equal lower and upper bounds still \
includes one\\n     * point, the one both bounds share.\\n     *\\n     * \
@return {boolean} Whether this box is empty or not.\\n     */\\n    isEmpty() \
{\\n      return this.max.x < this.min.x || this.max.y < this.min.y || \
this.max.z < this.min.z;\\n    }\\n    /**\\n     * Returns the center point \
of this box.\\n     *\\n     * @param {Vector3} target - The target vector \
that is used to store the method\\'s result.\\n     * @return {Vector3} The \
center point.\\n     */\\n    getCenter(target) {\\n      return \
this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, \
this.max).multiplyScalar(0.5);\\n    }\\n    /**\\n     * Returns the \
dimensions of this box.\\n     *\\n     * @param {Vector3} target - The \
target vector that is used to store the method\\'s result.\\n     * @return \
{Vector3} The size.\\n     */\\n    getSize(target) {\\n      return \
this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, \
this.min);\\n    }\\n    /**\\n     * Expands the boundaries of this box to \
include the given point.\\n     *\\n     * @param {Vector3} point - The point \
that should be included by the bounding box.\\n     * @return {Box3} A \
reference to this bounding box.\\n     */\\n    expandByPoint(point) {\\n     \
 this.min.min(point);\\n      this.max.max(point);\\n      return this;\\n    \
}\\n    /**\\n     * Expands this box equilaterally by the given vector. The \
width of this\\n     * box will be expanded by the x component of the vector \
in both\\n     * directions. The height of this box will be expanded by the y \
component of\\n     * the vector in both directions. The depth of this box \
will be\\n     * expanded by the z component of the vector in both \
directions.\\n     *\\n     * @param {Vector3} vector - The vector that \
should expand the bounding box.\\n     * @return {Box3} A reference to this \
bounding box.\\n     */\\n    expandByVector(vector) {\\n      \
this.min.sub(vector);\\n      this.max.add(vector);\\n      return this;\\n   \
 }\\n    /**\\n     * Expands each dimension of the box by the given scalar. \
If negative, the\\n     * dimensions of the box will be contracted.\\n     \
*\\n     * @param {number} scalar - The scalar value that should expand the \
bounding box.\\n     * @return {Box3} A reference to this bounding box.\\n    \
 */\\n    expandByScalar(scalar) {\\n      this.min.addScalar(-scalar);\\n    \
  this.max.addScalar(scalar);\\n      return this;\\n    }\\n    /**\\n     * \
Expands the boundaries of this box to include the given 3D object and\\n     \
* its children, accounting for the object\\'s, and children\\'s, world\\n     \
* transforms. The function may result in a larger box than strictly\\n     * \
necessary (unless the precise parameter is set to true).\\n     *\\n     * \
@param {Object3D} object - The 3D object that should expand the bounding \
box.\\n     * @param {boolean} precise - If set to `true`, the method expands \
the bounding box\\n     * as little as necessary at the expense of more \
computation.\\n     * @return {Box3} A reference to this bounding box.\\n     \
*/\\n    expandByObject(object, precise = false) {\\n      \
object.updateWorldMatrix(false, false);\\n      const geometry = \
object.geometry;\\n      if (geometry !== void 0) {\\n        const \
positionAttribute = geometry.getAttribute(\"position\");\\n        if \
(precise === true && positionAttribute !== void 0 && object.isInstancedMesh \
!== true) {\\n          for (let i2 = 0, l = positionAttribute.count; i2 < l; \
i2++) {\\n            if (object.isMesh === true) {\\n              \
object.getVertexPosition(i2, _vector$b);\\n            } else {\\n            \
  _vector$b.fromBufferAttribute(positionAttribute, i2);\\n            }\\n    \
        _vector$b.applyMatrix4(object.matrixWorld);\\n            \
this.expandByPoint(_vector$b);\\n          }\\n        } else {\\n          \
if (object.boundingBox !== void 0) {\\n            if (object.boundingBox === \
null) {\\n              object.computeBoundingBox();\\n            }\\n       \
     _box$4.copy(object.boundingBox);\\n          } else {\\n            if \
(geometry.boundingBox === null) {\\n              \
geometry.computeBoundingBox();\\n            }\\n            \
_box$4.copy(geometry.boundingBox);\\n          }\\n          \
_box$4.applyMatrix4(object.matrixWorld);\\n          this.union(_box$4);\\n   \
     }\\n      }\\n      const children = object.children;\\n      for (let \
i2 = 0, l = children.length; i2 < l; i2++) {\\n        \
this.expandByObject(children[i2], precise);\\n      }\\n      return this;\\n \
   }\\n    /**\\n     * Returns `true` if the given point lies within or on \
the boundaries of this box.\\n     *\\n     * @param {Vector3} point - The \
point to test.\\n     * @return {boolean} Whether the bounding box contains \
the given point or not.\\n     */\\n    containsPoint(point) {\\n      return \
point.x >= this.min.x && point.x <= this.max.x && point.y >= this.min.y && \
point.y <= this.max.y && point.z >= this.min.z && point.z <= this.max.z;\\n   \
 }\\n    /**\\n     * Returns `true` if this bounding box includes the \
entirety of the given bounding box.\\n     * If this box and the given one \
are identical, this function also returns `true`.\\n     *\\n     * @param \
{Box3} box - The bounding box to test.\\n     * @return {boolean} Whether the \
bounding box contains the given bounding box or not.\\n     */\\n    \
containsBox(box) {\\n      return this.min.x <= box.min.x && box.max.x <= \
this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && \
this.min.z <= box.min.z && box.max.z <= this.max.z;\\n    }\\n    /**\\n     \
* Returns a point as a proportion of this box\\'s width, height and depth.\\n \
    *\\n     * @param {Vector3} point - A point in 3D space.\\n     * @param \
{Vector3} target - The target vector that is used to store the method\\'s \
result.\\n     * @return {Vector3} A point as a proportion of this box\\'s \
width, height and depth.\\n     */\\n    getParameter(point, target) {\\n     \
 return target.set(\\n        (point.x - this.min.x) / (this.max.x - \
this.min.x),\\n        (point.y - this.min.y) / (this.max.y - this.min.y),\\n \
       (point.z - this.min.z) / (this.max.z - this.min.z)\\n      );\\n    \
}\\n    /**\\n     * Returns `true` if the given bounding box intersects with \
this bounding box.\\n     *\\n     * @param {Box3} box - The bounding box to \
test.\\n     * @return {boolean} Whether the given bounding box intersects \
with this bounding box.\\n     */\\n    intersectsBox(box) {\\n      return \
box.max.x >= this.min.x && box.min.x <= this.max.x && box.max.y >= this.min.y \
&& box.min.y <= this.max.y && box.max.z >= this.min.z && box.min.z <= \
this.max.z;\\n    }\\n    /**\\n     * Returns `true` if the given bounding \
sphere intersects with this bounding box.\\n     *\\n     * @param {Sphere} \
sphere - The bounding sphere to test.\\n     * @return {boolean} Whether the \
given bounding sphere intersects with this bounding box.\\n     */\\n    \
intersectsSphere(sphere) {\\n      this.clampPoint(sphere.center, \
_vector$b);\\n      return _vector$b.distanceToSquared(sphere.center) <= \
sphere.radius * sphere.radius;\\n    }\\n    /**\\n     * Returns `true` if \
the given plane intersects with this bounding box.\\n     *\\n     * @param \
{Plane} plane - The plane to test.\\n     * @return {boolean} Whether the \
given plane intersects with this bounding box.\\n     */\\n    \
intersectsPlane(plane) {\\n      let min, max2;\\n      if (plane.normal.x > \
0) {\\n        min = plane.normal.x * this.min.x;\\n        max2 = \
plane.normal.x * this.max.x;\\n      } else {\\n        min = plane.normal.x \
* this.max.x;\\n        max2 = plane.normal.x * this.min.x;\\n      }\\n      \
if (plane.normal.y > 0) {\\n        min += plane.normal.y * this.min.y;\\n    \
    max2 += plane.normal.y * this.max.y;\\n      } else {\\n        min += \
plane.normal.y * this.max.y;\\n        max2 += plane.normal.y * \
this.min.y;\\n      }\\n      if (plane.normal.z > 0) {\\n        min += \
plane.normal.z * this.min.z;\\n        max2 += plane.normal.z * \
this.max.z;\\n      } else {\\n        min += plane.normal.z * this.max.z;\\n \
       max2 += plane.normal.z * this.min.z;\\n      }\\n      return min <= \
-plane.constant && max2 >= -plane.constant;\\n    }\\n    /**\\n     * \
Returns `true` if the given triangle intersects with this bounding box.\\n    \
 *\\n     * @param {Triangle} triangle - The triangle to test.\\n     * \
@return {boolean} Whether the given triangle intersects with this bounding \
box.\\n     */\\n    intersectsTriangle(triangle) {\\n      if \
(this.isEmpty()) {\\n        return false;\\n      }\\n      \
this.getCenter(_center);\\n      _extents.subVectors(this.max, _center);\\n   \
   _v0$2.subVectors(triangle.a, _center);\\n      \
_v1$7.subVectors(triangle.b, _center);\\n      _v2$4.subVectors(triangle.c, \
_center);\\n      _f0.subVectors(_v1$7, _v0$2);\\n      _f1.subVectors(_v2$4, \
_v1$7);\\n      _f2.subVectors(_v0$2, _v2$4);\\n      let axes = [\\n        \
0,\\n        -_f0.z,\\n        _f0.y,\\n        0,\\n        -_f1.z,\\n       \
 _f1.y,\\n        0,\\n        -_f2.z,\\n        _f2.y,\\n        _f0.z,\\n   \
     0,\\n        -_f0.x,\\n        _f1.z,\\n        0,\\n        -_f1.x,\\n  \
      _f2.z,\\n        0,\\n        -_f2.x,\\n        -_f0.y,\\n        \
_f0.x,\\n        0,\\n        -_f1.y,\\n        _f1.x,\\n        0,\\n        \
-_f2.y,\\n        _f2.x,\\n        0\\n      ];\\n      if (!satForAxes(axes, \
_v0$2, _v1$7, _v2$4, _extents)) {\\n        return false;\\n      }\\n      \
axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];\\n      if (!satForAxes(axes, _v0$2, \
_v1$7, _v2$4, _extents)) {\\n        return false;\\n      }\\n      \
_triangleNormal.crossVectors(_f0, _f1);\\n      axes = [_triangleNormal.x, \
_triangleNormal.y, _triangleNormal.z];\\n      return satForAxes(axes, _v0$2, \
_v1$7, _v2$4, _extents);\\n    }\\n    /**\\n     * Clamps the given point \
within the bounds of this box.\\n     *\\n     * @param {Vector3} point - The \
point to clamp.\\n     * @param {Vector3} target - The target vector that is \
used to store the method\\'s result.\\n     * @return {Vector3} The clamped \
point.\\n     */\\n    clampPoint(point, target) {\\n      return \
target.copy(point).clamp(this.min, this.max);\\n    }\\n    /**\\n     * \
Returns the euclidean distance from any edge of this box to the specified \
point. If\\n     * the given point lies inside of this box, the distance will \
be `0`.\\n     *\\n     * @param {Vector3} point - The point to compute the \
distance to.\\n     * @return {number} The euclidean distance.\\n     */\\n   \
 distanceToPoint(point) {\\n      return this.clampPoint(point, \
_vector$b).distanceTo(point);\\n    }\\n    /**\\n     * Returns a bounding \
sphere that encloses this bounding box.\\n     *\\n     * @param {Sphere} \
target - The target sphere that is used to store the method\\'s result.\\n    \
 * @return {Sphere} The bounding sphere that encloses this bounding box.\\n   \
  */\\n    getBoundingSphere(target) {\\n      if (this.isEmpty()) {\\n       \
 target.makeEmpty();\\n      } else {\\n        \
this.getCenter(target.center);\\n        target.radius = \
this.getSize(_vector$b).length() * 0.5;\\n      }\\n      return target;\\n   \
 }\\n    /**\\n     * Computes the intersection of this bounding box and the \
given one, setting the upper\\n     * bound of this box to the lesser of the \
two boxes\\' upper bounds and the\\n     * lower bound of this box to the \
greater of the two boxes\\' lower bounds. If\\n     * there\\'s no overlap, \
makes this box empty.\\n     *\\n     * @param {Box3} box - The bounding box \
to intersect with.\\n     * @return {Box3} A reference to this bounding \
box.\\n     */\\n    intersect(box) {\\n      this.min.max(box.min);\\n      \
this.max.min(box.max);\\n      if (this.isEmpty()) this.makeEmpty();\\n      \
return this;\\n    }\\n    /**\\n     * Computes the union of this box and \
another and the given one, setting the upper\\n     * bound of this box to \
the greater of the two boxes\\' upper bounds and the\\n     * lower bound of \
this box to the lesser of the two boxes\\' lower bounds.\\n     *\\n     * \
@param {Box3} box - The bounding box that will be unioned with this \
instance.\\n     * @return {Box3} A reference to this bounding box.\\n     \
*/\\n    union(box) {\\n      this.min.min(box.min);\\n      \
this.max.max(box.max);\\n      return this;\\n    }\\n    /**\\n     * \
Transforms this bounding box by the given 4x4 transformation matrix.\\n     \
*\\n     * @param {Matrix4} matrix - The transformation matrix.\\n     * \
@return {Box3} A reference to this bounding box.\\n     */\\n    \
applyMatrix4(matrix) {\\n      if (this.isEmpty()) return this;\\n      \
_points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);\\n   \
   _points[1].set(this.min.x, this.min.y, \
this.max.z).applyMatrix4(matrix);\\n      _points[2].set(this.min.x, \
this.max.y, this.min.z).applyMatrix4(matrix);\\n      \
_points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);\\n   \
   _points[4].set(this.max.x, this.min.y, \
this.min.z).applyMatrix4(matrix);\\n      _points[5].set(this.max.x, \
this.min.y, this.max.z).applyMatrix4(matrix);\\n      \
_points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);\\n   \
   _points[7].set(this.max.x, this.max.y, \
this.max.z).applyMatrix4(matrix);\\n      this.setFromPoints(_points);\\n     \
 return this;\\n    }\\n    /**\\n     * Adds the given offset to both the \
upper and lower bounds of this bounding box,\\n     * effectively moving it \
in 3D space.\\n     *\\n     * @param {Vector3} offset - The offset that \
should be used to translate the bounding box.\\n     * @return {Box3} A \
reference to this bounding box.\\n     */\\n    translate(offset) {\\n      \
this.min.add(offset);\\n      this.max.add(offset);\\n      return this;\\n   \
 }\\n    /**\\n     * Returns `true` if this bounding box is equal with the \
given one.\\n     *\\n     * @param {Box3} box - The box to test for \
equality.\\n     * @return {boolean} Whether this bounding box is equal with \
the given one.\\n     */\\n    equals(box) {\\n      return \
box.min.equals(this.min) && box.max.equals(this.max);\\n    }\\n    /**\\n    \
 * Returns a serialized structure of the bounding box.\\n     *\\n     * \
@return {Object} Serialized structure with fields representing the object \
state.\\n     */\\n    toJSON() {\\n      return {\\n        min: \
this.min.toArray(),\\n        max: this.max.toArray()\\n      };\\n    }\\n   \
 /**\\n     * Returns a serialized structure of the bounding box.\\n     *\\n \
    * @param {Object} json - The serialized json to set the box from.\\n     \
* @return {Box3} A reference to this bounding box.\\n     */\\n    \
fromJSON(json) {\\n      this.min.fromArray(json.min);\\n      \
this.max.fromArray(json.max);\\n      return this;\\n    }\\n  }\\n  const \
_points = [\\n    /* @__PURE__ */ new Vector3(),\\n    /* @__PURE__ */ new \
Vector3(),\\n    /* @__PURE__ */ new Vector3(),\\n    /* @__PURE__ */ new \
Vector3(),\\n    /* @__PURE__ */ new Vector3(),\\n    /* @__PURE__ */ new \
Vector3(),\\n    /* @__PURE__ */ new Vector3(),\\n    /* @__PURE__ */ new \
Vector3()\\n  ];\\n  const _vector$b = /* @__PURE__ */ new Vector3();\\n  \
const _box$4 = /* @__PURE__ */ new Box3();\\n  const _v0$2 = /* @__PURE__ */ \
new Vector3();\\n  const _v1$7 = /* @__PURE__ */ new Vector3();\\n  const \
_v2$4 = /* @__PURE__ */ new Vector3();\\n  const _f0 = /* @__PURE__ */ new \
Vector3();\\n  const _f1 = /* @__PURE__ */ new Vector3();\\n  const _f2 = /* \
@__PURE__ */ new Vector3();\\n  const _center = /* @__PURE__ */ new \
Vector3();\\n  const _extents = /* @__PURE__ */ new Vector3();\\n  const \
_triangleNormal = /* @__PURE__ */ new Vector3();\\n  const _testAxis = /* \
@__PURE__ */ new Vector3();\\n  function satForAxes(axes, v0, v1, v2, \
extents) {\\n    for (let i2 = 0, j = axes.length - 3; i2 <= j; i2 += 3) {\\n \
     _testAxis.fromArray(axes, i2);\\n      const r = extents.x * \
Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * \
Math.abs(_testAxis.z);\\n      const p0 = v0.dot(_testAxis);\\n      const p1 \
= v1.dot(_testAxis);\\n      const p2 = v2.dot(_testAxis);\\n      if \
(Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {\\n        \
return false;\\n      }\\n    }\\n    return true;\\n  }\\n  const \
_colorKeywords = {\\n    \"aliceblue\": 15792383,\\n    \"antiquewhite\": \
16444375,\\n    \"aqua\": 65535,\\n    \"aquamarine\": 8388564,\\n    \
\"azure\": 15794175,\\n    \"beige\": 16119260,\\n    \"bisque\": \
16770244,\\n    \"black\": 0,\\n    \"blanchedalmond\": 16772045,\\n    \
\"blue\": 255,\\n    \"blueviolet\": 9055202,\\n    \"brown\": 10824234,\\n   \
 \"burlywood\": 14596231,\\n    \"cadetblue\": 6266528,\\n    \"chartreuse\": \
8388352,\\n    \"chocolate\": 13789470,\\n    \"coral\": 16744272,\\n    \
\"cornflowerblue\": 6591981,\\n    \"cornsilk\": 16775388,\\n    \"crimson\": \
14423100,\\n    \"cyan\": 65535,\\n    \"darkblue\": 139,\\n    \"darkcyan\": \
35723,\\n    \"darkgoldenrod\": 12092939,\\n    \"darkgray\": 11119017,\\n    \
\"darkgreen\": 25600,\\n    \"darkgrey\": 11119017,\\n    \"darkkhaki\": \
12433259,\\n    \"darkmagenta\": 9109643,\\n    \"darkolivegreen\": \
5597999,\\n    \"darkorange\": 16747520,\\n    \"darkorchid\": 10040012,\\n   \
 \"darkred\": 9109504,\\n    \"darksalmon\": 15308410,\\n    \
\"darkseagreen\": 9419919,\\n    \"darkslateblue\": 4734347,\\n    \
\"darkslategray\": 3100495,\\n    \"darkslategrey\": 3100495,\\n    \
\"darkturquoise\": 52945,\\n    \"darkviolet\": 9699539,\\n    \"deeppink\": \
16716947,\\n    \"deepskyblue\": 49151,\\n    \"dimgray\": 6908265,\\n    \
\"dimgrey\": 6908265,\\n    \"dodgerblue\": 2003199,\\n    \"firebrick\": \
11674146,\\n    \"floralwhite\": 16775920,\\n    \"forestgreen\": 2263842,\\n \
   \"fuchsia\": 16711935,\\n    \"gainsboro\": 14474460,\\n    \
\"ghostwhite\": 16316671,\\n    \"gold\": 16766720,\\n    \"goldenrod\": \
14329120,\\n    \"gray\": 8421504,\\n    \"green\": 32768,\\n    \
\"greenyellow\": 11403055,\\n    \"grey\": 8421504,\\n    \"honeydew\": \
15794160,\\n    \"hotpink\": 16738740,\\n    \"indianred\": 13458524,\\n    \
\"indigo\": 4915330,\\n    \"ivory\": 16777200,\\n    \"khaki\": 15787660,\\n \
   \"lavender\": 15132410,\\n    \"lavenderblush\": 16773365,\\n    \
\"lawngreen\": 8190976,\\n    \"lemonchiffon\": 16775885,\\n    \
\"lightblue\": 11393254,\\n    \"lightcoral\": 15761536,\\n    \"lightcyan\": \
14745599,\\n    \"lightgoldenrodyellow\": 16448210,\\n    \"lightgray\": \
13882323,\\n    \"lightgreen\": 9498256,\\n    \"lightgrey\": 13882323,\\n    \
\"lightpink\": 16758465,\\n    \"lightsalmon\": 16752762,\\n    \
\"lightseagreen\": 2142890,\\n    \"lightskyblue\": 8900346,\\n    \
\"lightslategray\": 7833753,\\n    \"lightslategrey\": 7833753,\\n    \
\"lightsteelblue\": 11584734,\\n    \"lightyellow\": 16777184,\\n    \
\"lime\": 65280,\\n    \"limegreen\": 3329330,\\n    \"linen\": 16445670,\\n  \
  \"magenta\": 16711935,\\n    \"maroon\": 8388608,\\n    \
\"mediumaquamarine\": 6737322,\\n    \"mediumblue\": 205,\\n    \
\"mediumorchid\": 12211667,\\n    \"mediumpurple\": 9662683,\\n    \
\"mediumseagreen\": 3978097,\\n    \"mediumslateblue\": 8087790,\\n    \
\"mediumspringgreen\": 64154,\\n    \"mediumturquoise\": 4772300,\\n    \
\"mediumvioletred\": 13047173,\\n    \"midnightblue\": 1644912,\\n    \
\"mintcream\": 16121850,\\n    \"mistyrose\": 16770273,\\n    \"moccasin\": \
16770229,\\n    \"navajowhite\": 16768685,\\n    \"navy\": 128,\\n    \
\"oldlace\": 16643558,\\n    \"olive\": 8421376,\\n    \"olivedrab\": \
7048739,\\n    \"orange\": 16753920,\\n    \"orangered\": 16729344,\\n    \
\"orchid\": 14315734,\\n    \"palegoldenrod\": 15657130,\\n    \"palegreen\": \
10025880,\\n    \"paleturquoise\": 11529966,\\n    \"palevioletred\": \
14381203,\\n    \"papayawhip\": 16773077,\\n    \"peachpuff\": 16767673,\\n   \
 \"peru\": 13468991,\\n    \"pink\": 16761035,\\n    \"plum\": 14524637,\\n   \
 \"powderblue\": 11591910,\\n    \"purple\": 8388736,\\n    \
\"rebeccapurple\": 6697881,\\n    \"red\": 16711680,\\n    \"rosybrown\": \
12357519,\\n    \"royalblue\": 4286945,\\n    \"saddlebrown\": 9127187,\\n    \
\"salmon\": 16416882,\\n    \"sandybrown\": 16032864,\\n    \"seagreen\": \
3050327,\\n    \"seashell\": 16774638,\\n    \"sienna\": 10506797,\\n    \
\"silver\": 12632256,\\n    \"skyblue\": 8900331,\\n    \"slateblue\": \
6970061,\\n    \"slategray\": 7372944,\\n    \"slategrey\": 7372944,\\n    \
\"snow\": 16775930,\\n    \"springgreen\": 65407,\\n    \"steelblue\": \
4620980,\\n    \"tan\": 13808780,\\n    \"teal\": 32896,\\n    \"thistle\": \
14204888,\\n    \"tomato\": 16737095,\\n    \"turquoise\": 4251856,\\n    \
\"violet\": 15631086,\\n    \"wheat\": 16113331,\\n    \"white\": \
16777215,\\n    \"whitesmoke\": 16119285,\\n    \"yellow\": 16776960,\\n    \
\"yellowgreen\": 10145074\\n  };\\n  const _hslA = { h: 0, s: 0, l: 0 };\\n  \
const _hslB = { h: 0, s: 0, l: 0 };\\n  function hue2rgb(p, q, t) {\\n    if \
(t < 0) t += 1;\\n    if (t > 1) t -= 1;\\n    if (t < 1 / 6) return p + (q - \
p) * 6 * t;\\n    if (t < 1 / 2) return q;\\n    if (t < 2 / 3) return p + (q \
- p) * 6 * (2 / 3 - t);\\n    return p;\\n  }\\n  class Color {\\n    /**\\n  \
   * Constructs a new color.\\n     *\\n     * Note that standard method of \
specifying color in three.js is with a hexadecimal triplet,\\n     * and that \
method is used throughout the rest of the documentation.\\n     *\\n     * \
@param {(number|string|Color)} [r] - The red component of the color. If `g` \
and `b` are\\n     * not provided, it can be hexadecimal triplet, a CSS-style \
string or another `Color` instance.\\n     * @param {number} [g] - The green \
component.\\n     * @param {number} [b] - The blue component.\\n     */\\n    \
constructor(r, g, b) {\\n      this.isColor = true;\\n      this.r = 1;\\n    \
  this.g = 1;\\n      this.b = 1;\\n      return this.set(r, g, b);\\n    \
}\\n    /**\\n     * Sets the colors\\'s components from the given values.\\n \
    *\\n     * @param {(number|string|Color)} [r] - The red component of the \
color. If `g` and `b` are\\n     * not provided, it can be hexadecimal \
triplet, a CSS-style string or another `Color` instance.\\n     * @param \
{number} [g] - The green component.\\n     * @param {number} [b] - The blue \
component.\\n     * @return {Color} A reference to this color.\\n     */\\n   \
 set(r, g, b) {\\n      if (g === void 0 && b === void 0) {\\n        const \
value = r;\\n        if (value && value.isColor) {\\n          \
this.copy(value);\\n        } else if (typeof value === \"number\") {\\n      \
    this.setHex(value);\\n        } else if (typeof value === \"string\") \
{\\n          this.setStyle(value);\\n        }\\n      } else {\\n        \
this.setRGB(r, g, b);\\n      }\\n      return this;\\n    }\\n    /**\\n     \
* Sets the colors\\'s components to the given scalar value.\\n     *\\n     * \
@param {number} scalar - The scalar value.\\n     * @return {Color} A \
reference to this color.\\n     */\\n    setScalar(scalar) {\\n      this.r = \
scalar;\\n      this.g = scalar;\\n      this.b = scalar;\\n      return \
this;\\n    }\\n    /**\\n     * Sets this color from a hexadecimal value.\\n \
    *\\n     * @param {number} hex - The hexadecimal value.\\n     * @param \
{string} [colorSpace=SRGBColorSpace] - The color space.\\n     * @return \
{Color} A reference to this color.\\n     */\\n    setHex(hex, colorSpace = \
SRGBColorSpace) {\\n      hex = Math.floor(hex);\\n      this.r = (hex >> 16 \
& 255) / 255;\\n      this.g = (hex >> 8 & 255) / 255;\\n      this.b = (hex \
& 255) / 255;\\n      ColorManagement.colorSpaceToWorking(this, \
colorSpace);\\n      return this;\\n    }\\n    /**\\n     * Sets this color \
from RGB values.\\n     *\\n     * @param {number} r - Red channel value \
between `0.0` and `1.0`.\\n     * @param {number} g - Green channel value \
between `0.0` and `1.0`.\\n     * @param {number} b - Blue channel value \
between `0.0` and `1.0`.\\n     * @param {string} \
[colorSpace=ColorManagement.workingColorSpace] - The color space.\\n     * \
@return {Color} A reference to this color.\\n     */\\n    setRGB(r, g, b, \
colorSpace = ColorManagement.workingColorSpace) {\\n      this.r = r;\\n      \
this.g = g;\\n      this.b = b;\\n      \
ColorManagement.colorSpaceToWorking(this, colorSpace);\\n      return \
this;\\n    }\\n    /**\\n     * Sets this color from RGB values.\\n     *\\n \
    * @param {number} h - Hue value between `0.0` and `1.0`.\\n     * @param \
{number} s - Saturation value between `0.0` and `1.0`.\\n     * @param \
{number} l - Lightness value between `0.0` and `1.0`.\\n     * @param \
{string} [colorSpace=ColorManagement.workingColorSpace] - The color space.\\n \
    * @return {Color} A reference to this color.\\n     */\\n    setHSL(h, s, \
l, colorSpace = ColorManagement.workingColorSpace) {\\n      h = \
euclideanModulo(h, 1);\\n      s = clamp(s, 0, 1);\\n      l = clamp(l, 0, \
1);\\n      if (s === 0) {\\n        this.r = this.g = this.b = l;\\n      } \
else {\\n        const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;\\n        \
const q = 2 * l - p;\\n        this.r = hue2rgb(q, p, h + 1 / 3);\\n        \
this.g = hue2rgb(q, p, h);\\n        this.b = hue2rgb(q, p, h - 1 / 3);\\n    \
  }\\n      ColorManagement.colorSpaceToWorking(this, colorSpace);\\n      \
return this;\\n    }\\n    /**\\n     * Sets this color from a CSS-style \
string. For example, `rgb(250, 0,0)`,\\n     * `rgb(100%, 0%, 0%)`, `hsl(0, \
100%, 50%)`, `#ff0000`, `#f00`, or `red` ( or\\n     * any [X11 color \
name]{@link https://en.wikipedia.org/wiki/X11_color_names#Color_name_chart} \
-\\n     * all 140 color names are supported).\\n     *\\n     * @param \
{string} style - Color as a CSS-style string.\\n     * @param {string} \
[colorSpace=SRGBColorSpace] - The color space.\\n     * @return {Color} A \
reference to this color.\\n     */\\n    setStyle(style, colorSpace = \
SRGBColorSpace) {\\n      function handleAlpha(string) {\\n        if (string \
=== void 0) return;\\n        if (parseFloat(string) < 1) {\\n          \
console.warn(\"THREE.Color: Alpha component of \" + style + \" will be \
ignored.\");\\n        }\\n      }\\n      let m;\\n      if (m = \
/^(\\\\w+)\\\\(([^\\\\)]*)\\\\)/.exec(style)) {\\n        let color;\\n       \
 const name = m[1];\\n        const components = m[2];\\n        switch \
(name) {\\n          case \"rgb\":\\n          case \"rgba\":\\n            \
if (color = \
/^\\\\s*(\\\\d+)\\\\s*,\\\\s*(\\\\d+)\\\\s*,\\\\s*(\\\\d+)\\\\s*(?:,\\\\s*(\\\
\\d*\\\\.?\\\\d+)\\\\s*)?$/.exec(components)) {\\n              \
handleAlpha(color[4]);\\n              return this.setRGB(\\n                \
Math.min(255, parseInt(color[1], 10)) / 255,\\n                Math.min(255, \
parseInt(color[2], 10)) / 255,\\n                Math.min(255, \
parseInt(color[3], 10)) / 255,\\n                colorSpace\\n              \
);\\n            }\\n            if (color = \
/^\\\\s*(\\\\d+)\\\\%\\\\s*,\\\\s*(\\\\d+)\\\\%\\\\s*,\\\\s*(\\\\d+)\\\\%\\\\\
s*(?:,\\\\s*(\\\\d*\\\\.?\\\\d+)\\\\s*)?$/.exec(components)) {\\n             \
 handleAlpha(color[4]);\\n              return this.setRGB(\\n                \
Math.min(100, parseInt(color[1], 10)) / 100,\\n                Math.min(100, \
parseInt(color[2], 10)) / 100,\\n                Math.min(100, \
parseInt(color[3], 10)) / 100,\\n                colorSpace\\n              \
);\\n            }\\n            break;\\n          case \"hsl\":\\n          \
case \"hsla\":\\n            if (color = \
/^\\\\s*(\\\\d*\\\\.?\\\\d+)\\\\s*,\\\\s*(\\\\d*\\\\.?\\\\d+)\\\\%\\\\s*,\\\\\
s*(\\\\d*\\\\.?\\\\d+)\\\\%\\\\s*(?:,\\\\s*(\\\\d*\\\\.?\\\\d+)\\\\s*)?$/.exe\
c(components)) {\\n              handleAlpha(color[4]);\\n              \
return this.setHSL(\\n                parseFloat(color[1]) / 360,\\n          \
      parseFloat(color[2]) / 100,\\n                parseFloat(color[3]) / \
100,\\n                colorSpace\\n              );\\n            }\\n       \
     break;\\n          default:\\n            console.warn(\"THREE.Color: \
Unknown color model \" + style);\\n        }\\n      } else if (m = \
/^\\\\#([A-Fa-f\\\\d]+)$/.exec(style)) {\\n        const hex = m[1];\\n       \
 const size = hex.length;\\n        if (size === 3) {\\n          return \
this.setRGB(\\n            parseInt(hex.charAt(0), 16) / 15,\\n            \
parseInt(hex.charAt(1), 16) / 15,\\n            parseInt(hex.charAt(2), 16) / \
15,\\n            colorSpace\\n          );\\n        } else if (size === 6) \
{\\n          return this.setHex(parseInt(hex, 16), colorSpace);\\n        } \
else {\\n          console.warn(\"THREE.Color: Invalid hex color \" + \
style);\\n        }\\n      } else if (style && style.length > 0) {\\n        \
return this.setColorName(style, colorSpace);\\n      }\\n      return \
this;\\n    }\\n    /**\\n     * Sets this color from a color name. Faster \
than {@link Color#setStyle} if\\n     * you don\\'t need the other CSS-style \
formats.\\n     *\\n     * For convenience, the list of names is exposed in \
`Color.NAMES` as a hash.\\n     * ```js\\n     * Color.NAMES.aliceblue // \
returns 0xF0F8FF\\n     * ```\\n     *\\n     * @param {string} style - The \
color name.\\n     * @param {string} [colorSpace=SRGBColorSpace] - The color \
space.\\n     * @return {Color} A reference to this color.\\n     */\\n    \
setColorName(style, colorSpace = SRGBColorSpace) {\\n      const hex = \
_colorKeywords[style.toLowerCase()];\\n      if (hex !== void 0) {\\n        \
this.setHex(hex, colorSpace);\\n      } else {\\n        \
console.warn(\"THREE.Color: Unknown color \" + style);\\n      }\\n      \
return this;\\n    }\\n    /**\\n     * Returns a new color with copied \
values from this instance.\\n     *\\n     * @return {Color} A clone of this \
instance.\\n     */\\n    clone() {\\n      return new \
this.constructor(this.r, this.g, this.b);\\n    }\\n    /**\\n     * Copies \
the values of the given color to this instance.\\n     *\\n     * @param \
{Color} color - The color to copy.\\n     * @return {Color} A reference to \
this color.\\n     */\\n    copy(color) {\\n      this.r = color.r;\\n      \
this.g = color.g;\\n      this.b = color.b;\\n      return this;\\n    }\\n   \
 /**\\n     * Copies the given color into this color, and then converts this \
color from\\n     * `SRGBColorSpace` to `LinearSRGBColorSpace`.\\n     *\\n   \
  * @param {Color} color - The color to copy/convert.\\n     * @return \
{Color} A reference to this color.\\n     */\\n    copySRGBToLinear(color) \
{\\n      this.r = SRGBToLinear(color.r);\\n      this.g = \
SRGBToLinear(color.g);\\n      this.b = SRGBToLinear(color.b);\\n      return \
this;\\n    }\\n    /**\\n     * Copies the given color into this color, and \
then converts this color from\\n     * `LinearSRGBColorSpace` to \
`SRGBColorSpace`.\\n     *\\n     * @param {Color} color - The color to \
copy/convert.\\n     * @return {Color} A reference to this color.\\n     \
*/\\n    copyLinearToSRGB(color) {\\n      this.r = LinearToSRGB(color.r);\\n \
     this.g = LinearToSRGB(color.g);\\n      this.b = \
LinearToSRGB(color.b);\\n      return this;\\n    }\\n    /**\\n     * \
Converts this color from `SRGBColorSpace` to `LinearSRGBColorSpace`.\\n     \
*\\n     * @return {Color} A reference to this color.\\n     */\\n    \
convertSRGBToLinear() {\\n      this.copySRGBToLinear(this);\\n      return \
this;\\n    }\\n    /**\\n     * Converts this color from \
`LinearSRGBColorSpace` to `SRGBColorSpace`.\\n     *\\n     * @return {Color} \
A reference to this color.\\n     */\\n    convertLinearToSRGB() {\\n      \
this.copyLinearToSRGB(this);\\n      return this;\\n    }\\n    /**\\n     * \
Returns the hexadecimal value of this color.\\n     *\\n     * @param \
{string} [colorSpace=SRGBColorSpace] - The color space.\\n     * @return \
{number} The hexadecimal value.\\n     */\\n    getHex(colorSpace = \
SRGBColorSpace) {\\n      \
ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);\\n      \
return Math.round(clamp(_color.r * 255, 0, 255)) * 65536 + \
Math.round(clamp(_color.g * 255, 0, 255)) * 256 + Math.round(clamp(_color.b * \
255, 0, 255));\\n    }\\n    /**\\n     * Returns the hexadecimal value of \
this color as a string (for example, \\'FFFFFF\\').\\n     *\\n     * @param \
{string} [colorSpace=SRGBColorSpace] - The color space.\\n     * @return \
{string} The hexadecimal value as a string.\\n     */\\n    \
getHexString(colorSpace = SRGBColorSpace) {\\n      return (\"000000\" + \
this.getHex(colorSpace).toString(16)).slice(-6);\\n    }\\n    /**\\n     * \
Converts the colors RGB values into the HSL format and stores them into \
the\\n     * given target object.\\n     *\\n     * @param \
{{h:number,s:number,l:number}} target - The target object that is used to \
store the method\\'s result.\\n     * @param {string} \
[colorSpace=ColorManagement.workingColorSpace] - The color space.\\n     * \
@return {{h:number,s:number,l:number}} The HSL representation of this \
color.\\n     */\\n    getHSL(target, colorSpace = \
ColorManagement.workingColorSpace) {\\n      \
ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);\\n      \
const r = _color.r, g = _color.g, b = _color.b;\\n      const max2 = \
Math.max(r, g, b);\\n      const min = Math.min(r, g, b);\\n      let hue, \
saturation;\\n      const lightness = (min + max2) / 2;\\n      if (min === \
max2) {\\n        hue = 0;\\n        saturation = 0;\\n      } else {\\n      \
  const delta = max2 - min;\\n        saturation = lightness <= 0.5 ? delta / \
(max2 + min) : delta / (2 - max2 - min);\\n        switch (max2) {\\n         \
 case r:\\n            hue = (g - b) / delta + (g < b ? 6 : 0);\\n            \
break;\\n          case g:\\n            hue = (b - r) / delta + 2;\\n        \
    break;\\n          case b:\\n            hue = (r - g) / delta + 4;\\n    \
        break;\\n        }\\n        hue /= 6;\\n      }\\n      target.h = \
hue;\\n      target.s = saturation;\\n      target.l = lightness;\\n      \
return target;\\n    }\\n    /**\\n     * Returns the RGB values of this \
color and stores them into the given target object.\\n     *\\n     * @param \
{Color} target - The target color that is used to store the method\\'s \
result.\\n     * @param {string} \
[colorSpace=ColorManagement.workingColorSpace] - The color space.\\n     * \
@return {Color} The RGB representation of this color.\\n     */\\n    \
getRGB(target, colorSpace = ColorManagement.workingColorSpace) {\\n      \
ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);\\n      \
target.r = _color.r;\\n      target.g = _color.g;\\n      target.b = \
_color.b;\\n      return target;\\n    }\\n    /**\\n     * Returns the value \
of this color as a CSS style string. Example: `rgb(255,0,0)`.\\n     *\\n     \
* @param {string} [colorSpace=SRGBColorSpace] - The color space.\\n     * \
@return {string} The CSS representation of this color.\\n     */\\n    \
getStyle(colorSpace = SRGBColorSpace) {\\n      \
ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);\\n      \
const r = _color.r, g = _color.g, b = _color.b;\\n      if (colorSpace !== \
SRGBColorSpace) {\\n        return `color(${colorSpace} ${r.toFixed(3)} \
${g.toFixed(3)} ${b.toFixed(3)})`;\\n      }\\n      return \
`rgb(${Math.round(r * 255)},${Math.round(g * 255)},${Math.round(b * \
255)})`;\\n    }\\n    /**\\n     * Adds the given HSL values to this \
color\\'s values.\\n     * Internally, this converts the color\\'s RGB values \
to HSL, adds HSL\\n     * and then converts the color back to RGB.\\n     \
*\\n     * @param {number} h - Hue value between `0.0` and `1.0`.\\n     * \
@param {number} s - Saturation value between `0.0` and `1.0`.\\n     * @param \
{number} l - Lightness value between `0.0` and `1.0`.\\n     * @return \
{Color} A reference to this color.\\n     */\\n    offsetHSL(h, s, l) {\\n    \
  this.getHSL(_hslA);\\n      return this.setHSL(_hslA.h + h, _hslA.s + s, \
_hslA.l + l);\\n    }\\n    /**\\n     * Adds the RGB values of the given \
color to the RGB values of this color.\\n     *\\n     * @param {Color} color \
- The color to add.\\n     * @return {Color} A reference to this color.\\n    \
 */\\n    add(color) {\\n      this.r += color.r;\\n      this.g += \
color.g;\\n      this.b += color.b;\\n      return this;\\n    }\\n    /**\\n \
    * Adds the RGB values of the given colors and stores the result in this \
instance.\\n     *\\n     * @param {Color} color1 - The first color.\\n     * \
@param {Color} color2 - The second color.\\n     * @return {Color} A \
reference to this color.\\n     */\\n    addColors(color1, color2) {\\n      \
this.r = color1.r + color2.r;\\n      this.g = color1.g + color2.g;\\n      \
this.b = color1.b + color2.b;\\n      return this;\\n    }\\n    /**\\n     * \
Adds the given scalar value to the RGB values of this color.\\n     *\\n     \
* @param {number} s - The scalar to add.\\n     * @return {Color} A reference \
to this color.\\n     */\\n    addScalar(s) {\\n      this.r += s;\\n      \
this.g += s;\\n      this.b += s;\\n      return this;\\n    }\\n    /**\\n   \
  * Subtracts the RGB values of the given color from the RGB values of this \
color.\\n     *\\n     * @param {Color} color - The color to subtract.\\n     \
* @return {Color} A reference to this color.\\n     */\\n    sub(color) {\\n  \
    this.r = Math.max(0, this.r - color.r);\\n      this.g = Math.max(0, \
this.g - color.g);\\n      this.b = Math.max(0, this.b - color.b);\\n      \
return this;\\n    }\\n    /**\\n     * Multiplies the RGB values of the \
given color with the RGB values of this color.\\n     *\\n     * @param \
{Color} color - The color to multiply.\\n     * @return {Color} A reference \
to this color.\\n     */\\n    multiply(color) {\\n      this.r *= \
color.r;\\n      this.g *= color.g;\\n      this.b *= color.b;\\n      return \
this;\\n    }\\n    /**\\n     * Multiplies the given scalar value with the \
RGB values of this color.\\n     *\\n     * @param {number} s - The scalar to \
multiply.\\n     * @return {Color} A reference to this color.\\n     */\\n    \
multiplyScalar(s) {\\n      this.r *= s;\\n      this.g *= s;\\n      this.b \
*= s;\\n      return this;\\n    }\\n    /**\\n     * Linearly interpolates \
this color\\'s RGB values toward the RGB values of the\\n     * given color. \
The alpha argument can be thought of as the ratio between\\n     * the two \
colors, where `0.0` is this color and `1.0` is the first argument.\\n     \
*\\n     * @param {Color} color - The color to converge on.\\n     * @param \
{number} alpha - The interpolation factor in the closed interval `[0,1]`.\\n  \
   * @return {Color} A reference to this color.\\n     */\\n    lerp(color, \
alpha) {\\n      this.r += (color.r - this.r) * alpha;\\n      this.g += \
(color.g - this.g) * alpha;\\n      this.b += (color.b - this.b) * alpha;\\n  \
    return this;\\n    }\\n    /**\\n     * Linearly interpolates between the \
given colors and stores the result in this instance.\\n     * The alpha \
argument can be thought of as the ratio between the two colors, where \
`0.0`\\n     * is the first and `1.0` is the second color.\\n     *\\n     * \
@param {Color} color1 - The first color.\\n     * @param {Color} color2 - The \
second color.\\n     * @param {number} alpha - The interpolation factor in \
the closed interval `[0,1]`.\\n     * @return {Color} A reference to this \
color.\\n     */\\n    lerpColors(color1, color2, alpha) {\\n      this.r = \
color1.r + (color2.r - color1.r) * alpha;\\n      this.g = color1.g + \
(color2.g - color1.g) * alpha;\\n      this.b = color1.b + (color2.b - \
color1.b) * alpha;\\n      return this;\\n    }\\n    /**\\n     * Linearly \
interpolates this color\\'s HSL values toward the HSL values of the\\n     * \
given color. It differs from {@link Color#lerp} by not interpolating \
straight\\n     * from one color to the other, but instead going through all \
the hues in between\\n     * those two colors. The alpha argument can be \
thought of as the ratio between\\n     * the two colors, where 0.0 is this \
color and 1.0 is the first argument.\\n     *\\n     * @param {Color} color - \
The color to converge on.\\n     * @param {number} alpha - The interpolation \
factor in the closed interval `[0,1]`.\\n     * @return {Color} A reference \
to this color.\\n     */\\n    lerpHSL(color, alpha) {\\n      \
this.getHSL(_hslA);\\n      color.getHSL(_hslB);\\n      const h = \
lerp(_hslA.h, _hslB.h, alpha);\\n      const s = lerp(_hslA.s, _hslB.s, \
alpha);\\n      const l = lerp(_hslA.l, _hslB.l, alpha);\\n      \
this.setHSL(h, s, l);\\n      return this;\\n    }\\n    /**\\n     * Sets \
the color\\'s RGB components from the given 3D vector.\\n     *\\n     * \
@param {Vector3} v - The vector to set.\\n     * @return {Color} A reference \
to this color.\\n     */\\n    setFromVector3(v) {\\n      this.r = v.x;\\n   \
   this.g = v.y;\\n      this.b = v.z;\\n      return this;\\n    }\\n    \
/**\\n     * Transforms this color with the given 3x3 matrix.\\n     *\\n     \
* @param {Matrix3} m - The matrix.\\n     * @return {Color} A reference to \
this color.\\n     */\\n    applyMatrix3(m) {\\n      const r = this.r, g = \
this.g, b = this.b;\\n      const e = m.elements;\\n      this.r = e[0] * r + \
e[3] * g + e[6] * b;\\n      this.g = e[1] * r + e[4] * g + e[7] * b;\\n      \
this.b = e[2] * r + e[5] * g + e[8] * b;\\n      return this;\\n    }\\n    \
/**\\n     * Returns `true` if this color is equal with the given one.\\n     \
*\\n     * @param {Color} c - The color to test for equality.\\n     * \
@return {boolean} Whether this bounding color is equal with the given one.\\n \
    */\\n    equals(c) {\\n      return c.r === this.r && c.g === this.g && \
c.b === this.b;\\n    }\\n    /**\\n     * Sets this color\\'s RGB components \
from the given array.\\n     *\\n     * @param {Array<number>} array - An \
array holding the RGB values.\\n     * @param {number} [offset=0] - The \
offset into the array.\\n     * @return {Color} A reference to this color.\\n \
    */\\n    fromArray(array, offset = 0) {\\n      this.r = \
array[offset];\\n      this.g = array[offset + 1];\\n      this.b = \
array[offset + 2];\\n      return this;\\n    }\\n    /**\\n     * Writes the \
RGB components of this color to the given array. If no array is provided,\\n  \
   * the method returns a new instance.\\n     *\\n     * @param \
{Array<number>} [array=[]] - The target array holding the color \
components.\\n     * @param {number} [offset=0] - Index of the first element \
in the array.\\n     * @return {Array<number>} The color components.\\n     \
*/\\n    toArray(array = [], offset = 0) {\\n      array[offset] = this.r;\\n \
     array[offset + 1] = this.g;\\n      array[offset + 2] = this.b;\\n      \
return array;\\n    }\\n    /**\\n     * Sets the components of this color \
from the given buffer attribute.\\n     *\\n     * @param {BufferAttribute} \
attribute - The buffer attribute holding color data.\\n     * @param {number} \
index - The index into the attribute.\\n     * @return {Color} A reference to \
this color.\\n     */\\n    fromBufferAttribute(attribute, index) {\\n      \
this.r = attribute.getX(index);\\n      this.g = attribute.getY(index);\\n    \
  this.b = attribute.getZ(index);\\n      return this;\\n    }\\n    /**\\n   \
  * This methods defines the serialization result of this class. Returns the \
color\\n     * as a hexadecimal value.\\n     *\\n     * @return {number} The \
hexadecimal value.\\n     */\\n    toJSON() {\\n      return \
this.getHex();\\n    }\\n    *[Symbol.iterator]() {\\n      yield this.r;\\n  \
    yield this.g;\\n      yield this.b;\\n    }\\n  }\\n  const _color = /* \
@__PURE__ */ new Color();\\n  Color.NAMES = _colorKeywords;\\n  if (typeof \
__THREE_DEVTOOLS__ !== \"undefined\") {\\n    \
__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent(\"register\", { detail: {\\n \
     revision: REVISION\\n    } }));\\n  }\\n  if (typeof window !== \
\"undefined\") {\\n    if (window.__THREE__) {\\n      \
console.warn(\"WARNING: Multiple instances of Three.js being imported.\");\\n \
   } else {\\n      window.__THREE__ = REVISION;\\n    }\\n  }\\n  const \
LN_SCALE_MIN = -12;\\n  const LN_SCALE_MAX = 9;\\n  const LN_SCALE_ZERO = \
-30;\\n  const SCALE_ZERO = Math.exp(LN_SCALE_ZERO);\\n  const \
SPLAT_TEX_WIDTH_BITS = 11;\\n  const SPLAT_TEX_HEIGHT_BITS = 11;\\n  const \
SPLAT_TEX_WIDTH = 1 << SPLAT_TEX_WIDTH_BITS;\\n  const SPLAT_TEX_HEIGHT = 1 \
<< SPLAT_TEX_HEIGHT_BITS;\\n  const SPLAT_TEX_MIN_HEIGHT = 1;\\n  function \
unindentLines(s) {\\n    var _a2;\\n    let seenNonEmpty = false;\\n    const \
lines = s.split(\"\\\\n\").map((line) => {\\n      const trimmedLine = \
line.trimEnd();\\n      if (seenNonEmpty) {\\n        return trimmedLine;\\n  \
    }\\n      if (trimmedLine.length > 0) {\\n        seenNonEmpty = true;\\n \
       return trimmedLine;\\n      }\\n      return null;\\n    \
}).filter((line) => line != null);\\n    while (lines.length > 0 && \
lines[lines.length - 1].length === 0) {\\n      lines.pop();\\n    }\\n    if \
(lines.length === 0) {\\n      return [];\\n    }\\n    const indent = (_a2 = \
lines[0].match(/^\\\\s*/)) == null ? void 0 : _a2[0];\\n    if (!indent) {\\n \
     return lines;\\n    }\\n    const regex = new RegExp(`^${indent}`);\\n   \
 return lines.map((line) => line.replace(regex, \"\"));\\n  }\\n  function \
unindent(s) {\\n    return unindentLines(s).join(\"\\\\n\");\\n  }\\n  const \
f32buffer = new Float32Array(1);\\n  const u32buffer = new \
Uint32Array(f32buffer.buffer);\\n  const supportsFloat16Array = \
\"Float16Array\" in globalThis;\\n  const f16buffer = supportsFloat16Array ? \
new globalThis[\"Float16Array\"](1) : null;\\n  const u16buffer = new \
Uint16Array(f16buffer == null ? void 0 : f16buffer.buffer);\\n  function \
normalize(vec) {\\n    const norm = Math.sqrt(vec.reduce((acc, v) => acc + v \
* v, 0));\\n    return vec.map((v) => v / norm);\\n  }\\n  const toHalf = \
supportsFloat16Array ? toHalfNative : toHalfJS;\\n  const fromHalf = \
supportsFloat16Array ? fromHalfNative : fromHalfJS;\\n  function \
toHalfNative(f) {\\n    f16buffer[0] = f;\\n    return u16buffer[0];\\n  }\\n \
 function toHalfJS(f) {\\n    f32buffer[0] = f;\\n    const bits2 = \
u32buffer[0];\\n    const sign = bits2 >> 31 & 1;\\n    const exp = bits2 >> \
23 & 255;\\n    const frac = bits2 & 8388607;\\n    const halfSign = sign << \
15;\\n    if (exp === 255) {\\n      if (frac !== 0) {\\n        return \
halfSign | 32767;\\n      }\\n      return halfSign | 31744;\\n    }\\n    \
const newExp = exp - 127 + 15;\\n    if (newExp >= 31) {\\n      return \
halfSign | 31744;\\n    }\\n    if (newExp <= 0) {\\n      if (newExp < -10) \
{\\n        return halfSign;\\n      }\\n      const subFrac = (frac | \
8388608) >> 1 - newExp + 13;\\n      return halfSign | subFrac;\\n    }\\n    \
const halfFrac = frac >> 13;\\n    return halfSign | newExp << 10 | \
halfFrac;\\n  }\\n  function fromHalfNative(u) {\\n    u16buffer[0] = u;\\n   \
 return f16buffer[0];\\n  }\\n  function fromHalfJS(h) {\\n    const sign = h \
>> 15 & 1;\\n    const exp = h >> 10 & 31;\\n    const frac = h & 1023;\\n    \
let f32bits;\\n    if (exp === 0) {\\n      if (frac === 0) {\\n        \
f32bits = sign << 31;\\n      } else {\\n        let mant = frac;\\n        \
let e = -14;\\n        while ((mant & 1024) === 0) {\\n          mant <<= \
1;\\n          e--;\\n        }\\n        mant &= 1023;\\n        const \
newExp = e + 127;\\n        const newFrac = mant << 13;\\n        f32bits = \
sign << 31 | newExp << 23 | newFrac;\\n      }\\n    } else if (exp === 31) \
{\\n      if (frac === 0) {\\n        f32bits = sign << 31 | 2139095040;\\n   \
   } else {\\n        f32bits = sign << 31 | 2143289344;\\n      }\\n    } \
else {\\n      const newExp = exp - 15 + 127;\\n      const newFrac = frac << \
13;\\n      f32bits = sign << 31 | newExp << 23 | newFrac;\\n    }\\n    \
u32buffer[0] = f32bits;\\n    return f32buffer[0];\\n  }\\n  function \
floatToUint8(v) {\\n    return Math.max(0, Math.min(255, Math.round(v * \
255)));\\n  }\\n  function getArrayBuffers(ctx) {\\n    const buffers = \
[];\\n    const seen = /* @__PURE__ */ new Set();\\n    function \
traverse(obj) {\\n      if (obj && typeof obj === \"object\" && \
!seen.has(obj)) {\\n        seen.add(obj);\\n        if (obj instanceof \
ArrayBuffer) {\\n          buffers.push(obj);\\n        } else if \
(ArrayBuffer.isView(obj)) {\\n          buffers.push(obj.buffer);\\n        } \
else if (Array.isArray(obj)) {\\n          obj.forEach(traverse);\\n        } \
else {\\n          Object.values(obj).forEach(traverse);\\n        }\\n      \
}\\n    }\\n    traverse(ctx);\\n    return buffers;\\n  }\\n  function \
setPackedSplat(packedSplats, index, x2, y, z, scaleX, scaleY, scaleZ, quatX, \
quatY, quatZ, quatW, opacity, r, g, b, encoding) {\\n    const rgbMin = \
(encoding == null ? void 0 : encoding.rgbMin) ?? 0;\\n    const rgbMax = \
(encoding == null ? void 0 : encoding.rgbMax) ?? 1;\\n    const rgbRange = \
rgbMax - rgbMin;\\n    const uR = floatToUint8((r - rgbMin) / rgbRange);\\n   \
 const uG = floatToUint8((g - rgbMin) / rgbRange);\\n    const uB = \
floatToUint8((b - rgbMin) / rgbRange);\\n    const uA = \
floatToUint8(opacity);\\n    const uQuat = encodeQuatOctXy88R8(\\n      \
tempQuaternion.set(quatX, quatY, quatZ, quatW)\\n    );\\n    const uQuatX = \
uQuat & 255;\\n    const uQuatY = uQuat >>> 8 & 255;\\n    const uQuatZ = \
uQuat >>> 16 & 255;\\n    const lnScaleMin = (encoding == null ? void 0 : \
encoding.lnScaleMin) ?? LN_SCALE_MIN;\\n    const lnScaleMax = (encoding == \
null ? void 0 : encoding.lnScaleMax) ?? LN_SCALE_MAX;\\n    const \
lnScaleScale = 254 / (lnScaleMax - lnScaleMin);\\n    const uScaleX = scaleX \
< SCALE_ZERO ? 0 : Math.min(\\n      255,\\n      Math.max(\\n        1,\\n   \
     Math.round((Math.log(scaleX) - lnScaleMin) * lnScaleScale) + 1\\n      \
)\\n    );\\n    const uScaleY = scaleY < SCALE_ZERO ? 0 : Math.min(\\n      \
255,\\n      Math.max(\\n        1,\\n        Math.round((Math.log(scaleY) - \
lnScaleMin) * lnScaleScale) + 1\\n      )\\n    );\\n    const uScaleZ = \
scaleZ < SCALE_ZERO ? 0 : Math.min(\\n      255,\\n      Math.max(\\n        \
1,\\n        Math.round((Math.log(scaleZ) - lnScaleMin) * lnScaleScale) + \
1\\n      )\\n    );\\n    const uCenterX = toHalf(x2);\\n    const uCenterY \
= toHalf(y);\\n    const uCenterZ = toHalf(z);\\n    const i4 = index * 4;\\n \
   packedSplats[i4] = uR | uG << 8 | uB << 16 | uA << 24;\\n    \
packedSplats[i4 + 1] = uCenterX | uCenterY << 16;\\n    packedSplats[i4 + 2] \
= uCenterZ | uQuatX << 16 | uQuatY << 24;\\n    packedSplats[i4 + 3] = \
uScaleX | uScaleY << 8 | uScaleZ << 16 | uQuatZ << 24;\\n  }\\n  function \
setPackedSplatCenter(packedSplats, index, x2, y, z) {\\n    const uCenterX = \
toHalf(x2);\\n    const uCenterY = toHalf(y);\\n    const uCenterZ = \
toHalf(z);\\n    const i4 = index * 4;\\n    packedSplats[i4 + 1] = uCenterX \
| uCenterY << 16;\\n    packedSplats[i4 + 2] = uCenterZ | packedSplats[i4 + \
2] & 4294901760;\\n  }\\n  function setPackedSplatScales(packedSplats, index, \
scaleX, scaleY, scaleZ, encoding) {\\n    const lnScaleMin = (encoding == \
null ? void 0 : encoding.lnScaleMin) ?? LN_SCALE_MIN;\\n    const lnScaleMax \
= (encoding == null ? void 0 : encoding.lnScaleMax) ?? LN_SCALE_MAX;\\n    \
const lnScaleScale = 254 / (lnScaleMax - lnScaleMin);\\n    const uScaleX = \
scaleX < SCALE_ZERO ? 0 : Math.min(\\n      255,\\n      Math.max(\\n        \
1,\\n        Math.round((Math.log(scaleX) - lnScaleMin) * lnScaleScale) + \
1\\n      )\\n    );\\n    const uScaleY = scaleY < SCALE_ZERO ? 0 : \
Math.min(\\n      255,\\n      Math.max(\\n        1,\\n        \
Math.round((Math.log(scaleY) - lnScaleMin) * lnScaleScale) + 1\\n      )\\n   \
 );\\n    const uScaleZ = scaleZ < SCALE_ZERO ? 0 : Math.min(\\n      255,\\n \
     Math.max(\\n        1,\\n        Math.round((Math.log(scaleZ) - \
lnScaleMin) * lnScaleScale) + 1\\n      )\\n    );\\n    const i4 = index * \
4;\\n    packedSplats[i4 + 3] = uScaleX | uScaleY << 8 | uScaleZ << 16 | \
packedSplats[i4 + 3] & 4278190080;\\n  }\\n  const tempQuaternion = new \
Quaternion();\\n  function setPackedSplatQuat(packedSplats, index, quatX, \
quatY, quatZ, quatW) {\\n    const uQuat = encodeQuatOctXy88R8(\\n      \
tempQuaternion.set(quatX, quatY, quatZ, quatW)\\n    );\\n    const uQuatX = \
uQuat & 255;\\n    const uQuatY = uQuat >>> 8 & 255;\\n    const uQuatZ = \
uQuat >>> 16 & 255;\\n    const i4 = index * 4;\\n    packedSplats[i4 + 2] = \
packedSplats[i4 + 2] & 65535 | uQuatX << 16 | uQuatY << 24;\\n    \
packedSplats[i4 + 3] = packedSplats[i4 + 3] & 16777215 | uQuatZ << 24;\\n  \
}\\n  function setPackedSplatRgba(packedSplats, index, r, g, b, a, encoding) \
{\\n    const rgbMin = (encoding == null ? void 0 : encoding.rgbMin) ?? 0;\\n \
   const rgbMax = (encoding == null ? void 0 : encoding.rgbMax) ?? 1;\\n    \
const rgbRange = rgbMax - rgbMin;\\n    const uR = floatToUint8((r - rgbMin) \
/ rgbRange);\\n    const uG = floatToUint8((g - rgbMin) / rgbRange);\\n    \
const uB = floatToUint8((b - rgbMin) / rgbRange);\\n    const uA = \
floatToUint8(a);\\n    const i4 = index * 4;\\n    packedSplats[i4] = uR | uG \
<< 8 | uB << 16 | uA << 24;\\n  }\\n  function \
setPackedSplatRgb(packedSplats, index, r, g, b, encoding) {\\n    const \
rgbMin = (encoding == null ? void 0 : encoding.rgbMin) ?? 0;\\n    const \
rgbMax = (encoding == null ? void 0 : encoding.rgbMax) ?? 1;\\n    const \
rgbRange = rgbMax - rgbMin;\\n    const uR = floatToUint8((r - rgbMin) / \
rgbRange);\\n    const uG = floatToUint8((g - rgbMin) / rgbRange);\\n    \
const uB = floatToUint8((b - rgbMin) / rgbRange);\\n    const i4 = index * \
4;\\n    packedSplats[i4] = uR | uG << 8 | uB << 16 | packedSplats[i4] & \
4278190080;\\n  }\\n  function setPackedSplatOpacity(packedSplats, index, \
opacity) {\\n    const uA = floatToUint8(opacity);\\n    const i4 = index * \
4;\\n    packedSplats[i4] = packedSplats[i4] & 16777215 | uA << 24;\\n  }\\n  \
new Vector3();\\n  new Vector3();\\n  new Color();\\n  function \
getTextureSize(numSplats) {\\n    const width = SPLAT_TEX_WIDTH;\\n    const \
height = Math.max(\\n      SPLAT_TEX_MIN_HEIGHT,\\n      \
Math.min(SPLAT_TEX_HEIGHT, Math.ceil(numSplats / width))\\n    );\\n    const \
depth = Math.ceil(numSplats / (width * height));\\n    const maxSplats = \
width * height * depth;\\n    return { width, height, depth, maxSplats };\\n  \
}\\n  function computeMaxSplats(numSplats) {\\n    const width = \
SPLAT_TEX_WIDTH;\\n    const height = Math.max(\\n      \
SPLAT_TEX_MIN_HEIGHT,\\n      Math.min(SPLAT_TEX_HEIGHT, Math.ceil(numSplats \
/ width))\\n    );\\n    const depth = Math.ceil(numSplats / (width * \
height));\\n    return width * height * depth;\\n  }\\n  unindent(`\\n  \
precision highp float;\\n\\n  in vec3 position;\\n\\n  void main() {\\n    \
gl_Position = vec4(position.xy, 0.0, 1.0);\\n  }\\n`);\\n  const \
tempNormalizedQuaternion = new Quaternion();\\n  const tempAxis = new \
Vector3();\\n  function encodeQuatOctXy88R8(q) {\\n    const qnorm = \
tempNormalizedQuaternion.copy(q).normalize();\\n    if (qnorm.w < 0) {\\n     \
 qnorm.set(-qnorm.x, -qnorm.y, -qnorm.z, -qnorm.w);\\n    }\\n    const theta \
= 2 * Math.acos(qnorm.w);\\n    const xyz_norm = Math.sqrt(\\n      qnorm.x * \
qnorm.x + qnorm.y * qnorm.y + qnorm.z * qnorm.z\\n    );\\n    const axis = \
xyz_norm < 1e-6 ? tempAxis.set(1, 0, 0) : tempAxis.set(qnorm.x, qnorm.y, \
qnorm.z).divideScalar(xyz_norm);\\n    const sum = Math.abs(axis.x) + \
Math.abs(axis.y) + Math.abs(axis.z);\\n    let p_x = axis.x / sum;\\n    let \
p_y = axis.y / sum;\\n    if (axis.z < 0) {\\n      const tmp = p_x;\\n      \
p_x = (1 - Math.abs(p_y)) * (p_x >= 0 ? 1 : -1);\\n      p_y = (1 - \
Math.abs(tmp)) * (p_y >= 0 ? 1 : -1);\\n    }\\n    const u_f = p_x * 0.5 + \
0.5;\\n    const v_f = p_y * 0.5 + 0.5;\\n    const quantU = Math.round(u_f * \
255);\\n    const quantV = Math.round(v_f * 255);\\n    const angleInt = \
Math.round(theta * (255 / Math.PI));\\n    return angleInt << 16 | quantV << \
8 | quantU;\\n  }\\n  function packSint8Bytes(b0, b1, b22, b3) {\\n    const \
clampedB0 = Math.max(-127, Math.min(127, b0 * 127));\\n    const clampedB1 = \
Math.max(-127, Math.min(127, b1 * 127));\\n    const clampedB2 = \
Math.max(-127, Math.min(127, b22 * 127));\\n    const clampedB3 = \
Math.max(-127, Math.min(127, b3 * 127));\\n    return clampedB0 & 255 | \
(clampedB1 & 255) << 8 | (clampedB2 & 255) << 16 | (clampedB3 & 255) << \
24;\\n  }\\n  function encodeSh1Rgb(sh1Array, index, sh1Rgb, encoding) {\\n   \
 const sh1Min = (encoding == null ? void 0 : encoding.sh1Min) ?? -1;\\n    \
const sh1Max = (encoding == null ? void 0 : encoding.sh1Max) ?? 1;\\n    \
const sh1Mid = 0.5 * (sh1Min + sh1Max);\\n    const sh1Scale = 126 / (sh1Max \
- sh1Min);\\n    const base = index * 2;\\n    for (let i2 = 0; i2 < 9; ++i2) \
{\\n      const s = (sh1Rgb[i2] - sh1Mid) * sh1Scale;\\n      const value = \
Math.round(Math.max(-63, Math.min(63, s))) & 127;\\n      const bitStart = i2 \
* 7;\\n      const bitEnd = bitStart + 7;\\n      const wordStart = \
Math.floor(bitStart / 32);\\n      const bitOffset = bitStart - wordStart * \
32;\\n      const firstWord = value << bitOffset & 4294967295;\\n      \
sh1Array[base + wordStart] |= firstWord;\\n      if (bitEnd > wordStart * 32 \
+ 32) {\\n        const secondWord = value >>> 32 - bitOffset & \
4294967295;\\n        sh1Array[base + wordStart + 1] |= secondWord;\\n      \
}\\n    }\\n  }\\n  function encodeSh2Rgb(sh2Array, index, sh2Rgb, encoding) \
{\\n    const sh2Min = (encoding == null ? void 0 : encoding.sh2Min) ?? \
-1;\\n    const sh2Max = (encoding == null ? void 0 : encoding.sh2Max) ?? \
1;\\n    const sh2Mid = 0.5 * (sh2Min + sh2Max);\\n    const sh2Scale = 2 / \
(sh2Max - sh2Min);\\n    sh2Array[index * 4 + 0] = packSint8Bytes(\\n      \
(sh2Rgb[0] - sh2Mid) * sh2Scale,\\n      (sh2Rgb[1] - sh2Mid) * sh2Scale,\\n  \
    (sh2Rgb[2] - sh2Mid) * sh2Scale,\\n      (sh2Rgb[3] - sh2Mid) * \
sh2Scale\\n    );\\n    sh2Array[index * 4 + 1] = packSint8Bytes(\\n      \
(sh2Rgb[4] - sh2Mid) * sh2Scale,\\n      (sh2Rgb[5] - sh2Mid) * sh2Scale,\\n  \
    (sh2Rgb[6] - sh2Mid) * sh2Scale,\\n      (sh2Rgb[7] - sh2Mid) * \
sh2Scale\\n    );\\n    sh2Array[index * 4 + 2] = packSint8Bytes(\\n      \
(sh2Rgb[8] - sh2Mid) * sh2Scale,\\n      (sh2Rgb[9] - sh2Mid) * sh2Scale,\\n  \
    (sh2Rgb[10] - sh2Mid) * sh2Scale,\\n      (sh2Rgb[11] - sh2Mid) * \
sh2Scale\\n    );\\n    sh2Array[index * 4 + 3] = packSint8Bytes(\\n      \
(sh2Rgb[12] - sh2Mid) * sh2Scale,\\n      (sh2Rgb[13] - sh2Mid) * \
sh2Scale,\\n      (sh2Rgb[14] - sh2Mid) * sh2Scale,\\n      0\\n    );\\n  \
}\\n  function encodeSh3Rgb(sh3Array, index, sh3Rgb, encoding) {\\n    const \
sh3Min = (encoding == null ? void 0 : encoding.sh3Min) ?? -1;\\n    const \
sh3Max = (encoding == null ? void 0 : encoding.sh3Max) ?? 1;\\n    const \
sh3Mid = 0.5 * (sh3Min + sh3Max);\\n    const sh3Scale = 62 / (sh3Max - \
sh3Min);\\n    const base = index * 4;\\n    for (let i2 = 0; i2 < 21; ++i2) \
{\\n      const s = (sh3Rgb[i2] - sh3Mid) * sh3Scale;\\n      const value = \
Math.round(Math.max(-31, Math.min(31, s))) & 63;\\n      const bitStart = i2 \
* 6;\\n      const bitEnd = bitStart + 6;\\n      const wordStart = \
Math.floor(bitStart / 32);\\n      const bitOffset = bitStart - wordStart * \
32;\\n      const firstWord = value << bitOffset & 4294967295;\\n      \
sh3Array[base + wordStart] |= firstWord;\\n      if (bitEnd > wordStart * 32 \
+ 32) {\\n        const secondWord = value >>> 32 - bitOffset & \
4294967295;\\n        sh3Array[base + wordStart + 1] |= secondWord;\\n      \
}\\n    }\\n  }\\n  function decompressPartialGzip(fileBytes, numBytes) {\\n  \
  const chunks = [];\\n    let totalBytes = 0;\\n    let result = null;\\n    \
const gunzip = new Gunzip((data, final) => {\\n      chunks.push(data);\\n    \
  totalBytes += data.length;\\n      if (final || totalBytes >= numBytes) \
{\\n        const allBytes = new Uint8Array(totalBytes);\\n        let \
offset2 = 0;\\n        for (const chunk of chunks) {\\n          \
allBytes.set(chunk, offset2);\\n          offset2 += chunk.length;\\n        \
}\\n        result = allBytes.slice(0, numBytes);\\n      }\\n    });\\n    \
const CHUNK_SIZE = 1024;\\n    let offset = 0;\\n    while (result == null && \
offset < fileBytes.length) {\\n      const chunk = fileBytes.slice(offset, \
offset + CHUNK_SIZE);\\n      gunzip.push(chunk, false);\\n      offset += \
CHUNK_SIZE;\\n    }\\n    if (result == null) {\\n      gunzip.push(new \
Uint8Array(), true);\\n      if (result == null) {\\n        throw new \
Error(\"Failed to decompress partial gzip\");\\n      }\\n    }\\n    return \
result;\\n  }\\n  class GunzipReader {\\n    constructor({\\n      \
fileBytes,\\n      chunkBytes = 64 * 1024\\n    }) {\\n      this.fileBytes = \
fileBytes;\\n      this.chunkBytes = chunkBytes;\\n      this.chunks = [];\\n \
     this.totalBytes = 0;\\n      const ds = new \
DecompressionStream(\"gzip\");\\n      const decompressionStream = new \
Blob([fileBytes]).stream().pipeThrough(ds);\\n      this.reader = \
decompressionStream.getReader();\\n    }\\n    async read(numBytes) {\\n      \
while (this.totalBytes < numBytes) {\\n        const { value: chunk, done: \
readerDone } = await this.reader.read();\\n        if (readerDone) {\\n       \
   break;\\n        }\\n        this.chunks.push(chunk);\\n        \
this.totalBytes += chunk.length;\\n      }\\n      if (this.totalBytes < \
numBytes) {\\n        throw new Error(\\n          `Unexpected EOF: needed \
${numBytes}, got ${this.totalBytes}`\\n        );\\n      }\\n      const \
allBytes = new Uint8Array(this.totalBytes);\\n      let outOffset = 0;\\n     \
 for (const chunk of this.chunks) {\\n        allBytes.set(chunk, \
outOffset);\\n        outOffset += chunk.length;\\n      }\\n      const \
result = allBytes.subarray(0, numBytes);\\n      this.chunks = \
[allBytes.subarray(numBytes)];\\n      this.totalBytes -= numBytes;\\n      \
return result;\\n    }\\n  }\\n  function decodeAntiSplat(fileBytes, \
initNumSplats, splatCallback) {\\n    const numSplats = \
Math.floor(fileBytes.length / 32);\\n    if (numSplats * 32 !== \
fileBytes.length) {\\n      throw new Error(\"Invalid .splat file size\");\\n \
   }\\n    initNumSplats(numSplats);\\n    const f32 = new \
Float32Array(fileBytes.buffer);\\n    for (let i2 = 0; i2 < numSplats; ++i2) \
{\\n      const i322 = i2 * 32;\\n      const i8 = i2 * 8;\\n      const x2 = \
f32[i8 + 0];\\n      const y = f32[i8 + 1];\\n      const z = f32[i8 + 2];\\n \
     const scaleX = f32[i8 + 3];\\n      const scaleY = f32[i8 + 4];\\n      \
const scaleZ = f32[i8 + 5];\\n      const r = fileBytes[i322 + 24] / 255;\\n  \
    const g = fileBytes[i322 + 25] / 255;\\n      const b = fileBytes[i322 + \
26] / 255;\\n      const opacity = fileBytes[i322 + 27] / 255;\\n      const \
quatW = (fileBytes[i322 + 28] - 128) / 128;\\n      const quatX = \
(fileBytes[i322 + 29] - 128) / 128;\\n      const quatY = (fileBytes[i322 + \
30] - 128) / 128;\\n      const quatZ = (fileBytes[i322 + 31] - 128) / \
128;\\n      splatCallback(\\n        i2,\\n        x2,\\n        y,\\n       \
 z,\\n        scaleX,\\n        scaleY,\\n        scaleZ,\\n        quatX,\\n \
       quatY,\\n        quatZ,\\n        quatW,\\n        opacity,\\n        \
r,\\n        g,\\n        b\\n      );\\n    }\\n  }\\n  function \
unpackAntiSplat(fileBytes, splatEncoding) {\\n    let numSplats = 0;\\n    \
let maxSplats = 0;\\n    let packedArray = new Uint32Array(0);\\n    \
decodeAntiSplat(\\n      fileBytes,\\n      (cbNumSplats) => {\\n        \
numSplats = cbNumSplats;\\n        maxSplats = \
computeMaxSplats(numSplats);\\n        packedArray = new \
Uint32Array(maxSplats * 4);\\n      },\\n      (index, x2, y, z, scaleX, \
scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\\n        \
setPackedSplat(\\n          packedArray,\\n          index,\\n          \
x2,\\n          y,\\n          z,\\n          scaleX,\\n          scaleY,\\n  \
        scaleZ,\\n          quatX,\\n          quatY,\\n          quatZ,\\n   \
       quatW,\\n          opacity,\\n          r,\\n          g,\\n          \
b,\\n          splatEncoding\\n        );\\n      }\\n    );\\n    return { \
packedArray, numSplats };\\n  }\\n  const KSPLAT_COMPRESSION = {\\n    0: \
{\\n      bytesPerCenter: 12,\\n      bytesPerScale: 12,\\n      \
bytesPerRotation: 16,\\n      bytesPerColor: 4,\\n      \
bytesPerSphericalHarmonicsComponent: 4,\\n      scaleOffsetBytes: 12,\\n      \
rotationOffsetBytes: 24,\\n      colorOffsetBytes: 40,\\n      \
sphericalHarmonicsOffsetBytes: 44,\\n      scaleRange: 1\\n    },\\n    1: \
{\\n      bytesPerCenter: 6,\\n      bytesPerScale: 6,\\n      \
bytesPerRotation: 8,\\n      bytesPerColor: 4,\\n      \
bytesPerSphericalHarmonicsComponent: 2,\\n      scaleOffsetBytes: 6,\\n      \
rotationOffsetBytes: 12,\\n      colorOffsetBytes: 20,\\n      \
sphericalHarmonicsOffsetBytes: 24,\\n      scaleRange: 32767\\n    },\\n    \
2: {\\n      bytesPerCenter: 6,\\n      bytesPerScale: 6,\\n      \
bytesPerRotation: 8,\\n      bytesPerColor: 4,\\n      \
bytesPerSphericalHarmonicsComponent: 1,\\n      scaleOffsetBytes: 6,\\n      \
rotationOffsetBytes: 12,\\n      colorOffsetBytes: 20,\\n      \
sphericalHarmonicsOffsetBytes: 24,\\n      scaleRange: 32767\\n    }\\n  \
};\\n  const KSPLAT_SH_DEGREE_TO_COMPONENTS = {\\n    0: 0,\\n    1: 9,\\n    \
2: 24,\\n    3: 45\\n  };\\n  function decodeKsplat(fileBytes, initNumSplats, \
splatCallback, shCallback) {\\n    var _a2;\\n    const HEADER_BYTES = \
4096;\\n    const SECTION_BYTES = 1024;\\n    let headerOffset = 0;\\n    \
const header = new DataView(fileBytes.buffer, headerOffset, HEADER_BYTES);\\n \
   headerOffset += HEADER_BYTES;\\n    const versionMajor = \
header.getUint8(0);\\n    const versionMinor = header.getUint8(1);\\n    if \
(versionMajor !== 0 || versionMinor < 1) {\\n      throw new Error(\\n        \
`Unsupported .ksplat version: ${versionMajor}.${versionMinor}`\\n      );\\n  \
  }\\n    const maxSectionCount = header.getUint32(4, true);\\n    \
header.getUint32(16, true);\\n    const compressionLevel = \
header.getUint16(20, true);\\n    if (compressionLevel < 0 || \
compressionLevel > 2) {\\n      throw new Error(`Invalid .ksplat compression \
level: ${compressionLevel}`);\\n    }\\n    const minSphericalHarmonicsCoeff \
= header.getFloat32(36, true) || -1.5;\\n    const maxSphericalHarmonicsCoeff \
= header.getFloat32(40, true) || 1.5;\\n    let sectionBase = HEADER_BYTES + \
maxSectionCount * SECTION_BYTES;\\n    for (let section = 0; section < \
maxSectionCount; ++section) {\\n      let getSh = function(splatOffset, \
component) {\\n        if (compressionLevel === 0) {\\n          return \
data.getFloat32(\\n            splatOffset + sphericalHarmonicsOffsetBytes + \
component * 4,\\n            true\\n          );\\n        }\\n        if \
(compressionLevel === 1) {\\n          return fromHalf(\\n            \
data.getUint16(\\n              splatOffset + sphericalHarmonicsOffsetBytes + \
component * 2,\\n              true\\n            )\\n          );\\n        \
}\\n        const t = data.getUint8(splatOffset + \
sphericalHarmonicsOffsetBytes + component) / 255;\\n        return \
minSphericalHarmonicsCoeff + t * (maxSphericalHarmonicsCoeff - \
minSphericalHarmonicsCoeff);\\n      };\\n      const section2 = new \
DataView(fileBytes.buffer, headerOffset, SECTION_BYTES);\\n      headerOffset \
+= SECTION_BYTES;\\n      const sectionSplatCount = section2.getUint32(0, \
true);\\n      const sectionMaxSplatCount = section2.getUint32(4, true);\\n   \
   const bucketSize = section2.getUint32(8, true);\\n      const bucketCount \
= section2.getUint32(12, true);\\n      const bucketBlockSize = \
section2.getFloat32(16, true);\\n      const bucketStorageSizeBytes = \
section2.getUint16(20, true);\\n      const compressionScaleRange = \
(section2.getUint32(24, true) || ((_a2 = \
KSPLAT_COMPRESSION[compressionLevel]) == null ? void 0 : _a2.scaleRange)) ?? \
1;\\n      const fullBucketCount = section2.getUint32(32, true);\\n      \
const fullBucketSplats = fullBucketCount * bucketSize;\\n      const \
partiallyFilledBucketCount = section2.getUint32(36, true);\\n      const \
bucketsMetaDataSizeBytes = partiallyFilledBucketCount * 4;\\n      const \
bucketsStorageSizeBytes = bucketStorageSizeBytes * bucketCount + \
bucketsMetaDataSizeBytes;\\n      const sphericalHarmonicsDegree = \
section2.getUint16(40, true);\\n      const shComponents = \
KSPLAT_SH_DEGREE_TO_COMPONENTS[sphericalHarmonicsDegree];\\n      const {\\n  \
      bytesPerCenter,\\n        bytesPerScale,\\n        bytesPerRotation,\\n \
       bytesPerColor,\\n        bytesPerSphericalHarmonicsComponent,\\n       \
 scaleOffsetBytes,\\n        rotationOffsetBytes,\\n        \
colorOffsetBytes,\\n        sphericalHarmonicsOffsetBytes\\n      } = \
KSPLAT_COMPRESSION[compressionLevel];\\n      const bytesPerSplat = \
bytesPerCenter + bytesPerScale + bytesPerRotation + bytesPerColor + \
shComponents * bytesPerSphericalHarmonicsComponent;\\n      const \
splatDataStorageSizeBytes = bytesPerSplat * sectionMaxSplatCount;\\n      \
const storageSizeBytes = splatDataStorageSizeBytes + \
bucketsStorageSizeBytes;\\n      const sh1Index = [0, 3, 6, 1, 4, 7, 2, 5, \
8];\\n      const sh2Index = [\\n        9,\\n        14,\\n        19,\\n    \
    10,\\n        15,\\n        20,\\n        11,\\n        16,\\n        \
21,\\n        12,\\n        17,\\n        22,\\n        13,\\n        18,\\n  \
      23\\n      ];\\n      const sh3Index = [\\n        24,\\n        31,\\n \
       38,\\n        25,\\n        32,\\n        39,\\n        26,\\n        \
33,\\n        40,\\n        27,\\n        34,\\n        41,\\n        28,\\n  \
      35,\\n        42,\\n        29,\\n        36,\\n        43,\\n        \
30,\\n        37,\\n        44\\n      ];\\n      const sh1 = \
sphericalHarmonicsDegree >= 1 ? new Float32Array(3 * 3) : void 0;\\n      \
const sh2 = sphericalHarmonicsDegree >= 2 ? new Float32Array(5 * 3) : void \
0;\\n      const sh3 = sphericalHarmonicsDegree >= 3 ? new Float32Array(7 * \
3) : void 0;\\n      const compressionScaleFactor = bucketBlockSize / 2 / \
compressionScaleRange;\\n      const bucketsBase = sectionBase + \
bucketsMetaDataSizeBytes;\\n      const dataBase = sectionBase + \
bucketsStorageSizeBytes;\\n      const data = new DataView(\\n        \
fileBytes.buffer,\\n        dataBase,\\n        splatDataStorageSizeBytes\\n  \
    );\\n      const bucketArray = new Float32Array(\\n        \
fileBytes.buffer,\\n        bucketsBase,\\n        bucketCount * 3\\n      \
);\\n      const partiallyFilledBucketLengths = new Uint32Array(\\n        \
fileBytes.buffer,\\n        sectionBase,\\n        \
partiallyFilledBucketCount\\n      );\\n      let partialBucketIndex = \
fullBucketCount;\\n      let partialBucketBase = fullBucketSplats;\\n      \
for (let i2 = 0; i2 < sectionSplatCount; ++i2) {\\n        const splatOffset \
= i2 * bytesPerSplat;\\n        let bucketIndex;\\n        if (i2 < \
fullBucketSplats) {\\n          bucketIndex = Math.floor(i2 / bucketSize);\\n \
       } else {\\n          const bucketLength = \
partiallyFilledBucketLengths[partialBucketIndex - fullBucketCount];\\n        \
  if (i2 >= partialBucketBase + bucketLength) {\\n            \
partialBucketIndex += 1;\\n            partialBucketBase += bucketLength;\\n  \
        }\\n          bucketIndex = partialBucketIndex;\\n        }\\n        \
const x2 = compressionLevel === 0 ? data.getFloat32(splatOffset + 0, true) : \
(data.getUint16(splatOffset + 0, true) - compressionScaleRange) * \
compressionScaleFactor + bucketArray[3 * bucketIndex + 0];\\n        const y \
= compressionLevel === 0 ? data.getFloat32(splatOffset + 4, true) : \
(data.getUint16(splatOffset + 2, true) - compressionScaleRange) * \
compressionScaleFactor + bucketArray[3 * bucketIndex + 1];\\n        const z \
= compressionLevel === 0 ? data.getFloat32(splatOffset + 8, true) : \
(data.getUint16(splatOffset + 4, true) - compressionScaleRange) * \
compressionScaleFactor + bucketArray[3 * bucketIndex + 2];\\n        const \
scaleX = compressionLevel === 0 ? data.getFloat32(splatOffset + \
scaleOffsetBytes + 0, true) : fromHalf(data.getUint16(splatOffset + \
scaleOffsetBytes + 0, true));\\n        const scaleY = compressionLevel === 0 \
? data.getFloat32(splatOffset + scaleOffsetBytes + 4, true) : \
fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 2, true));\\n        \
const scaleZ = compressionLevel === 0 ? data.getFloat32(splatOffset + \
scaleOffsetBytes + 8, true) : fromHalf(data.getUint16(splatOffset + \
scaleOffsetBytes + 4, true));\\n        const quatW = compressionLevel === 0 \
? data.getFloat32(splatOffset + rotationOffsetBytes + 0, true) : fromHalf(\\n \
         data.getUint16(splatOffset + rotationOffsetBytes + 0, true)\\n       \
 );\\n        const quatX = compressionLevel === 0 ? \
data.getFloat32(splatOffset + rotationOffsetBytes + 4, true) : fromHalf(\\n   \
       data.getUint16(splatOffset + rotationOffsetBytes + 2, true)\\n        \
);\\n        const quatY = compressionLevel === 0 ? \
data.getFloat32(splatOffset + rotationOffsetBytes + 8, true) : fromHalf(\\n   \
       data.getUint16(splatOffset + rotationOffsetBytes + 4, true)\\n        \
);\\n        const quatZ = compressionLevel === 0 ? \
data.getFloat32(splatOffset + rotationOffsetBytes + 12, true) : fromHalf(\\n  \
        data.getUint16(splatOffset + rotationOffsetBytes + 6, true)\\n        \
);\\n        const r = data.getUint8(splatOffset + colorOffsetBytes + 0) / \
255;\\n        const g = data.getUint8(splatOffset + colorOffsetBytes + 1) / \
255;\\n        const b = data.getUint8(splatOffset + colorOffsetBytes + 2) / \
255;\\n        const opacity = data.getUint8(splatOffset + colorOffsetBytes + \
3) / 255;\\n        splatCallback(\\n          i2,\\n          x2,\\n         \
 y,\\n          z,\\n          scaleX,\\n          scaleY,\\n          \
scaleZ,\\n          quatX,\\n          quatY,\\n          quatZ,\\n          \
quatW,\\n          opacity,\\n          r,\\n          g,\\n          b\\n    \
    );\\n        if (sphericalHarmonicsDegree >= 1 && sh1) {\\n          for \
(const [i22, key] of sh1Index.entries()) {\\n            sh1[i22] = \
getSh(splatOffset, key);\\n          }\\n          if (sh2) {\\n            \
for (const [i22, key] of sh2Index.entries()) {\\n              sh2[i22] = \
getSh(splatOffset, key);\\n            }\\n          }\\n          if (sh3) \
{\\n            for (const [i22, key] of sh3Index.entries()) {\\n             \
 sh3[i22] = getSh(splatOffset, key);\\n            }\\n          }\\n         \
 shCallback == null ? void 0 : shCallback(i2, sh1, sh2, sh3);\\n        }\\n  \
    }\\n      sectionBase += storageSizeBytes;\\n    }\\n  }\\n  function \
unpackKsplat(fileBytes, splatEncoding) {\\n    var _a2;\\n    const \
HEADER_BYTES = 4096;\\n    const SECTION_BYTES = 1024;\\n    let headerOffset \
= 0;\\n    const header = new DataView(fileBytes.buffer, headerOffset, \
HEADER_BYTES);\\n    headerOffset += HEADER_BYTES;\\n    const versionMajor = \
header.getUint8(0);\\n    const versionMinor = header.getUint8(1);\\n    if \
(versionMajor !== 0 || versionMinor < 1) {\\n      throw new Error(\\n        \
`Unsupported .ksplat version: ${versionMajor}.${versionMinor}`\\n      );\\n  \
  }\\n    const maxSectionCount = header.getUint32(4, true);\\n    const \
splatCount = header.getUint32(16, true);\\n    const compressionLevel = \
header.getUint16(20, true);\\n    if (compressionLevel < 0 || \
compressionLevel > 2) {\\n      throw new Error(`Invalid .ksplat compression \
level: ${compressionLevel}`);\\n    }\\n    const minSphericalHarmonicsCoeff \
= header.getFloat32(36, true) || -1.5;\\n    const maxSphericalHarmonicsCoeff \
= header.getFloat32(40, true) || 1.5;\\n    const numSplats = splatCount;\\n  \
  const maxSplats = computeMaxSplats(numSplats);\\n    const packedArray = \
new Uint32Array(maxSplats * 4);\\n    const extra = {};\\n    let sectionBase \
= HEADER_BYTES + maxSectionCount * SECTION_BYTES;\\n    for (let section = 0; \
section < maxSectionCount; ++section) {\\n      let getSh = \
function(splatOffset, component) {\\n        if (compressionLevel === 0) {\\n \
         return data.getFloat32(\\n            splatOffset + \
sphericalHarmonicsOffsetBytes + component * 4,\\n            true\\n          \
);\\n        }\\n        if (compressionLevel === 1) {\\n          return \
fromHalf(\\n            data.getUint16(\\n              splatOffset + \
sphericalHarmonicsOffsetBytes + component * 2,\\n              true\\n        \
    )\\n          );\\n        }\\n        const t = \
data.getUint8(splatOffset + sphericalHarmonicsOffsetBytes + component) / \
255;\\n        return minSphericalHarmonicsCoeff + t * \
(maxSphericalHarmonicsCoeff - minSphericalHarmonicsCoeff);\\n      };\\n      \
const section2 = new DataView(fileBytes.buffer, headerOffset, \
SECTION_BYTES);\\n      headerOffset += SECTION_BYTES;\\n      const \
sectionSplatCount = section2.getUint32(0, true);\\n      const \
sectionMaxSplatCount = section2.getUint32(4, true);\\n      const bucketSize \
= section2.getUint32(8, true);\\n      const bucketCount = \
section2.getUint32(12, true);\\n      const bucketBlockSize = \
section2.getFloat32(16, true);\\n      const bucketStorageSizeBytes = \
section2.getUint16(20, true);\\n      const compressionScaleRange = \
(section2.getUint32(24, true) || ((_a2 = \
KSPLAT_COMPRESSION[compressionLevel]) == null ? void 0 : _a2.scaleRange)) ?? \
1;\\n      const fullBucketCount = section2.getUint32(32, true);\\n      \
const fullBucketSplats = fullBucketCount * bucketSize;\\n      const \
partiallyFilledBucketCount = section2.getUint32(36, true);\\n      const \
bucketsMetaDataSizeBytes = partiallyFilledBucketCount * 4;\\n      const \
bucketsStorageSizeBytes = bucketStorageSizeBytes * bucketCount + \
bucketsMetaDataSizeBytes;\\n      const sphericalHarmonicsDegree = \
section2.getUint16(40, true);\\n      const shComponents = \
KSPLAT_SH_DEGREE_TO_COMPONENTS[sphericalHarmonicsDegree];\\n      const {\\n  \
      bytesPerCenter,\\n        bytesPerScale,\\n        bytesPerRotation,\\n \
       bytesPerColor,\\n        bytesPerSphericalHarmonicsComponent,\\n       \
 scaleOffsetBytes,\\n        rotationOffsetBytes,\\n        \
colorOffsetBytes,\\n        sphericalHarmonicsOffsetBytes\\n      } = \
KSPLAT_COMPRESSION[compressionLevel];\\n      const bytesPerSplat = \
bytesPerCenter + bytesPerScale + bytesPerRotation + bytesPerColor + \
shComponents * bytesPerSphericalHarmonicsComponent;\\n      const \
splatDataStorageSizeBytes = bytesPerSplat * sectionMaxSplatCount;\\n      \
const storageSizeBytes = splatDataStorageSizeBytes + \
bucketsStorageSizeBytes;\\n      const sh1Index = [0, 3, 6, 1, 4, 7, 2, 5, \
8];\\n      const sh2Index = [\\n        9,\\n        14,\\n        19,\\n    \
    10,\\n        15,\\n        20,\\n        11,\\n        16,\\n        \
21,\\n        12,\\n        17,\\n        22,\\n        13,\\n        18,\\n  \
      23\\n      ];\\n      const sh3Index = [\\n        24,\\n        31,\\n \
       38,\\n        25,\\n        32,\\n        39,\\n        26,\\n        \
33,\\n        40,\\n        27,\\n        34,\\n        41,\\n        28,\\n  \
      35,\\n        42,\\n        29,\\n        36,\\n        43,\\n        \
30,\\n        37,\\n        44\\n      ];\\n      const sh1 = \
sphericalHarmonicsDegree >= 1 ? new Float32Array(3 * 3) : void 0;\\n      \
const sh2 = sphericalHarmonicsDegree >= 2 ? new Float32Array(5 * 3) : void \
0;\\n      const sh3 = sphericalHarmonicsDegree >= 3 ? new Float32Array(7 * \
3) : void 0;\\n      const compressionScaleFactor = bucketBlockSize / 2 / \
compressionScaleRange;\\n      const bucketsBase = sectionBase + \
bucketsMetaDataSizeBytes;\\n      const dataBase = sectionBase + \
bucketsStorageSizeBytes;\\n      const data = new DataView(\\n        \
fileBytes.buffer,\\n        dataBase,\\n        splatDataStorageSizeBytes\\n  \
    );\\n      const bucketArray = new Float32Array(\\n        \
fileBytes.buffer,\\n        bucketsBase,\\n        bucketCount * 3\\n      \
);\\n      const partiallyFilledBucketLengths = new Uint32Array(\\n        \
fileBytes.buffer,\\n        sectionBase,\\n        \
partiallyFilledBucketCount\\n      );\\n      let partialBucketIndex = \
fullBucketCount;\\n      let partialBucketBase = fullBucketSplats;\\n      \
for (let i2 = 0; i2 < sectionSplatCount; ++i2) {\\n        const splatOffset \
= i2 * bytesPerSplat;\\n        let bucketIndex;\\n        if (i2 < \
fullBucketSplats) {\\n          bucketIndex = Math.floor(i2 / bucketSize);\\n \
       } else {\\n          const bucketLength = \
partiallyFilledBucketLengths[partialBucketIndex - fullBucketCount];\\n        \
  if (i2 >= partialBucketBase + bucketLength) {\\n            \
partialBucketIndex += 1;\\n            partialBucketBase += bucketLength;\\n  \
        }\\n          bucketIndex = partialBucketIndex;\\n        }\\n        \
const x2 = compressionLevel === 0 ? data.getFloat32(splatOffset + 0, true) : \
(data.getUint16(splatOffset + 0, true) - compressionScaleRange) * \
compressionScaleFactor + bucketArray[3 * bucketIndex + 0];\\n        const y \
= compressionLevel === 0 ? data.getFloat32(splatOffset + 4, true) : \
(data.getUint16(splatOffset + 2, true) - compressionScaleRange) * \
compressionScaleFactor + bucketArray[3 * bucketIndex + 1];\\n        const z \
= compressionLevel === 0 ? data.getFloat32(splatOffset + 8, true) : \
(data.getUint16(splatOffset + 4, true) - compressionScaleRange) * \
compressionScaleFactor + bucketArray[3 * bucketIndex + 2];\\n        const \
scaleX = compressionLevel === 0 ? data.getFloat32(splatOffset + \
scaleOffsetBytes + 0, true) : fromHalf(data.getUint16(splatOffset + \
scaleOffsetBytes + 0, true));\\n        const scaleY = compressionLevel === 0 \
? data.getFloat32(splatOffset + scaleOffsetBytes + 4, true) : \
fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 2, true));\\n        \
const scaleZ = compressionLevel === 0 ? data.getFloat32(splatOffset + \
scaleOffsetBytes + 8, true) : fromHalf(data.getUint16(splatOffset + \
scaleOffsetBytes + 4, true));\\n        const quatW = compressionLevel === 0 \
? data.getFloat32(splatOffset + rotationOffsetBytes + 0, true) : fromHalf(\\n \
         data.getUint16(splatOffset + rotationOffsetBytes + 0, true)\\n       \
 );\\n        const quatX = compressionLevel === 0 ? \
data.getFloat32(splatOffset + rotationOffsetBytes + 4, true) : fromHalf(\\n   \
       data.getUint16(splatOffset + rotationOffsetBytes + 2, true)\\n        \
);\\n        const quatY = compressionLevel === 0 ? \
data.getFloat32(splatOffset + rotationOffsetBytes + 8, true) : fromHalf(\\n   \
       data.getUint16(splatOffset + rotationOffsetBytes + 4, true)\\n        \
);\\n        const quatZ = compressionLevel === 0 ? \
data.getFloat32(splatOffset + rotationOffsetBytes + 12, true) : fromHalf(\\n  \
        data.getUint16(splatOffset + rotationOffsetBytes + 6, true)\\n        \
);\\n        const r = data.getUint8(splatOffset + colorOffsetBytes + 0) / \
255;\\n        const g = data.getUint8(splatOffset + colorOffsetBytes + 1) / \
255;\\n        const b = data.getUint8(splatOffset + colorOffsetBytes + 2) / \
255;\\n        const opacity = data.getUint8(splatOffset + colorOffsetBytes + \
3) / 255;\\n        setPackedSplat(\\n          packedArray,\\n          \
i2,\\n          x2,\\n          y,\\n          z,\\n          scaleX,\\n      \
    scaleY,\\n          scaleZ,\\n          quatX,\\n          quatY,\\n      \
    quatZ,\\n          quatW,\\n          opacity,\\n          r,\\n          \
g,\\n          b,\\n          splatEncoding\\n        );\\n        if \
(sphericalHarmonicsDegree >= 1) {\\n          if (sh1) {\\n            if \
(!extra.sh1) {\\n              extra.sh1 = new Uint32Array(numSplats * 2);\\n \
           }\\n            for (const [i22, key] of sh1Index.entries()) {\\n  \
            sh1[i22] = getSh(splatOffset, key);\\n            }\\n            \
encodeSh1Rgb(extra.sh1, i2, sh1, splatEncoding);\\n          }\\n          if \
(sh2) {\\n            if (!extra.sh2) {\\n              extra.sh2 = new \
Uint32Array(numSplats * 4);\\n            }\\n            for (const [i22, \
key] of sh2Index.entries()) {\\n              sh2[i22] = getSh(splatOffset, \
key);\\n            }\\n            encodeSh2Rgb(extra.sh2, i2, sh2, \
splatEncoding);\\n          }\\n          if (sh3) {\\n            if \
(!extra.sh3) {\\n              extra.sh3 = new Uint32Array(numSplats * 4);\\n \
           }\\n            for (const [i22, key] of sh3Index.entries()) {\\n  \
            sh3[i22] = getSh(splatOffset, key);\\n            }\\n            \
encodeSh3Rgb(extra.sh3, i2, sh3, splatEncoding);\\n          }\\n        }\\n \
     }\\n      sectionBase += storageSizeBytes;\\n    }\\n    return { \
packedArray, numSplats, extra };\\n  }\\n  const PLY_PROPERTY_TYPES = [\\n    \
\"char\",\\n    \"uchar\",\\n    \"short\",\\n    \"ushort\",\\n    \
\"int\",\\n    \"uint\",\\n    \"float\",\\n    \"double\"\\n  ];\\n  const \
_PlyReader = class _PlyReader {\\n    // Create a PlyReader from a \
Uint8Array/ArrayBuffer, no parsing done yet\\n    constructor({ fileBytes }) \
{\\n      this.header = \"\";\\n      this.littleEndian = true;\\n      \
this.elements = {};\\n      this.comments = [];\\n      this.data = null;\\n  \
    this.numSplats = 0;\\n      this.fileBytes = fileBytes instanceof \
ArrayBuffer ? new Uint8Array(fileBytes) : fileBytes;\\n    }\\n    // \
Identify and parse the PLY text header (assumed to be <64KB in size).\\n    \
// this.elements will contain all the elements in the file, typically\\n    \
// \"vertex\" contains the Gsplat data.\\n    async parseHeader() {\\n      \
const bufferStream = new ReadableStream({\\n        start: (controller) => \
{\\n          controller.enqueue(this.fileBytes.slice(0, 65536));\\n          \
controller.close();\\n        }\\n      });\\n      const decoder = \
bufferStream.pipeThrough(new TextDecoderStream()).getReader();\\n      \
this.header = \"\";\\n      const headerTerminator = \"end_header\\\\n\";\\n  \
    while (true) {\\n        const { value, done } = await decoder.read();\\n \
       if (done) {\\n          throw new Error(\"Failed to read header\");\\n \
       }\\n        this.header += value;\\n        const endHeader = \
this.header.indexOf(headerTerminator);\\n        if (endHeader >= 0) {\\n     \
     this.header = this.header.slice(0, endHeader + \
headerTerminator.length);\\n          break;\\n        }\\n      }\\n      \
const headerLen = new TextEncoder().encode(this.header).length;\\n      \
this.data = new DataView(this.fileBytes.buffer, headerLen);\\n      \
this.elements = {};\\n      let curElement = null;\\n      this.comments = \
[];\\n      this.header.trim().split(\"\\\\n\").forEach((line, lineIndex) => \
{\\n        const trimmedLine = line.trim();\\n        if (lineIndex === 0) \
{\\n          if (trimmedLine !== \"ply\") {\\n            throw new \
Error(\"Invalid PLY header\");\\n          }\\n          return;\\n        \
}\\n        if (trimmedLine.length === 0) {\\n          return;\\n        \
}\\n        const fields = trimmedLine.split(\" \");\\n        switch \
(fields[0]) {\\n          case \"format\":\\n            if (fields[1] === \
\"binary_little_endian\") {\\n              this.littleEndian = true;\\n      \
      } else if (fields[1] === \"binary_big_endian\") {\\n              \
this.littleEndian = false;\\n            } else {\\n              throw new \
Error(`Unsupported PLY format: ${fields[1]}`);\\n            }\\n            \
if (fields[2] !== \"1.0\") {\\n              throw new Error(`Unsupported PLY \
version: ${fields[2]}`);\\n            }\\n            break;\\n          \
case \"end_header\":\\n            break;\\n          case \"comment\":\\n    \
        this.comments.push(trimmedLine.slice(\"comment \".length));\\n        \
    break;\\n          case \"element\": {\\n            const name = \
fields[1];\\n            curElement = {\\n              name,\\n              \
count: Number.parseInt(fields[2]),\\n              properties: {}\\n          \
  };\\n            this.elements[name] = curElement;\\n            break;\\n  \
        }\\n          case \"property\":\\n            if (curElement == \
null) {\\n              throw new Error(\"Property must be inside an \
element\");\\n            }\\n            if (fields[1] === \"list\") {\\n    \
          curElement.properties[fields[4]] = {\\n                isList: \
true,\\n                type: fields[3],\\n                countType: \
fields[2]\\n              };\\n            } else {\\n              \
curElement.properties[fields[2]] = {\\n                isList: false,\\n      \
          type: fields[1]\\n              };\\n            }\\n            \
break;\\n        }\\n      });\\n      if (this.elements.vertex) {\\n        \
this.numSplats = this.elements.vertex.count;\\n      }\\n    }\\n    \
parseData(elementCallback) {\\n      let offset = 0;\\n      const data = \
this.data;\\n      if (data == null) {\\n        throw new Error(\"No data to \
parse\");\\n      }\\n      for (const elementName in this.elements) {\\n     \
   const element = this.elements[elementName];\\n        const { count, \
properties } = element;\\n        const item = \
createEmptyItem(properties);\\n        const parseFn = \
createParseFn(properties, this.littleEndian);\\n        const callback = \
elementCallback(element) ?? (() => {\\n        });\\n        for (let index = \
0; index < count; index++) {\\n          offset = parseFn(data, offset, \
item);\\n          callback(index, item);\\n        }\\n      }\\n    }\\n    \
// Parse all the Gsplat data in the PLY file in go, invoking the given\\n    \
// callbacks for each Gsplat.\\n    parseSplats(splatCallback, shCallback) \
{\\n      if (this.elements.vertex == null) {\\n        throw new Error(\"No \
vertex element found\");\\n      }\\n      let isSuperSplat = false;\\n      \
const ssChunks = [];\\n      let numSh = 0;\\n      let sh1Props = [];\\n     \
 let sh2Props = [];\\n      let sh3Props = [];\\n      let sh1 = void 0;\\n   \
   let sh2 = void 0;\\n      let sh3 = void 0;\\n      function prepareSh() \
{\\n        const num_f_rest = NUM_SH_TO_NUM_F_REST[numSh];\\n        \
sh1Props = new Array(3).fill(null).flatMap((_, k) => [0, 1, 2].map((_2, d) => \
k + d * num_f_rest / 3));\\n        sh2Props = new \
Array(5).fill(null).flatMap(\\n          (_, k) => [0, 1, 2].map((_2, d) => 3 \
+ k + d * num_f_rest / 3)\\n        );\\n        sh3Props = new \
Array(7).fill(null).flatMap(\\n          (_, k) => [0, 1, 2].map((_2, d) => 8 \
+ k + d * num_f_rest / 3)\\n        );\\n        sh1 = numSh >= 1 ? new \
Float32Array(3 * 3) : void 0;\\n        sh2 = numSh >= 2 ? new Float32Array(5 \
* 3) : void 0;\\n        sh3 = numSh >= 3 ? new Float32Array(7 * 3) : void \
0;\\n      }\\n      function ssShCallback(index, item) {\\n        if (!sh1) \
{\\n          throw new Error(\"Missing sh1\");\\n        }\\n        const \
sh = item.f_rest;\\n        for (let i2 = 0; i2 < sh1Props.length; i2++) {\\n \
         sh1[i2] = sh[sh1Props[i2]] * 8 / 255 - 4;\\n        }\\n        if \
(sh2) {\\n          for (let i2 = 0; i2 < sh2Props.length; i2++) {\\n         \
   sh2[i2] = sh[sh2Props[i2]] * 8 / 255 - 4;\\n          }\\n        }\\n     \
   if (sh3) {\\n          for (let i2 = 0; i2 < sh3Props.length; i2++) {\\n   \
         sh3[i2] = sh[sh3Props[i2]] * 8 / 255 - 4;\\n          }\\n        \
}\\n        shCallback == null ? void 0 : shCallback(index, sh1, sh2, \
sh3);\\n      }\\n      function initSuperSplat(element) {\\n        const \
{\\n          min_x,\\n          min_y,\\n          min_z,\\n          \
max_x,\\n          max_y,\\n          max_z,\\n          min_scale_x,\\n      \
    min_scale_y,\\n          min_scale_z,\\n          max_scale_x,\\n         \
 max_scale_y,\\n          max_scale_z\\n        } = element.properties;\\n    \
    if (!min_x || !min_y || !min_z || !max_x || !max_y || !max_z || \
!min_scale_x || !min_scale_y || !min_scale_z || !max_scale_x || !max_scale_y \
|| !max_scale_z) {\\n          throw new Error(\"Missing PLY chunk \
properties\");\\n        }\\n        isSuperSplat = true;\\n        return \
(index, item) => {\\n          const {\\n            min_x: min_x2,\\n        \
    min_y: min_y2,\\n            min_z: min_z2,\\n            max_x: \
max_x2,\\n            max_y: max_y2,\\n            max_z: max_z2,\\n          \
  min_scale_x: min_scale_x2,\\n            min_scale_y: min_scale_y2,\\n      \
      min_scale_z: min_scale_z2,\\n            max_scale_x: max_scale_x2,\\n  \
          max_scale_y: max_scale_y2,\\n            max_scale_z: \
max_scale_z2,\\n            min_r,\\n            min_g,\\n            \
min_b,\\n            max_r,\\n            max_g,\\n            max_b\\n       \
   } = item;\\n          ssChunks.push({\\n            min_x: min_x2,\\n      \
      min_y: min_y2,\\n            min_z: min_z2,\\n            max_x: \
max_x2,\\n            max_y: max_y2,\\n            max_z: max_z2,\\n          \
  min_scale_x: min_scale_x2,\\n            min_scale_y: min_scale_y2,\\n      \
      min_scale_z: min_scale_z2,\\n            max_scale_x: max_scale_x2,\\n  \
          max_scale_y: max_scale_y2,\\n            max_scale_z: \
max_scale_z2,\\n            min_r,\\n            min_g,\\n            \
min_b,\\n            max_r,\\n            max_g,\\n            max_b\\n       \
   });\\n        };\\n      }\\n      function decodeSuperSplat(element) {\\n \
       if (shCallback && element.name === \"sh\") {\\n          numSh = \
getNumSh(element.properties);\\n          prepareSh();\\n          return \
ssShCallback;\\n        }\\n        if (element.name !== \"vertex\") {\\n     \
     return null;\\n        }\\n        const { packed_position, \
packed_rotation, packed_scale, packed_color } = element.properties;\\n        \
if (!packed_position || !packed_rotation || !packed_scale || !packed_color) \
{\\n          throw new Error(\\n            \"Missing PLY properties: \
packed_position, packed_rotation, packed_scale, packed_color\"\\n          \
);\\n        }\\n        const SQRT2 = Math.sqrt(2);\\n        return (index, \
item) => {\\n          const chunk = ssChunks[index >>> 8];\\n          if \
(chunk == null) {\\n            throw new Error(\"Missing PLY chunk\");\\n    \
      }\\n          const {\\n            min_x,\\n            min_y,\\n      \
      min_z,\\n            max_x,\\n            max_y,\\n            \
max_z,\\n            min_scale_x,\\n            min_scale_y,\\n            \
min_scale_z,\\n            max_scale_x,\\n            max_scale_y,\\n         \
   max_scale_z,\\n            min_r,\\n            min_g,\\n            \
min_b,\\n            max_r,\\n            max_g,\\n            max_b\\n       \
   } = chunk;\\n          const { packed_position: packed_position2, \
packed_rotation: packed_rotation2, packed_scale: packed_scale2, packed_color: \
packed_color2 } = item;\\n          const x2 = (packed_position2 >>> 21 & \
2047) / 2047 * (max_x - min_x) + min_x;\\n          const y = \
(packed_position2 >>> 11 & 1023) / 1023 * (max_y - min_y) + min_y;\\n         \
 const z = (packed_position2 & 2047) / 2047 * (max_z - min_z) + min_z;\\n     \
     const r0 = ((packed_rotation2 >>> 20 & 1023) / 1023 - 0.5) * SQRT2;\\n   \
       const r1 = ((packed_rotation2 >>> 10 & 1023) / 1023 - 0.5) * SQRT2;\\n \
         const r2 = ((packed_rotation2 & 1023) / 1023 - 0.5) * SQRT2;\\n      \
    const rr = Math.sqrt(Math.max(0, 1 - r0 * r0 - r1 * r1 - r2 * r2));\\n    \
      const rOrder = packed_rotation2 >>> 30;\\n          const quatX = \
rOrder === 0 ? r0 : rOrder === 1 ? rr : r1;\\n          const quatY = rOrder \
<= 1 ? r1 : rOrder === 2 ? rr : r2;\\n          const quatZ = rOrder <= 2 ? \
r2 : rr;\\n          const quatW = rOrder === 0 ? rr : r0;\\n          const \
scaleX = Math.exp(\\n            (packed_scale2 >>> 21 & 2047) / 2047 * \
(max_scale_x - min_scale_x) + min_scale_x\\n          );\\n          const \
scaleY = Math.exp(\\n            (packed_scale2 >>> 11 & 1023) / 1023 * \
(max_scale_y - min_scale_y) + min_scale_y\\n          );\\n          const \
scaleZ = Math.exp(\\n            (packed_scale2 & 2047) / 2047 * (max_scale_z \
- min_scale_z) + min_scale_z\\n          );\\n          const r = \
(packed_color2 >>> 24 & 255) / 255 * ((max_r ?? 1) - (min_r ?? 0)) + (min_r \
?? 0);\\n          const g = (packed_color2 >>> 16 & 255) / 255 * ((max_g ?? \
1) - (min_g ?? 0)) + (min_g ?? 0);\\n          const b = (packed_color2 >>> 8 \
& 255) / 255 * ((max_b ?? 1) - (min_b ?? 0)) + (min_b ?? 0);\\n          \
const opacity = (packed_color2 & 255) / 255;\\n          splatCallback(\\n    \
        index,\\n            x2,\\n            y,\\n            z,\\n         \
   scaleX,\\n            scaleY,\\n            scaleZ,\\n            \
quatX,\\n            quatY,\\n            quatZ,\\n            quatW,\\n      \
      opacity,\\n            r,\\n            g,\\n            b\\n          \
);\\n        };\\n      }\\n      const elementCallback = (element) => {\\n   \
     if (element.name === \"chunk\") {\\n          return \
initSuperSplat(element);\\n        }\\n        if (isSuperSplat) {\\n         \
 return decodeSuperSplat(element);\\n        }\\n        if (element.name !== \
\"vertex\") {\\n          return null;\\n        }\\n        const {\\n       \
   x: x2,\\n          y,\\n          z,\\n          scale_0,\\n          \
scale_1,\\n          scale_2,\\n          rot_0,\\n          rot_1,\\n        \
  rot_2,\\n          rot_3,\\n          opacity,\\n          f_dc_0,\\n       \
   f_dc_1,\\n          f_dc_2,\\n          red,\\n          green,\\n         \
 blue,\\n          alpha\\n        } = element.properties;\\n        if (!x2 \
|| !y || !z) {\\n          throw new Error(\"Missing PLY properties: x, y, \
z\");\\n        }\\n        const hasScales = scale_0 && scale_1 && \
scale_2;\\n        const hasRots = rot_0 && rot_1 && rot_2 && rot_3;\\n       \
 const alphaDiv = alpha != null ? FIELD_SCALE[alpha.type] : 1;\\n        \
const redDiv = red != null ? FIELD_SCALE[red.type] : 1;\\n        const \
greenDiv = green != null ? FIELD_SCALE[green.type] : 1;\\n        const \
blueDiv = blue != null ? FIELD_SCALE[blue.type] : 1;\\n        numSh = \
getNumSh(element.properties);\\n        prepareSh();\\n        return (index, \
item) => {\\n          const scaleX = hasScales ? Math.exp(item.scale_0) : \
_PlyReader.defaultPointScale;\\n          const scaleY = hasScales ? \
Math.exp(item.scale_1) : _PlyReader.defaultPointScale;\\n          const \
scaleZ = hasScales ? Math.exp(item.scale_2) : \
_PlyReader.defaultPointScale;\\n          const quatX = hasRots ? item.rot_1 \
: 0;\\n          const quatY = hasRots ? item.rot_2 : 0;\\n          const \
quatZ = hasRots ? item.rot_3 : 0;\\n          const quatW = hasRots ? \
item.rot_0 : 1;\\n          const op = opacity != null ? 1 / (1 + \
Math.exp(-item.opacity)) : alpha != null ? item.alpha / alphaDiv : 1;\\n      \
    const r = f_dc_0 != null ? item.f_dc_0 * SH_C0$1 + 0.5 : red != null ? \
item.red / redDiv : 1;\\n          const g = f_dc_1 != null ? item.f_dc_1 * \
SH_C0$1 + 0.5 : green != null ? item.green / greenDiv : 1;\\n          const \
b = f_dc_2 != null ? item.f_dc_2 * SH_C0$1 + 0.5 : blue != null ? item.blue / \
blueDiv : 1;\\n          splatCallback(\\n            index,\\n            \
item.x,\\n            item.y,\\n            item.z,\\n            scaleX,\\n  \
          scaleY,\\n            scaleZ,\\n            quatX,\\n            \
quatY,\\n            quatZ,\\n            quatW,\\n            op,\\n         \
   r,\\n            g,\\n            b\\n          );\\n          if \
(shCallback && sh1) {\\n            const sh = item.f_rest;\\n            if \
(sh1) {\\n              for (let i2 = 0; i2 < sh1Props.length; i2++) {\\n     \
           sh1[i2] = sh[sh1Props[i2]];\\n              }\\n            }\\n   \
         if (sh2) {\\n              for (let i2 = 0; i2 < sh2Props.length; \
i2++) {\\n                sh2[i2] = sh[sh2Props[i2]];\\n              }\\n    \
        }\\n            if (sh3) {\\n              for (let i2 = 0; i2 < \
sh3Props.length; i2++) {\\n                sh3[i2] = sh[sh3Props[i2]];\\n     \
         }\\n            }\\n            shCallback(index, sh1, sh2, sh3);\\n \
         }\\n        };\\n      };\\n      \
this.parseData(elementCallback);\\n    }\\n    // Inject RGBA values into \
original PLY file, which can be used to modify\\n    // the color/opacity of \
the Gsplats and write out the modified PLY file.\\n    injectRgba(rgba) {\\n  \
    let offset = 0;\\n      const data = this.data;\\n      if (data == null) \
{\\n        throw new Error(\"No parsed data\");\\n      }\\n      if \
(rgba.length !== this.numSplats * 4) {\\n        throw new Error(\"Invalid \
RGBA array length\");\\n      }\\n      for (const elementName in \
this.elements) {\\n        const element = this.elements[elementName];\\n     \
   const { count, properties } = element;\\n        const parsers = [];\\n    \
    let rgbaOffset = 0;\\n        const isVertex = elementName === \
\"vertex\";\\n        if (isVertex) {\\n          for (const name of \
[\"opacity\", \"f_dc_0\", \"f_dc_1\", \"f_dc_2\"]) {\\n            if \
(!properties[name] || properties[name].type !== \"float\") {\\n              \
throw new Error(`Can\\'t injectRgba due to property: ${name}`);\\n            \
}\\n          }\\n        }\\n        for (const [propertyName, property] of \
Object.entries(properties)) {\\n          if (!property.isList) {\\n          \
  if (isVertex) {\\n              if (propertyName === \"f_dc_0\" || \
propertyName === \"f_dc_1\" || propertyName === \"f_dc_2\") {\\n              \
  const component = Number.parseInt(\\n                  \
propertyName.slice(\"f_dc_\".length)\\n                );\\n                \
parsers.push(() => {\\n                  const value = (rgba[rgbaOffset + \
component] / 255 - 0.5) / SH_C0$1;\\n                  \
SET_FIELD[property.type](\\n                    data,\\n                    \
offset,\\n                    this.littleEndian,\\n                    \
value\\n                  );\\n                });\\n              } else if \
(propertyName === \"opacity\") {\\n                parsers.push(() => {\\n    \
              const value = Math.max(\\n                    -100,\\n          \
          Math.min(\\n                      100,\\n                      \
-Math.log(1 / (rgba[rgbaOffset + 3] / 255) - 1)\\n                    )\\n    \
              );\\n                  SET_FIELD[property.type](\\n             \
       data,\\n                    offset,\\n                    \
this.littleEndian,\\n                    value\\n                  );\\n      \
          });\\n              }\\n            }\\n            parsers.push(() \
=> {\\n              offset += FIELD_BYTES[property.type];\\n            \
});\\n          } else {\\n            parsers.push(() => {\\n              \
const length = PARSE_FIELD[property.countType](\\n                data,\\n    \
            offset,\\n                this.littleEndian\\n              );\\n \
             offset += FIELD_BYTES[property.countType];\\n              \
offset += length * FIELD_BYTES[property.type];\\n            });\\n          \
}\\n        }\\n        for (let index = 0; index < count; index++) {\\n      \
    for (const parser of parsers) {\\n            parser();\\n          }\\n  \
        if (isVertex) {\\n            rgbaOffset += 4;\\n          }\\n       \
 }\\n      }\\n    }\\n  };\\n  _PlyReader.defaultPointScale = 1e-3;\\n  let \
PlyReader = _PlyReader;\\n  const SH_C0$1 = 0.28209479177387814;\\n  const \
PARSE_FIELD = {\\n    char: (data, offset, littleEndian) => {\\n      return \
data.getInt8(offset);\\n    },\\n    uchar: (data, offset, littleEndian) => \
{\\n      return data.getUint8(offset);\\n    },\\n    short: (data, offset, \
littleEndian) => {\\n      return data.getInt16(offset, littleEndian);\\n    \
},\\n    ushort: (data, offset, littleEndian) => {\\n      return \
data.getUint16(offset, littleEndian);\\n    },\\n    int: (data, offset, \
littleEndian) => {\\n      return data.getInt32(offset, littleEndian);\\n    \
},\\n    uint: (data, offset, littleEndian) => {\\n      return \
data.getUint32(offset, littleEndian);\\n    },\\n    float: (data, offset, \
littleEndian) => {\\n      return data.getFloat32(offset, littleEndian);\\n   \
 },\\n    double: (data, offset, littleEndian) => {\\n      return \
data.getFloat64(offset, littleEndian);\\n    }\\n  };\\n  const SET_FIELD = \
{\\n    char: (data, offset, littleEndian, value) => {\\n      \
data.setInt8(offset, value);\\n    },\\n    uchar: (data, offset, \
littleEndian, value) => {\\n      data.setUint8(offset, value);\\n    },\\n   \
 short: (data, offset, littleEndian, value) => {\\n      \
data.setInt16(offset, value, littleEndian);\\n    },\\n    ushort: (data, \
offset, littleEndian, value) => {\\n      data.setUint16(offset, value, \
littleEndian);\\n    },\\n    int: (data, offset, littleEndian, value) => \
{\\n      data.setInt32(offset, value, littleEndian);\\n    },\\n    uint: \
(data, offset, littleEndian, value) => {\\n      data.setUint32(offset, \
value, littleEndian);\\n    },\\n    float: (data, offset, littleEndian, \
value) => {\\n      data.setFloat32(offset, value, littleEndian);\\n    },\\n \
   double: (data, offset, littleEndian, value) => {\\n      \
data.setFloat64(offset, value, littleEndian);\\n    }\\n  };\\n  const \
FIELD_BYTES = {\\n    char: 1,\\n    uchar: 1,\\n    short: 2,\\n    ushort: \
2,\\n    int: 4,\\n    uint: 4,\\n    float: 4,\\n    double: 8\\n  };\\n  \
const FIELD_SCALE = {\\n    char: 127,\\n    uchar: 255,\\n    short: \
32767,\\n    ushort: 65535,\\n    int: 2147483647,\\n    uint: 4294967295,\\n \
   float: 1,\\n    double: 1\\n  };\\n  const NUM_F_REST_TO_NUM_SH = {\\n    \
0: 0,\\n    9: 1,\\n    24: 2,\\n    45: 3\\n  };\\n  const \
NUM_SH_TO_NUM_F_REST = {\\n    0: 0,\\n    1: 9,\\n    2: 24,\\n    3: 45\\n  \
};\\n  const F_REST_REGEX = /^f_rest_([0-9]{1,2})$/;\\n  function \
createEmptyItem(properties) {\\n    const item = {};\\n    for (const \
[propertyName, property] of Object.entries(properties)) {\\n      if \
(F_REST_REGEX.test(propertyName)) {\\n        item.f_rest = new \
Array(getNumSh(properties));\\n      } else {\\n        item[propertyName] = \
property.isList ? [] : 0;\\n      }\\n    }\\n    return item;\\n  }\\n  \
function createParseFn(properties, littleEndian) {\\n    if \
(safeToCompile(properties)) {\\n      return \
createCompiledParserFn(properties, littleEndian);\\n    }\\n    return \
createDynamicParserFn(properties, littleEndian);\\n  }\\n  const \
UNSAFE_EVAL_ALLOWED = (() => {\\n    try {\\n      new Function(\"return \
42;\");\\n    } catch (e) {\\n      return false;\\n    }\\n    return \
true;\\n  })();\\n  const PROPERTY_NAME_REGEX = /^[a-zA-Z0-9_]+$/;\\n  \
function safeToCompile(properties) {\\n    if (!UNSAFE_EVAL_ALLOWED) {\\n     \
 return false;\\n    }\\n    for (const [propertyName, property] of \
Object.entries(properties)) {\\n      if \
(!PROPERTY_NAME_REGEX.test(propertyName)) {\\n        return false;\\n      \
}\\n      if (property.isList && \
!PLY_PROPERTY_TYPES.includes(property.countType)) {\\n        return \
false;\\n      }\\n      if (!PLY_PROPERTY_TYPES.includes(property.type)) \
{\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n  \
function createCompiledParserFn(properties, littleEndian) {\\n    const \
parserSrc = [\"let list;\"];\\n    for (const [propertyName, property] of \
Object.entries(properties)) {\\n      const fRestMatch = \
propertyName.match(F_REST_REGEX);\\n      if (fRestMatch) {\\n        const \
fRestIndex = +fRestMatch[1];\\n        parserSrc.push(\\n          /*js*/\\n  \
        `\\n        item.f_rest[${fRestIndex}] = \
PARSE_FIELD[\\'${property.type}\\'](data, offset, ${littleEndian});\\n        \
offset += ${FIELD_BYTES[property.type]};\\n      `\\n        );\\n      } \
else if (!property.isList) {\\n        parserSrc.push(\\n          /*js*/\\n  \
        `\\n        item[\\'${propertyName}\\'] = \
PARSE_FIELD[\\'${property.type}\\'](data, offset, ${littleEndian});\\n        \
offset += ${FIELD_BYTES[property.type]};\\n      `\\n        );\\n      } \
else {\\n        parserSrc.push(\\n          /*js*/\\n          `\\n        \
list = item[\\'${propertyName}\\'];\\n        list.length = \
PARSE_FIELD[\\'${property.countType}\\'](data, offset, ${littleEndian});\\n   \
     offset += ${FIELD_BYTES[property.countType]};\\n        for (let i = 0; \
i < list.length; i++) {\\n          list[i] = \
PARSE_FIELD[\\'${property.type}\\'](data, offset, ${littleEndian});\\n        \
  offset += ${FIELD_BYTES[property.type]};\\n        }\\n      `\\n        \
);\\n      }\\n    }\\n    parserSrc.push(\"return offset;\");\\n    const fn \
= new Function(\\n      \"data\",\\n      \"offset\",\\n      \"item\",\\n    \
  \"PARSE_FIELD\",\\n      parserSrc.join(\"\\\\n\")\\n    );\\n    return \
(data, offset, item) => fn(data, offset, item, PARSE_FIELD);\\n  }\\n  \
function createDynamicParserFn(properties, littleEndian) {\\n    const \
parsers = [];\\n    for (const [propertyName, property] of \
Object.entries(properties)) {\\n      const fRestMatch = \
propertyName.match(F_REST_REGEX);\\n      if (fRestMatch) {\\n        const \
fRestIndex = +fRestMatch[1];\\n        parsers.push(\\n          (data, \
offset, item) => {\\n            item.f_rest[fRestIndex] = \
PARSE_FIELD[property.type](\\n              data,\\n              offset,\\n  \
            littleEndian\\n            );\\n            return offset + \
FIELD_BYTES[property.type];\\n          }\\n        );\\n      } else if \
(!property.isList) {\\n        parsers.push(\\n          (data, offset, item) \
=> {\\n            item[propertyName] = PARSE_FIELD[property.type](\\n        \
      data,\\n              offset,\\n              littleEndian\\n           \
 );\\n            return offset + FIELD_BYTES[property.type];\\n          \
}\\n        );\\n      } else {\\n        parsers.push(\\n          (data, \
offset, item) => {\\n            const list = item[propertyName];\\n          \
  list.length = PARSE_FIELD[property.countType](\\n              data,\\n     \
         offset,\\n              littleEndian\\n            );\\n            \
let currentOffset = offset + FIELD_BYTES[property.countType];\\n            \
for (let i2 = 0; i2 < list.length; i2++) {\\n              list[i2] = \
PARSE_FIELD[property.type](\\n                data,\\n                \
currentOffset,\\n                littleEndian\\n              );\\n           \
   currentOffset += FIELD_BYTES[property.type];\\n            }\\n            \
return currentOffset;\\n          }\\n        );\\n      }\\n    }\\n    \
return (data, offset, item) => {\\n      let currentOffset = offset;\\n      \
for (let parserIndex = 0; parserIndex < parsers.length; parserIndex++) {\\n   \
     currentOffset = parsers[parserIndex](data, currentOffset, item);\\n      \
}\\n      return currentOffset;\\n    };\\n  }\\n  function \
getNumSh(properties) {\\n    let num_f_rest = 0;\\n    while \
(properties[`f_rest_${num_f_rest}`]) {\\n      num_f_rest += 1;\\n    }\\n    \
const numSh = NUM_F_REST_TO_NUM_SH[num_f_rest];\\n    if (numSh == null) {\\n \
     throw new Error(`Unsupported number of SH coefficients: \
${num_f_rest}`);\\n    }\\n    return numSh;\\n  }\\n  var SplatFileType = /* \
@__PURE__ */ ((SplatFileType2) => {\\n    SplatFileType2[\"PLY\"] = \
\"ply\";\\n    SplatFileType2[\"SPZ\"] = \"spz\";\\n    \
SplatFileType2[\"SPLAT\"] = \"splat\";\\n    SplatFileType2[\"KSPLAT\"] = \
\"ksplat\";\\n    SplatFileType2[\"PCSOGS\"] = \"pcsogs\";\\n    \
SplatFileType2[\"PCSOGSZIP\"] = \"pcsogszip\";\\n    return \
SplatFileType2;\\n  })(SplatFileType || {});\\n  function \
getSplatFileType(fileBytes) {\\n    const view = new \
DataView(fileBytes.buffer);\\n    if ((view.getUint32(0, true) & 16777215) \
=== 7957616) {\\n      return \"ply\";\\n    }\\n    if ((view.getUint32(0, \
true) & 16777215) === 559903) {\\n      const header = \
decompressPartialGzip(fileBytes, 4);\\n      const gView = new \
DataView(header.buffer);\\n      if (gView.getUint32(0, true) === 1347635022) \
{\\n        return \"spz\";\\n      }\\n      return void 0;\\n    }\\n    if \
(view.getUint32(0, true) === 67324752) {\\n      if (tryPcSogsZip(fileBytes)) \
{\\n        return \"pcsogszip\";\\n      }\\n      return void 0;\\n    }\\n \
   return void 0;\\n  }\\n  function getFileExtension(pathOrUrl) {\\n    \
const noTrailing = pathOrUrl.split(/[?#]/, 1)[0];\\n    const lastSlash = \
Math.max(\\n      noTrailing.lastIndexOf(\"/\"),\\n      \
noTrailing.lastIndexOf(\"\\\\\\\\\")\\n    );\\n    const filename = \
noTrailing.slice(lastSlash + 1);\\n    const lastDot = \
filename.lastIndexOf(\".\");\\n    if (lastDot <= 0 || lastDot === \
filename.length - 1) {\\n      return \"\";\\n    }\\n    return \
filename.slice(lastDot + 1).toLowerCase();\\n  }\\n  function \
getSplatFileTypeFromPath(pathOrUrl) {\\n    const extension = \
getFileExtension(pathOrUrl);\\n    if (extension === \"ply\") {\\n      \
return \"ply\";\\n    }\\n    if (extension === \"spz\") {\\n      return \
\"spz\";\\n    }\\n    if (extension === \"splat\") {\\n      return \
\"splat\";\\n    }\\n    if (extension === \"ksplat\") {\\n      return \
\"ksplat\";\\n    }\\n    if (extension === \"sog\") {\\n      return \
\"pcsogszip\";\\n    }\\n    return void 0;\\n  }\\n  function \
tryPcSogs(input) {\\n    try {\\n      let text;\\n      if (typeof input === \
\"string\") {\\n        text = input;\\n      } else {\\n        const \
fileBytes = input instanceof ArrayBuffer ? new Uint8Array(input) : input;\\n  \
      if (fileBytes.length > 65536) {\\n          return void 0;\\n        \
}\\n        text = new TextDecoder().decode(fileBytes);\\n      }\\n      \
const json = JSON.parse(text);\\n      if (!json || typeof json !== \
\"object\" || Array.isArray(json)) {\\n        return void 0;\\n      }\\n    \
  const isVersion2 = json.version === 2;\\n      for (const key of \
[\"means\", \"scales\", \"quats\", \"sh0\"]) {\\n        if (!json[key] || \
typeof json[key] !== \"object\" || Array.isArray(json[key])) {\\n          \
return void 0;\\n        }\\n        if (isVersion2) {\\n          if \
(!json[key].files) {\\n            return void 0;\\n          }\\n          \
if ((key === \"scales\" || key === \"sh0\") && !json[key].codebook) {\\n      \
      return void 0;\\n          }\\n          if (key === \"means\" && \
(!json[key].mins || !json[key].maxs)) {\\n            return void 0;\\n       \
   }\\n        } else {\\n          if (!json[key].shape || !json[key].files) \
{\\n            return void 0;\\n          }\\n          if (key !== \
\"quats\" && (!json[key].mins || !json[key].maxs)) {\\n            return \
void 0;\\n          }\\n        }\\n      }\\n      return json;\\n    } \
catch {\\n      return void 0;\\n    }\\n  }\\n  function tryPcSogsZip(input) \
{\\n    try {\\n      const fileBytes = input instanceof ArrayBuffer ? new \
Uint8Array(input) : input;\\n      let metaFilename = null;\\n      const \
unzipped = unzipSync(fileBytes, {\\n        filter: ({ name }) => {\\n        \
  const filename = name.split(/[\\\\\\\\/]/).pop();\\n          if (filename \
=== \"meta.json\") {\\n            metaFilename = name;\\n            return \
true;\\n          }\\n          return false;\\n        }\\n      });\\n      \
if (!metaFilename) {\\n        return void 0;\\n      }\\n      const json = \
tryPcSogs(unzipped[metaFilename]);\\n      if (!json) {\\n        return void \
0;\\n      }\\n      return { name: metaFilename, json };\\n    } catch {\\n  \
    return void 0;\\n    }\\n  }\\n  class SplatData {\\n    constructor({ \
maxSplats = 1 } = {}) {\\n      this.numSplats = 0;\\n      this.maxSplats = \
getTextureSize(maxSplats).maxSplats;\\n      this.centers = new \
Float32Array(this.maxSplats * 3);\\n      this.scales = new \
Float32Array(this.maxSplats * 3);\\n      this.quaternions = new \
Float32Array(this.maxSplats * 4);\\n      this.opacities = new \
Float32Array(this.maxSplats);\\n      this.colors = new \
Float32Array(this.maxSplats * 3);\\n    }\\n    pushSplat() {\\n      const \
index = this.numSplats;\\n      this.ensureIndex(index);\\n      \
this.numSplats += 1;\\n      return index;\\n    }\\n    unpushSplat(index) \
{\\n      if (index === this.numSplats - 1) {\\n        this.numSplats -= \
1;\\n      } else {\\n        throw new Error(\"Cannot unpush splat from \
non-last position\");\\n      }\\n    }\\n    ensureCapacity(numSplats) {\\n  \
    if (numSplats > this.maxSplats) {\\n        const targetSplats = \
Math.max(numSplats, this.maxSplats * 2);\\n        const newCenters = new \
Float32Array(targetSplats * 3);\\n        const newScales = new \
Float32Array(targetSplats * 3);\\n        const newQuaternions = new \
Float32Array(targetSplats * 4);\\n        const newOpacities = new \
Float32Array(targetSplats);\\n        const newColors = new \
Float32Array(targetSplats * 3);\\n        newCenters.set(this.centers);\\n    \
    newScales.set(this.scales);\\n        \
newQuaternions.set(this.quaternions);\\n        \
newOpacities.set(this.opacities);\\n        newColors.set(this.colors);\\n    \
    this.centers = newCenters;\\n        this.scales = newScales;\\n        \
this.quaternions = newQuaternions;\\n        this.opacities = \
newOpacities;\\n        this.colors = newColors;\\n        if (this.sh1) {\\n \
         const newSh1 = new Float32Array(targetSplats * 9);\\n          \
newSh1.set(this.sh1);\\n          this.sh1 = newSh1;\\n        }\\n        if \
(this.sh2) {\\n          const newSh2 = new Float32Array(targetSplats * \
15);\\n          newSh2.set(this.sh2);\\n          this.sh2 = newSh2;\\n      \
  }\\n        if (this.sh3) {\\n          const newSh3 = new \
Float32Array(targetSplats * 21);\\n          newSh3.set(this.sh3);\\n         \
 this.sh3 = newSh3;\\n        }\\n        this.maxSplats = targetSplats;\\n   \
   }\\n    }\\n    ensureIndex(index) {\\n      this.ensureCapacity(index + \
1);\\n    }\\n    setCenter(index, x2, y, z) {\\n      this.centers[index * \
3] = x2;\\n      this.centers[index * 3 + 1] = y;\\n      this.centers[index \
* 3 + 2] = z;\\n    }\\n    setScale(index, scaleX, scaleY, scaleZ) {\\n      \
this.scales[index * 3] = scaleX;\\n      this.scales[index * 3 + 1] = \
scaleY;\\n      this.scales[index * 3 + 2] = scaleZ;\\n    }\\n    \
setQuaternion(index, x2, y, z, w) {\\n      this.quaternions[index * 4] = \
x2;\\n      this.quaternions[index * 4 + 1] = y;\\n      \
this.quaternions[index * 4 + 2] = z;\\n      this.quaternions[index * 4 + 3] \
= w;\\n    }\\n    setOpacity(index, opacity) {\\n      this.opacities[index] \
= opacity;\\n    }\\n    setColor(index, r, g, b) {\\n      this.colors[index \
* 3] = r;\\n      this.colors[index * 3 + 1] = g;\\n      this.colors[index * \
3 + 2] = b;\\n    }\\n    setSh1(index, sh1) {\\n      if (!this.sh1) {\\n    \
    this.sh1 = new Float32Array(this.maxSplats * 9);\\n      }\\n      for \
(let j = 0; j < 9; ++j) {\\n        this.sh1[index * 9 + j] = sh1[j];\\n      \
}\\n    }\\n    setSh2(index, sh2) {\\n      if (!this.sh2) {\\n        \
this.sh2 = new Float32Array(this.maxSplats * 15);\\n      }\\n      for (let \
j = 0; j < 15; ++j) {\\n        this.sh2[index * 15 + j] = sh2[j];\\n      \
}\\n    }\\n    setSh3(index, sh3) {\\n      if (!this.sh3) {\\n        \
this.sh3 = new Float32Array(this.maxSplats * 21);\\n      }\\n      for (let \
j = 0; j < 21; ++j) {\\n        this.sh3[index * 21 + j] = sh3[j];\\n      \
}\\n    }\\n  }\\n  async function unpackPcSogs(json, extraFiles, \
splatEncoding) {\\n    const isVersion2 = \"version\" in json;\\n    if \
(!isVersion2 && json.quats.encoding !== \"quaternion_packed\") {\\n      \
throw new Error(\"Unsupported quaternion encoding\");\\n    }\\n    const \
numSplats = isVersion2 ? json.count : json.means.shape[0];\\n    const \
maxSplats = computeMaxSplats(numSplats);\\n    const packedArray = new \
Uint32Array(maxSplats * 4);\\n    const extra = {};\\n    const meansPromise \
= Promise.all([\\n      decodeImageRgba(extraFiles[json.means.files[0]]),\\n  \
    decodeImageRgba(extraFiles[json.means.files[1]])\\n    ]).then((means) => \
{\\n      for (let i2 = 0; i2 < numSplats; ++i2) {\\n        const i4 = i2 * \
4;\\n        const fx = (means[0][i4 + 0] + (means[1][i4 + 0] << 8)) / \
65535;\\n        const fy = (means[0][i4 + 1] + (means[1][i4 + 1] << 8)) / \
65535;\\n        const fz = (means[0][i4 + 2] + (means[1][i4 + 2] << 8)) / \
65535;\\n        let x2 = json.means.mins[0] + (json.means.maxs[0] - \
json.means.mins[0]) * fx;\\n        let y = json.means.mins[1] + \
(json.means.maxs[1] - json.means.mins[1]) * fy;\\n        let z = \
json.means.mins[2] + (json.means.maxs[2] - json.means.mins[2]) * fz;\\n       \
 x2 = Math.sign(x2) * (Math.exp(Math.abs(x2)) - 1);\\n        y = \
Math.sign(y) * (Math.exp(Math.abs(y)) - 1);\\n        z = Math.sign(z) * \
(Math.exp(Math.abs(z)) - 1);\\n        setPackedSplatCenter(packedArray, i2, \
x2, y, z);\\n      }\\n    });\\n    const scalesPromise = \
decodeImageRgba(extraFiles[json.scales.files[0]]).then(\\n      (scales) => \
{\\n        let xLookup;\\n        let yLookup;\\n        let zLookup;\\n     \
   if (isVersion2) {\\n          xLookup = yLookup = zLookup = \
json.scales.codebook.map((x2) => Math.exp(x2));\\n        } else {\\n         \
 xLookup = new Array(256).fill(0).map(\\n            (_, i2) => \
json.scales.mins[0] + (json.scales.maxs[0] - json.scales.mins[0]) * (i2 / \
255)\\n          ).map((x2) => Math.exp(x2));\\n          yLookup = new \
Array(256).fill(0).map(\\n            (_, i2) => json.scales.mins[1] + \
(json.scales.maxs[1] - json.scales.mins[1]) * (i2 / 255)\\n          \
).map((x2) => Math.exp(x2));\\n          zLookup = new \
Array(256).fill(0).map(\\n            (_, i2) => json.scales.mins[2] + \
(json.scales.maxs[2] - json.scales.mins[2]) * (i2 / 255)\\n          \
).map((x2) => Math.exp(x2));\\n        }\\n        for (let i2 = 0; i2 < \
numSplats; ++i2) {\\n          const i4 = i2 * 4;\\n          \
setPackedSplatScales(\\n            packedArray,\\n            i2,\\n         \
   xLookup[scales[i4 + 0]],\\n            yLookup[scales[i4 + 1]],\\n         \
   zLookup[scales[i4 + 2]],\\n            splatEncoding\\n          );\\n     \
   }\\n      }\\n    );\\n    const quatsPromise = \
decodeImageRgba(extraFiles[json.quats.files[0]]).then(\\n      (quats) => \
{\\n        const SQRT2 = Math.sqrt(2);\\n        const lookup = new \
Array(256).fill(0).map((_, i2) => (i2 / 255 - 0.5) * SQRT2);\\n        for \
(let i2 = 0; i2 < numSplats; ++i2) {\\n          const i4 = i2 * 4;\\n        \
  const r0 = lookup[quats[i4 + 0]];\\n          const r1 = lookup[quats[i4 + \
1]];\\n          const r2 = lookup[quats[i4 + 2]];\\n          const rr = \
Math.sqrt(Math.max(0, 1 - r0 * r0 - r1 * r1 - r2 * r2));\\n          const \
rOrder = quats[i4 + 3] - 252;\\n          const quatX = rOrder === 0 ? r0 : \
rOrder === 1 ? rr : r1;\\n          const quatY = rOrder <= 1 ? r1 : rOrder \
=== 2 ? rr : r2;\\n          const quatZ = rOrder <= 2 ? r2 : rr;\\n          \
const quatW = rOrder === 0 ? rr : r0;\\n          \
setPackedSplatQuat(packedArray, i2, quatX, quatY, quatZ, quatW);\\n        \
}\\n      }\\n    );\\n    const sh0Promise = \
decodeImageRgba(extraFiles[json.sh0.files[0]]).then(\\n      (sh0) => {\\n    \
    const SH_C02 = 0.28209479177387814;\\n        let rLookup;\\n        let \
gLookup;\\n        let bLookup;\\n        let aLookup;\\n        if \
(isVersion2) {\\n          rLookup = gLookup = bLookup = \
json.sh0.codebook.map((x2) => SH_C02 * x2 + 0.5);\\n          aLookup = new \
Array(256).fill(0).map((_, i2) => i2 / 255);\\n        } else {\\n          \
rLookup = new Array(256).fill(0).map(\\n            (_, i2) => \
json.sh0.mins[0] + (json.sh0.maxs[0] - json.sh0.mins[0]) * (i2 / 255)\\n      \
    ).map((x2) => SH_C02 * x2 + 0.5);\\n          gLookup = new \
Array(256).fill(0).map(\\n            (_, i2) => json.sh0.mins[1] + \
(json.sh0.maxs[1] - json.sh0.mins[1]) * (i2 / 255)\\n          ).map((x2) => \
SH_C02 * x2 + 0.5);\\n          bLookup = new Array(256).fill(0).map(\\n      \
      (_, i2) => json.sh0.mins[2] + (json.sh0.maxs[2] - json.sh0.mins[2]) * \
(i2 / 255)\\n          ).map((x2) => SH_C02 * x2 + 0.5);\\n          aLookup \
= new Array(256).fill(0).map(\\n            (_, i2) => json.sh0.mins[3] + \
(json.sh0.maxs[3] - json.sh0.mins[3]) * (i2 / 255)\\n          ).map((x2) => \
1 / (1 + Math.exp(-x2)));\\n        }\\n        for (let i2 = 0; i2 < \
numSplats; ++i2) {\\n          const i4 = i2 * 4;\\n          \
setPackedSplatRgba(\\n            packedArray,\\n            i2,\\n           \
 rLookup[sh0[i4 + 0]],\\n            gLookup[sh0[i4 + 1]],\\n            \
bLookup[sh0[i4 + 2]],\\n            aLookup[sh0[i4 + 3]],\\n            \
splatEncoding\\n          );\\n        }\\n      }\\n    );\\n    const \
promises = [meansPromise, scalesPromise, quatsPromise, sh0Promise];\\n    if \
(json.shN) {\\n      const useSH3 = isVersion2 ? json.shN.bands >= 3 : \
json.shN.shape[1] >= 48 - 3;\\n      const useSH2 = isVersion2 ? \
json.shN.bands >= 2 : json.shN.shape[1] >= 27 - 3;\\n      const useSH1 = \
isVersion2 ? json.shN.bands >= 1 : json.shN.shape[1] >= 12 - 3;\\n      if \
(useSH1) extra.sh1 = new Uint32Array(numSplats * 2);\\n      if (useSH2) \
extra.sh2 = new Uint32Array(numSplats * 4);\\n      if (useSH3) extra.sh3 = \
new Uint32Array(numSplats * 4);\\n      const sh1 = new Float32Array(9);\\n   \
   const sh2 = new Float32Array(15);\\n      const sh3 = new \
Float32Array(21);\\n      const shN = json.shN;\\n      const shNPromise = \
Promise.all([\\n        decodeImage(extraFiles[json.shN.files[0]]),\\n        \
decodeImage(extraFiles[json.shN.files[1]])\\n      ]).then(([centroids, \
labels]) => {\\n        const lookup = \"codebook\" in shN ? shN.codebook : \
new Array(256).fill(0).map((_, i2) => shN.mins + (shN.maxs - shN.mins) * (i2 \
/ 255));\\n        for (let i2 = 0; i2 < numSplats; ++i2) {\\n          const \
i4 = i2 * 4;\\n          const label = labels.rgba[i4 + 0] + (labels.rgba[i4 \
+ 1] << 8);\\n          const col = (label & 63) * 15;\\n          const row \
= label >>> 6;\\n          const offset = row * centroids.width + col;\\n     \
     for (let d = 0; d < 3; ++d) {\\n            if (useSH1) {\\n             \
 for (let k = 0; k < 3; ++k) {\\n                sh1[k * 3 + d] = \
lookup[centroids.rgba[(offset + k) * 4 + d]];\\n              }\\n            \
}\\n            if (useSH2) {\\n              for (let k = 0; k < 5; ++k) \
{\\n                sh2[k * 3 + d] = lookup[centroids.rgba[(offset + 3 + k) * \
4 + d]];\\n              }\\n            }\\n            if (useSH3) {\\n     \
         for (let k = 0; k < 7; ++k) {\\n                sh3[k * 3 + d] = \
lookup[centroids.rgba[(offset + 8 + k) * 4 + d]];\\n              }\\n        \
    }\\n          }\\n          if (useSH1)\\n            \
encodeSh1Rgb(extra.sh1, i2, sh1, splatEncoding);\\n          if (useSH2)\\n   \
         encodeSh2Rgb(extra.sh2, i2, sh2, splatEncoding);\\n          if \
(useSH3)\\n            encodeSh3Rgb(extra.sh3, i2, sh3, splatEncoding);\\n    \
    }\\n      });\\n      promises.push(shNPromise);\\n    }\\n    await \
Promise.all(promises);\\n    return { packedArray, numSplats, extra };\\n  \
}\\n  let offscreenGlContext = null;\\n  async function \
decodeImage(fileBytes) {\\n    if (!offscreenGlContext) {\\n      const \
canvas = new OffscreenCanvas(1, 1);\\n      offscreenGlContext = \
canvas.getContext(\"webgl2\");\\n      if (!offscreenGlContext) {\\n        \
throw new Error(\"Failed to create WebGL2 context\");\\n      }\\n    }\\n    \
const imageBlob = new Blob([fileBytes]);\\n    const bitmap = await \
createImageBitmap(imageBlob, {\\n      premultiplyAlpha: \"none\"\\n    \
});\\n    const gl = offscreenGlContext;\\n    const texture = \
gl.createTexture();\\n    gl.bindTexture(gl.TEXTURE_2D, texture);\\n    \
gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\\n    \
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, \
bitmap);\\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, \
gl.NEAREST);\\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, \
gl.NEAREST);\\n    const framebuffer = gl.createFramebuffer();\\n    \
gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\\n    \
gl.framebufferTexture2D(\\n      gl.FRAMEBUFFER,\\n      \
gl.COLOR_ATTACHMENT0,\\n      gl.TEXTURE_2D,\\n      texture,\\n      0\\n    \
);\\n    const data = new Uint8Array(bitmap.width * bitmap.height * 4);\\n    \
gl.readPixels(\\n      0,\\n      0,\\n      bitmap.width,\\n      \
bitmap.height,\\n      gl.RGBA,\\n      gl.UNSIGNED_BYTE,\\n      data\\n    \
);\\n    gl.deleteTexture(texture);\\n    \
gl.deleteFramebuffer(framebuffer);\\n    return { rgba: data, width: \
bitmap.width, height: bitmap.height };\\n  }\\n  async function \
decodeImageRgba(fileBytes) {\\n    const { rgba } = await \
decodeImage(fileBytes);\\n    return rgba;\\n  }\\n  async function \
unpackPcSogsZip(fileBytes, splatEncoding) {\\n    var _a2;\\n    const \
nameJson = tryPcSogsZip(fileBytes);\\n    if (!nameJson) {\\n      throw new \
Error(\"Invalid PC SOGS zip file\");\\n    }\\n    const { name, json } = \
nameJson;\\n    const lastSlash = name.lastIndexOf(\"/\");\\n    const \
lastBackslash = name.lastIndexOf(\"\\\\\\\\\");\\n    const prefix = \
name.slice(0, Math.max(lastSlash, lastBackslash) + 1);\\n    const fileMap = \
/* @__PURE__ */ new Map();\\n    const refFiles = [\\n      \
...json.means.files,\\n      ...json.scales.files,\\n      \
...json.quats.files,\\n      ...json.sh0.files,\\n      ...((_a2 = json.shN) \
== null ? void 0 : _a2.files) ?? []\\n    ];\\n    for (const file of \
refFiles) {\\n      fileMap.set(prefix + file, file);\\n    }\\n    const \
unzipped = await new Promise(\\n      (resolve, reject) => {\\n        \
unzip(\\n          fileBytes,\\n          {\\n            filter: ({ name: \
name2 }) => {\\n              return fileMap.has(name2);\\n            }\\n   \
       },\\n          (err2, files) => {\\n            if (err2) {\\n         \
     reject(err2);\\n            } else {\\n              resolve(files);\\n  \
          }\\n          }\\n        );\\n      }\\n    );\\n    const \
extraFiles = {};\\n    for (const [full, name2] of fileMap.entries()) {\\n    \
  extraFiles[name2] = unzipped[full];\\n    }\\n    return await \
unpackPcSogs(json, extraFiles, splatEncoding);\\n  }\\n  class SpzReader {\\n \
   constructor({ fileBytes }) {\\n      this.version = -1;\\n      \
this.numSplats = 0;\\n      this.shDegree = 0;\\n      this.fractionalBits = \
0;\\n      this.flags = 0;\\n      this.flagAntiAlias = false;\\n      \
this.reserved = 0;\\n      this.headerParsed = false;\\n      this.parsed = \
false;\\n      this.fileBytes = fileBytes instanceof ArrayBuffer ? new \
Uint8Array(fileBytes) : fileBytes;\\n      this.reader = new GunzipReader({ \
fileBytes: this.fileBytes });\\n    }\\n    async parseHeader() {\\n      if \
(this.headerParsed) {\\n        throw new Error(\"SPZ file header already \
parsed\");\\n      }\\n      const header = new DataView((await \
this.reader.read(16)).buffer);\\n      if (header.getUint32(0, true) !== \
1347635022) {\\n        throw new Error(\"Invalid SPZ file\");\\n      }\\n   \
   this.version = header.getUint32(4, true);\\n      if (this.version < 1 || \
this.version > 3) {\\n        throw new Error(`Unsupported SPZ version: \
${this.version}`);\\n      }\\n      this.numSplats = header.getUint32(8, \
true);\\n      this.shDegree = header.getUint8(12);\\n      \
this.fractionalBits = header.getUint8(13);\\n      this.flags = \
header.getUint8(14);\\n      this.flagAntiAlias = (this.flags & 1) !== 0;\\n  \
    this.reserved = header.getUint8(15);\\n      this.headerParsed = true;\\n \
     this.parsed = false;\\n    }\\n    async parseSplats(centerCallback, \
alphaCallback, rgbCallback, scalesCallback, quatCallback, shCallback) {\\n    \
  if (!this.headerParsed) {\\n        throw new Error(\"SPZ file header must \
be parsed first\");\\n      }\\n      if (this.parsed) {\\n        throw new \
Error(\"SPZ file already parsed\");\\n      }\\n      this.parsed = true;\\n  \
    if (this.version === 1) {\\n        const centerBytes = await \
this.reader.read(this.numSplats * 3 * 2);\\n        const centerUint16 = new \
Uint16Array(centerBytes.buffer);\\n        for (let i2 = 0; i2 < \
this.numSplats; i2++) {\\n          const i3 = i2 * 3;\\n          const x2 = \
fromHalf(centerUint16[i3]);\\n          const y = fromHalf(centerUint16[i3 + \
1]);\\n          const z = fromHalf(centerUint16[i3 + 2]);\\n          \
centerCallback == null ? void 0 : centerCallback(i2, x2, y, z);\\n        \
}\\n      } else if (this.version === 2 || this.version === 3) {\\n        \
const fixed = 1 << this.fractionalBits;\\n        const centerBytes = await \
this.reader.read(this.numSplats * 3 * 3);\\n        for (let i2 = 0; i2 < \
this.numSplats; i2++) {\\n          const i9 = i2 * 9;\\n          const x2 = \
((centerBytes[i9 + 2] << 24 | centerBytes[i9 + 1] << 16 | centerBytes[i9] << \
8) >> 8) / fixed;\\n          const y = ((centerBytes[i9 + 5] << 24 | \
centerBytes[i9 + 4] << 16 | centerBytes[i9 + 3] << 8) >> 8) / fixed;\\n       \
   const z = ((centerBytes[i9 + 8] << 24 | centerBytes[i9 + 7] << 16 | \
centerBytes[i9 + 6] << 8) >> 8) / fixed;\\n          centerCallback == null ? \
void 0 : centerCallback(i2, x2, y, z);\\n        }\\n      } else {\\n        \
throw new Error(\"Unreachable\");\\n      }\\n      {\\n        const bytes = \
await this.reader.read(this.numSplats);\\n        for (let i2 = 0; i2 < \
this.numSplats; i2++) {\\n          alphaCallback == null ? void 0 : \
alphaCallback(i2, bytes[i2] / 255);\\n        }\\n      }\\n      {\\n        \
const rgbBytes = await this.reader.read(this.numSplats * 3);\\n        const \
scale = SH_C0 / 0.15;\\n        for (let i2 = 0; i2 < this.numSplats; i2++) \
{\\n          const i3 = i2 * 3;\\n          const r = (rgbBytes[i3] / 255 - \
0.5) * scale + 0.5;\\n          const g = (rgbBytes[i3 + 1] / 255 - 0.5) * \
scale + 0.5;\\n          const b = (rgbBytes[i3 + 2] / 255 - 0.5) * scale + \
0.5;\\n          rgbCallback == null ? void 0 : rgbCallback(i2, r, g, b);\\n  \
      }\\n      }\\n      {\\n        const scalesBytes = await \
this.reader.read(this.numSplats * 3);\\n        for (let i2 = 0; i2 < \
this.numSplats; i2++) {\\n          const i3 = i2 * 3;\\n          const \
scaleX = Math.exp(scalesBytes[i3] / 16 - 10);\\n          const scaleY = \
Math.exp(scalesBytes[i3 + 1] / 16 - 10);\\n          const scaleZ = \
Math.exp(scalesBytes[i3 + 2] / 16 - 10);\\n          scalesCallback == null ? \
void 0 : scalesCallback(i2, scaleX, scaleY, scaleZ);\\n        }\\n      }\\n \
     if (this.version === 3) {\\n        const maxValue = 1 / \
Math.sqrt(2);\\n        const quatBytes = await \
this.reader.read(this.numSplats * 4);\\n        for (let i2 = 0; i2 < \
this.numSplats; i2++) {\\n          const i3 = i2 * 4;\\n          const \
quaternion = [0, 0, 0, 0];\\n          const values = [\\n            \
quatBytes[i3],\\n            quatBytes[i3 + 1],\\n            quatBytes[i3 + \
2],\\n            quatBytes[i3 + 3]\\n          ];\\n          const \
combinedValues = values[0] + (values[1] << 8) + (values[2] << 16) + \
(values[3] << 24);\\n          const valueMask = (1 << 9) - 1;\\n          \
const largestIndex = combinedValues >>> 30;\\n          let remainingValues = \
combinedValues;\\n          let sumSquares = 0;\\n          for (let i22 = 3; \
i22 >= 0; --i22) {\\n            if (i22 !== largestIndex) {\\n              \
const value = remainingValues & valueMask;\\n              const sign = \
remainingValues >>> 9 & 1;\\n              remainingValues = remainingValues \
>>> 10;\\n              quaternion[i22] = maxValue * (value / valueMask);\\n  \
            quaternion[i22] = sign === 0 ? quaternion[i22] : \
-quaternion[i22];\\n              sumSquares += quaternion[i22] * \
quaternion[i22];\\n            }\\n          }\\n          const square = 1 - \
sumSquares;\\n          quaternion[largestIndex] = Math.sqrt(Math.max(square, \
0));\\n          quatCallback == null ? void 0 : quatCallback(\\n            \
i2,\\n            quaternion[0],\\n            quaternion[1],\\n            \
quaternion[2],\\n            quaternion[3]\\n          );\\n        }\\n      \
} else {\\n        const quatBytes = await this.reader.read(this.numSplats * \
3);\\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\\n          const \
i3 = i2 * 3;\\n          const quatX = quatBytes[i3] / 127.5 - 1;\\n          \
const quatY = quatBytes[i3 + 1] / 127.5 - 1;\\n          const quatZ = \
quatBytes[i3 + 2] / 127.5 - 1;\\n          const quatW = Math.sqrt(\\n        \
    Math.max(0, 1 - quatX * quatX - quatY * quatY - quatZ * quatZ)\\n         \
 );\\n          quatCallback == null ? void 0 : quatCallback(i2, quatX, \
quatY, quatZ, quatW);\\n        }\\n      }\\n      if (shCallback && \
this.shDegree >= 1) {\\n        const sh1 = new Float32Array(3 * 3);\\n       \
 const sh2 = this.shDegree >= 2 ? new Float32Array(5 * 3) : void 0;\\n        \
const sh3 = this.shDegree >= 3 ? new Float32Array(7 * 3) : void 0;\\n        \
const shBytes = await this.reader.read(\\n          this.numSplats * \
SH_DEGREE_TO_VECS[this.shDegree] * 3\\n        );\\n        let offset = \
0;\\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\\n          for \
(let j = 0; j < 9; ++j) {\\n            sh1[j] = (shBytes[offset + j] - 128) \
/ 128;\\n          }\\n          offset += 9;\\n          if (sh2) {\\n       \
     for (let j = 0; j < 15; ++j) {\\n              sh2[j] = (shBytes[offset \
+ j] - 128) / 128;\\n            }\\n            offset += 15;\\n          \
}\\n          if (sh3) {\\n            for (let j = 0; j < 21; ++j) {\\n      \
        sh3[j] = (shBytes[offset + j] - 128) / 128;\\n            }\\n        \
    offset += 21;\\n          }\\n          shCallback == null ? void 0 : \
shCallback(i2, sh1, sh2, sh3);\\n        }\\n      }\\n    }\\n  }\\n  const \
SH_DEGREE_TO_VECS = { 1: 3, 2: 8, 3: 15 };\\n  const SH_C0 = \
0.28209479177387814;\\n  const SPZ_MAGIC = 1347635022;\\n  const SPZ_VERSION \
= 3;\\n  const FLAG_ANTIALIASED = 1;\\n  class SpzWriter {\\n    \
constructor({\\n      numSplats,\\n      shDegree,\\n      fractionalBits = \
12,\\n      flagAntiAlias = true\\n    }) {\\n      this.clippedCount = 0;\\n \
     const splatSize = 9 + // Position\\n      1 + // Opacity\\n      3 + // \
Scale\\n      3 + // DC-rgb\\n      4 + // Rotation\\n      (shDegree >= 1 ? \
9 : 0) + (shDegree >= 2 ? 15 : 0) + (shDegree >= 3 ? 21 : 0);\\n      const \
bufferSize = 16 + numSplats * splatSize;\\n      this.buffer = new \
ArrayBuffer(bufferSize);\\n      this.view = new DataView(this.buffer);\\n    \
  this.view.setUint32(0, SPZ_MAGIC, true);\\n      this.view.setUint32(4, \
SPZ_VERSION, true);\\n      this.view.setUint32(8, numSplats, true);\\n      \
this.view.setUint8(12, shDegree);\\n      this.view.setUint8(13, \
fractionalBits);\\n      this.view.setUint8(14, flagAntiAlias ? \
FLAG_ANTIALIASED : 0);\\n      this.view.setUint8(15, 0);\\n      \
this.numSplats = numSplats;\\n      this.shDegree = shDegree;\\n      \
this.fractionalBits = fractionalBits;\\n      this.fraction = 1 << \
fractionalBits;\\n      this.flagAntiAlias = flagAntiAlias;\\n    }\\n    \
setCenter(index, x2, y, z) {\\n      const xRounded = Math.round(x2 * \
this.fraction);\\n      const xInt = Math.max(-8388607, Math.min(8388607, \
xRounded));\\n      const yRounded = Math.round(y * this.fraction);\\n      \
const yInt = Math.max(-8388607, Math.min(8388607, yRounded));\\n      const \
zRounded = Math.round(z * this.fraction);\\n      const zInt = \
Math.max(-8388607, Math.min(8388607, zRounded));\\n      const clipped = \
xRounded !== xInt || yRounded !== yInt || zRounded !== zInt;\\n      if \
(clipped) {\\n        this.clippedCount += 1;\\n      }\\n      const i9 = \
index * 9;\\n      const base = 16 + i9;\\n      this.view.setUint8(base, \
xInt & 255);\\n      this.view.setUint8(base + 1, xInt >> 8 & 255);\\n      \
this.view.setUint8(base + 2, xInt >> 16 & 255);\\n      \
this.view.setUint8(base + 3, yInt & 255);\\n      this.view.setUint8(base + \
4, yInt >> 8 & 255);\\n      this.view.setUint8(base + 5, yInt >> 16 & \
255);\\n      this.view.setUint8(base + 6, zInt & 255);\\n      \
this.view.setUint8(base + 7, zInt >> 8 & 255);\\n      \
this.view.setUint8(base + 8, zInt >> 16 & 255);\\n    }\\n    setAlpha(index, \
alpha) {\\n      const base = 16 + this.numSplats * 9 + index;\\n      \
this.view.setUint8(\\n        base,\\n        Math.max(0, Math.min(255, \
Math.round(alpha * 255)))\\n      );\\n    }\\n    static scaleRgb(r) {\\n    \
  const v = ((r - 0.5) / (SH_C0 / 0.15) + 0.5) * 255;\\n      return \
Math.max(0, Math.min(255, Math.round(v)));\\n    }\\n    setRgb(index, r, g, \
b) {\\n      const base = 16 + this.numSplats * 10 + index * 3;\\n      \
this.view.setUint8(base, SpzWriter.scaleRgb(r));\\n      \
this.view.setUint8(base + 1, SpzWriter.scaleRgb(g));\\n      \
this.view.setUint8(base + 2, SpzWriter.scaleRgb(b));\\n    }\\n    \
setScale(index, scaleX, scaleY, scaleZ) {\\n      const base = 16 + \
this.numSplats * 13 + index * 3;\\n      this.view.setUint8(\\n        \
base,\\n        Math.max(0, Math.min(255, Math.round((Math.log(scaleX) + 10) \
* 16)))\\n      );\\n      this.view.setUint8(\\n        base + 1,\\n        \
Math.max(0, Math.min(255, Math.round((Math.log(scaleY) + 10) * 16)))\\n      \
);\\n      this.view.setUint8(\\n        base + 2,\\n        Math.max(0, \
Math.min(255, Math.round((Math.log(scaleZ) + 10) * 16)))\\n      );\\n    \
}\\n    setQuat(index, ...q) {\\n      const base = 16 + this.numSplats * 16 \
+ index * 4;\\n      const quat = normalize(q);\\n      let iLargest = 0;\\n  \
    for (let i2 = 1; i2 < 4; ++i2) {\\n        if (Math.abs(quat[i2]) > \
Math.abs(quat[iLargest])) {\\n          iLargest = i2;\\n        }\\n      \
}\\n      const negate = quat[iLargest] < 0 ? 1 : 0;\\n      let comp = \
iLargest;\\n      for (let i2 = 0; i2 < 4; ++i2) {\\n        if (i2 !== \
iLargest) {\\n          const negbit = (quat[i2] < 0 ? 1 : 0) ^ negate;\\n    \
      const mag = Math.floor(\\n            ((1 << 9) - 1) * \
(Math.abs(quat[i2]) / Math.SQRT1_2) + 0.5\\n          );\\n          comp = \
comp << 10 | negbit << 9 | mag;\\n        }\\n      }\\n      \
this.view.setUint8(base, comp & 255);\\n      this.view.setUint8(base + 1, \
comp >> 8 & 255);\\n      this.view.setUint8(base + 2, comp >> 16 & 255);\\n  \
    this.view.setUint8(base + 3, comp >>> 24 & 255);\\n    }\\n    static \
quantizeSh(sh, bits2) {\\n      const value = Math.round(sh * 128) + 128;\\n  \
    const bucketSize = 1 << 8 - bits2;\\n      const quantized = \
Math.floor((value + bucketSize / 2) / bucketSize) * bucketSize;\\n      \
return Math.max(0, Math.min(255, quantized));\\n    }\\n    setSh(index, sh1, \
sh2, sh3) {\\n      const shVecs = SH_DEGREE_TO_VECS[this.shDegree] || 0;\\n  \
    const base1 = 16 + this.numSplats * 20 + index * shVecs * 3;\\n      for \
(let j = 0; j < 9; ++j) {\\n        this.view.setUint8(base1 + j, \
SpzWriter.quantizeSh(sh1[j], 5));\\n      }\\n      if (sh2) {\\n        \
const base2 = base1 + 9;\\n        for (let j = 0; j < 15; ++j) {\\n          \
this.view.setUint8(base2 + j, SpzWriter.quantizeSh(sh2[j], 4));\\n        \
}\\n        if (sh3) {\\n          const base3 = base2 + 15;\\n          for \
(let j = 0; j < 21; ++j) {\\n            this.view.setUint8(base3 + j, \
SpzWriter.quantizeSh(sh3[j], 4));\\n          }\\n        }\\n      }\\n    \
}\\n    async finalize() {\\n      const input = new \
Uint8Array(this.buffer);\\n      const stream = new ReadableStream({\\n       \
 async start(controller) {\\n          controller.enqueue(input);\\n          \
controller.close();\\n        }\\n      });\\n      const compressed = \
stream.pipeThrough(new CompressionStream(\"gzip\"));\\n      const response = \
new Response(compressed);\\n      const buffer = await \
response.arrayBuffer();\\n      console.log(\\n        \"Compressed\",\\n     \
   input.length,\\n        \"bytes to\",\\n        buffer.byteLength,\\n      \
  \"bytes\"\\n      );\\n      return new Uint8Array(buffer);\\n    }\\n  \
}\\n  async function transcodeSpz(input) {\\n    var _a2, _b2, _c;\\n    \
const splats = new SplatData();\\n    const {\\n      inputs,\\n      \
clipXyz,\\n      maxSh,\\n      fractionalBits = 12,\\n      \
opacityThreshold\\n    } = input;\\n    for (const input2 of inputs) {\\n     \
 let transformPos = function(pos) {\\n        pos.multiplyScalar(scale);\\n   \
     pos.applyQuaternion(quaternion);\\n        pos.add(translate);\\n        \
return pos;\\n      }, transformScales = function(scales) {\\n        \
scales.multiplyScalar(scale);\\n        return scales;\\n      }, \
transformQuaternion = function(quat) {\\n        \
quat.premultiply(quaternion);\\n        return quat;\\n      }, withinClip = \
function(p) {\\n        return !clip || clip.containsPoint(p);\\n      }, \
withinOpacity = function(opacity) {\\n        return opacityThreshold !== \
void 0 ? opacity >= opacityThreshold : true;\\n      };\\n      const scale = \
((_a2 = input2.transform) == null ? void 0 : _a2.scale) ?? 1;\\n      const \
quaternion = new Quaternion().fromArray(\\n        ((_b2 = input2.transform) \
== null ? void 0 : _b2.quaternion) ?? [0, 0, 0, 1]\\n      );\\n      const \
translate = new Vector3().fromArray(\\n        ((_c = input2.transform) == \
null ? void 0 : _c.translate) ?? [0, 0, 0]\\n      );\\n      const clip = \
clipXyz ? new Box3(\\n        new Vector3().fromArray(clipXyz.min),\\n        \
new Vector3().fromArray(clipXyz.max)\\n      ) : void 0;\\n      let fileType \
= input2.fileType;\\n      if (!fileType) {\\n        fileType = \
getSplatFileType(input2.fileBytes);\\n        if (!fileType && \
input2.pathOrUrl) {\\n          fileType = \
getSplatFileTypeFromPath(input2.pathOrUrl);\\n        }\\n      }\\n      \
switch (fileType) {\\n        case SplatFileType.PLY: {\\n          const ply \
= new PlyReader({ fileBytes: input2.fileBytes });\\n          await \
ply.parseHeader();\\n          let lastIndex = null;\\n          \
ply.parseSplats(\\n            (index, x2, y, z, scaleX, scaleY, scaleZ, \
quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\\n              const \
center = transformPos(new Vector3(x2, y, z));\\n              if \
(withinClip(center) && withinOpacity(opacity)) {\\n                lastIndex \
= splats.pushSplat();\\n                splats.setCenter(lastIndex, center.x, \
center.y, center.z);\\n                const scales = transformScales(\\n     \
             new Vector3(scaleX, scaleY, scaleZ)\\n                );\\n      \
          splats.setScale(lastIndex, scales.x, scales.y, scales.z);\\n        \
        const quaternion2 = transformQuaternion(\\n                  new \
Quaternion(quatX, quatY, quatZ, quatW)\\n                );\\n                \
splats.setQuaternion(\\n                  lastIndex,\\n                  \
quaternion2.x,\\n                  quaternion2.y,\\n                  \
quaternion2.z,\\n                  quaternion2.w\\n                );\\n      \
          splats.setOpacity(lastIndex, opacity);\\n                \
splats.setColor(lastIndex, r, g, b);\\n              } else {\\n              \
  lastIndex = null;\\n              }\\n            },\\n            (index, \
sh1, sh2, sh3) => {\\n              if (sh1 && lastIndex !== null) {\\n       \
         splats.setSh1(lastIndex, sh1);\\n              }\\n              if \
(sh2 && lastIndex !== null) {\\n                splats.setSh2(lastIndex, \
sh2);\\n              }\\n              if (sh3 && lastIndex !== null) {\\n   \
             splats.setSh3(lastIndex, sh3);\\n              }\\n            \
}\\n          );\\n          break;\\n        }\\n        case \
SplatFileType.SPZ: {\\n          const spz2 = new SpzReader({ fileBytes: \
input2.fileBytes });\\n          await spz2.parseHeader();\\n          const \
mapping = new Int32Array(spz2.numSplats);\\n          mapping.fill(-1);\\n    \
      const centers = new Float32Array(spz2.numSplats * 3);\\n          const \
center = new Vector3();\\n          spz2.parseSplats(\\n            (index, \
x2, y, z) => {\\n              const center2 = transformPos(new Vector3(x2, \
y, z));\\n              centers[index * 3] = center2.x;\\n              \
centers[index * 3 + 1] = center2.y;\\n              centers[index * 3 + 2] = \
center2.z;\\n            },\\n            (index, alpha) => {\\n              \
center.fromArray(centers, index * 3);\\n              if (withinClip(center) \
&& withinOpacity(alpha)) {\\n                mapping[index] = \
splats.pushSplat();\\n                splats.setCenter(mapping[index], \
center.x, center.y, center.z);\\n                \
splats.setOpacity(mapping[index], alpha);\\n              }\\n            \
},\\n            (index, r, g, b) => {\\n              if (mapping[index] >= \
0) {\\n                splats.setColor(mapping[index], r, g, b);\\n           \
   }\\n            },\\n            (index, scaleX, scaleY, scaleZ) => {\\n   \
           if (mapping[index] >= 0) {\\n                const scales = \
transformScales(\\n                  new Vector3(scaleX, scaleY, scaleZ)\\n   \
             );\\n                splats.setScale(mapping[index], scales.x, \
scales.y, scales.z);\\n              }\\n            },\\n            (index, \
quatX, quatY, quatZ, quatW) => {\\n              if (mapping[index] >= 0) \
{\\n                const quaternion2 = transformQuaternion(\\n               \
   new Quaternion(quatX, quatY, quatZ, quatW)\\n                );\\n         \
       splats.setQuaternion(\\n                  mapping[index],\\n           \
       quaternion2.x,\\n                  quaternion2.y,\\n                  \
quaternion2.z,\\n                  quaternion2.w\\n                );\\n      \
        }\\n            },\\n            (index, sh1, sh2, sh3) => {\\n       \
       if (mapping[index] >= 0) {\\n                \
splats.setSh1(mapping[index], sh1);\\n                if (sh2) {\\n           \
       splats.setSh2(mapping[index], sh2);\\n                }\\n             \
   if (sh3) {\\n                  splats.setSh3(mapping[index], sh3);\\n      \
          }\\n              }\\n            }\\n          );\\n          \
break;\\n        }\\n        case SplatFileType.SPLAT:\\n          \
decodeAntiSplat(\\n            input2.fileBytes,\\n            (numSplats) => \
{\\n            },\\n            (index, x2, y, z, scaleX, scaleY, scaleZ, \
quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\\n              const \
center = transformPos(new Vector3(x2, y, z));\\n              if \
(withinClip(center) && withinOpacity(opacity)) {\\n                const \
index2 = splats.pushSplat();\\n                splats.setCenter(index2, \
center.x, center.y, center.z);\\n                const scales = \
transformScales(\\n                  new Vector3(scaleX, scaleY, scaleZ)\\n   \
             );\\n                splats.setScale(index2, scales.x, scales.y, \
scales.z);\\n                const quaternion2 = transformQuaternion(\\n      \
            new Quaternion(quatX, quatY, quatZ, quatW)\\n                \
);\\n                splats.setQuaternion(\\n                  index2,\\n     \
             quaternion2.x,\\n                  quaternion2.y,\\n             \
     quaternion2.z,\\n                  quaternion2.w\\n                );\\n \
               splats.setOpacity(index2, opacity);\\n                \
splats.setColor(index2, r, g, b);\\n              }\\n            }\\n        \
  );\\n          break;\\n        case SplatFileType.KSPLAT: {\\n          \
let lastIndex = null;\\n          decodeKsplat(\\n            \
input2.fileBytes,\\n            (numSplats) => {\\n            },\\n          \
  (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, \
opacity, r, g, b) => {\\n              const center = transformPos(new \
Vector3(x2, y, z));\\n              if (withinClip(center) && \
withinOpacity(opacity)) {\\n                lastIndex = \
splats.pushSplat();\\n                splats.setCenter(lastIndex, center.x, \
center.y, center.z);\\n                const scales = transformScales(\\n     \
             new Vector3(scaleX, scaleY, scaleZ)\\n                );\\n      \
          splats.setScale(lastIndex, scales.x, scales.y, scales.z);\\n        \
        const quaternion2 = transformQuaternion(\\n                  new \
Quaternion(quatX, quatY, quatZ, quatW)\\n                );\\n                \
splats.setQuaternion(\\n                  lastIndex,\\n                  \
quaternion2.x,\\n                  quaternion2.y,\\n                  \
quaternion2.z,\\n                  quaternion2.w\\n                );\\n      \
          splats.setOpacity(lastIndex, opacity);\\n                \
splats.setColor(lastIndex, r, g, b);\\n              } else {\\n              \
  lastIndex = null;\\n              }\\n            },\\n            (index, \
sh1, sh2, sh3) => {\\n              if (lastIndex !== null) {\\n              \
  splats.setSh1(lastIndex, sh1);\\n                if (sh2) {\\n              \
    splats.setSh2(lastIndex, sh2);\\n                }\\n                if \
(sh3) {\\n                  splats.setSh3(lastIndex, sh3);\\n                \
}\\n              }\\n            }\\n          );\\n          break;\\n      \
  }\\n        default:\\n          throw new Error(`transcodeSpz not \
implemented for ${fileType}`);\\n      }\\n    }\\n    const shDegree = \
Math.min(\\n      maxSh ?? 3,\\n      splats.sh3 ? 3 : splats.sh2 ? 2 : \
splats.sh1 ? 1 : 0\\n    );\\n    const spz = new SpzWriter({\\n      \
numSplats: splats.numSplats,\\n      shDegree,\\n      fractionalBits,\\n     \
 flagAntiAlias: true\\n    });\\n    for (let i2 = 0; i2 < splats.numSplats; \
++i2) {\\n      const i3 = i2 * 3;\\n      const i4 = i2 * 4;\\n      \
spz.setCenter(\\n        i2,\\n        splats.centers[i3],\\n        \
splats.centers[i3 + 1],\\n        splats.centers[i3 + 2]\\n      );\\n      \
spz.setScale(\\n        i2,\\n        splats.scales[i3],\\n        \
splats.scales[i3 + 1],\\n        splats.scales[i3 + 2]\\n      );\\n      \
spz.setQuat(\\n        i2,\\n        splats.quaternions[i4],\\n        \
splats.quaternions[i4 + 1],\\n        splats.quaternions[i4 + 2],\\n        \
splats.quaternions[i4 + 3]\\n      );\\n      spz.setAlpha(i2, \
splats.opacities[i2]);\\n      spz.setRgb(\\n        i2,\\n        \
splats.colors[i3],\\n        splats.colors[i3 + 1],\\n        \
splats.colors[i3 + 2]\\n      );\\n      if (splats.sh1 && shDegree >= 1) \
{\\n        spz.setSh(\\n          i2,\\n          splats.sh1.slice(i2 * 9, \
(i2 + 1) * 9),\\n          shDegree >= 2 && splats.sh2 ? splats.sh2.slice(i2 \
* 15, (i2 + 1) * 15) : void 0,\\n          shDegree >= 3 && splats.sh3 ? \
splats.sh3.slice(i2 * 21, (i2 + 1) * 21) : void 0\\n        );\\n      }\\n   \
 }\\n    const spzBytes = await spz.finalize();\\n    return { fileBytes: \
spzBytes, clippedCount: spz.clippedCount };\\n  }\\n  async function \
onMessage(event) {\\n    const { name, args, id } = event.data;\\n    let \
result = void 0;\\n    let error = void 0;\\n    try {\\n      switch (name) \
{\\n        case \"unpackPly\": {\\n          const { packedArray, fileBytes, \
splatEncoding } = args;\\n          const decoded = await unpackPly({\\n      \
      packedArray,\\n            fileBytes,\\n            splatEncoding\\n    \
      });\\n          result = {\\n            id,\\n            numSplats: \
decoded.numSplats,\\n            packedArray: decoded.packedArray,\\n         \
   extra: decoded.extra\\n          };\\n          break;\\n        }\\n      \
  case \"decodeSpz\": {\\n          const { fileBytes, splatEncoding } = \
args;\\n          const decoded = await unpackSpz(fileBytes, \
splatEncoding);\\n          result = {\\n            id,\\n            \
numSplats: decoded.numSplats,\\n            packedArray: \
decoded.packedArray,\\n            extra: decoded.extra\\n          };\\n     \
     break;\\n        }\\n        case \"decodeAntiSplat\": {\\n          \
const { fileBytes, splatEncoding } = args;\\n          const decoded = \
unpackAntiSplat(fileBytes, splatEncoding);\\n          result = {\\n          \
  id,\\n            numSplats: decoded.numSplats,\\n            packedArray: \
decoded.packedArray\\n          };\\n          break;\\n        }\\n        \
case \"decodeKsplat\": {\\n          const { fileBytes, splatEncoding } = \
args;\\n          const decoded = unpackKsplat(fileBytes, splatEncoding);\\n  \
        result = {\\n            id,\\n            numSplats: \
decoded.numSplats,\\n            packedArray: decoded.packedArray,\\n         \
   extra: decoded.extra\\n          };\\n          break;\\n        }\\n      \
  case \"decodePcSogs\": {\\n          const { fileBytes, extraFiles, \
splatEncoding } = args;\\n          const json = JSON.parse(\\n            \
new TextDecoder().decode(fileBytes)\\n          );\\n          const decoded \
= await unpackPcSogs(json, extraFiles, splatEncoding);\\n          result = \
{\\n            id,\\n            numSplats: decoded.numSplats,\\n            \
packedArray: decoded.packedArray,\\n            extra: decoded.extra\\n       \
   };\\n          break;\\n        }\\n        case \"decodePcSogsZip\": {\\n \
         const { fileBytes, splatEncoding } = args;\\n          const decoded \
= await unpackPcSogsZip(fileBytes, splatEncoding);\\n          result = {\\n  \
          id,\\n            numSplats: decoded.numSplats,\\n            \
packedArray: decoded.packedArray,\\n            extra: decoded.extra\\n       \
   };\\n          break;\\n        }\\n        case \"sortSplats\": {\\n      \
    const { totalSplats, readback, ordering } = args;\\n          result = \
{\\n            id,\\n            readback,\\n            ...sortSplats({ \
totalSplats, readback, ordering })\\n          };\\n          break;\\n       \
 }\\n        case \"sortDoubleSplats\": {\\n          const { numSplats, \
readback, ordering } = args;\\n          {\\n            result = {\\n        \
      id,\\n              readback,\\n              ordering,\\n              \
activeSplats: sort_splats(numSplats, readback, ordering)\\n            };\\n  \
        }\\n          break;\\n        }\\n        case \"sort32Splats\": \
{\\n          const { numSplats, readback, ordering } = args;\\n          \
{\\n            result = {\\n              id,\\n              readback,\\n   \
           ordering,\\n              activeSplats: sort32_splats(numSplats, \
readback, ordering)\\n            };\\n          }\\n          break;\\n      \
  }\\n        case \"transcodeSpz\": {\\n          const input = args;\\n     \
     const spzBytes = await transcodeSpz(input);\\n          result = {\\n    \
        id,\\n            fileBytes: spzBytes,\\n            input\\n         \
 };\\n          break;\\n        }\\n        default: {\\n          throw new \
Error(`Unknown name: ${name}`);\\n        }\\n      }\\n    } catch (e) {\\n  \
    error = e;\\n      console.error(error);\\n    }\\n    \
self.postMessage(\\n      { id, result, error },\\n      { transfer: \
getArrayBuffers(result) }\\n    );\\n  }\\n  async function unpackPly({\\n    \
packedArray,\\n    fileBytes,\\n    splatEncoding\\n  }) {\\n    const ply = \
new PlyReader({ fileBytes });\\n    await ply.parseHeader();\\n    const \
numSplats = ply.numSplats;\\n    const extra = {};\\n    ply.parseSplats(\\n  \
    (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, \
opacity, r, g, b) => {\\n        setPackedSplat(\\n          packedArray,\\n  \
        index,\\n          x2,\\n          y,\\n          z,\\n          \
scaleX,\\n          scaleY,\\n          scaleZ,\\n          quatX,\\n         \
 quatY,\\n          quatZ,\\n          quatW,\\n          opacity,\\n         \
 r,\\n          g,\\n          b,\\n          splatEncoding\\n        );\\n   \
   },\\n      (index, sh1, sh2, sh3) => {\\n        if (sh1) {\\n          if \
(!extra.sh1) {\\n            extra.sh1 = new Uint32Array(numSplats * 2);\\n   \
       }\\n          encodeSh1Rgb(extra.sh1, index, sh1, splatEncoding);\\n   \
     }\\n        if (sh2) {\\n          if (!extra.sh2) {\\n            \
extra.sh2 = new Uint32Array(numSplats * 4);\\n          }\\n          \
encodeSh2Rgb(extra.sh2, index, sh2, splatEncoding);\\n        }\\n        if \
(sh3) {\\n          if (!extra.sh3) {\\n            extra.sh3 = new \
Uint32Array(numSplats * 4);\\n          }\\n          encodeSh3Rgb(extra.sh3, \
index, sh3, splatEncoding);\\n        }\\n      }\\n    );\\n    return { \
packedArray, numSplats, extra };\\n  }\\n  async function \
unpackSpz(fileBytes, splatEncoding) {\\n    const spz = new SpzReader({ \
fileBytes });\\n    await spz.parseHeader();\\n    const numSplats = \
spz.numSplats;\\n    const maxSplats = computeMaxSplats(numSplats);\\n    \
const packedArray = new Uint32Array(maxSplats * 4);\\n    const extra = \
{};\\n    await spz.parseSplats(\\n      (index, x2, y, z) => {\\n        \
setPackedSplatCenter(packedArray, index, x2, y, z);\\n      },\\n      \
(index, alpha) => {\\n        setPackedSplatOpacity(packedArray, index, \
alpha);\\n      },\\n      (index, r, g, b) => {\\n        \
setPackedSplatRgb(packedArray, index, r, g, b, splatEncoding);\\n      },\\n  \
    (index, scaleX, scaleY, scaleZ) => {\\n        setPackedSplatScales(\\n   \
       packedArray,\\n          index,\\n          scaleX,\\n          \
scaleY,\\n          scaleZ,\\n          splatEncoding\\n        );\\n      \
},\\n      (index, quatX, quatY, quatZ, quatW) => {\\n        \
setPackedSplatQuat(packedArray, index, quatX, quatY, quatZ, quatW);\\n      \
},\\n      (index, sh1, sh2, sh3) => {\\n        if (sh1) {\\n          if \
(!extra.sh1) {\\n            extra.sh1 = new Uint32Array(numSplats * 2);\\n   \
       }\\n          encodeSh1Rgb(extra.sh1, index, sh1, splatEncoding);\\n   \
     }\\n        if (sh2) {\\n          if (!extra.sh2) {\\n            \
extra.sh2 = new Uint32Array(numSplats * 4);\\n          }\\n          \
encodeSh2Rgb(extra.sh2, index, sh2, splatEncoding);\\n        }\\n        if \
(sh3) {\\n          if (!extra.sh3) {\\n            extra.sh3 = new \
Uint32Array(numSplats * 4);\\n          }\\n          encodeSh3Rgb(extra.sh3, \
index, sh3, splatEncoding);\\n        }\\n      }\\n    );\\n    return { \
packedArray, numSplats, extra };\\n  }\\n  const DEPTH_INFINITY_F16 = \
31744;\\n  const DEPTH_SIZE_16 = DEPTH_INFINITY_F16 + 1;\\n  let depthArray16 \
= null;\\n  function sortSplats({\\n    totalSplats,\\n    readback,\\n    \
ordering\\n  }) {\\n    if (!depthArray16) {\\n      depthArray16 = new \
Uint32Array(DEPTH_SIZE_16);\\n    }\\n    depthArray16.fill(0);\\n    const \
readbackUint32 = readback.map((layer) => new Uint32Array(layer.buffer));\\n   \
 const layerSize = readbackUint32[0].length;\\n    const numLayers = \
Math.ceil(totalSplats / layerSize);\\n    let layerBase = 0;\\n    for (let \
layer = 0; layer < numLayers; ++layer) {\\n      const readbackLayer = \
readbackUint32[layer];\\n      const layerSplats = \
Math.min(readbackLayer.length, totalSplats - layerBase);\\n      for (let i2 \
= 0; i2 < layerSplats; ++i2) {\\n        const pri = readbackLayer[i2] & \
32767;\\n        if (pri < DEPTH_INFINITY_F16) {\\n          \
depthArray16[pri] += 1;\\n        }\\n      }\\n      layerBase += \
layerSplats;\\n    }\\n    let activeSplats = 0;\\n    for (let j = 0; j < \
DEPTH_SIZE_16; ++j) {\\n      const nextIndex = activeSplats + \
depthArray16[j];\\n      depthArray16[j] = activeSplats;\\n      activeSplats \
= nextIndex;\\n    }\\n    layerBase = 0;\\n    for (let layer = 0; layer < \
numLayers; ++layer) {\\n      const readbackLayer = readbackUint32[layer];\\n \
     const layerSplats = Math.min(readbackLayer.length, totalSplats - \
layerBase);\\n      for (let i2 = 0; i2 < layerSplats; ++i2) {\\n        \
const pri = readbackLayer[i2] & 32767;\\n        if (pri < \
DEPTH_INFINITY_F16) {\\n          ordering[depthArray16[pri]] = layerBase + \
i2;\\n          depthArray16[pri] += 1;\\n        }\\n      }\\n      \
layerBase += layerSplats;\\n    }\\n    if (depthArray16[DEPTH_SIZE_16 - 1] \
!== activeSplats) {\\n      throw new Error(\\n        `Expected \
${activeSplats} active splats but got ${depthArray16[DEPTH_SIZE_16 - 1]}`\\n  \
    );\\n    }\\n    return { activeSplats, ordering };\\n  }\\n  const \
messageBuffer = [];\\n  function bufferMessage(event) {\\n    \
messageBuffer.push(event);\\n  }\\n  async function initialize() {\\n    \
self.addEventListener(\"message\", bufferMessage);\\n    await \
__wbg_init();\\n    self.removeEventListener(\"message\", bufferMessage);\\n  \
  self.addEventListener(\"message\", onMessage);\\n    for (const event of \
messageBuffer) {\\n      onMessage(event);\\n    }\\n    messageBuffer.length \
= 0;\\n  }\\n  initialize().catch(console.error);\\n})();\\n//# \
sourceMappingURL=worker-CVv1zjxY.js.map\\n';\nconst blob = typeof self !== \
\"undefined\" && self.Blob && new Blob([jsContent], { type: \
\"text/javascript;charset=utf-8\" });\nfunction WorkerWrapper(options) {\n  \
let objURL;\n  try {\n    objURL = blob && (self.URL || \
self.webkitURL).createObjectURL(blob);\n    if (!objURL) throw \"\";\n    \
const worker = new Worker(objURL, {\n      name: options == null ? void 0 : \
options.name\n    });\n    worker.addEventListener(\"error\", () => {\n      \
(self.URL || self.webkitURL).revokeObjectURL(objURL);\n    });\n    return \
worker;\n  } catch (e) {\n    return new Worker(\n      \
\"data:text/javascript;charset=utf-8,\" + encodeURIComponent(jsContent),\n    \
  {\n        name: options == null ? void 0 : options.name\n      }\n    );\n \
 } finally {\n    objURL && (self.URL || \
self.webkitURL).revokeObjectURL(objURL);\n  }\n}\nclass SplatWorker {\n  \
constructor() {\n    this.messages = {};\n    this.messageIdNext = 0;\n    \
this.worker = new WorkerWrapper();\n    this.worker.onmessage = (event) => \
this.onMessage(event);\n  }\n  makeMessageId() {\n    return \
++this.messageIdNext;\n  }\n  makeMessagePromiseId() {\n    const id = \
this.makeMessageId();\n    const promise = new Promise((resolve, reject) => \
{\n      this.messages[id] = { resolve, reject };\n    });\n    return { id, \
promise };\n  }\n  onMessage(event) {\n    const { id, result, error } = \
event.data;\n    const handler = this.messages[id];\n    if (handler) {\n     \
 delete this.messages[id];\n      if (error) {\n        \
handler.reject(error);\n      } else {\n        handler.resolve(result);\n    \
  }\n    }\n  }\n  // Invoke an RPC on the worker with the given name and \
arguments.\n  // The normal usage of a worker is to run one activity at a \
time,\n  // but this function allows for concurrent calls, tagging each \
request\n  // with a unique message Id and awaiting a response to that same \
Id.\n  // The method will automatically transfer any ArrayBuffers in the\n  \
// arguments to the worker. If you'd like to transfer a copy of a\n  // \
buffer then you must clone it before passing to this function.\n  async \
call(name, args) {\n    const { id, promise } = \
this.makeMessagePromiseId();\n    this.worker.postMessage(\n      { name, \
args, id },\n      { transfer: getArrayBuffers(args) }\n    );\n    return \
promise;\n  }\n}\nlet maxWorkers = 4;\nlet numWorkers = 0;\nconst freeWorkers \
= [];\nconst workerQueue = [];\nasync function allocWorker() {\n  const \
worker = freeWorkers.shift();\n  if (worker) {\n    return worker;\n  }\n  if \
(numWorkers < maxWorkers) {\n    const worker2 = new SplatWorker();\n    \
numWorkers += 1;\n    return worker2;\n  }\n  return new Promise((resolve) => \
{\n    workerQueue.push(resolve);\n  });\n}\nfunction freeWorker(worker) {\n  \
if (numWorkers > maxWorkers) {\n    numWorkers -= 1;\n    return;\n  }\n  \
const waiter = workerQueue.shift();\n  if (waiter) {\n    waiter(worker);\n   \
 return;\n  }\n  freeWorkers.push(worker);\n}\nasync function \
withWorker(callback) {\n  const worker = await allocWorker();\n  try {\n    \
return await callback(worker);\n  } finally {\n    freeWorker(worker);\n  \
}\n}\nclass SplatLoader extends Loader {\n  constructor(manager) {\n    \
super(manager);\n    this.fileLoader = new FileLoader(manager);\n  }\n  \
load(url, onLoad, onProgress, onError) {\n    const resolvedURL = \
this.manager.resolveURL(\n      (this.path ?? \"\") + (url ?? \"\")\n    );\n \
   const headers = new Headers(this.requestHeader);\n    const credentials = \
this.withCredentials ? \"include\" : \"same-origin\";\n    const request = \
new Request(resolvedURL, { headers, credentials });\n    let fileType = \
this.fileType;\n    this.manager.itemStart(resolvedURL);\n    \
fetchWithProgress(request, onProgress).then(async (input) => {\n      var \
_a2;\n      const progresses = [\n        new ProgressEvent(\"progress\", {\n \
         lengthComputable: true,\n          loaded: input.byteLength,\n       \
   total: input.byteLength\n        })\n      ];\n      function \
updateProgresses() {\n        if (onProgress) {\n          const \
lengthComputable = progresses.every((p) => {\n            return \
p.lengthComputable || p.loaded === 0 && p.total === 0;\n          });\n       \
   const loaded = progresses.reduce((sum, p) => sum + p.loaded, 0);\n         \
 const total = progresses.reduce((sum, p) => sum + p.total, 0);\n          \
onProgress(\n            new ProgressEvent(\"progress\", {\n              \
lengthComputable,\n              loaded,\n              total\n            \
})\n          );\n        }\n      }\n      const extraFiles = {};\n      \
const promises = [];\n      const pcSogsJson = tryPcSogs(input);\n      if \
(fileType === \"pcsogs\") {\n        if (pcSogsJson === void 0) {\n          \
throw new Error(\"Invalid PC SOGS file\");\n        }\n      }\n      if \
(pcSogsJson !== void 0) {\n        fileType = \"pcsogs\";\n        for (const \
key of [\"means\", \"scales\", \"quats\", \"sh0\", \"shN\"]) {\n          \
const prop = pcSogsJson[key];\n          if (prop) {\n            for (const \
file of prop.files) {\n              const fileUrl = new URL(file, \
resolvedURL).toString();\n              const progressIndex = \
progresses.length;\n              progresses.push(new \
ProgressEvent(\"progress\"));\n              \
this.manager.itemStart(fileUrl);\n              const request2 = new \
Request(fileUrl, { headers, credentials });\n              const promise = \
fetchWithProgress(request2, (progress) => {\n                \
progresses[progressIndex] = progress;\n                updateProgresses();\n  \
            }).then((data) => {\n                extraFiles[file] = data;\n   \
           }).catch((error) => {\n                \
this.manager.itemError(fileUrl);\n                throw error;\n              \
}).finally(() => {\n                this.manager.itemEnd(fileUrl);\n          \
    });\n              promises.push(promise);\n            }\n          }\n  \
      }\n      }\n      await Promise.all(promises);\n      if (onLoad) {\n   \
     const splatEncoding = ((_a2 = this.packedSplats) == null ? void 0 : \
_a2.splatEncoding) ?? DEFAULT_SPLAT_ENCODING;\n        const decoded = await \
unpackSplats({\n          input,\n          extraFiles,\n          \
fileType,\n          pathOrUrl: resolvedURL,\n          splatEncoding\n       \
 });\n        if (this.packedSplats) {\n          \
this.packedSplats.initialize(decoded);\n          \
onLoad(this.packedSplats);\n        } else {\n          onLoad(new \
PackedSplats(decoded));\n        }\n      }\n    }).catch((error) => {\n      \
this.manager.itemError(resolvedURL);\n      onError == null ? void 0 : \
onError(error);\n    }).finally(() => {\n      \
this.manager.itemEnd(resolvedURL);\n    });\n  }\n  async loadAsync(url, \
onProgress) {\n    return new Promise((resolve, reject) => {\n      \
this.load(\n        url,\n        (decoded) => {\n          \
resolve(decoded);\n        },\n        onProgress,\n        reject\n      \
);\n    });\n  }\n  parse(packedSplats) {\n    return new SplatMesh({ \
packedSplats });\n  }\n}\nasync function fetchWithProgress(request, \
onProgress) {\n  const response = await fetch(request);\n  if (!response.ok) \
{\n    throw new Error(\n      `${response.status} \"${response.statusText}\" \
fetching URL: ${request.url}`\n    );\n  }\n  if (!response.body) {\n    \
throw new Error(`Response body is null for URL: ${request.url}`);\n  }\n  \
const reader = response.body.getReader();\n  const contentLength = \
Number.parseInt(\n    response.headers.get(\"Content-Length\") || \"0\"\n  \
);\n  const total = Number.isNaN(contentLength) ? 0 : contentLength;\n  let \
loaded = 0;\n  const chunks = [];\n  while (true) {\n    const { done, value \
} = await reader.read();\n    if (done) {\n      break;\n    }\n    \
chunks.push(value);\n    loaded += value.length;\n    if (onProgress) {\n     \
 onProgress(\n        new ProgressEvent(\"progress\", {\n          \
lengthComputable: total !== 0,\n          loaded,\n          total\n        \
})\n      );\n    }\n  }\n  const bytes = new Uint8Array(loaded);\n  let \
offset = 0;\n  for (const chunk of chunks) {\n    bytes.set(chunk, offset);\n \
   offset += chunk.length;\n  }\n  return bytes.buffer;\n}\nvar SplatFileType \
= /* @__PURE__ */ ((SplatFileType2) => {\n  SplatFileType2[\"PLY\"] = \
\"ply\";\n  SplatFileType2[\"SPZ\"] = \"spz\";\n  SplatFileType2[\"SPLAT\"] = \
\"splat\";\n  SplatFileType2[\"KSPLAT\"] = \"ksplat\";\n  \
SplatFileType2[\"PCSOGS\"] = \"pcsogs\";\n  SplatFileType2[\"PCSOGSZIP\"] = \
\"pcsogszip\";\n  return SplatFileType2;\n})(SplatFileType || {});\nfunction \
getSplatFileType(fileBytes) {\n  const view = new \
DataView(fileBytes.buffer);\n  if ((view.getUint32(0, true) & 16777215) === \
7957616) {\n    return \"ply\";\n  }\n  if ((view.getUint32(0, true) & \
16777215) === 559903) {\n    const header = decompressPartialGzip(fileBytes, \
4);\n    const gView = new DataView(header.buffer);\n    if \
(gView.getUint32(0, true) === 1347635022) {\n      return \"spz\";\n    }\n   \
 return void 0;\n  }\n  if (view.getUint32(0, true) === 67324752) {\n    if \
(tryPcSogsZip(fileBytes)) {\n      return \"pcsogszip\";\n    }\n    return \
void 0;\n  }\n  return void 0;\n}\nfunction getFileExtension(pathOrUrl) {\n  \
const noTrailing = pathOrUrl.split(/[?#]/, 1)[0];\n  const lastSlash = \
Math.max(\n    noTrailing.lastIndexOf(\"/\"),\n    \
noTrailing.lastIndexOf(\"\\\\\")\n  );\n  const filename = \
noTrailing.slice(lastSlash + 1);\n  const lastDot = \
filename.lastIndexOf(\".\");\n  if (lastDot <= 0 || lastDot === \
filename.length - 1) {\n    return \"\";\n  }\n  return \
filename.slice(lastDot + 1).toLowerCase();\n}\nfunction \
getSplatFileTypeFromPath(pathOrUrl) {\n  const extension = \
getFileExtension(pathOrUrl);\n  if (extension === \"ply\") {\n    return \
\"ply\";\n  }\n  if (extension === \"spz\") {\n    return \"spz\";\n  }\n  if \
(extension === \"splat\") {\n    return \"splat\";\n  }\n  if (extension === \
\"ksplat\") {\n    return \"ksplat\";\n  }\n  if (extension === \"sog\") {\n  \
  return \"pcsogszip\";\n  }\n  return void 0;\n}\nfunction isPcSogs(input) \
{\n  return tryPcSogs(input) !== void 0;\n}\nfunction tryPcSogs(input) {\n  \
try {\n    let text;\n    if (typeof input === \"string\") {\n      text = \
input;\n    } else {\n      const fileBytes = input instanceof ArrayBuffer ? \
new Uint8Array(input) : input;\n      if (fileBytes.length > 65536) {\n       \
 return void 0;\n      }\n      text = new TextDecoder().decode(fileBytes);\n \
   }\n    const json = JSON.parse(text);\n    if (!json || typeof json !== \
\"object\" || Array.isArray(json)) {\n      return void 0;\n    }\n    const \
isVersion2 = json.version === 2;\n    for (const key of [\"means\", \
\"scales\", \"quats\", \"sh0\"]) {\n      if (!json[key] || typeof json[key] \
!== \"object\" || Array.isArray(json[key])) {\n        return void 0;\n      \
}\n      if (isVersion2) {\n        if (!json[key].files) {\n          return \
void 0;\n        }\n        if ((key === \"scales\" || key === \"sh0\") && \
!json[key].codebook) {\n          return void 0;\n        }\n        if (key \
=== \"means\" && (!json[key].mins || !json[key].maxs)) {\n          return \
void 0;\n        }\n      } else {\n        if (!json[key].shape || \
!json[key].files) {\n          return void 0;\n        }\n        if (key !== \
\"quats\" && (!json[key].mins || !json[key].maxs)) {\n          return void \
0;\n        }\n      }\n    }\n    return json;\n  } catch {\n    return void \
0;\n  }\n}\nfunction tryPcSogsZip(input) {\n  try {\n    const fileBytes = \
input instanceof ArrayBuffer ? new Uint8Array(input) : input;\n    let \
metaFilename = null;\n    const unzipped = unzipSync(fileBytes, {\n      \
filter: ({ name }) => {\n        const filename = \
name.split(/[\\\\/]/).pop();\n        if (filename === \"meta.json\") {\n     \
     metaFilename = name;\n          return true;\n        }\n        return \
false;\n      }\n    });\n    if (!metaFilename) {\n      return void 0;\n    \
}\n    const json = tryPcSogs(unzipped[metaFilename]);\n    if (!json) {\n    \
  return void 0;\n    }\n    return { name: metaFilename, json };\n  } catch \
{\n    return void 0;\n  }\n}\nasync function unpackSplats({\n  input,\n  \
extraFiles,\n  fileType,\n  pathOrUrl,\n  splatEncoding\n}) {\n  const \
fileBytes = input instanceof ArrayBuffer ? new Uint8Array(input) : input;\n  \
let splatFileType = fileType;\n  if (!fileType) {\n    splatFileType = \
getSplatFileType(fileBytes);\n    if (!splatFileType && pathOrUrl) {\n      \
splatFileType = getSplatFileTypeFromPath(pathOrUrl);\n    }\n  }\n  switch \
(splatFileType) {\n    case \"ply\": {\n      const ply = new PlyReader({ \
fileBytes });\n      await ply.parseHeader();\n      const numSplats = \
ply.numSplats;\n      const maxSplats = \
getTextureSize(numSplats).maxSplats;\n      const args = {\n        \
fileBytes,\n        packedArray: new Uint32Array(maxSplats * 4),\n        \
splatEncoding\n      };\n      return await withWorker(async (worker) => {\n  \
      const { packedArray, numSplats: numSplats2, extra } = await \
worker.call(\n          \"unpackPly\",\n          args\n        );\n        \
return { packedArray, numSplats: numSplats2, extra };\n      });\n    }\n    \
case \"spz\": {\n      return await withWorker(async (worker) => {\n        \
const { packedArray, numSplats, extra } = await worker.call(\n          \
\"decodeSpz\",\n          {\n            fileBytes,\n            \
splatEncoding\n          }\n        );\n        return { packedArray, \
numSplats, extra };\n      });\n    }\n    case \"splat\": {\n      return \
await withWorker(async (worker) => {\n        const { packedArray, numSplats \
} = await worker.call(\n          \"decodeAntiSplat\",\n          {\n         \
   fileBytes,\n            splatEncoding\n          }\n        );\n        \
return { packedArray, numSplats };\n      });\n    }\n    case \"ksplat\": \
{\n      return await withWorker(async (worker) => {\n        const { \
packedArray, numSplats, extra } = await worker.call(\n          \
\"decodeKsplat\",\n          { fileBytes, splatEncoding }\n        );\n       \
 return { packedArray, numSplats, extra };\n      });\n    }\n    case \
\"pcsogs\": {\n      return await withWorker(async (worker) => {\n        \
const { packedArray, numSplats, extra } = await worker.call(\n          \
\"decodePcSogs\",\n          { fileBytes, extraFiles, splatEncoding }\n       \
 );\n        return { packedArray, numSplats, extra };\n      });\n    }\n    \
case \"pcsogszip\": {\n      return await withWorker(async (worker) => {\n    \
    const { packedArray, numSplats, extra } = await worker.call(\n          \
\"decodePcSogsZip\",\n          { fileBytes, splatEncoding }\n        );\n    \
    return { packedArray, numSplats, extra };\n      });\n    }\n    default: \
{\n      throw new Error(`Unknown splat file type: ${splatFileType}`);\n    \
}\n  }\n}\nclass SplatData {\n  constructor({ maxSplats = 1 } = {}) {\n    \
this.numSplats = 0;\n    this.maxSplats = \
getTextureSize(maxSplats).maxSplats;\n    this.centers = new \
Float32Array(this.maxSplats * 3);\n    this.scales = new \
Float32Array(this.maxSplats * 3);\n    this.quaternions = new \
Float32Array(this.maxSplats * 4);\n    this.opacities = new \
Float32Array(this.maxSplats);\n    this.colors = new \
Float32Array(this.maxSplats * 3);\n  }\n  pushSplat() {\n    const index = \
this.numSplats;\n    this.ensureIndex(index);\n    this.numSplats += 1;\n    \
return index;\n  }\n  unpushSplat(index) {\n    if (index === this.numSplats \
- 1) {\n      this.numSplats -= 1;\n    } else {\n      throw new \
Error(\"Cannot unpush splat from non-last position\");\n    }\n  }\n  \
ensureCapacity(numSplats) {\n    if (numSplats > this.maxSplats) {\n      \
const targetSplats = Math.max(numSplats, this.maxSplats * 2);\n      const \
newCenters = new Float32Array(targetSplats * 3);\n      const newScales = new \
Float32Array(targetSplats * 3);\n      const newQuaternions = new \
Float32Array(targetSplats * 4);\n      const newOpacities = new \
Float32Array(targetSplats);\n      const newColors = new \
Float32Array(targetSplats * 3);\n      newCenters.set(this.centers);\n      \
newScales.set(this.scales);\n      newQuaternions.set(this.quaternions);\n    \
  newOpacities.set(this.opacities);\n      newColors.set(this.colors);\n      \
this.centers = newCenters;\n      this.scales = newScales;\n      \
this.quaternions = newQuaternions;\n      this.opacities = newOpacities;\n    \
  this.colors = newColors;\n      if (this.sh1) {\n        const newSh1 = new \
Float32Array(targetSplats * 9);\n        newSh1.set(this.sh1);\n        \
this.sh1 = newSh1;\n      }\n      if (this.sh2) {\n        const newSh2 = \
new Float32Array(targetSplats * 15);\n        newSh2.set(this.sh2);\n        \
this.sh2 = newSh2;\n      }\n      if (this.sh3) {\n        const newSh3 = \
new Float32Array(targetSplats * 21);\n        newSh3.set(this.sh3);\n        \
this.sh3 = newSh3;\n      }\n      this.maxSplats = targetSplats;\n    }\n  \
}\n  ensureIndex(index) {\n    this.ensureCapacity(index + 1);\n  }\n  \
setCenter(index, x, y, z) {\n    this.centers[index * 3] = x;\n    \
this.centers[index * 3 + 1] = y;\n    this.centers[index * 3 + 2] = z;\n  }\n \
 setScale(index, scaleX, scaleY, scaleZ) {\n    this.scales[index * 3] = \
scaleX;\n    this.scales[index * 3 + 1] = scaleY;\n    this.scales[index * 3 \
+ 2] = scaleZ;\n  }\n  setQuaternion(index, x, y, z, w) {\n    \
this.quaternions[index * 4] = x;\n    this.quaternions[index * 4 + 1] = y;\n  \
  this.quaternions[index * 4 + 2] = z;\n    this.quaternions[index * 4 + 3] = \
w;\n  }\n  setOpacity(index, opacity) {\n    this.opacities[index] = \
opacity;\n  }\n  setColor(index, r, g, b) {\n    this.colors[index * 3] = \
r;\n    this.colors[index * 3 + 1] = g;\n    this.colors[index * 3 + 2] = \
b;\n  }\n  setSh1(index, sh1) {\n    if (!this.sh1) {\n      this.sh1 = new \
Float32Array(this.maxSplats * 9);\n    }\n    for (let j = 0; j < 9; ++j) {\n \
     this.sh1[index * 9 + j] = sh1[j];\n    }\n  }\n  setSh2(index, sh2) {\n  \
  if (!this.sh2) {\n      this.sh2 = new Float32Array(this.maxSplats * 15);\n \
   }\n    for (let j = 0; j < 15; ++j) {\n      this.sh2[index * 15 + j] = \
sh2[j];\n    }\n  }\n  setSh3(index, sh3) {\n    if (!this.sh3) {\n      \
this.sh3 = new Float32Array(this.maxSplats * 21);\n    }\n    for (let j = 0; \
j < 21; ++j) {\n      this.sh3[index * 21 + j] = sh3[j];\n    }\n  }\n}\nvar \
computeUvec4_default = \"precision highp float;\\nprecision highp \
int;\\nprecision highp sampler2D;\\nprecision highp usampler2D;\\nprecision \
highp isampler2D;\\nprecision highp sampler2DArray;\\nprecision highp \
usampler2DArray;\\nprecision highp isampler2DArray;\\nprecision highp \
sampler3D;\\nprecision highp usampler3D;\\nprecision highp \
isampler3D;\\n\\n#include <splatDefines>\\n\\nuniform uint \
targetLayer;\\nuniform int targetBase;\\nuniform int targetCount;\\n\\nout \
uvec4 target;\\n\\n{{ GLOBALS }}\\n\\nvoid produceSplat(int index) {\\n    {{ \
STATEMENTS }}\\n}\\n\\nvoid main() {\\n    int targetIndex = int(targetLayer \
<< SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) \
+ int(gl_FragCoord.x);\\n    int index = targetIndex - targetBase;\\n\\n    \
if ((index >= 0) && (index < targetCount)) {\\n        \
produceSplat(index);\\n    } else {\\n        target = uvec4(0u, 0u, 0u, \
0u);\\n    }\\n}\";\nconst DEFAULT_SPLAT_ENCODING = {\n  rgbMin: 0,\n  \
rgbMax: 1,\n  lnScaleMin: LN_SCALE_MIN,\n  lnScaleMax: LN_SCALE_MAX,\n  \
sh1Min: -1,\n  sh1Max: 1,\n  sh2Min: -1,\n  sh2Max: 1,\n  sh3Min: -1,\n  \
sh3Max: 1\n};\nconst _PackedSplats = class _PackedSplats {\n  \
constructor(options = {}) {\n    this.maxSplats = 0;\n    this.numSplats = \
0;\n    this.packedArray = null;\n    this.isInitialized = false;\n    \
this.target = null;\n    this.source = null;\n    this.needsUpdate = true;\n  \
  this.extra = {};\n    this.dyno = new DynoPackedSplats({ packedSplats: this \
});\n    this.dynoRgbMinMaxLnScaleMinMax = new DynoVec4({\n      key: \
\"rgbMinMaxLnScaleMinMax\",\n      value: new THREE.Vector4(0, 1, \
LN_SCALE_MIN, LN_SCALE_MAX),\n      update: (value) => {\n        var _a2, \
_b2, _c, _d;\n        value.set(\n          ((_a2 = this.splatEncoding) == \
null ? void 0 : _a2.rgbMin) ?? 0,\n          ((_b2 = this.splatEncoding) == \
null ? void 0 : _b2.rgbMax) ?? 1,\n          ((_c = this.splatEncoding) == \
null ? void 0 : _c.lnScaleMin) ?? LN_SCALE_MIN,\n          ((_d = \
this.splatEncoding) == null ? void 0 : _d.lnScaleMax) ?? LN_SCALE_MAX\n       \
 );\n        return value;\n      }\n    });\n    this.dynoSh1MinMax = new \
DynoVec2({\n      key: \"sh1MinMax\",\n      value: new THREE.Vector2(-1, \
1),\n      update: (value) => {\n        var _a2, _b2;\n        value.set(\n  \
        ((_a2 = this.splatEncoding) == null ? void 0 : _a2.sh1Min) ?? -1,\n   \
       ((_b2 = this.splatEncoding) == null ? void 0 : _b2.sh1Max) ?? 1\n      \
  );\n        return value;\n      }\n    });\n    this.dynoSh2MinMax = new \
DynoVec2({\n      key: \"sh2MinMax\",\n      value: new THREE.Vector2(-1, \
1),\n      update: (value) => {\n        var _a2, _b2;\n        value.set(\n  \
        ((_a2 = this.splatEncoding) == null ? void 0 : _a2.sh2Min) ?? -1,\n   \
       ((_b2 = this.splatEncoding) == null ? void 0 : _b2.sh2Max) ?? 1\n      \
  );\n        return value;\n      }\n    });\n    this.dynoSh3MinMax = new \
DynoVec2({\n      key: \"sh3MinMax\",\n      value: new THREE.Vector2(-1, \
1),\n      update: (value) => {\n        var _a2, _b2;\n        value.set(\n  \
        ((_a2 = this.splatEncoding) == null ? void 0 : _a2.sh3Min) ?? -1,\n   \
       ((_b2 = this.splatEncoding) == null ? void 0 : _b2.sh3Max) ?? 1\n      \
  );\n        return value;\n      }\n    });\n    this.initialized = \
Promise.resolve(this);\n    this.reinitialize(options);\n  }\n  \
reinitialize(options) {\n    this.isInitialized = false;\n    this.extra = \
{};\n    this.splatEncoding = options.splatEncoding;\n    if (options.url || \
options.fileBytes || options.construct) {\n      this.initialized = \
this.asyncInitialize(options).then(() => {\n        this.isInitialized = \
true;\n        return this;\n      });\n    } else {\n      \
this.initialize(options);\n      this.isInitialized = true;\n      \
this.initialized = Promise.resolve(this);\n    }\n  }\n  initialize(options) \
{\n    if (options.packedArray) {\n      this.packedArray = \
options.packedArray;\n      this.maxSplats = \
Math.floor(this.packedArray.length / 4);\n      this.maxSplats = \
Math.floor(this.maxSplats / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n      \
this.numSplats = Math.min(\n        this.maxSplats,\n        \
options.numSplats ?? Number.POSITIVE_INFINITY\n      );\n    } else {\n      \
this.maxSplats = options.maxSplats ?? 0;\n      this.numSplats = 0;\n    }\n  \
  this.extra = options.extra ?? {};\n  }\n  async asyncInitialize(options) \
{\n    const { url, fileBytes, construct } = options;\n    if (url) {\n      \
const loader = new SplatLoader();\n      loader.packedSplats = this;\n      \
await loader.loadAsync(url);\n    } else if (fileBytes) {\n      const \
unpacked = await unpackSplats({\n        input: fileBytes,\n        fileType: \
options.fileType,\n        pathOrUrl: options.fileName ?? url,\n        \
splatEncoding: options.splatEncoding ?? DEFAULT_SPLAT_ENCODING\n      });\n   \
   this.initialize(unpacked);\n    }\n    if (construct) {\n      const \
maybePromise = construct(this);\n      if (maybePromise instanceof Promise) \
{\n        await maybePromise;\n      }\n    }\n  }\n  // Call this when you \
are finished with the PackedSplats and want to free\n  // any buffers it \
holds.\n  dispose() {\n    if (this.target) {\n      this.target.dispose();\n \
     this.target = null;\n    }\n    if (this.source) {\n      \
this.source.dispose();\n      this.source = null;\n    }\n  }\n  // Ensures \
that this.packedArray can fit numSplats Gsplats. If it's too small,\n  // \
resize exponentially and copy over the original data.\n  //\n  // Typically \
you don't need to call this, because calling this.setSplat(index, ...)\n  // \
and this.pushSplat(...) will automatically call ensureSplats() so we have\n  \
// enough splats.\n  ensureSplats(numSplats) {\n    const targetSize = \
numSplats <= this.maxSplats ? this.maxSplats : (\n      // Grow exponentially \
to avoid frequent reallocations\n      Math.max(numSplats, 2 * \
this.maxSplats)\n    );\n    const currentSize = !this.packedArray ? 0 : \
this.packedArray.length / 4;\n    if (!this.packedArray || targetSize > \
currentSize) {\n      this.maxSplats = \
getTextureSize(targetSize).maxSplats;\n      const newArray2 = new \
Uint32Array(this.maxSplats * 4);\n      if (this.packedArray) {\n        \
newArray2.set(this.packedArray);\n      }\n      this.packedArray = \
newArray2;\n    }\n    return this.packedArray;\n  }\n  // Ensure the extra \
array for the given level is large enough to hold numSplats\n  \
ensureSplatsSh(level, numSplats) {\n    let wordsPerSplat;\n    let key;\n    \
if (level === 0) {\n      return this.ensureSplats(numSplats);\n    }\n    if \
(level === 1) {\n      wordsPerSplat = 2;\n      key = \"sh1\";\n    } else \
if (level === 2) {\n      wordsPerSplat = 4;\n      key = \"sh2\";\n    } \
else if (level === 3) {\n      wordsPerSplat = 4;\n      key = \"sh3\";\n    \
} else {\n      throw new Error(`Invalid level: ${level}`);\n    }\n    let \
maxSplats = !this.extra[key] ? 0 : this.extra[key].length / wordsPerSplat;\n  \
  const targetSize = numSplats <= maxSplats ? maxSplats : Math.max(numSplats, \
2 * maxSplats);\n    if (!this.extra[key] || targetSize > maxSplats) {\n      \
maxSplats = getTextureSize(targetSize).maxSplats;\n      const newArray2 = \
new Uint32Array(maxSplats * wordsPerSplat);\n      if (this.extra[key]) {\n   \
     newArray2.set(this.extra[key]);\n      }\n      this.extra[key] = \
newArray2;\n    }\n    return this.extra[key];\n  }\n  // Unpack the 16-byte \
Gsplat data at index into the Three.js components\n  // center: \
THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion,\n  // \
opacity: number 0..1, color: THREE.Color 0..1.\n  getSplat(index) {\n    if \
(!this.packedArray || index >= this.numSplats) {\n      throw new \
Error(\"Invalid index\");\n    }\n    return unpackSplat(this.packedArray, \
index, this.splatEncoding);\n  }\n  // Set all PackedSplat components at \
index with the provided Gsplat attributes\n  // (can be the same objects \
returned by getSplat). Ensures there is capacity\n  // for at least index+1 \
Gsplats.\n  setSplat(index, center, scales, quaternion, opacity, color) {\n   \
 const packedSplats = this.ensureSplats(index + 1);\n    setPackedSplat(\n    \
  packedSplats,\n      index,\n      center.x,\n      center.y,\n      \
center.z,\n      scales.x,\n      scales.y,\n      scales.z,\n      \
quaternion.x,\n      quaternion.y,\n      quaternion.z,\n      \
quaternion.w,\n      opacity,\n      color.r,\n      color.g,\n      \
color.b\n    );\n    this.numSplats = Math.max(this.numSplats, index + 1);\n  \
}\n  // Effectively calls this.setSplat(this.numSplats++, center, ...), \
useful on\n  // construction where you just want to iterate and create a \
collection of Gsplats.\n  pushSplat(center, scales, quaternion, opacity, \
color) {\n    const packedSplats = this.ensureSplats(this.numSplats + 1);\n   \
 setPackedSplat(\n      packedSplats,\n      this.numSplats,\n      \
center.x,\n      center.y,\n      center.z,\n      scales.x,\n      \
scales.y,\n      scales.z,\n      quaternion.x,\n      quaternion.y,\n      \
quaternion.z,\n      quaternion.w,\n      opacity,\n      color.r,\n      \
color.g,\n      color.b\n    );\n    ++this.numSplats;\n  }\n  // Iterate \
over Gsplats index 0..=(this.numSplats-1), unpack each Gsplat\n  // and \
invoke the callback function with the Gsplat attributes.\n  \
forEachSplat(callback) {\n    if (!this.packedArray || !this.numSplats) {\n   \
   return;\n    }\n    for (let i = 0; i < this.numSplats; ++i) {\n      \
const unpacked = unpackSplat(this.packedArray, i, this.splatEncoding);\n      \
callback(\n        i,\n        unpacked.center,\n        unpacked.scales,\n   \
     unpacked.quaternion,\n        unpacked.opacity,\n        \
unpacked.color\n      );\n    }\n  }\n  // Ensures our PackedSplats.target \
render target has enough space to generate\n  // maxSplats total Gsplats, and \
reallocate if not large enough.\n  ensureGenerate(maxSplats) {\n    if \
(this.target && (maxSplats ?? 1) <= this.maxSplats) {\n      return false;\n  \
  }\n    this.dispose();\n    const textureSize2 = getTextureSize(maxSplats \
?? 1);\n    const { width, height, depth } = textureSize2;\n    \
this.maxSplats = textureSize2.maxSplats;\n    this.target = new \
THREE.WebGLArrayRenderTarget(width, height, depth, {\n      depthBuffer: \
false,\n      stencilBuffer: false,\n      generateMipmaps: false,\n      \
magFilter: THREE.NearestFilter,\n      minFilter: THREE.NearestFilter\n    \
});\n    this.target.texture.format = THREE.RGBAIntegerFormat;\n    \
this.target.texture.type = THREE.UnsignedIntType;\n    \
this.target.texture.internalFormat = \"RGBA32UI\";\n    \
this.target.scissorTest = true;\n    return true;\n  }\n  // Given an array \
of splatCounts (.numSplats for each\n  // SplatGenerator/SplatMesh in the \
scene), compute a\n  // \"mapping layout\" in the composite array of \
generated outputs.\n  generateMapping(splatCounts) {\n    let maxSplats = \
0;\n    const mapping = splatCounts.map((numSplats) => {\n      const base = \
maxSplats;\n      const rounded = Math.ceil(numSplats / SPLAT_TEX_WIDTH) * \
SPLAT_TEX_WIDTH;\n      maxSplats += rounded;\n      return { base, count: \
numSplats };\n    });\n    return { maxSplats, mapping };\n  }\n  // Returns \
a THREE.DataArrayTexture representing the PackedSplats content as\n  // a \
Uint32x4 data array texture (2048 x 2048 x depth in size)\n  getTexture() {\n \
   if (this.target) {\n      return this.target.texture;\n    }\n    if \
(this.source || this.packedArray) {\n      const source = \
this.maybeUpdateSource();\n      return source;\n    }\n    return \
_PackedSplats.getEmpty();\n  }\n  // Check if source texture needs to be \
created/updated\n  maybeUpdateSource() {\n    if (!this.packedArray) {\n      \
throw new Error(\"No packed splats\");\n    }\n    if (this.needsUpdate || \
!this.source) {\n      this.needsUpdate = false;\n      if (this.source) {\n  \
      const { width, height, depth } = this.source.image;\n        if \
(this.maxSplats !== width * height * depth) {\n          \
this.source.dispose();\n          this.source = null;\n        }\n      }\n   \
   if (!this.source) {\n        const { width, height, depth } = \
getTextureSize(this.maxSplats);\n        this.source = new \
THREE.DataArrayTexture(\n          this.packedArray,\n          width,\n      \
    height,\n          depth\n        );\n        this.source.format = \
THREE.RGBAIntegerFormat;\n        this.source.type = THREE.UnsignedIntType;\n \
       this.source.internalFormat = \"RGBA32UI\";\n        \
this.source.needsUpdate = true;\n      } else if (this.packedArray.buffer !== \
this.source.image.data.buffer) {\n        this.source.image.data = new \
Uint8Array(this.packedArray.buffer);\n      }\n      this.source.needsUpdate \
= true;\n    }\n    return this.source;\n  }\n  // Can be used where you need \
an uninitialized THREE.DataArrayTexture like\n  // a uniform you will update \
with the result of this.getTexture() later.\n  static getEmpty() {\n    if \
(!_PackedSplats.emptySource) {\n      const { width, height, depth, maxSplats \
} = getTextureSize(1);\n      const emptyArray = new Uint32Array(maxSplats * \
4);\n      _PackedSplats.emptySource = new THREE.DataArrayTexture(\n        \
emptyArray,\n        width,\n        height,\n        depth\n      );\n      \
_PackedSplats.emptySource.format = THREE.RGBAIntegerFormat;\n      \
_PackedSplats.emptySource.type = THREE.UnsignedIntType;\n      \
_PackedSplats.emptySource.internalFormat = \"RGBA32UI\";\n      \
_PackedSplats.emptySource.needsUpdate = true;\n    }\n    return \
_PackedSplats.emptySource;\n  }\n  // Get a program and \
THREE.RawShaderMaterial for a given GsplatGenerator,\n  // generating it if \
necessary and caching the result.\n  prepareProgramMaterial(generator) {\n    \
let program = _PackedSplats.generatorProgram.get(generator);\n    if \
(!program) {\n      const graph = dynoBlock(\n        { index: \"int\" },\n   \
     { output: \"uvec4\" },\n        ({ index }) => {\n          \
generator.inputs.index = index;\n          const gsplat = \
generator.outputs.gsplat;\n          const output = outputPackedSplat(\n      \
      gsplat,\n            this.dynoRgbMinMaxLnScaleMinMax\n          );\n    \
      return { output };\n        }\n      );\n      if \
(!_PackedSplats.programTemplate) {\n        _PackedSplats.programTemplate = \
new DynoProgramTemplate(\n          computeUvec4_default\n        );\n      \
}\n      program = new DynoProgram({\n        graph,\n        inputs: { \
index: \"index\" },\n        outputs: { output: \"target\" },\n        \
template: _PackedSplats.programTemplate\n      });\n      \
Object.assign(program.uniforms, {\n        targetLayer: { value: 0 },\n       \
 targetBase: { value: 0 },\n        targetCount: { value: 0 }\n      });\n    \
  _PackedSplats.generatorProgram.set(generator, program);\n    }\n    const \
material = program.prepareMaterial();\n    \
_PackedSplats.fullScreenQuad.material = material;\n    return { program, \
material };\n  }\n  saveRenderState(renderer) {\n    return {\n      \
xrEnabled: renderer.xr.enabled,\n      autoClear: renderer.autoClear\n    \
};\n  }\n  resetRenderState(renderer, state) {\n    \
renderer.setRenderTarget(null);\n    renderer.xr.enabled = state.xrEnabled;\n \
   renderer.autoClear = state.autoClear;\n  }\n  // Executes a dyno program \
specified by generator which is any DynoBlock that\n  // maps { index: \
\"int\" } to { gsplat: Gsplat }. This is called in\n  // \
SparkRenderer.updateInternal() to re-generate Gsplats in the scene for\n  // \
SplatGenerator instances whose version is newer than what was generated\n  // \
for it last time.\n  generate({\n    generator,\n    base,\n    count,\n    \
renderer\n  }) {\n    if (!this.target) {\n      throw new Error(\"Target \
must be initialized with ensureSplats\");\n    }\n    if (base + count > \
this.maxSplats) {\n      throw new Error(\"Base + count exceeds \
maxSplats\");\n    }\n    const { program, material } = \
this.prepareProgramMaterial(generator);\n    program.update();\n    const \
renderState = this.saveRenderState(renderer);\n    const nextBase = \
Math.ceil((base + count) / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n    const \
layerSize = SPLAT_TEX_WIDTH * SPLAT_TEX_HEIGHT;\n    \
material.uniforms.targetBase.value = base;\n    \
material.uniforms.targetCount.value = count;\n    while (base < nextBase) {\n \
     const layer = Math.floor(base / layerSize);\n      \
material.uniforms.targetLayer.value = layer;\n      const layerBase = layer * \
layerSize;\n      const layerYStart = Math.floor((base - layerBase) / \
SPLAT_TEX_WIDTH);\n      const layerYEnd = Math.min(\n        \
SPLAT_TEX_HEIGHT,\n        Math.ceil((nextBase - layerBase) / \
SPLAT_TEX_WIDTH)\n      );\n      this.target.scissor.set(\n        0,\n      \
  layerYStart,\n        SPLAT_TEX_WIDTH,\n        layerYEnd - layerYStart\n   \
   );\n      renderer.setRenderTarget(this.target, layer);\n      \
renderer.xr.enabled = false;\n      renderer.autoClear = false;\n      \
_PackedSplats.fullScreenQuad.render(renderer);\n      base += SPLAT_TEX_WIDTH \
* (layerYEnd - layerYStart);\n    }\n    this.resetRenderState(renderer, \
renderState);\n    return { nextBase };\n  }\n};\n_PackedSplats.emptySource = \
null;\n_PackedSplats.programTemplate = null;\n_PackedSplats.generatorProgram \
= /* @__PURE__ */ new Map();\n_PackedSplats.fullScreenQuad = new \
FullScreenQuad(\n  new THREE.RawShaderMaterial({ visible: false })\n);\nlet \
PackedSplats = _PackedSplats;\nclass DynoPackedSplats extends DynoUniform {\n \
 constructor({ packedSplats } = {}) {\n    super({\n      key: \
\"packedSplats\",\n      type: TPackedSplats,\n      globals: () => \
[definePackedSplats],\n      value: {\n        texture: \
PackedSplats.getEmpty(),\n        numSplats: 0,\n        \
rgbMinMaxLnScaleMinMax: new THREE.Vector4(\n          0,\n          1,\n      \
    LN_SCALE_MIN,\n          LN_SCALE_MAX\n        )\n      },\n      update: \
(value) => {\n        var _a2, _b2, _c, _d, _e, _f, _g, _h, _i, _j;\n        \
value.texture = ((_a2 = this.packedSplats) == null ? void 0 : \
_a2.getTexture()) ?? PackedSplats.getEmpty();\n        value.numSplats = \
((_b2 = this.packedSplats) == null ? void 0 : _b2.numSplats) ?? 0;\n        \
value.rgbMinMaxLnScaleMinMax.set(\n          ((_d = (_c = this.packedSplats) \
== null ? void 0 : _c.splatEncoding) == null ? void 0 : _d.rgbMin) ?? 0,\n    \
      ((_f = (_e = this.packedSplats) == null ? void 0 : _e.splatEncoding) == \
null ? void 0 : _f.rgbMax) ?? 1,\n          ((_h = (_g = this.packedSplats) \
== null ? void 0 : _g.splatEncoding) == null ? void 0 : _h.lnScaleMin) ?? \
LN_SCALE_MIN,\n          ((_j = (_i = this.packedSplats) == null ? void 0 : \
_i.splatEncoding) == null ? void 0 : _j.lnScaleMax) ?? LN_SCALE_MAX\n        \
);\n        return value;\n      }\n    });\n    this.packedSplats = \
packedSplats;\n  }\n}\nclass SplatGeometry extends \
THREE.InstancedBufferGeometry {\n  constructor(ordering, activeSplats) {\n    \
super();\n    this.ordering = ordering;\n    this.setAttribute(\"position\", \
new THREE.BufferAttribute(QUAD_VERTICES, 3));\n    this.setIndex(new \
THREE.BufferAttribute(QUAD_INDICES, 1));\n    this._maxInstanceCount = \
ordering.length;\n    this.instanceCount = activeSplats;\n    this.attribute \
= new THREE.InstancedBufferAttribute(ordering, 1, false, 1);\n    \
this.attribute.setUsage(THREE.DynamicDrawUsage);\n    \
this.setAttribute(\"splatIndex\", this.attribute);\n  }\n  update(ordering, \
activeSplats) {\n    this.ordering = ordering;\n    this.attribute.array = \
ordering;\n    this.instanceCount = activeSplats;\n    \
this.attribute.addUpdateRange(0, activeSplats);\n    \
this.attribute.needsUpdate = true;\n  }\n}\nconst QUAD_VERTICES = new \
Float32Array([\n  -1,\n  -1,\n  0,\n  1,\n  -1,\n  0,\n  1,\n  1,\n  0,\n  \
-1,\n  1,\n  0\n]);\nconst QUAD_INDICES = new Uint16Array([0, 1, 2, 0, 2, \
3]);\nconst _SparkViewpoint = class _SparkViewpoint {\n  constructor(options) \
{\n    this.lastTime = null;\n    this.encodeLinear = false;\n    \
this.superXY = 1;\n    this.display = null;\n    this.sorting = null;\n    \
this.pending = null;\n    this.sortingCheck = false;\n    this.readback16 = \
new Uint16Array(0);\n    this.readback32 = new Uint32Array(0);\n    \
this.spark = options.spark;\n    this.camera = options.camera;\n    \
this.viewToWorld = options.viewToWorld ?? new THREE.Matrix4();\n    if \
(options.target) {\n      const { width, height, doubleBuffer } = \
options.target;\n      const superXY = Math.max(1, Math.min(4, \
options.target.superXY ?? 1));\n      this.superXY = superXY;\n      if \
(width * superXY > 8192 || height * superXY > 8192) {\n        throw new \
Error(\"Target size too large\");\n      }\n      this.target = new \
THREE.WebGLRenderTarget(\n        width * superXY,\n        height * \
superXY,\n        {\n          format: THREE.RGBAFormat,\n          type: \
THREE.UnsignedByteType,\n          colorSpace: THREE.SRGBColorSpace\n        \
}\n      );\n      if (doubleBuffer) {\n        this.back = new \
THREE.WebGLRenderTarget(\n          width * superXY,\n          height * \
superXY,\n          {\n            format: THREE.RGBAFormat,\n            \
type: THREE.UnsignedByteType,\n            colorSpace: THREE.SRGBColorSpace\n \
         }\n        );\n      }\n      this.encodeLinear = true;\n    }\n    \
this.onTextureUpdated = options.onTextureUpdated;\n    this.sortRadial = \
options.sortRadial ?? true;\n    this.sortDistance = options.sortDistance;\n  \
  this.sortCoorient = options.sortCoorient;\n    this.depthBias = \
options.depthBias;\n    this.sort360 = options.sort360;\n    this.sort32 = \
options.sort32;\n    this.stochastic = options.stochastic ?? false;\n    \
this.orderingFreelist = new FreeList({\n      allocate: (maxSplats) => new \
Uint32Array(maxSplats),\n      valid: (ordering, maxSplats) => \
ordering.length === maxSplats\n    });\n    this.autoUpdate = false;\n    \
this.setAutoUpdate(options.autoUpdate ?? false);\n  }\n  // Call this when \
you are done with the SparkViewpoint and want to\n  // free up its resources \
(GPU targets, pixel buffers, etc.)\n  dispose() {\n    var _a2;\n    \
this.setAutoUpdate(false);\n    if (this.target) {\n      \
this.target.dispose();\n      this.target = void 0;\n    }\n    if \
(this.back) {\n      this.back.dispose();\n      this.back = void 0;\n    }\n \
   if (this.display) {\n      \
this.spark.releaseAccumulator(this.display.accumulator);\n      \
this.display.geometry.dispose();\n      this.display = null;\n    }\n    if \
((_a2 = this.pending) == null ? void 0 : _a2.accumulator) {\n      \
this.spark.releaseAccumulator(this.pending.accumulator);\n      this.pending \
= null;\n    }\n  }\n  // Use this function to change whether this viewpoint \
will auto-update\n  // its sort order whenever the attached SparkRenderer \
updates the Gsplats.\n  // Turn this on or off depending on whether you \
expect to do renders from\n  // this viewpoint most frames.\n  \
setAutoUpdate(autoUpdate) {\n    if (!this.autoUpdate && autoUpdate) {\n      \
this.spark.autoViewpoints.push(this);\n    } else if (this.autoUpdate && \
!autoUpdate) {\n      this.spark.autoViewpoints = \
this.spark.autoViewpoints.filter(\n        (v) => v !== this\n      );\n    \
}\n    this.autoUpdate = autoUpdate;\n  }\n  // See below async \
prepareRenderPixels() for explanation of parameters.\n  // Awaiting this \
method updates the Gsplats in the scene and performs a sort of the\n  // \
Gsplats from this viewpoint, preparing it for a subsequent \
this.renderTarget()\n  // call in the same tick.\n  async prepare({\n    \
scene,\n    camera,\n    viewToWorld,\n    update,\n    forceOrigin\n  }) {\n \
   var _a2;\n    if (viewToWorld) {\n      this.viewToWorld = viewToWorld;\n  \
  } else {\n      this.camera = camera ?? this.camera;\n      if \
(this.camera) {\n        this.camera.updateMatrixWorld();\n        \
this.viewToWorld = this.camera.matrixWorld.clone();\n      }\n    }\n    \
while (update ?? true) {\n      const originToWorld = forceOrigin ? \
this.viewToWorld : void 0;\n      const updated = this.spark.updateInternal({ \
scene, originToWorld });\n      if (updated) {\n        break;\n      }\n     \
 await new Promise((resolve) => setTimeout(resolve, 10));\n    }\n    const \
accumulator = this.spark.active;\n    if (accumulator !== ((_a2 = \
this.display) == null ? void 0 : _a2.accumulator)) {\n      \
this.spark.active.refCount += 1;\n    }\n    await this.sortUpdate({ \
accumulator, viewToWorld: this.viewToWorld });\n  }\n  // Render out the \
viewpoint to the view target RGBA buffer.\n  // Swaps buffers if \
doubleBuffer: true was set.\n  // Calls onTextureUpdated(texture) with the \
resulting texture.\n  renderTarget({\n    scene,\n    camera\n  }) {\n    var \
_a2;\n    const target = this.back ?? this.target;\n    if (!target) {\n      \
throw new Error(\"Must initialize SparkViewpoint with target\");\n    }\n    \
camera = camera ?? this.camera;\n    if (!camera) {\n      throw new \
Error(\"Must provide camera\");\n    }\n    if (camera instanceof \
THREE.PerspectiveCamera) {\n      const newCam = new \
THREE.PerspectiveCamera().copy(camera, false);\n      newCam.aspect = \
target.width / target.height;\n      newCam.updateProjectionMatrix();\n      \
camera = newCam;\n    }\n    this.viewToWorld = camera.matrixWorld.clone();\n \
   try {\n      this.spark.renderer.setRenderTarget(target);\n      \
this.spark.prepareViewpoint(this);\n      this.spark.renderer.render(scene, \
camera);\n    } finally {\n      \
this.spark.prepareViewpoint(this.spark.defaultView);\n      \
this.spark.renderer.setRenderTarget(null);\n    }\n    if (target !== \
this.target) {\n      [this.target, this.back] = [this.back, this.target];\n  \
  }\n    (_a2 = this.onTextureUpdated) == null ? void 0 : _a2.call(this, \
target.texture);\n  }\n  // Read back the previously rendered target image as \
a Uint8Array of packed\n  // RGBA values (in that order). If superXY was set \
greater than 1 then\n  // downsampling is performed in the target pixel array \
with simple averaging\n  // to derive the returned pixel values. Subsequent \
calls to this.readTarget()\n  // will reuse the same buffers to minimize \
memory allocations.\n  async readTarget() {\n    if (!this.target) {\n      \
throw new Error(\"Must initialize SparkViewpoint with target\");\n    }\n    \
const { width, height } = this.target;\n    const byteSize = width * height * \
4;\n    if (!this.superPixels || this.superPixels.length < byteSize) {\n      \
this.superPixels = new Uint8Array(byteSize);\n    }\n    await \
this.spark.renderer.readRenderTargetPixelsAsync(\n      this.target,\n      \
0,\n      0,\n      width,\n      height,\n      this.superPixels\n    );\n   \
 const { superXY } = this;\n    if (superXY === 1) {\n      return \
this.superPixels;\n    }\n    const subWidth = width / superXY;\n    const \
subHeight = height / superXY;\n    const subSize = subWidth * subHeight * \
4;\n    if (!this.pixels || this.pixels.length < subSize) {\n      \
this.pixels = new Uint8Array(subSize);\n    }\n    const { superPixels, \
pixels } = this;\n    const super2 = superXY * superXY;\n    for (let y = 0; \
y < subHeight; y++) {\n      const row = y * subWidth;\n      for (let x = 0; \
x < subWidth; x++) {\n        const superCol = x * superXY;\n        let r = \
0;\n        let g = 0;\n        let b = 0;\n        let a = 0;\n        for \
(let sy = 0; sy < superXY; sy++) {\n          const superRow = (y * superXY + \
sy) * this.target.width;\n          for (let sx = 0; sx < superXY; sx++) {\n  \
          const superIndex = (superRow + superCol + sx) * 4;\n            r \
+= superPixels[superIndex];\n            g += superPixels[superIndex + 1];\n  \
          b += superPixels[superIndex + 2];\n            a += \
superPixels[superIndex + 3];\n          }\n        }\n        const \
pixelIndex = (row + x) * 4;\n        pixels[pixelIndex] = r / super2;\n       \
 pixels[pixelIndex + 1] = g / super2;\n        pixels[pixelIndex + 2] = b / \
super2;\n        pixels[pixelIndex + 3] = a / super2;\n      }\n    }\n    \
return pixels;\n  }\n  // Render out a viewpoint as a Uint8Array of RGBA \
values for the provided scene\n  // and any camera/viewToWorld viewpoint \
overrides. By default update is true,\n  // which triggers its SparkRenderer \
to check and potentially update the Gsplats.\n  // Setting update to false \
disables this and sorts the Gsplats as they are.\n  // Setting forceOrigin \
(default: false) to true forces the view update to\n  // recalculate the \
splats with this view origin, potentially altering any\n  // view-dependent \
effects. If you expect view-dependent effects to play a role\n  // in the \
rendering quality, enable this.\n  //\n  // Underneath, prepareRenderPixels() \
simply calls await this.prepare(...),\n  // this.renderTarget(...), and \
finally returns the result this.readTarget(),\n  // a Promise to a Uint8Array \
with RGBA values for all the pixels (potentially\n  // downsampled if the \
superXY parameter was used). These steps can also be called\n  // manually, \
for example if you need to alter the scene before and after\n  // \
this.renderTarget(...) to hide UI elements from being rendered.\n  async \
prepareRenderPixels({\n    scene,\n    camera,\n    viewToWorld,\n    \
update,\n    forceOrigin\n  }) {\n    await this.prepare({ scene, camera, \
viewToWorld, update, forceOrigin });\n    this.renderTarget({ scene, camera \
});\n    return this.readTarget();\n  }\n  // This is called automatically by \
SparkRenderer, there is no need to call it!\n  // The method cannot be \
private because then SparkRenderer would\n  // not be able to call it.\n  \
autoPoll({ accumulator }) {\n    var _a2, _b2, _c, _d;\n    if (this.camera) \
{\n      this.camera.updateMatrixWorld();\n      this.viewToWorld = \
this.camera.matrixWorld.clone();\n    }\n    let needsSort = false;\n    let \
displayed = false;\n    if (!this.display) {\n      needsSort = true;\n    } \
else if (accumulator) {\n      needsSort = true;\n      const { \
mappingVersion } = this.display.accumulator;\n      if \
(accumulator.mappingVersion === mappingVersion) {\n        \
this.spark.releaseAccumulator(this.display.accumulator);\n        \
this.display.accumulator = accumulator;\n        displayed = true;\n      }\n \
   }\n    const latestView = ((_a2 = this.sorting) == null ? void 0 : \
_a2.viewToWorld) ?? ((_b2 = this.display) == null ? void 0 : \
_b2.viewToWorld);\n    if (latestView && !withinCoorientDist({\n      \
matrix1: this.viewToWorld,\n      matrix2: latestView,\n      // By default \
update sort each 1 cm\n      maxDistance: this.sortDistance ?? 0.01,\n      \
// By default for radial sort, update for intermittent movement so that\n     \
 // we bring back splats culled by being behind the camera.\n      // For \
depth sort, small rotations can change sort order a lot, so\n      // update \
sort for even small rotations.\n      minCoorient: this.sortCoorient ?? \
this.sortRadial ? 0.99 : 0.999\n    })) {\n      needsSort = true;\n    }\n   \
 if (!needsSort) {\n      return;\n    }\n    if (accumulator) {\n      \
accumulator.refCount += 1;\n    }\n    if (accumulator && ((_c = \
this.pending) == null ? void 0 : _c.accumulator) && this.pending.accumulator \
!== ((_d = this.display) == null ? void 0 : _d.accumulator)) {\n      \
this.spark.releaseAccumulator(this.pending.accumulator);\n    }\n    \
this.pending = { accumulator, viewToWorld: this.viewToWorld, displayed };\n   \
 this.driveSort();\n  }\n  async driveSort() {\n    var _a2;\n    while \
(true) {\n      if (this.sorting || !this.pending) {\n        return;\n      \
}\n      const { viewToWorld, displayed } = this.pending;\n      let \
accumulator = this.pending.accumulator ?? ((_a2 = this.display) == null ? \
void 0 : _a2.accumulator);\n      if (!accumulator) {\n        accumulator = \
this.spark.active;\n        accumulator.refCount += 1;\n      }\n      \
this.pending = null;\n      if (!accumulator) {\n        throw new Error(\"No \
accumulator to sort\");\n      }\n      this.sorting = { viewToWorld };\n     \
 await this.sortUpdate({ accumulator, viewToWorld, displayed });\n      \
this.sorting = null;\n    }\n  }\n  async sortUpdate({\n    accumulator,\n    \
viewToWorld,\n    displayed = false\n  }) {\n    if (this.sortingCheck) {\n   \
   throw new Error(\"Only one sort at a time\");\n    }\n    \
this.sortingCheck = true;\n    accumulator = accumulator ?? \
this.spark.active;\n    const { numSplats, maxSplats } = \
accumulator.splats;\n    let activeSplats = 0;\n    let ordering = \
this.orderingFreelist.alloc(maxSplats);\n    if (this.stochastic) {\n      \
activeSplats = numSplats;\n      for (let i = 0; i < numSplats; ++i) {\n      \
  ordering[i] = i;\n      }\n    } else if (numSplats > 0) {\n      const {\n \
       reader,\n        doubleSortReader,\n        sort32Reader,\n        \
dynoSortRadial,\n        dynoOrigin,\n        dynoDirection,\n        \
dynoDepthBias,\n        dynoSort360,\n        dynoSplats\n      } = \
_SparkViewpoint.makeSorter();\n      const sort32 = this.sort32 ?? false;\n   \
   let readback;\n      if (sort32) {\n        this.readback32 = \
reader.ensureBuffer(maxSplats, this.readback32);\n        readback = \
this.readback32;\n      } else {\n        const halfMaxSplats = \
Math.ceil(maxSplats / 2);\n        this.readback16 = \
reader.ensureBuffer(halfMaxSplats, this.readback16);\n        readback = \
this.readback16;\n      }\n      const worldToOrigin = \
accumulator.toWorld.clone().invert();\n      const viewToOrigin = \
viewToWorld.clone().premultiply(worldToOrigin);\n      dynoSortRadial.value = \
this.sort360 ? true : this.sortRadial;\n      dynoOrigin.value.set(0, 0, \
0).applyMatrix4(viewToOrigin);\n      dynoDirection.value.set(0, 0, \
-1).applyMatrix4(viewToOrigin).sub(dynoOrigin.value).normalize();\n      \
dynoDepthBias.value = this.depthBias ?? 1;\n      dynoSort360.value = \
this.sort360 ?? false;\n      dynoSplats.packedSplats = accumulator.splats;\n \
     const sortReader = sort32 ? sort32Reader : doubleSortReader;\n      \
const count = sort32 ? numSplats : Math.ceil(numSplats / 2);\n      await \
reader.renderReadback({\n        renderer: this.spark.renderer,\n        \
reader: sortReader,\n        count,\n        readback\n      });\n      const \
result = await withWorker(async (worker) => {\n        const rpcName = sort32 \
? \"sort32Splats\" : \"sortDoubleSplats\";\n        return \
worker.call(rpcName, {\n          maxSplats,\n          numSplats,\n          \
readback,\n          ordering\n        });\n      });\n      if (sort32) {\n  \
      this.readback32 = result.readback;\n      } else {\n        \
this.readback16 = result.readback;\n      }\n      ordering = \
result.ordering;\n      activeSplats = result.activeSplats;\n    }\n    \
this.updateDisplay({\n      accumulator,\n      viewToWorld,\n      \
ordering,\n      activeSplats,\n      displayed\n    });\n    \
this.sortingCheck = false;\n  }\n  updateDisplay({\n    accumulator,\n    \
viewToWorld,\n    ordering,\n    activeSplats,\n    displayed = false\n  }) \
{\n    if (!this.display) {\n      this.display = {\n        accumulator,\n   \
     viewToWorld,\n        geometry: new SplatGeometry(ordering, \
activeSplats)\n      };\n    } else {\n      if (!displayed && accumulator \
!== this.display.accumulator) {\n        \
this.spark.releaseAccumulator(this.display.accumulator);\n        \
this.display.accumulator = accumulator;\n      }\n      \
this.display.viewToWorld = viewToWorld;\n      const oldOrdering = \
this.display.geometry.ordering;\n      if (oldOrdering.length === \
ordering.length) {\n        this.display.geometry.update(ordering, \
activeSplats);\n      } else {\n        this.display.geometry.dispose();\n    \
    this.display.geometry = new SplatGeometry(ordering, activeSplats);\n      \
}\n      this.orderingFreelist.free(oldOrdering);\n    }\n    if \
(this.spark.viewpoint === this) {\n      this.spark.prepareViewpoint(this);\n \
   }\n  }\n  static makeSorter() {\n    if (!_SparkViewpoint.dynos) {\n      \
const dynoSortRadial = new DynoBool({ value: true });\n      const dynoOrigin \
= new DynoVec3({ value: new THREE.Vector3() });\n      const dynoDirection = \
new DynoVec3({ value: new THREE.Vector3() });\n      const dynoDepthBias = \
new DynoFloat({ value: 1 });\n      const dynoSort360 = new DynoBool({ value: \
false });\n      const dynoSplats = new DynoPackedSplats();\n      const \
reader = new Readback();\n      const doubleSortReader = dynoBlock(\n        \
{ index: \"int\" },\n        { rgba8: \"vec4\" },\n        ({ index }) => {\n \
         if (!index) {\n            throw new Error(\"No index\");\n          \
}\n          const sortParams = {\n            sortRadial: dynoSortRadial,\n  \
          sortOrigin: dynoOrigin,\n            sortDirection: \
dynoDirection,\n            sortDepthBias: dynoDepthBias,\n            \
sort360: dynoSort360\n          };\n          const index2 = mul(index, \
dynoConst(\"int\", 2));\n          const gsplat0 = \
readPackedSplat(dynoSplats, index2);\n          const metric0 = \
computeSortMetric({ gsplat: gsplat0, ...sortParams });\n          const \
gsplat1 = readPackedSplat(\n            dynoSplats,\n            add(index2, \
dynoConst(\"int\", 1))\n          );\n          const metric1 = \
computeSortMetric({ gsplat: gsplat1, ...sortParams });\n          const \
combined = combine({\n            vectorType: \"vec2\",\n            x: \
metric0,\n            y: metric1\n          });\n          const rgba8 = \
uintToRgba8(packHalf2x16(combined));\n          return { rgba8 };\n        \
}\n      );\n      const sort32Reader = dynoBlock(\n        { index: \"int\" \
},\n        { rgba8: \"vec4\" },\n        ({ index }) => {\n          if \
(!index) {\n            throw new Error(\"No index\");\n          }\n         \
 const sortParams = {\n            sortRadial: dynoSortRadial,\n            \
sortOrigin: dynoOrigin,\n            sortDirection: dynoDirection,\n          \
  sortDepthBias: dynoDepthBias,\n            sort360: dynoSort360\n          \
};\n          const gsplat = readPackedSplat(dynoSplats, index);\n          \
const metric = computeSortMetric({ gsplat, ...sortParams });\n          const \
rgba8 = uintToRgba8(floatBitsToUint(metric));\n          return { rgba8 };\n  \
      }\n      );\n      _SparkViewpoint.dynos = {\n        dynoSortRadial,\n \
       dynoOrigin,\n        dynoDirection,\n        dynoDepthBias,\n        \
dynoSort360,\n        dynoSplats,\n        reader,\n        \
doubleSortReader,\n        sort32Reader\n      };\n    }\n    return \
_SparkViewpoint.dynos;\n  }\n};\n_SparkViewpoint.EMPTY_TEXTURE = new \
THREE.Texture();\n_SparkViewpoint.dynos = null;\nlet SparkViewpoint = \
_SparkViewpoint;\nconst defineComputeSortMetric = unindent(`\n  float \
computeSort(Gsplat gsplat, bool sortRadial, vec3 sortOrigin, vec3 \
sortDirection, float sortDepthBias, bool sort360) {\n    if \
(!isGsplatActive(gsplat.flags)) {\n      return INFINITY;\n    }\n\n    vec3 \
center = gsplat.center - sortOrigin;\n    float biasedDepth = dot(center, \
sortDirection) + sortDepthBias;\n    if (!sort360 && (biasedDepth <= 0.0)) \
{\n      return INFINITY;\n    }\n\n    return sortRadial ? length(center) : \
biasedDepth;\n  }\n`);\nfunction computeSortMetric({\n  gsplat,\n  \
sortRadial,\n  sortOrigin,\n  sortDirection,\n  sortDepthBias,\n  sort360\n}) \
{\n  return dyno$1({\n    inTypes: {\n      gsplat: Gsplat,\n      \
sortRadial: \"bool\",\n      sortOrigin: \"vec3\",\n      sortDirection: \
\"vec3\",\n      sortDepthBias: \"float\",\n      sort360: \"bool\"\n    },\n \
   outTypes: { metric: \"float\" },\n    globals: () => [defineGsplat, \
defineComputeSortMetric],\n    inputs: {\n      gsplat,\n      sortRadial,\n  \
    sortOrigin,\n      sortDirection,\n      sortDepthBias,\n      sort360\n  \
  },\n    statements: ({ inputs, outputs }) => {\n      const {\n        \
gsplat: gsplat2,\n        sortRadial: sortRadial2,\n        sortOrigin: \
sortOrigin2,\n        sortDirection: sortDirection2,\n        sortDepthBias: \
sortDepthBias2,\n        sort360: sort3602\n      } = inputs;\n      return \
unindentLines(`\n        ${outputs.metric} = computeSort(${gsplat2}, \
${sortRadial2}, ${sortOrigin2}, ${sortDirection2}, ${sortDepthBias2}, \
${sort3602});\n      `);\n    }\n  }).outputs.metric;\n}\nclass \
SplatAccumulator {\n  constructor() {\n    this.splats = new \
PackedSplats();\n    this.toWorld = new THREE.Matrix4();\n    this.mapping = \
[];\n    this.refCount = 0;\n    this.splatsVersion = -1;\n    \
this.mappingVersion = -1;\n  }\n  ensureGenerate(maxSplats) {\n    if \
(this.splats.ensureGenerate(maxSplats)) {\n      this.mapping = [];\n    }\n  \
}\n  // Generate all Gsplats from an array of generators\n  \
generateSplats({\n    renderer,\n    modifier,\n    generators: \
generators2,\n    forceUpdate,\n    originToWorld\n  }) {\n    const mapping \
= this.mapping.reduce((map, record) => {\n      map.set(record.node, \
record);\n      return map;\n    }, /* @__PURE__ */ new Map());\n    let \
updated = 0;\n    let numSplats = 0;\n    for (const { node, generator, \
version, base, count } of generators2) {\n      const current = \
mapping.get(node);\n      if (forceUpdate || generator !== (current == null ? \
void 0 : current.generator) || version !== (current == null ? void 0 : \
current.version) || base !== (current == null ? void 0 : current.base) || \
count !== (current == null ? void 0 : current.count)) {\n        if \
(generator && count > 0) {\n          const modGenerator = \
modifier.apply(generator);\n          try {\n            \
this.splats.generate({\n              generator: modGenerator,\n              \
base,\n              count,\n              renderer\n            });\n        \
  } catch (error) {\n            node.generator = void 0;\n            \
node.generatorError = error;\n          }\n          updated += 1;\n        \
}\n      }\n      numSplats = Math.max(numSplats, base + count);\n    }\n    \
this.splats.numSplats = numSplats;\n    this.toWorld = originToWorld;\n    \
this.mapping = generators2;\n    return updated !== 0;\n  }\n  // Check if \
this accumulator has exactly the same generator mapping as\n  // the previous \
one. If so, we can reuse the Gsplat sort order.\n  hasCorrespondence(other) \
{\n    if (this.mapping.length !== other.mapping.length) {\n      return \
false;\n    }\n    return this.mapping.every(({ node, base, count }, i) => \
{\n      const {\n        node: otherNode,\n        base: otherBase,\n        \
count: otherCount\n      } = other.mapping[i];\n      return node === \
otherNode && base === otherBase && count === otherCount;\n    });\n  \
}\n}\nvar splatDefines_default = \"const float LN_SCALE_MIN = -12.0;\\nconst \
float LN_SCALE_MAX = 9.0;\\n\\nconst uint SPLAT_TEX_WIDTH_BITS = 11u;\\nconst \
uint SPLAT_TEX_HEIGHT_BITS = 11u;\\nconst uint SPLAT_TEX_DEPTH_BITS = \
11u;\\nconst uint SPLAT_TEX_LAYER_BITS = SPLAT_TEX_WIDTH_BITS + \
SPLAT_TEX_HEIGHT_BITS;\\n\\nconst uint SPLAT_TEX_WIDTH = 1u << \
SPLAT_TEX_WIDTH_BITS;\\nconst uint SPLAT_TEX_HEIGHT = 1u << \
SPLAT_TEX_HEIGHT_BITS;\\nconst uint SPLAT_TEX_DEPTH = 1u << \
SPLAT_TEX_DEPTH_BITS;\\n\\nconst uint SPLAT_TEX_WIDTH_MASK = SPLAT_TEX_WIDTH \
- 1u;\\nconst uint SPLAT_TEX_HEIGHT_MASK = SPLAT_TEX_HEIGHT - 1u;\\nconst \
uint SPLAT_TEX_DEPTH_MASK = SPLAT_TEX_DEPTH - 1u;\\n\\nconst uint F16_INF = \
0x7c00u;\\nconst float PI = 3.1415926535897932384626433832795;\\n\\nconst \
float INFINITY = 1.0 / 0.0;\\nconst float NEG_INFINITY = \
-INFINITY;\\n\\nfloat sqr(float x) {\\n    return x * x;\\n}\\n\\nfloat \
pow4(float x) {\\n    float x2 = x * x;\\n    return x2 * x2;\\n}\\n\\nfloat \
pow8(float x) {\\n    float x4 = pow4(x);\\n    return x4 * x4;\\n}\\n\\nvec3 \
srgbToLinear(vec3 rgb) {\\n    return pow(rgb, vec3(2.2));\\n}\\n\\nvec3 \
linearToSrgb(vec3 rgb) {\\n    return pow(rgb, vec3(1.0 / \
2.2));\\n}\\n\\nuint encodeQuatOctXy88R8(vec4 q) {\\n    \\n    if (q.w < \
0.0) {\\n        q = -q;\\n    }\\n    \\n    float theta = 2.0 * \
acos(q.w);\\n    float halfTheta = theta * 0.5;\\n    float s = \
sin(halfTheta);\\n    \\n    vec3 axis = (abs(s) < 1e-6) ? vec3(1.0, 0.0, \
0.0) : q.xyz / s;\\n    \\n    \\n    \\n    float sum = abs(axis.x) + \
abs(axis.y) + abs(axis.z);\\n    vec2 p = vec2(axis.x, axis.y) / sum;\\n    \
\\n    if (axis.z < 0.0) {\\n        float oldPx = p.x;\\n        p.x = (1.0 \
- abs(p.y)) * (p.x >= 0.0 ? 1.0 : -1.0);\\n        p.y = (1.0 - abs(oldPx)) * \
(p.y >= 0.0 ? 1.0 : -1.0);\\n    }\\n    \\n    float u_f = p.x * 0.5 + \
0.5;\\n    float v_f = p.y * 0.5 + 0.5;\\n    \\n    uint quantU = \
uint(clamp(round(u_f * 255.0), 0.0, 255.0));\\n    uint quantV = \
uint(clamp(round(v_f * 255.0), 0.0, 255.0));\\n    \\n    \\n    \\n    uint \
angleInt = uint(clamp(round((theta / 3.14159265359) * 255.0), 0.0, \
255.0));\\n    \\n    \\n    return (angleInt << 16u) | (quantV << 8u) | \
quantU;\\n}\\n\\nvec4 decodeQuatOctXy88R8(uint encoded) {\\n    \\n    uint \
quantU = encoded & uint(0xFFu);               \\n    uint quantV = (encoded \
>> 8u) & uint(0xFFu);         \\n    uint angleInt = encoded >> 16u;          \
            \\n\\n    \\n    float u_f = float(quantU) / 255.0;\\n    float \
v_f = float(quantV) / 255.0;\\n    vec2 f = vec2(u_f * 2.0 - 1.0, v_f * 2.0 - \
1.0);\\n\\n    vec3 axis = vec3(f.xy, 1.0 - abs(f.x) - abs(f.y));\\n    float \
t = max(-axis.z, 0.0);\\n    axis.x += (axis.x >= 0.0) ? -t : t;\\n    axis.y \
+= (axis.y >= 0.0) ? -t : t;\\n    axis = normalize(axis);\\n    \\n    \\n   \
 float theta = (float(angleInt) / 255.0) * 3.14159265359;\\n    float \
halfTheta = theta * 0.5;\\n    float s = sin(halfTheta);\\n    float w = \
cos(halfTheta);\\n    \\n    return vec4(axis * s, w);\\n}\\n\\n    \\n\\n    \
\\n\\n    \\n\\n    \\n\\n    \\n\\n    \\n\\n    \\n\\n    \\n\\n    \\n\\n  \
  \\n\\nuvec4 packSplatEncoding(\\n    vec3 center, vec3 scales, vec4 \
quaternion, vec4 rgba, vec4 rgbMinMaxLnScaleMinMax\\n) {\\n    float rgbMin = \
rgbMinMaxLnScaleMinMax.x;\\n    float rgbMax = rgbMinMaxLnScaleMinMax.y;\\n   \
 vec3 encRgb = (rgba.rgb - vec3(rgbMin)) / (rgbMax - rgbMin);\\n    uvec4 \
uRgba = uvec4(round(clamp(vec4(encRgb, rgba.a) * 255.0, 0.0, 255.0)));\\n\\n  \
  uint uQuat = encodeQuatOctXy88R8(quaternion);\\n    \\n    \\n    uvec3 \
uQuat3 = uvec3(uQuat & 0xffu, (uQuat >> 8u) & 0xffu, (uQuat >> 16u) & \
0xffu);\\n\\n    \\n    float lnScaleMin = rgbMinMaxLnScaleMinMax.z;\\n    \
float lnScaleMax = rgbMinMaxLnScaleMinMax.w;\\n    float lnScaleScale = 254.0 \
/ (lnScaleMax - lnScaleMin);\\n    uvec3 uScales = uvec3(\\n        (scales.x \
== 0.0) ? 0u : uint(round(clamp((log(scales.x) - lnScaleMin) * lnScaleScale, \
0.0, 254.0))) + 1u,\\n        (scales.y == 0.0) ? 0u : \
uint(round(clamp((log(scales.y) - lnScaleMin) * lnScaleScale, 0.0, 254.0))) + \
1u,\\n        (scales.z == 0.0) ? 0u : uint(round(clamp((log(scales.z) - \
lnScaleMin) * lnScaleScale, 0.0, 254.0))) + 1u\\n    );\\n\\n    \\n    uint \
word0 = uRgba.r | (uRgba.g << 8u) | (uRgba.b << 16u) | (uRgba.a << 24u);\\n   \
 uint word1 = packHalf2x16(center.xy);\\n    uint word2 = \
packHalf2x16(vec2(center.z, 0.0)) | (uQuat3.x << 16u) | (uQuat3.y << 24u);\\n \
   uint word3 = uScales.x | (uScales.y << 8u) | (uScales.z << 16u) | \
(uQuat3.z << 24u);\\n    return uvec4(word0, word1, word2, \
word3);\\n}\\n\\nuvec4 packSplat(vec3 center, vec3 scales, vec4 quaternion, \
vec4 rgba) {\\n    return packSplatEncoding(center, scales, quaternion, rgba, \
vec4(0.0, 1.0, LN_SCALE_MIN, LN_SCALE_MAX));\\n}\\n\\nvoid \
unpackSplatEncoding(uvec4 packed, out vec3 center, out vec3 scales, out vec4 \
quaternion, out vec4 rgba, vec4 rgbMinMaxLnScaleMinMax) {\\n    uint word0 = \
packed.x, word1 = packed.y, word2 = packed.z, word3 = packed.w;\\n\\n    \
uvec4 uRgba = uvec4(word0 & 0xffu, (word0 >> 8u) & 0xffu, (word0 >> 16u) & \
0xffu, (word0 >> 24u) & 0xffu);\\n    float rgbMin = \
rgbMinMaxLnScaleMinMax.x;\\n    float rgbMax = rgbMinMaxLnScaleMinMax.y;\\n   \
 rgba = (vec4(uRgba) / 255.0);\\n    rgba.rgb = rgba.rgb * (rgbMax - rgbMin) \
+ rgbMin;\\n\\n    center = vec4(\\n        unpackHalf2x16(word1),\\n        \
unpackHalf2x16(word2 & 0xffffu)\\n    ).xyz;\\n\\n    uvec3 uScales = \
uvec3(word3 & 0xffu, (word3 >> 8u) & 0xffu, (word3 >> 16u) & 0xffu);\\n    \
float lnScaleMin = rgbMinMaxLnScaleMinMax.z;\\n    float lnScaleMax = \
rgbMinMaxLnScaleMinMax.w;\\n    float lnScaleScale = (lnScaleMax - \
lnScaleMin) / 254.0;\\n    scales = vec3(\\n        (uScales.x == 0u) ? 0.0 : \
exp(lnScaleMin + float(uScales.x - 1u) * lnScaleScale),\\n        (uScales.y \
== 0u) ? 0.0 : exp(lnScaleMin + float(uScales.y - 1u) * lnScaleScale),\\n     \
   (uScales.z == 0u) ? 0.0 : exp(lnScaleMin + float(uScales.z - 1u) * \
lnScaleScale)\\n    );\\n\\n    uint uQuat = ((word2 >> 16u) & 0xFFFFu) | \
((word3 >> 8u) & 0xFF0000u);\\n    quaternion = \
decodeQuatOctXy88R8(uQuat);\\n    \\n    \\n}\\n\\nvoid unpackSplat(uvec4 \
packed, out vec3 center, out vec3 scales, out vec4 quaternion, out vec4 rgba) \
{\\n    unpackSplatEncoding(packed, center, scales, quaternion, rgba, \
vec4(0.0, 1.0, LN_SCALE_MIN, LN_SCALE_MAX));\\n}\\n\\nvec3 quatVec(vec4 q, \
vec3 v) {\\n    \\n    vec3 t = 2.0 * cross(q.xyz, v);\\n    return v + q.w * \
t + cross(q.xyz, t);\\n}\\n\\nvec4 quatQuat(vec4 q1, vec4 q2) {\\n    return \
vec4(\\n        q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,\\n     \
   q1.w * q2.y - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x,\\n        q1.w * \
q2.z + q1.x * q2.y - q1.y * q2.x + q1.z * q2.w,\\n        q1.w * q2.w - q1.x \
* q2.x - q1.y * q2.y - q1.z * q2.z\\n    );\\n}\\n\\nmat3 \
scaleQuaternionToMatrix(vec3 s, vec4 q) {\\n    \\n    return mat3(\\n        \
s.x * (1.0 - 2.0 * (q.y * q.y + q.z * q.z)),\\n        s.x * (2.0 * (q.x * \
q.y + q.w * q.z)),\\n        s.x * (2.0 * (q.x * q.z - q.w * q.y)),\\n        \
s.y * (2.0 * (q.x * q.y - q.w * q.z)),\\n        s.y * (1.0 - 2.0 * (q.x * \
q.x + q.z * q.z)),\\n        s.y * (2.0 * (q.y * q.z + q.w * q.x)),\\n        \
s.z * (2.0 * (q.x * q.z + q.w * q.y)),\\n        s.z * (2.0 * (q.y * q.z - \
q.w * q.x)),\\n        s.z * (1.0 - 2.0 * (q.x * q.x + q.y * q.y))\\n    \
);\\n}\\n\\nvec4 slerp(vec4 q1, vec4 q2, float t) {\\n    \\n    float \
cosHalfTheta = dot(q1, q2);\\n\\n    \\n    if (abs(cosHalfTheta) >= 0.999) \
{\\n        return q1;\\n    }\\n    \\n    \\n    \\n    if (cosHalfTheta < \
0.0) {\\n        q2 = -q2;\\n        cosHalfTheta = -cosHalfTheta;\\n    \
}\\n\\n    \\n    float halfTheta = acos(cosHalfTheta);\\n    float \
sinHalfTheta = sqrt(1.0 - cosHalfTheta * cosHalfTheta);\\n\\n    \\n    float \
ratioA = sin((1.0 - t) * halfTheta) / sinHalfTheta;\\n    float ratioB = \
sin(t * halfTheta) / sinHalfTheta;\\n\\n    \\n    return q1 * ratioA + q2 * \
ratioB;\\n}\\n\\nivec3 splatTexCoord(int index) {\\n    uint x = uint(index) \
& SPLAT_TEX_WIDTH_MASK;\\n    uint y = (uint(index) >> SPLAT_TEX_WIDTH_BITS) \
& SPLAT_TEX_HEIGHT_MASK;\\n    uint z = uint(index) >> \
SPLAT_TEX_LAYER_BITS;\\n    return ivec3(x, y, z);\\n}\";\nvar \
splatFragment_default = \"precision highp float;\\nprecision highp \
int;\\n\\n#include <splatDefines>\\n\\nuniform float near;\\nuniform float \
far;\\nuniform bool encodeLinear;\\nuniform float time;\\nuniform bool \
debugFlag;\\nuniform float maxStdDev;\\nuniform float minAlpha;\\nuniform \
bool stochastic;\\nuniform bool disableFalloff;\\nuniform float \
falloff;\\n\\nuniform bool splatTexEnable;\\nuniform sampler3D \
splatTexture;\\nuniform mat2 splatTexMul;\\nuniform vec2 \
splatTexAdd;\\nuniform float splatTexNear;\\nuniform float \
splatTexFar;\\nuniform float splatTexMid;\\n\\nout vec4 fragColor;\\n\\nin \
vec4 vRgba;\\nin vec2 vSplatUv;\\nin vec3 vNdc;\\nflat in uint \
vSplatIndex;\\n\\nvoid main() {\\n    vec4 rgba = vRgba;\\n\\n    float z = \
dot(vSplatUv, vSplatUv);\\n    if (!splatTexEnable) {\\n        if (z > \
(maxStdDev * maxStdDev)) {\\n            discard;\\n        }\\n    } else \
{\\n        vec2 uv = splatTexMul * vSplatUv + splatTexAdd;\\n        float \
ndcZ = vNdc.z;\\n        float depth = (2.0 * near * far) / (far + near - \
ndcZ * (far - near));\\n        float clampedFar = max(splatTexFar, \
splatTexNear);\\n        float clampedDepth = clamp(depth, splatTexNear, \
clampedFar);\\n        float logDepth = log2(clampedDepth + 1.0);\\n        \
float logNear = log2(splatTexNear + 1.0);\\n        float logFar = \
log2(clampedFar + 1.0);\\n\\n        float texZ;\\n        if (splatTexMid > \
0.0) {\\n            float clampedMid = clamp(splatTexMid, splatTexNear, \
clampedFar);\\n            float logMid = log2(clampedMid + 1.0);\\n          \
  texZ = (clampedDepth <= clampedMid) ?\\n                (0.5 * ((logDepth - \
logNear) / (logMid - logNear))) :\\n                (0.5 * ((logDepth - \
logMid) / (logFar - logMid)) + 0.5);\\n        } else {\\n            texZ = \
(logDepth - logNear) / (logFar - logNear);\\n        }\\n\\n        vec4 \
modulate = texture(splatTexture, vec3(uv, 1.0 - texZ));\\n        rgba *= \
modulate;\\n    }\\n\\n    rgba.a *= mix(1.0, exp(-0.5 * z), falloff);\\n\\n  \
  if (rgba.a < minAlpha) {\\n        discard;\\n    }\\n    if (encodeLinear) \
{\\n        rgba.rgb = srgbToLinear(rgba.rgb);\\n    }\\n\\n    if \
(stochastic) {\\n        const bool STEADY = false;\\n        uint uTime = \
STEADY ? 0u : floatBitsToUint(time);\\n        uvec2 coord = \
uvec2(gl_FragCoord.xy);\\n        uint state = uTime + 0x9e3779b9u * coord.x \
+ 0x85ebca6bu * coord.y + 0xc2b2ae35u * uint(vSplatIndex);\\n        state = \
state * 747796405u + 2891336453u;\\n        uint hash = ((state >> ((state >> \
28u) + 4u)) ^ state) * 277803737u;\\n        hash = (hash >> 22u) ^ hash;\\n  \
      float rand = float(hash) / 4294967296.0;\\n        if (rand < rgba.a) \
{\\n            fragColor = vec4(rgba.rgb, 1.0);\\n        } else {\\n        \
    discard;\\n        }\\n    } else {\\n        #ifdef \
PREMULTIPLIED_ALPHA\\n            fragColor = vec4(rgba.rgb * rgba.a, \
rgba.a);\\n        #else\\n            fragColor = rgba;\\n        #endif\\n  \
  }\\n}\";\nvar splatVertex_default = \"precision highp float;\\nprecision \
highp int;\\nprecision highp usampler2DArray;\\n\\n#include \
<splatDefines>\\n\\nattribute uint splatIndex;\\n\\nout vec4 vRgba;\\nout \
vec2 vSplatUv;\\nout vec3 vNdc;\\nflat out uint vSplatIndex;\\n\\nuniform \
vec2 renderSize;\\nuniform uint numSplats;\\nuniform vec4 \
renderToViewQuat;\\nuniform vec3 renderToViewPos;\\nuniform float \
maxStdDev;\\nuniform float minPixelRadius;\\nuniform float \
maxPixelRadius;\\nuniform float time;\\nuniform float deltaTime;\\nuniform \
bool debugFlag;\\nuniform float minAlpha;\\nuniform bool \
stochastic;\\nuniform bool enable2DGS;\\nuniform float blurAmount;\\nuniform \
float preBlurAmount;\\nuniform float focalDistance;\\nuniform float \
apertureAngle;\\nuniform float clipXY;\\nuniform float \
focalAdjustment;\\n\\nuniform usampler2DArray packedSplats;\\nuniform vec4 \
rgbMinMaxLnScaleMinMax;\\n\\nvoid main() {\\n    \\n    gl_Position = \
vec4(0.0, 0.0, 2.0, 1.0);\\n\\n    if (uint(gl_InstanceID) >= numSplats) {\\n \
       return;\\n    }\\n\\n    ivec3 texCoord;\\n    if (stochastic) {\\n    \
    texCoord = ivec3(\\n            uint(gl_InstanceID) & \
SPLAT_TEX_WIDTH_MASK,\\n            (uint(gl_InstanceID) >> \
SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK,\\n            \
(uint(gl_InstanceID) >> SPLAT_TEX_LAYER_BITS)\\n        );\\n    } else {\\n  \
      if (splatIndex == 0xffffffffu) {\\n            \\n            \
return;\\n        }\\n        texCoord = ivec3(\\n            splatIndex & \
SPLAT_TEX_WIDTH_MASK,\\n            (splatIndex >> SPLAT_TEX_WIDTH_BITS) & \
SPLAT_TEX_HEIGHT_MASK,\\n            splatIndex >> SPLAT_TEX_LAYER_BITS\\n    \
    );\\n    }\\n    uvec4 packed = texelFetch(packedSplats, texCoord, \
0);\\n\\n    vec3 center, scales;\\n    vec4 quaternion, rgba;\\n    \
unpackSplatEncoding(packed, center, scales, quaternion, rgba, \
rgbMinMaxLnScaleMinMax);\\n\\n    if (rgba.a < minAlpha) {\\n        \
return;\\n    }\\n    bvec3 zeroScales = equal(scales, vec3(0.0));\\n    if \
(all(zeroScales)) {\\n        return;\\n    }\\n\\n    \\n    vec3 viewCenter \
= quatVec(renderToViewQuat, center) + renderToViewPos;\\n\\n    \\n    if \
(viewCenter.z >= 0.0) {\\n        return;\\n    }\\n\\n    \\n    vec4 \
clipCenter = projectionMatrix * vec4(viewCenter, 1.0);\\n\\n    \\n    if \
(abs(clipCenter.z) >= clipCenter.w) {\\n        return;\\n    }\\n\\n    \\n  \
  float clip = clipXY * clipCenter.w;\\n    if (abs(clipCenter.x) > clip || \
abs(clipCenter.y) > clip) {\\n        return;\\n    }\\n\\n    \\n    \
vSplatIndex = splatIndex;\\n\\n    \\n    vec4 viewQuaternion = \
quatQuat(renderToViewQuat, quaternion);\\n\\n    if (enable2DGS && \
any(zeroScales)) {\\n        vRgba = rgba;\\n        vSplatUv = position.xy * \
maxStdDev;\\n\\n        vec3 offset;\\n        if (zeroScales.z) {\\n         \
   offset = vec3(vSplatUv.xy * scales.xy, 0.0);\\n        } else if \
(zeroScales.y) {\\n            offset = vec3(vSplatUv.x * scales.x, 0.0, \
vSplatUv.y * scales.z);\\n        } else {\\n            offset = vec3(0.0, \
vSplatUv.xy * scales.yz);\\n        }\\n\\n        vec3 viewPos = viewCenter \
+ quatVec(viewQuaternion, offset);\\n        gl_Position = projectionMatrix * \
vec4(viewPos, 1.0);\\n        vNdc = gl_Position.xyz / gl_Position.w;\\n      \
  return;\\n    }\\n\\n    \\n    vec3 ndcCenter = clipCenter.xyz / \
clipCenter.w;\\n\\n    \\n    mat3 RS = scaleQuaternionToMatrix(scales, \
viewQuaternion);\\n    mat3 cov3D = RS * transpose(RS);\\n\\n    \\n    vec2 \
scaledRenderSize = renderSize * focalAdjustment;\\n    vec2 focal = 0.5 * \
scaledRenderSize * vec2(projectionMatrix[0][0], \
projectionMatrix[1][1]);\\n\\n    mat3 J;\\n    if(isOrthographic) {\\n       \
 J = mat3(\\n            focal.x, 0.0, 0.0,\\n            0.0, focal.y, \
0.0,\\n            0.0, 0.0, 0.0\\n        );\\n    } else {\\n        float \
invZ = 1.0 / viewCenter.z;\\n        vec2 J1 = focal * invZ;\\n        vec2 \
J2 = -(J1 * viewCenter.xy) * invZ;\\n        J = mat3(\\n            J1.x, \
0.0, J2.x,\\n            0.0, J1.y, J2.y,\\n            0.0, 0.0, 0.0\\n      \
  );\\n    }\\n\\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    mat3 \
cov2D = transpose(J) * cov3D * J;\\n    float a = cov2D[0][0];\\n    float d \
= cov2D[1][1];\\n    float b = cov2D[0][1];\\n\\n    \\n    a += \
preBlurAmount;\\n    d += preBlurAmount;\\n\\n    float fullBlurAmount = \
blurAmount;\\n    if ((focalDistance > 0.0) && (apertureAngle > 0.0)) {\\n    \
    float focusRadius = maxPixelRadius;\\n        if (viewCenter.z < 0.0) \
{\\n            float focusBlur = abs((-viewCenter.z - focalDistance) / \
viewCenter.z);\\n            float apertureRadius = focal.x * tan(0.5 * \
apertureAngle);\\n            focusRadius = focusBlur * apertureRadius;\\n    \
    }\\n        fullBlurAmount = clamp(sqr(focusRadius), blurAmount, \
sqr(maxPixelRadius));\\n    }\\n\\n    \\n    float detOrig = a * d - b * \
b;\\n    a += fullBlurAmount;\\n    d += fullBlurAmount;\\n    float det = a \
* d - b * b;\\n\\n    \\n    float blurAdjust = sqrt(max(0.0, detOrig / \
det));\\n    rgba.a *= blurAdjust;\\n    if (rgba.a < minAlpha) {\\n        \
return;\\n    }\\n\\n    \\n    float eigenAvg = 0.5 * (a + d);\\n    float \
eigenDelta = sqrt(max(0.0, eigenAvg * eigenAvg - det));\\n    float eigen1 = \
eigenAvg + eigenDelta;\\n    float eigen2 = eigenAvg - eigenDelta;\\n\\n    \
vec2 eigenVec1 = normalize(vec2((abs(b) < 0.001) ? 1.0 : b, eigen1 - a));\\n  \
  vec2 eigenVec2 = vec2(eigenVec1.y, -eigenVec1.x);\\n\\n    float scale1 = \
min(maxPixelRadius, maxStdDev * sqrt(eigen1));\\n    float scale2 = \
min(maxPixelRadius, maxStdDev * sqrt(eigen2));\\n    if (scale1 < \
minPixelRadius && scale2 < minPixelRadius) {\\n        return;\\n    }\\n\\n  \
  \\n    vec2 pixelOffset = position.x * eigenVec1 * scale1 + position.y * \
eigenVec2 * scale2;\\n    vec2 ndcOffset = (2.0 / scaledRenderSize) * \
pixelOffset;\\n    vec3 ndc = vec3(ndcCenter.xy + ndcOffset, \
ndcCenter.z);\\n\\n    vRgba = rgba;\\n    vSplatUv = position.xy * \
maxStdDev;\\n    vNdc = ndc;\\n    gl_Position = vec4(ndc.xy * clipCenter.w, \
clipCenter.zw);\\n}\";\nlet shaders = null;\nfunction getShaders() {\n  if \
(!shaders) {\n    THREE.ShaderChunk.splatDefines = splatDefines_default;\n    \
shaders = {\n      splatVertex: splatVertex_default,\n      splatFragment: \
splatFragment_default\n    };\n  }\n  return shaders;\n}\nconst \
MAX_ACCUMULATORS = 5;\nconst _SparkRenderer = class _SparkRenderer extends \
THREE.Mesh {\n  constructor(options) {\n    const uniforms = \
_SparkRenderer.makeUniforms();\n    const shaders2 = getShaders();\n    const \
premultipliedAlpha = options.premultipliedAlpha ?? true;\n    const material \
= new THREE.ShaderMaterial({\n      glslVersion: THREE.GLSL3,\n      \
vertexShader: shaders2.splatVertex,\n      fragmentShader: \
shaders2.splatFragment,\n      uniforms,\n      premultipliedAlpha,\n      \
transparent: true,\n      depthTest: true,\n      depthWrite: false,\n      \
side: THREE.DoubleSide\n    });\n    super(EMPTY_GEOMETRY, material);\n    \
this.splatTexture = null;\n    this.autoViewpoints = [];\n    \
this.rotateToAccumulator = new DynoVec4({ value: new THREE.Quaternion() });\n \
   this.translateToAccumulator = new DynoVec3({ value: new THREE.Vector3() \
});\n    this.lastFrame = -1;\n    this.lastUpdateTime = null;\n    \
this.defaultCameras = [];\n    this.lastStochastic = null;\n    \
this.pendingUpdate = {\n      scene: null,\n      originToWorld: new \
THREE.Matrix4(),\n      timeoutId: -1\n    };\n    this.envViewpoint = \
null;\n    this.frustumCulled = false;\n    this.renderer = \
options.renderer;\n    this.material = material;\n    this.uniforms = \
uniforms;\n    const modifier = dynoBlock(\n      { gsplat: Gsplat },\n      \
{ gsplat: Gsplat },\n      ({ gsplat }) => {\n        if (!gsplat) {\n        \
  throw new Error(\"gsplat not defined\");\n        }\n        gsplat = \
transformGsplat(gsplat, {\n          rotate: this.rotateToAccumulator,\n      \
    translate: this.translateToAccumulator\n        });\n        return { \
gsplat };\n      }\n    );\n    this.modifier = new \
SplatModifier(modifier);\n    this.premultipliedAlpha = premultipliedAlpha;\n \
   this.autoUpdate = options.autoUpdate ?? true;\n    this.preUpdate = \
options.preUpdate ?? false;\n    this.needsUpdate = false;\n    \
this.originDistance = options.originDistance ?? 1;\n    this.maxStdDev = \
options.maxStdDev ?? Math.sqrt(8);\n    this.minPixelRadius = \
options.minPixelRadius ?? 0;\n    this.maxPixelRadius = \
options.maxPixelRadius ?? 512;\n    this.minAlpha = options.minAlpha ?? 0.5 * \
(1 / 255);\n    this.enable2DGS = options.enable2DGS ?? false;\n    \
this.preBlurAmount = options.preBlurAmount ?? 0;\n    this.blurAmount = \
options.blurAmount ?? 0.3;\n    this.focalDistance = options.focalDistance ?? \
0;\n    this.apertureAngle = options.apertureAngle ?? 0;\n    this.falloff = \
options.falloff ?? 1;\n    this.clipXY = options.clipXY ?? 1.4;\n    \
this.focalAdjustment = options.focalAdjustment ?? 1;\n    this.splatEncoding \
= options.splatEncoding ?? { ...DEFAULT_SPLAT_ENCODING };\n    this.active = \
new SplatAccumulator();\n    this.accumulatorCount = 1;\n    \
this.freeAccumulators = [];\n    for (let count = 0; count < 1; ++count) {\n  \
    this.freeAccumulators.push(new SplatAccumulator());\n      \
this.accumulatorCount += 1;\n    }\n    this.defaultView = new \
SparkViewpoint({\n      ...options.view,\n      autoUpdate: true,\n      \
spark: this\n    });\n    this.viewpoint = this.defaultView;\n    \
this.prepareViewpoint(this.viewpoint);\n    this.clock = options.clock ? \
cloneClock(options.clock) : new THREE.Clock();\n  }\n  static makeUniforms() \
{\n    const uniforms = {\n      // Size of render viewport in pixels\n      \
renderSize: { value: new THREE.Vector2() },\n      // Near and far plane \
distances\n      near: { value: 0.1 },\n      far: { value: 1e3 },\n      // \
Total number of Gsplats in packedSplats to render\n      numSplats: { value: \
0 },\n      // SplatAccumulator to view transformation quaternion\n      \
renderToViewQuat: { value: new THREE.Quaternion() },\n      // \
SplatAccumulator to view transformation translation\n      renderToViewPos: { \
value: new THREE.Vector3() },\n      // Maximum distance (in stddevs) from \
Gsplat center to render\n      maxStdDev: { value: 1 },\n      // Minimum \
pixel radius for splat rendering\n      minPixelRadius: { value: 0 },\n      \
// Maximum pixel radius for splat rendering\n      maxPixelRadius: { value: \
512 },\n      // Minimum alpha value for splat rendering\n      minAlpha: { \
value: 0.5 * (1 / 255) },\n      // Enable stochastic splat rendering\n      \
stochastic: { value: false },\n      // Enable interpreting 0-thickness \
Gsplats as 2DGS\n      enable2DGS: { value: false },\n      // Add to \
projected 2D splat covariance diagonal (thickens and brightens)\n      \
preBlurAmount: { value: 0 },\n      // Add to 2D splat covariance diagonal \
and adjust opacity (anti-aliasing)\n      blurAmount: { value: 0.3 },\n      \
// Depth-of-field distance to focal plane\n      focalDistance: { value: 0 \
},\n      // Full-width angle of aperture opening (in radians)\n      \
apertureAngle: { value: 0 },\n      // Modulate Gaussian kernal falloff. 0 \
means \"no falloff, flat shading\",\n      // 1 is normal e^-x^2 falloff.\n   \
   falloff: { value: 1 },\n      // Clip Gsplats that are clipXY times beyond \
the +-1 frustum bounds\n      clipXY: { value: 1.4 },\n      // Debug \
renderSize scale factor\n      focalAdjustment: { value: 1 },\n      // \
Enable splat texture rendering\n      splatTexEnable: { value: false },\n     \
 // Splat texture to render\n      splatTexture: { type: \"t\", value: \
_SparkRenderer.EMPTY_SPLAT_TEXTURE },\n      // Splat texture UV transform \
(multiply)\n      splatTexMul: { value: new THREE.Matrix2() },\n      // \
Splat texture UV transform (add)\n      splatTexAdd: { value: new \
THREE.Vector2() },\n      // Splat texture near plane distance\n      \
splatTexNear: { value: 0.1 },\n      // Splat texture far plane distance\n    \
  splatTexFar: { value: 1e3 },\n      // Splat texture mid plane distance, or \
0.0 to disable\n      splatTexMid: { value: 0 },\n      // Gsplat collection \
to render\n      packedSplats: { type: \"t\", value: PackedSplats.getEmpty() \
},\n      // Splat encoding ranges\n      rgbMinMaxLnScaleMinMax: { value: \
new THREE.Vector4() },\n      // Time in seconds for time-based effects\n     \
 time: { value: 0 },\n      // Delta time in seconds since last frame\n      \
deltaTime: { value: 0 },\n      // Whether to encode Gsplat with linear RGB \
(for environment mapping)\n      encodeLinear: { value: false },\n      // \
Debug flag that alternates each frame\n      debugFlag: { value: false }\n    \
};\n    return uniforms;\n  }\n  canAllocAccumulator() {\n    return \
this.freeAccumulators.length > 0 || this.accumulatorCount < \
MAX_ACCUMULATORS;\n  }\n  maybeAllocAccumulator() {\n    let accumulator = \
this.freeAccumulators.pop();\n    if (accumulator === void 0) {\n      if \
(this.accumulatorCount >= MAX_ACCUMULATORS) {\n        return null;\n      \
}\n      accumulator = new SplatAccumulator();\n      this.accumulatorCount \
+= 1;\n    }\n    accumulator.refCount = 1;\n    return accumulator;\n  }\n  \
releaseAccumulator(accumulator) {\n    accumulator.refCount -= 1;\n    if \
(accumulator.refCount === 0) {\n      \
this.freeAccumulators.push(accumulator);\n    }\n  }\n  newViewpoint(options) \
{\n    return new SparkViewpoint({ ...options, spark: this });\n  }\n  \
onBeforeRender(renderer, scene, camera) {\n    var _a2, _b2;\n    const time \
= this.time ?? this.clock.getElapsedTime();\n    const deltaTime = time - \
(this.viewpoint.lastTime ?? time);\n    this.viewpoint.lastTime = time;\n    \
const frame = renderer.info.render.frame;\n    const isNewFrame = frame !== \
this.lastFrame;\n    this.lastFrame = frame;\n    const viewpoint = \
this.viewpoint;\n    if (viewpoint === this.defaultView) {\n      if \
(isNewFrame) {\n        if (!renderer.xr.isPresenting) {\n          \
this.defaultView.viewToWorld = camera.matrixWorld.clone();\n          \
this.defaultCameras = [this.defaultView.viewToWorld];\n        } else {\n     \
     const cameras = renderer.xr.getCamera().cameras;\n          \
this.defaultCameras = cameras.map((camera2) => camera2.matrixWorld);\n        \
  this.defaultView.viewToWorld = averageOriginToWorlds(this.defaultCameras) \
?? new THREE.Matrix4();\n        }\n      }\n      if (this.autoUpdate) {\n   \
     this.update({ scene, viewToWorld: this.defaultView.viewToWorld });\n     \
 }\n    }\n    if (isNewFrame) {\n      if (this.material.premultipliedAlpha \
!== this.premultipliedAlpha) {\n        this.material.premultipliedAlpha = \
this.premultipliedAlpha;\n        this.material.needsUpdate = true;\n      \
}\n      this.uniforms.time.value = time;\n      \
this.uniforms.deltaTime.value = deltaTime;\n      \
this.uniforms.debugFlag.value = performance.now() / 1e3 % 2 < 1;\n      if \
(viewpoint.display && viewpoint.stochastic) {\n        \
this.geometry.instanceCount = this.uniforms.numSplats.value;\n      }\n    \
}\n    if (viewpoint.target) {\n      this.uniforms.renderSize.value.set(\n   \
     viewpoint.target.width,\n        viewpoint.target.height\n      );\n    \
} else {\n      const renderSize = renderer.getDrawingBufferSize(\n        \
this.uniforms.renderSize.value\n      );\n      if (renderSize.x === 1 && \
renderSize.y === 1) {\n        const baseLayer = (_a2 = \
renderer.xr.getSession()) == null ? void 0 : _a2.renderState.baseLayer;\n     \
   if (baseLayer) {\n          renderSize.x = baseLayer.framebufferWidth;\n   \
       renderSize.y = baseLayer.framebufferHeight;\n        }\n      }\n    \
}\n    const typedCamera = camera;\n    this.uniforms.near.value = \
typedCamera.near;\n    this.uniforms.far.value = typedCamera.far;\n    \
this.uniforms.encodeLinear.value = viewpoint.encodeLinear;\n    \
this.uniforms.maxStdDev.value = this.maxStdDev;\n    \
this.uniforms.minPixelRadius.value = this.minPixelRadius;\n    \
this.uniforms.maxPixelRadius.value = this.maxPixelRadius;\n    \
this.uniforms.minAlpha.value = this.minAlpha;\n    \
this.uniforms.stochastic.value = viewpoint.stochastic;\n    \
this.uniforms.enable2DGS.value = this.enable2DGS;\n    \
this.uniforms.preBlurAmount.value = this.preBlurAmount;\n    \
this.uniforms.blurAmount.value = this.blurAmount;\n    \
this.uniforms.focalDistance.value = this.focalDistance;\n    \
this.uniforms.apertureAngle.value = this.apertureAngle;\n    \
this.uniforms.falloff.value = this.falloff;\n    this.uniforms.clipXY.value = \
this.clipXY;\n    this.uniforms.focalAdjustment.value = \
this.focalAdjustment;\n    if (this.lastStochastic !== !viewpoint.stochastic) \
{\n      this.lastStochastic = !viewpoint.stochastic;\n      \
this.material.transparent = !viewpoint.stochastic;\n      \
this.material.depthWrite = viewpoint.stochastic;\n      \
this.material.needsUpdate = true;\n    }\n    if (this.splatTexture) {\n      \
const { enable, texture: texture2, multiply, add: add2, near, far, mid } = \
this.splatTexture;\n      if (enable && texture2) {\n        \
this.uniforms.splatTexEnable.value = true;\n        \
this.uniforms.splatTexture.value = texture2;\n        if (multiply) {\n       \
   this.uniforms.splatTexMul.value.fromArray(multiply.elements);\n        } \
else {\n          this.uniforms.splatTexMul.value.set(\n            0.5 / \
this.maxStdDev,\n            0,\n            0,\n            0.5 / \
this.maxStdDev\n          );\n        }\n        \
this.uniforms.splatTexAdd.value.set((add2 == null ? void 0 : add2.x) ?? 0.5, \
(add2 == null ? void 0 : add2.y) ?? 0.5);\n        \
this.uniforms.splatTexNear.value = near ?? this.uniforms.near.value;\n        \
this.uniforms.splatTexFar.value = far ?? this.uniforms.far.value;\n        \
this.uniforms.splatTexMid.value = mid ?? 0;\n      } else {\n        \
this.uniforms.splatTexEnable.value = false;\n        \
this.uniforms.splatTexture.value = _SparkRenderer.EMPTY_SPLAT_TEXTURE;\n      \
}\n    } else {\n      this.uniforms.splatTexEnable.value = false;\n      \
this.uniforms.splatTexture.value = _SparkRenderer.EMPTY_SPLAT_TEXTURE;\n    \
}\n    const accumToWorld = ((_b2 = viewpoint.display) == null ? void 0 : \
_b2.accumulator.toWorld) ?? new THREE.Matrix4();\n    const worldToCamera = \
camera.matrixWorld.clone().invert();\n    const originToCamera = \
accumToWorld.clone().premultiply(worldToCamera);\n    \
originToCamera.decompose(\n      this.uniforms.renderToViewPos.value,\n      \
this.uniforms.renderToViewQuat.value,\n      new THREE.Vector3()\n    );\n  \
}\n  // Update the uniforms for the given viewpoint.\n  // Note that the \
client expects to be able to call render() at any point\n  // to update the \
canvas, so we must switch the viewpoint back to\n  // defaultView when we're \
finished.\n  prepareViewpoint(viewpoint) {\n    var _a2, _b2, _c, _d;\n    \
this.viewpoint = viewpoint ?? this.viewpoint;\n    if \
(this.viewpoint.display) {\n      const { accumulator, geometry } = \
this.viewpoint.display;\n      this.uniforms.numSplats.value = \
accumulator.splats.numSplats;\n      this.uniforms.packedSplats.value = \
accumulator.splats.getTexture();\n      \
this.uniforms.rgbMinMaxLnScaleMinMax.value.set(\n        ((_a2 = \
accumulator.splats.splatEncoding) == null ? void 0 : _a2.rgbMin) ?? 0,\n      \
  ((_b2 = accumulator.splats.splatEncoding) == null ? void 0 : _b2.rgbMax) ?? \
1,\n        ((_c = accumulator.splats.splatEncoding) == null ? void 0 : \
_c.lnScaleMin) ?? LN_SCALE_MIN,\n        ((_d = \
accumulator.splats.splatEncoding) == null ? void 0 : _d.lnScaleMax) ?? \
LN_SCALE_MAX\n      );\n      this.geometry = geometry;\n      \
this.material.transparent = !this.viewpoint.stochastic;\n      \
this.material.depthWrite = this.viewpoint.stochastic;\n      \
this.material.needsUpdate = true;\n    } else {\n      \
this.uniforms.numSplats.value = 0;\n      this.uniforms.packedSplats.value = \
PackedSplats.getEmpty();\n      this.geometry = EMPTY_GEOMETRY;\n    }\n  }\n \
 // If spark.autoUpdate is false then you must manually call\n  // \
spark.update({ scene }) to have the scene Gsplats be re-generated.\n  \
update({\n    scene,\n    viewToWorld\n  }) {\n    const originToWorld = \
this.matrixWorld;\n    if (this.preUpdate) {\n      this.updateInternal({\n   \
     scene,\n        originToWorld: originToWorld.clone(),\n        \
viewToWorld\n      });\n    } else {\n      this.pendingUpdate.scene = \
scene;\n      this.pendingUpdate.originToWorld.copy(originToWorld);\n      if \
(this.pendingUpdate.timeoutId === -1) {\n        this.pendingUpdate.timeoutId \
= setTimeout(() => {\n          const { scene: scene2, originToWorld: \
originToWorld2 } = this.pendingUpdate;\n          this.pendingUpdate.scene = \
null;\n          this.pendingUpdate.timeoutId = -1;\n          const updated \
= this.updateInternal({\n            scene: scene2,\n            \
originToWorld: originToWorld2,\n            viewToWorld\n          });\n      \
    if (updated) {\n            const gl = this.renderer.getContext();\n      \
      gl.flush();\n          }\n        }, 1);\n      }\n    }\n  }\n  \
updateInternal({\n    scene,\n    originToWorld,\n    viewToWorld\n  }) {\n   \
 var _a2;\n    if (!this.canAllocAccumulator()) {\n      return false;\n    \
}\n    if (!originToWorld) {\n      originToWorld = this.active.toWorld;\n    \
}\n    viewToWorld = viewToWorld ?? originToWorld.clone();\n    const time = \
this.time ?? this.clock.getElapsedTime();\n    const deltaTime = time - \
(this.lastUpdateTime ?? time);\n    this.lastUpdateTime = time;\n    const \
activeMapping = this.active.mapping.reduce((map, record) => {\n      \
map.set(record.node, record);\n      return map;\n    }, /* @__PURE__ */ new \
Map());\n    const { generators: generators2, visibleGenerators, globalEdits \
} = this.compileScene(scene);\n    for (const object of generators2) {\n      \
(_a2 = object.frameUpdate) == null ? void 0 : _a2.call(object, {\n        \
object,\n        time,\n        deltaTime,\n        viewToWorld,\n        \
globalEdits\n      });\n    }\n    const visibleGenHash = new \
Set(visibleGenerators.map((g) => g.uuid));\n    for (const object of \
generators2) {\n      const current = activeMapping.get(object);\n      const \
isVisible = object.generator && visibleGenHash.has(object.uuid);\n      const \
numSplats = isVisible ? object.numSplats : 0;\n      if (this.needsUpdate || \
object.generator !== (current == null ? void 0 : current.generator) || \
numSplats !== (current == null ? void 0 : current.count)) {\n        \
object.updateVersion();\n      }\n    }\n    const originUpdate = \
!withinCoorientDist({\n      matrix1: originToWorld,\n      matrix2: \
this.active.toWorld,\n      maxDistance: this.originDistance\n    });\n    \
const needsUpdate = this.needsUpdate || originUpdate || generators2.length \
!== activeMapping.size || generators2.some((g) => {\n      var _a3;\n      \
return g.version !== ((_a3 = activeMapping.get(g)) == null ? void 0 : \
_a3.version);\n    });\n    this.needsUpdate = false;\n    let accumulator = \
null;\n    if (needsUpdate) {\n      accumulator = \
this.maybeAllocAccumulator();\n      if (!accumulator) {\n        throw new \
Error(\"Unreachable\");\n      }\n      const originChanged = \
!withinCoorientDist({\n        matrix1: originToWorld,\n        matrix2: \
this.active.toWorld,\n        maxDistance: 1e-5,\n        minCoorient: \
0.99999\n      });\n      const sorted = visibleGenerators.map((g, gIndex) => \
{\n        const lastGen = activeMapping.get(g);\n        return !lastGen ? \
[Number.POSITIVE_INFINITY, g.version, g] : (\n          // Sort by version \
deltas then by previous ordering in the mapping,\n          // attempting to \
keep unchanging generators near the front\n          // to improve our \
chances of avoiding a re-generation.\n          [g.version - lastGen.version, \
lastGen.base, g]\n        );\n      }).sort((a, b) => {\n        if (a[0] !== \
b[0]) {\n          return a[0] - b[0];\n        }\n        return a[1] - \
b[1];\n      });\n      const genOrder = sorted.map(([_version, _seq, g]) => \
g);\n      const splatCounts = genOrder.map((g) => g.numSplats);\n      const \
{ maxSplats, mapping } = accumulator.splats.generateMapping(splatCounts);\n   \
   const newGenerators = genOrder.map((node, gIndex) => {\n        const { \
base, count } = mapping[gIndex];\n        return {\n          node,\n         \
 generator: node.generator,\n          version: node.version,\n          \
base,\n          count\n        };\n      });\n      \
originToWorld.clone().invert().decompose(\n        \
this.translateToAccumulator.value,\n        this.rotateToAccumulator.value,\n \
       new THREE.Vector3()\n      );\n      \
accumulator.ensureGenerate(maxSplats);\n      \
accumulator.splats.splatEncoding = { ...this.splatEncoding };\n      \
accumulator.generateSplats({\n        renderer: this.renderer,\n        \
modifier: this.modifier,\n        generators: newGenerators,\n        \
forceUpdate: originChanged,\n        originToWorld\n      });\n      \
accumulator.splatsVersion = this.active.splatsVersion + 1;\n      const \
hasCorrespondence = accumulator.hasCorrespondence(this.active);\n      \
accumulator.mappingVersion = this.active.mappingVersion + (hasCorrespondence \
? 0 : 1);\n      this.releaseAccumulator(this.active);\n      this.active = \
accumulator;\n      this.prepareViewpoint();\n    }\n    setTimeout(() => {\n \
     for (const view of this.autoViewpoints) {\n        view.autoPoll({ \
accumulator: accumulator ?? void 0 });\n      }\n    }, 1);\n    return \
true;\n  }\n  compileScene(scene) {\n    const generators2 = [];\n    \
scene.traverse((node) => {\n      if (node instanceof SplatGenerator) {\n     \
   generators2.push(node);\n      }\n    });\n    const visibleGenerators = \
[];\n    scene.traverseVisible((node) => {\n      if (node instanceof \
SplatGenerator) {\n        visibleGenerators.push(node);\n      }\n    });\n  \
  const globalEdits = /* @__PURE__ */ new Set();\n    \
scene.traverseVisible((node) => {\n      if (node instanceof SplatEdit) {\n   \
     let ancestor = node.parent;\n        while (ancestor != null && \
!(ancestor instanceof SplatMesh)) {\n          ancestor = ancestor.parent;\n  \
      }\n        if (ancestor == null) {\n          globalEdits.add(node);\n  \
      }\n      }\n    });\n    return {\n      generators: generators2,\n     \
 visibleGenerators,\n      globalEdits: Array.from(globalEdits)\n    };\n  \
}\n  // Renders out the scene to an environment map that can be used for\n  \
// Image-based lighting or similar applications. First optionally updates \
Gsplats,\n  // sorts them with respect to the provided worldCenter, renders 6 \
cube faces,\n  // then pre-filters them using THREE.PMREMGenerator and \
returns a THREE.Texture\n  // that can assigned directly to a \
THREE.MeshStandardMaterial.envMap property.\n  async renderEnvMap({\n    \
renderer,\n    scene,\n    worldCenter,\n    size = 256,\n    near = 0.1,\n   \
 far = 1e3,\n    hideObjects = [],\n    update = false\n  }) {\n    var _a2, \
_b2;\n    if (!this.envViewpoint) {\n      this.envViewpoint = \
this.newViewpoint({ sort360: true });\n    }\n    if \
(!_SparkRenderer.cubeRender || _SparkRenderer.cubeRender.target.width !== \
size || _SparkRenderer.cubeRender.near !== near || \
_SparkRenderer.cubeRender.far !== far) {\n      if \
(_SparkRenderer.cubeRender) {\n        \
_SparkRenderer.cubeRender.target.dispose();\n      }\n      const target2 = \
new THREE.WebGLCubeRenderTarget(size, {\n        format: THREE.RGBAFormat,\n  \
      generateMipmaps: true,\n        minFilter: \
THREE.LinearMipMapLinearFilter\n      });\n      const camera2 = new \
THREE.CubeCamera(near, far, target2);\n      _SparkRenderer.cubeRender = { \
target: target2, camera: camera2, near, far };\n    }\n    if \
(!_SparkRenderer.pmrem) {\n      _SparkRenderer.pmrem = new \
THREE.PMREMGenerator(renderer ?? this.renderer);\n    }\n    const \
viewToWorld = new THREE.Matrix4().setPosition(worldCenter);\n    await ((_a2 \
= this.envViewpoint) == null ? void 0 : _a2.prepare({ scene, viewToWorld, \
update }));\n    const { target, camera } = _SparkRenderer.cubeRender;\n    \
camera.position.copy(worldCenter);\n    const objectVisibility = /* @__PURE__ \
*/ new Map();\n    for (const object of hideObjects) {\n      \
objectVisibility.set(object, object.visible);\n      object.visible = \
false;\n    }\n    this.prepareViewpoint(this.envViewpoint);\n    \
camera.update(renderer ?? this.renderer, scene);\n    \
this.prepareViewpoint(this.defaultView);\n    for (const [object, visible] of \
objectVisibility.entries()) {\n      object.visible = visible;\n    }\n    \
return (_b2 = _SparkRenderer.pmrem) == null ? void 0 : \
_b2.fromCubemap(target.texture).texture;\n  }\n  // Utility function to \
recursively set the envMap property for any\n  // THREE.MeshStandardMaterial \
within the subtree of root.\n  recurseSetEnvMap(root, envMap) {\n    \
root.traverse((node) => {\n      if (node instanceof THREE.Mesh) {\n        \
if (Array.isArray(node.material)) {\n          for (const material of \
node.material) {\n            if (material instanceof \
THREE.MeshStandardMaterial) {\n              material.envMap = envMap;\n      \
      }\n          }\n        } else {\n          if (node.material \
instanceof THREE.MeshStandardMaterial) {\n            node.material.envMap = \
envMap;\n          }\n        }\n      }\n    });\n  }\n  // Utility function \
that helps extract the Gsplat RGBA values from a\n  // SplatGenerator, \
including the result of any real-time RGBA SDF edits applied\n  // to a \
SplatMesh. This effectively \"bakes\" any computed RGBA values, which can\n  \
// now be used as a pipeline input via SplatMesh.splatRgba to inject these\n  \
// baked values into the Gsplat data.\n  getRgba({\n    generator,\n    \
rgba\n  }) {\n    const mapping = this.active.mapping.find(({ node }) => node \
=== generator);\n    if (!mapping) {\n      throw new Error(\"Generator not \
found\");\n    }\n    rgba = rgba ?? new RgbaArray();\n    \
rgba.fromPackedSplats({\n      packedSplats: this.active.splats,\n      base: \
mapping.base,\n      count: mapping.count,\n      renderer: this.renderer\n   \
 });\n    return rgba;\n  }\n  // Utility function that builds on getRgba({ \
generator }) and additionally\n  // reads back the RGBA values to the CPU in \
a Uint8Array with packed RGBA\n  // in that byte order.\n  async readRgba({\n \
   generator,\n    rgba\n  }) {\n    rgba = this.getRgba({ generator, rgba \
});\n    return rgba.read();\n  }\n};\n_SparkRenderer.cubeRender = \
null;\n_SparkRenderer.pmrem = null;\n_SparkRenderer.EMPTY_SPLAT_TEXTURE = new \
THREE.Data3DTexture();\nlet SparkRenderer = _SparkRenderer;\nconst \
EMPTY_GEOMETRY = new SplatGeometry(new Uint32Array(1), 0);\ndynoBlock(\n  { \
packedSplats: TPackedSplats, index: \"int\" },\n  { gsplat: Gsplat },\n  ({ \
packedSplats, index }) => {\n    if (!packedSplats || !index) {\n      throw \
new Error(\"Invalid input\");\n    }\n    const gsplat = \
readPackedSplat(packedSplats, index);\n    return { gsplat };\n  \
}\n);\nfunction averageOriginToWorlds(originToWorlds) {\n  if \
(originToWorlds.length === 0) {\n    return null;\n  }\n  const position = \
new THREE.Vector3();\n  const quaternion = new THREE.Quaternion();\n  const \
scale = new THREE.Vector3();\n  const positions = [];\n  const quaternions = \
[];\n  for (const matrix of originToWorlds) {\n    matrix.decompose(position, \
quaternion, scale);\n    positions.push(position);\n    \
quaternions.push(quaternion);\n  }\n  return new THREE.Matrix4().compose(\n   \
 averagePositions(positions),\n    averageQuaternions(quaternions),\n    new \
THREE.Vector3(1, 1, 1)\n  );\n}\nfunction decodeAntiSplat(fileBytes, \
initNumSplats, splatCallback) {\n  const numSplats = \
Math.floor(fileBytes.length / 32);\n  if (numSplats * 32 !== \
fileBytes.length) {\n    throw new Error(\"Invalid .splat file size\");\n  \
}\n  const f32 = new Float32Array(fileBytes.buffer);\n  for (let i = 0; i < \
numSplats; ++i) {\n    const i322 = i * 32;\n    const i8 = i * 8;\n    const \
x = f32[i8 + 0];\n    const y = f32[i8 + 1];\n    const z = f32[i8 + 2];\n    \
const scaleX = f32[i8 + 3];\n    const scaleY = f32[i8 + 4];\n    const \
scaleZ = f32[i8 + 5];\n    const r = fileBytes[i322 + 24] / 255;\n    const g \
= fileBytes[i322 + 25] / 255;\n    const b = fileBytes[i322 + 26] / 255;\n    \
const opacity = fileBytes[i322 + 27] / 255;\n    const quatW = \
(fileBytes[i322 + 28] - 128) / 128;\n    const quatX = (fileBytes[i322 + 29] \
- 128) / 128;\n    const quatY = (fileBytes[i322 + 30] - 128) / 128;\n    \
const quatZ = (fileBytes[i322 + 31] - 128) / 128;\n    splatCallback(\n      \
i,\n      x,\n      y,\n      z,\n      scaleX,\n      scaleY,\n      \
scaleZ,\n      quatX,\n      quatY,\n      quatZ,\n      quatW,\n      \
opacity,\n      r,\n      g,\n      b\n    );\n  }\n}\nconst \
KSPLAT_COMPRESSION = {\n  0: {\n    bytesPerCenter: 12,\n    bytesPerScale: \
12,\n    bytesPerRotation: 16,\n    bytesPerColor: 4,\n    \
bytesPerSphericalHarmonicsComponent: 4,\n    scaleOffsetBytes: 12,\n    \
rotationOffsetBytes: 24,\n    colorOffsetBytes: 40,\n    \
sphericalHarmonicsOffsetBytes: 44,\n    scaleRange: 1\n  },\n  1: {\n    \
bytesPerCenter: 6,\n    bytesPerScale: 6,\n    bytesPerRotation: 8,\n    \
bytesPerColor: 4,\n    bytesPerSphericalHarmonicsComponent: 2,\n    \
scaleOffsetBytes: 6,\n    rotationOffsetBytes: 12,\n    colorOffsetBytes: \
20,\n    sphericalHarmonicsOffsetBytes: 24,\n    scaleRange: 32767\n  },\n  \
2: {\n    bytesPerCenter: 6,\n    bytesPerScale: 6,\n    bytesPerRotation: \
8,\n    bytesPerColor: 4,\n    bytesPerSphericalHarmonicsComponent: 1,\n    \
scaleOffsetBytes: 6,\n    rotationOffsetBytes: 12,\n    colorOffsetBytes: \
20,\n    sphericalHarmonicsOffsetBytes: 24,\n    scaleRange: 32767\n  \
}\n};\nconst KSPLAT_SH_DEGREE_TO_COMPONENTS = {\n  0: 0,\n  1: 9,\n  2: 24,\n \
 3: 45\n};\nfunction decodeKsplat(fileBytes, initNumSplats, splatCallback, \
shCallback) {\n  var _a2;\n  const HEADER_BYTES = 4096;\n  const \
SECTION_BYTES = 1024;\n  let headerOffset = 0;\n  const header = new \
DataView(fileBytes.buffer, headerOffset, HEADER_BYTES);\n  headerOffset += \
HEADER_BYTES;\n  const versionMajor = header.getUint8(0);\n  const \
versionMinor = header.getUint8(1);\n  if (versionMajor !== 0 || versionMinor \
< 1) {\n    throw new Error(\n      `Unsupported .ksplat version: \
${versionMajor}.${versionMinor}`\n    );\n  }\n  const maxSectionCount = \
header.getUint32(4, true);\n  header.getUint32(16, true);\n  const \
compressionLevel = header.getUint16(20, true);\n  if (compressionLevel < 0 || \
compressionLevel > 2) {\n    throw new Error(`Invalid .ksplat compression \
level: ${compressionLevel}`);\n  }\n  const minSphericalHarmonicsCoeff = \
header.getFloat32(36, true) || -1.5;\n  const maxSphericalHarmonicsCoeff = \
header.getFloat32(40, true) || 1.5;\n  let sectionBase = HEADER_BYTES + \
maxSectionCount * SECTION_BYTES;\n  for (let section = 0; section < \
maxSectionCount; ++section) {\n    let getSh = function(splatOffset, \
component) {\n      if (compressionLevel === 0) {\n        return \
data.getFloat32(\n          splatOffset + sphericalHarmonicsOffsetBytes + \
component * 4,\n          true\n        );\n      }\n      if \
(compressionLevel === 1) {\n        return fromHalf(\n          \
data.getUint16(\n            splatOffset + sphericalHarmonicsOffsetBytes + \
component * 2,\n            true\n          )\n        );\n      }\n      \
const t = data.getUint8(splatOffset + sphericalHarmonicsOffsetBytes + \
component) / 255;\n      return minSphericalHarmonicsCoeff + t * \
(maxSphericalHarmonicsCoeff - minSphericalHarmonicsCoeff);\n    };\n    const \
section2 = new DataView(fileBytes.buffer, headerOffset, SECTION_BYTES);\n    \
headerOffset += SECTION_BYTES;\n    const sectionSplatCount = \
section2.getUint32(0, true);\n    const sectionMaxSplatCount = \
section2.getUint32(4, true);\n    const bucketSize = section2.getUint32(8, \
true);\n    const bucketCount = section2.getUint32(12, true);\n    const \
bucketBlockSize = section2.getFloat32(16, true);\n    const \
bucketStorageSizeBytes = section2.getUint16(20, true);\n    const \
compressionScaleRange = (section2.getUint32(24, true) || ((_a2 = \
KSPLAT_COMPRESSION[compressionLevel]) == null ? void 0 : _a2.scaleRange)) ?? \
1;\n    const fullBucketCount = section2.getUint32(32, true);\n    const \
fullBucketSplats = fullBucketCount * bucketSize;\n    const \
partiallyFilledBucketCount = section2.getUint32(36, true);\n    const \
bucketsMetaDataSizeBytes = partiallyFilledBucketCount * 4;\n    const \
bucketsStorageSizeBytes = bucketStorageSizeBytes * bucketCount + \
bucketsMetaDataSizeBytes;\n    const sphericalHarmonicsDegree = \
section2.getUint16(40, true);\n    const shComponents = \
KSPLAT_SH_DEGREE_TO_COMPONENTS[sphericalHarmonicsDegree];\n    const {\n      \
bytesPerCenter,\n      bytesPerScale,\n      bytesPerRotation,\n      \
bytesPerColor,\n      bytesPerSphericalHarmonicsComponent,\n      \
scaleOffsetBytes,\n      rotationOffsetBytes,\n      colorOffsetBytes,\n      \
sphericalHarmonicsOffsetBytes\n    } = \
KSPLAT_COMPRESSION[compressionLevel];\n    const bytesPerSplat = \
bytesPerCenter + bytesPerScale + bytesPerRotation + bytesPerColor + \
shComponents * bytesPerSphericalHarmonicsComponent;\n    const \
splatDataStorageSizeBytes = bytesPerSplat * sectionMaxSplatCount;\n    const \
storageSizeBytes = splatDataStorageSizeBytes + bucketsStorageSizeBytes;\n    \
const sh1Index = [0, 3, 6, 1, 4, 7, 2, 5, 8];\n    const sh2Index = [\n      \
9,\n      14,\n      19,\n      10,\n      15,\n      20,\n      11,\n      \
16,\n      21,\n      12,\n      17,\n      22,\n      13,\n      18,\n      \
23\n    ];\n    const sh3Index = [\n      24,\n      31,\n      38,\n      \
25,\n      32,\n      39,\n      26,\n      33,\n      40,\n      27,\n      \
34,\n      41,\n      28,\n      35,\n      42,\n      29,\n      36,\n      \
43,\n      30,\n      37,\n      44\n    ];\n    const sh1 = \
sphericalHarmonicsDegree >= 1 ? new Float32Array(3 * 3) : void 0;\n    const \
sh2 = sphericalHarmonicsDegree >= 2 ? new Float32Array(5 * 3) : void 0;\n    \
const sh3 = sphericalHarmonicsDegree >= 3 ? new Float32Array(7 * 3) : void \
0;\n    const compressionScaleFactor = bucketBlockSize / 2 / \
compressionScaleRange;\n    const bucketsBase = sectionBase + \
bucketsMetaDataSizeBytes;\n    const dataBase = sectionBase + \
bucketsStorageSizeBytes;\n    const data = new DataView(\n      \
fileBytes.buffer,\n      dataBase,\n      splatDataStorageSizeBytes\n    );\n \
   const bucketArray = new Float32Array(\n      fileBytes.buffer,\n      \
bucketsBase,\n      bucketCount * 3\n    );\n    const \
partiallyFilledBucketLengths = new Uint32Array(\n      fileBytes.buffer,\n    \
  sectionBase,\n      partiallyFilledBucketCount\n    );\n    let \
partialBucketIndex = fullBucketCount;\n    let partialBucketBase = \
fullBucketSplats;\n    for (let i = 0; i < sectionSplatCount; ++i) {\n      \
const splatOffset = i * bytesPerSplat;\n      let bucketIndex;\n      if (i < \
fullBucketSplats) {\n        bucketIndex = Math.floor(i / bucketSize);\n      \
} else {\n        const bucketLength = \
partiallyFilledBucketLengths[partialBucketIndex - fullBucketCount];\n        \
if (i >= partialBucketBase + bucketLength) {\n          partialBucketIndex += \
1;\n          partialBucketBase += bucketLength;\n        }\n        \
bucketIndex = partialBucketIndex;\n      }\n      const x = compressionLevel \
=== 0 ? data.getFloat32(splatOffset + 0, true) : (data.getUint16(splatOffset \
+ 0, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 \
* bucketIndex + 0];\n      const y = compressionLevel === 0 ? \
data.getFloat32(splatOffset + 4, true) : (data.getUint16(splatOffset + 2, \
true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * \
bucketIndex + 1];\n      const z = compressionLevel === 0 ? \
data.getFloat32(splatOffset + 8, true) : (data.getUint16(splatOffset + 4, \
true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * \
bucketIndex + 2];\n      const scaleX = compressionLevel === 0 ? \
data.getFloat32(splatOffset + scaleOffsetBytes + 0, true) : \
fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 0, true));\n      \
const scaleY = compressionLevel === 0 ? data.getFloat32(splatOffset + \
scaleOffsetBytes + 4, true) : fromHalf(data.getUint16(splatOffset + \
scaleOffsetBytes + 2, true));\n      const scaleZ = compressionLevel === 0 ? \
data.getFloat32(splatOffset + scaleOffsetBytes + 8, true) : \
fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 4, true));\n      \
const quatW = compressionLevel === 0 ? data.getFloat32(splatOffset + \
rotationOffsetBytes + 0, true) : fromHalf(\n        \
data.getUint16(splatOffset + rotationOffsetBytes + 0, true)\n      );\n      \
const quatX = compressionLevel === 0 ? data.getFloat32(splatOffset + \
rotationOffsetBytes + 4, true) : fromHalf(\n        \
data.getUint16(splatOffset + rotationOffsetBytes + 2, true)\n      );\n      \
const quatY = compressionLevel === 0 ? data.getFloat32(splatOffset + \
rotationOffsetBytes + 8, true) : fromHalf(\n        \
data.getUint16(splatOffset + rotationOffsetBytes + 4, true)\n      );\n      \
const quatZ = compressionLevel === 0 ? data.getFloat32(splatOffset + \
rotationOffsetBytes + 12, true) : fromHalf(\n        \
data.getUint16(splatOffset + rotationOffsetBytes + 6, true)\n      );\n      \
const r = data.getUint8(splatOffset + colorOffsetBytes + 0) / 255;\n      \
const g = data.getUint8(splatOffset + colorOffsetBytes + 1) / 255;\n      \
const b = data.getUint8(splatOffset + colorOffsetBytes + 2) / 255;\n      \
const opacity = data.getUint8(splatOffset + colorOffsetBytes + 3) / 255;\n    \
  splatCallback(\n        i,\n        x,\n        y,\n        z,\n        \
scaleX,\n        scaleY,\n        scaleZ,\n        quatX,\n        quatY,\n   \
     quatZ,\n        quatW,\n        opacity,\n        r,\n        g,\n       \
 b\n      );\n      if (sphericalHarmonicsDegree >= 1 && sh1) {\n        for \
(const [i2, key] of sh1Index.entries()) {\n          sh1[i2] = \
getSh(splatOffset, key);\n        }\n        if (sh2) {\n          for (const \
[i2, key] of sh2Index.entries()) {\n            sh2[i2] = getSh(splatOffset, \
key);\n          }\n        }\n        if (sh3) {\n          for (const [i2, \
key] of sh3Index.entries()) {\n            sh3[i2] = getSh(splatOffset, \
key);\n          }\n        }\n        shCallback == null ? void 0 : \
shCallback(i, sh1, sh2, sh3);\n      }\n    }\n    sectionBase += \
storageSizeBytes;\n  }\n}\nclass SpzReader {\n  constructor({ fileBytes }) \
{\n    this.version = -1;\n    this.numSplats = 0;\n    this.shDegree = 0;\n  \
  this.fractionalBits = 0;\n    this.flags = 0;\n    this.flagAntiAlias = \
false;\n    this.reserved = 0;\n    this.headerParsed = false;\n    \
this.parsed = false;\n    this.fileBytes = fileBytes instanceof ArrayBuffer ? \
new Uint8Array(fileBytes) : fileBytes;\n    this.reader = new GunzipReader({ \
fileBytes: this.fileBytes });\n  }\n  async parseHeader() {\n    if \
(this.headerParsed) {\n      throw new Error(\"SPZ file header already \
parsed\");\n    }\n    const header = new DataView((await \
this.reader.read(16)).buffer);\n    if (header.getUint32(0, true) !== \
1347635022) {\n      throw new Error(\"Invalid SPZ file\");\n    }\n    \
this.version = header.getUint32(4, true);\n    if (this.version < 1 || \
this.version > 3) {\n      throw new Error(`Unsupported SPZ version: \
${this.version}`);\n    }\n    this.numSplats = header.getUint32(8, true);\n  \
  this.shDegree = header.getUint8(12);\n    this.fractionalBits = \
header.getUint8(13);\n    this.flags = header.getUint8(14);\n    \
this.flagAntiAlias = (this.flags & 1) !== 0;\n    this.reserved = \
header.getUint8(15);\n    this.headerParsed = true;\n    this.parsed = \
false;\n  }\n  async parseSplats(centerCallback, alphaCallback, rgbCallback, \
scalesCallback, quatCallback, shCallback) {\n    if (!this.headerParsed) {\n  \
    throw new Error(\"SPZ file header must be parsed first\");\n    }\n    if \
(this.parsed) {\n      throw new Error(\"SPZ file already parsed\");\n    }\n \
   this.parsed = true;\n    if (this.version === 1) {\n      const \
centerBytes = await this.reader.read(this.numSplats * 3 * 2);\n      const \
centerUint16 = new Uint16Array(centerBytes.buffer);\n      for (let i = 0; i \
< this.numSplats; i++) {\n        const i3 = i * 3;\n        const x = \
fromHalf(centerUint16[i3]);\n        const y = fromHalf(centerUint16[i3 + \
1]);\n        const z = fromHalf(centerUint16[i3 + 2]);\n        \
centerCallback == null ? void 0 : centerCallback(i, x, y, z);\n      }\n    } \
else if (this.version === 2 || this.version === 3) {\n      const fixed = 1 \
<< this.fractionalBits;\n      const centerBytes = await \
this.reader.read(this.numSplats * 3 * 3);\n      for (let i = 0; i < \
this.numSplats; i++) {\n        const i9 = i * 9;\n        const x = \
((centerBytes[i9 + 2] << 24 | centerBytes[i9 + 1] << 16 | centerBytes[i9] << \
8) >> 8) / fixed;\n        const y = ((centerBytes[i9 + 5] << 24 | \
centerBytes[i9 + 4] << 16 | centerBytes[i9 + 3] << 8) >> 8) / fixed;\n        \
const z = ((centerBytes[i9 + 8] << 24 | centerBytes[i9 + 7] << 16 | \
centerBytes[i9 + 6] << 8) >> 8) / fixed;\n        centerCallback == null ? \
void 0 : centerCallback(i, x, y, z);\n      }\n    } else {\n      throw new \
Error(\"Unreachable\");\n    }\n    {\n      const bytes = await \
this.reader.read(this.numSplats);\n      for (let i = 0; i < this.numSplats; \
i++) {\n        alphaCallback == null ? void 0 : alphaCallback(i, bytes[i] / \
255);\n      }\n    }\n    {\n      const rgbBytes = await \
this.reader.read(this.numSplats * 3);\n      const scale = SH_C0 / 0.15;\n    \
  for (let i = 0; i < this.numSplats; i++) {\n        const i3 = i * 3;\n     \
   const r = (rgbBytes[i3] / 255 - 0.5) * scale + 0.5;\n        const g = \
(rgbBytes[i3 + 1] / 255 - 0.5) * scale + 0.5;\n        const b = (rgbBytes[i3 \
+ 2] / 255 - 0.5) * scale + 0.5;\n        rgbCallback == null ? void 0 : \
rgbCallback(i, r, g, b);\n      }\n    }\n    {\n      const scalesBytes = \
await this.reader.read(this.numSplats * 3);\n      for (let i = 0; i < \
this.numSplats; i++) {\n        const i3 = i * 3;\n        const scaleX = \
Math.exp(scalesBytes[i3] / 16 - 10);\n        const scaleY = \
Math.exp(scalesBytes[i3 + 1] / 16 - 10);\n        const scaleZ = \
Math.exp(scalesBytes[i3 + 2] / 16 - 10);\n        scalesCallback == null ? \
void 0 : scalesCallback(i, scaleX, scaleY, scaleZ);\n      }\n    }\n    if \
(this.version === 3) {\n      const maxValue = 1 / Math.sqrt(2);\n      const \
quatBytes = await this.reader.read(this.numSplats * 4);\n      for (let i = \
0; i < this.numSplats; i++) {\n        const i3 = i * 4;\n        const \
quaternion = [0, 0, 0, 0];\n        const values = [\n          \
quatBytes[i3],\n          quatBytes[i3 + 1],\n          quatBytes[i3 + 2],\n  \
        quatBytes[i3 + 3]\n        ];\n        const combinedValues = \
values[0] + (values[1] << 8) + (values[2] << 16) + (values[3] << 24);\n       \
 const valueMask = (1 << 9) - 1;\n        const largestIndex = combinedValues \
>>> 30;\n        let remainingValues = combinedValues;\n        let \
sumSquares = 0;\n        for (let i2 = 3; i2 >= 0; --i2) {\n          if (i2 \
!== largestIndex) {\n            const value = remainingValues & valueMask;\n \
           const sign2 = remainingValues >>> 9 & 1;\n            \
remainingValues = remainingValues >>> 10;\n            quaternion[i2] = \
maxValue * (value / valueMask);\n            quaternion[i2] = sign2 === 0 ? \
quaternion[i2] : -quaternion[i2];\n            sumSquares += quaternion[i2] * \
quaternion[i2];\n          }\n        }\n        const square = 1 - \
sumSquares;\n        quaternion[largestIndex] = Math.sqrt(Math.max(square, \
0));\n        quatCallback == null ? void 0 : quatCallback(\n          i,\n   \
       quaternion[0],\n          quaternion[1],\n          quaternion[2],\n   \
       quaternion[3]\n        );\n      }\n    } else {\n      const \
quatBytes = await this.reader.read(this.numSplats * 3);\n      for (let i = \
0; i < this.numSplats; i++) {\n        const i3 = i * 3;\n        const quatX \
= quatBytes[i3] / 127.5 - 1;\n        const quatY = quatBytes[i3 + 1] / 127.5 \
- 1;\n        const quatZ = quatBytes[i3 + 2] / 127.5 - 1;\n        const \
quatW = Math.sqrt(\n          Math.max(0, 1 - quatX * quatX - quatY * quatY - \
quatZ * quatZ)\n        );\n        quatCallback == null ? void 0 : \
quatCallback(i, quatX, quatY, quatZ, quatW);\n      }\n    }\n    if \
(shCallback && this.shDegree >= 1) {\n      const sh1 = new Float32Array(3 * \
3);\n      const sh2 = this.shDegree >= 2 ? new Float32Array(5 * 3) : void \
0;\n      const sh3 = this.shDegree >= 3 ? new Float32Array(7 * 3) : void \
0;\n      const shBytes = await this.reader.read(\n        this.numSplats * \
SH_DEGREE_TO_VECS[this.shDegree] * 3\n      );\n      let offset = 0;\n      \
for (let i = 0; i < this.numSplats; i++) {\n        for (let j = 0; j < 9; \
++j) {\n          sh1[j] = (shBytes[offset + j] - 128) / 128;\n        }\n    \
    offset += 9;\n        if (sh2) {\n          for (let j = 0; j < 15; ++j) \
{\n            sh2[j] = (shBytes[offset + j] - 128) / 128;\n          }\n     \
     offset += 15;\n        }\n        if (sh3) {\n          for (let j = 0; \
j < 21; ++j) {\n            sh3[j] = (shBytes[offset + j] - 128) / 128;\n     \
     }\n          offset += 21;\n        }\n        shCallback == null ? void \
0 : shCallback(i, sh1, sh2, sh3);\n      }\n    }\n  }\n}\nconst \
SH_DEGREE_TO_VECS = { 1: 3, 2: 8, 3: 15 };\nconst SH_C0 = \
0.28209479177387814;\nconst SPZ_MAGIC = 1347635022;\nconst SPZ_VERSION = \
3;\nconst FLAG_ANTIALIASED = 1;\nclass SpzWriter {\n  constructor({\n    \
numSplats,\n    shDegree,\n    fractionalBits = 12,\n    flagAntiAlias = \
true\n  }) {\n    this.clippedCount = 0;\n    const splatSize = 9 + // \
Position\n    1 + // Opacity\n    3 + // Scale\n    3 + // DC-rgb\n    4 + // \
Rotation\n    (shDegree >= 1 ? 9 : 0) + (shDegree >= 2 ? 15 : 0) + (shDegree \
>= 3 ? 21 : 0);\n    const bufferSize = 16 + numSplats * splatSize;\n    \
this.buffer = new ArrayBuffer(bufferSize);\n    this.view = new \
DataView(this.buffer);\n    this.view.setUint32(0, SPZ_MAGIC, true);\n    \
this.view.setUint32(4, SPZ_VERSION, true);\n    this.view.setUint32(8, \
numSplats, true);\n    this.view.setUint8(12, shDegree);\n    \
this.view.setUint8(13, fractionalBits);\n    this.view.setUint8(14, \
flagAntiAlias ? FLAG_ANTIALIASED : 0);\n    this.view.setUint8(15, 0);\n    \
this.numSplats = numSplats;\n    this.shDegree = shDegree;\n    \
this.fractionalBits = fractionalBits;\n    this.fraction = 1 << \
fractionalBits;\n    this.flagAntiAlias = flagAntiAlias;\n  }\n  \
setCenter(index, x, y, z) {\n    const xRounded = Math.round(x * \
this.fraction);\n    const xInt = Math.max(-8388607, Math.min(8388607, \
xRounded));\n    const yRounded = Math.round(y * this.fraction);\n    const \
yInt = Math.max(-8388607, Math.min(8388607, yRounded));\n    const zRounded = \
Math.round(z * this.fraction);\n    const zInt = Math.max(-8388607, \
Math.min(8388607, zRounded));\n    const clipped = xRounded !== xInt || \
yRounded !== yInt || zRounded !== zInt;\n    if (clipped) {\n      \
this.clippedCount += 1;\n    }\n    const i9 = index * 9;\n    const base = \
16 + i9;\n    this.view.setUint8(base, xInt & 255);\n    \
this.view.setUint8(base + 1, xInt >> 8 & 255);\n    this.view.setUint8(base + \
2, xInt >> 16 & 255);\n    this.view.setUint8(base + 3, yInt & 255);\n    \
this.view.setUint8(base + 4, yInt >> 8 & 255);\n    this.view.setUint8(base + \
5, yInt >> 16 & 255);\n    this.view.setUint8(base + 6, zInt & 255);\n    \
this.view.setUint8(base + 7, zInt >> 8 & 255);\n    this.view.setUint8(base + \
8, zInt >> 16 & 255);\n  }\n  setAlpha(index, alpha) {\n    const base = 16 + \
this.numSplats * 9 + index;\n    this.view.setUint8(\n      base,\n      \
Math.max(0, Math.min(255, Math.round(alpha * 255)))\n    );\n  }\n  static \
scaleRgb(r) {\n    const v = ((r - 0.5) / (SH_C0 / 0.15) + 0.5) * 255;\n    \
return Math.max(0, Math.min(255, Math.round(v)));\n  }\n  setRgb(index, r, g, \
b) {\n    const base = 16 + this.numSplats * 10 + index * 3;\n    \
this.view.setUint8(base, SpzWriter.scaleRgb(r));\n    this.view.setUint8(base \
+ 1, SpzWriter.scaleRgb(g));\n    this.view.setUint8(base + 2, \
SpzWriter.scaleRgb(b));\n  }\n  setScale(index, scaleX, scaleY, scaleZ) {\n   \
 const base = 16 + this.numSplats * 13 + index * 3;\n    \
this.view.setUint8(\n      base,\n      Math.max(0, Math.min(255, \
Math.round((Math.log(scaleX) + 10) * 16)))\n    );\n    this.view.setUint8(\n \
     base + 1,\n      Math.max(0, Math.min(255, Math.round((Math.log(scaleY) \
+ 10) * 16)))\n    );\n    this.view.setUint8(\n      base + 2,\n      \
Math.max(0, Math.min(255, Math.round((Math.log(scaleZ) + 10) * 16)))\n    \
);\n  }\n  setQuat(index, ...q) {\n    const base = 16 + this.numSplats * 16 \
+ index * 4;\n    const quat = normalize$1(q);\n    let iLargest = 0;\n    \
for (let i = 1; i < 4; ++i) {\n      if (Math.abs(quat[i]) > \
Math.abs(quat[iLargest])) {\n        iLargest = i;\n      }\n    }\n    const \
negate = quat[iLargest] < 0 ? 1 : 0;\n    let comp = iLargest;\n    for (let \
i = 0; i < 4; ++i) {\n      if (i !== iLargest) {\n        const negbit = \
(quat[i] < 0 ? 1 : 0) ^ negate;\n        const mag = Math.floor(\n          \
((1 << 9) - 1) * (Math.abs(quat[i]) / Math.SQRT1_2) + 0.5\n        );\n       \
 comp = comp << 10 | negbit << 9 | mag;\n      }\n    }\n    \
this.view.setUint8(base, comp & 255);\n    this.view.setUint8(base + 1, comp \
>> 8 & 255);\n    this.view.setUint8(base + 2, comp >> 16 & 255);\n    \
this.view.setUint8(base + 3, comp >>> 24 & 255);\n  }\n  static \
quantizeSh(sh, bits2) {\n    const value = Math.round(sh * 128) + 128;\n    \
const bucketSize = 1 << 8 - bits2;\n    const quantized = Math.floor((value + \
bucketSize / 2) / bucketSize) * bucketSize;\n    return Math.max(0, \
Math.min(255, quantized));\n  }\n  setSh(index, sh1, sh2, sh3) {\n    const \
shVecs = SH_DEGREE_TO_VECS[this.shDegree] || 0;\n    const base1 = 16 + \
this.numSplats * 20 + index * shVecs * 3;\n    for (let j = 0; j < 9; ++j) \
{\n      this.view.setUint8(base1 + j, SpzWriter.quantizeSh(sh1[j], 5));\n    \
}\n    if (sh2) {\n      const base2 = base1 + 9;\n      for (let j = 0; j < \
15; ++j) {\n        this.view.setUint8(base2 + j, \
SpzWriter.quantizeSh(sh2[j], 4));\n      }\n      if (sh3) {\n        const \
base3 = base2 + 15;\n        for (let j = 0; j < 21; ++j) {\n          \
this.view.setUint8(base3 + j, SpzWriter.quantizeSh(sh3[j], 4));\n        }\n  \
    }\n    }\n  }\n  async finalize() {\n    const input = new \
Uint8Array(this.buffer);\n    const stream = new ReadableStream({\n      \
async start(controller) {\n        controller.enqueue(input);\n        \
controller.close();\n      }\n    });\n    const compressed = \
stream.pipeThrough(new CompressionStream(\"gzip\"));\n    const response = \
new Response(compressed);\n    const buffer = await response.arrayBuffer();\n \
   console.log(\n      \"Compressed\",\n      input.length,\n      \"bytes \
to\",\n      buffer.byteLength,\n      \"bytes\"\n    );\n    return new \
Uint8Array(buffer);\n  }\n}\nasync function transcodeSpz(input) {\n  var _a2, \
_b2, _c;\n  const splats = new SplatData();\n  const {\n    inputs,\n    \
clipXyz,\n    maxSh,\n    fractionalBits = 12,\n    opacityThreshold\n  } = \
input;\n  for (const input2 of inputs) {\n    let transformPos2 = \
function(pos) {\n      pos.multiplyScalar(scale);\n      \
pos.applyQuaternion(quaternion);\n      pos.add(translate);\n      return \
pos;\n    }, transformScales = function(scales) {\n      \
scales.multiplyScalar(scale);\n      return scales;\n    }, \
transformQuaternion = function(quat) {\n      quat.premultiply(quaternion);\n \
     return quat;\n    }, withinClip = function(p) {\n      return !clip || \
clip.containsPoint(p);\n    }, withinOpacity = function(opacity) {\n      \
return opacityThreshold !== void 0 ? opacity >= opacityThreshold : true;\n    \
};\n    const scale = ((_a2 = input2.transform) == null ? void 0 : _a2.scale) \
?? 1;\n    const quaternion = new THREE.Quaternion().fromArray(\n      ((_b2 \
= input2.transform) == null ? void 0 : _b2.quaternion) ?? [0, 0, 0, 1]\n    \
);\n    const translate = new THREE.Vector3().fromArray(\n      ((_c = \
input2.transform) == null ? void 0 : _c.translate) ?? [0, 0, 0]\n    );\n    \
const clip = clipXyz ? new THREE.Box3(\n      new \
THREE.Vector3().fromArray(clipXyz.min),\n      new \
THREE.Vector3().fromArray(clipXyz.max)\n    ) : void 0;\n    let fileType = \
input2.fileType;\n    if (!fileType) {\n      fileType = \
getSplatFileType(input2.fileBytes);\n      if (!fileType && input2.pathOrUrl) \
{\n        fileType = getSplatFileTypeFromPath(input2.pathOrUrl);\n      }\n  \
  }\n    switch (fileType) {\n      case SplatFileType.PLY: {\n        const \
ply = new PlyReader({ fileBytes: input2.fileBytes });\n        await \
ply.parseHeader();\n        let lastIndex = null;\n        ply.parseSplats(\n \
         (index, x, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, \
opacity, r, g, b) => {\n            const center = transformPos2(new \
THREE.Vector3(x, y, z));\n            if (withinClip(center) && \
withinOpacity(opacity)) {\n              lastIndex = splats.pushSplat();\n    \
          splats.setCenter(lastIndex, center.x, center.y, center.z);\n        \
      const scales = transformScales(\n                new \
THREE.Vector3(scaleX, scaleY, scaleZ)\n              );\n              \
splats.setScale(lastIndex, scales.x, scales.y, scales.z);\n              \
const quaternion2 = transformQuaternion(\n                new \
THREE.Quaternion(quatX, quatY, quatZ, quatW)\n              );\n              \
splats.setQuaternion(\n                lastIndex,\n                \
quaternion2.x,\n                quaternion2.y,\n                \
quaternion2.z,\n                quaternion2.w\n              );\n             \
 splats.setOpacity(lastIndex, opacity);\n              \
splats.setColor(lastIndex, r, g, b);\n            } else {\n              \
lastIndex = null;\n            }\n          },\n          (index, sh1, sh2, \
sh3) => {\n            if (sh1 && lastIndex !== null) {\n              \
splats.setSh1(lastIndex, sh1);\n            }\n            if (sh2 && \
lastIndex !== null) {\n              splats.setSh2(lastIndex, sh2);\n         \
   }\n            if (sh3 && lastIndex !== null) {\n              \
splats.setSh3(lastIndex, sh3);\n            }\n          }\n        );\n      \
  break;\n      }\n      case SplatFileType.SPZ: {\n        const spz2 = new \
SpzReader({ fileBytes: input2.fileBytes });\n        await \
spz2.parseHeader();\n        const mapping = new \
Int32Array(spz2.numSplats);\n        mapping.fill(-1);\n        const centers \
= new Float32Array(spz2.numSplats * 3);\n        const center = new \
THREE.Vector3();\n        spz2.parseSplats(\n          (index, x, y, z) => \
{\n            const center2 = transformPos2(new THREE.Vector3(x, y, z));\n   \
         centers[index * 3] = center2.x;\n            centers[index * 3 + 1] \
= center2.y;\n            centers[index * 3 + 2] = center2.z;\n          },\n \
         (index, alpha) => {\n            center.fromArray(centers, index * \
3);\n            if (withinClip(center) && withinOpacity(alpha)) {\n          \
    mapping[index] = splats.pushSplat();\n              \
splats.setCenter(mapping[index], center.x, center.y, center.z);\n             \
 splats.setOpacity(mapping[index], alpha);\n            }\n          },\n     \
     (index, r, g, b) => {\n            if (mapping[index] >= 0) {\n          \
    splats.setColor(mapping[index], r, g, b);\n            }\n          },\n  \
        (index, scaleX, scaleY, scaleZ) => {\n            if (mapping[index] \
>= 0) {\n              const scales = transformScales(\n                new \
THREE.Vector3(scaleX, scaleY, scaleZ)\n              );\n              \
splats.setScale(mapping[index], scales.x, scales.y, scales.z);\n            \
}\n          },\n          (index, quatX, quatY, quatZ, quatW) => {\n         \
   if (mapping[index] >= 0) {\n              const quaternion2 = \
transformQuaternion(\n                new THREE.Quaternion(quatX, quatY, \
quatZ, quatW)\n              );\n              splats.setQuaternion(\n        \
        mapping[index],\n                quaternion2.x,\n                \
quaternion2.y,\n                quaternion2.z,\n                \
quaternion2.w\n              );\n            }\n          },\n          \
(index, sh1, sh2, sh3) => {\n            if (mapping[index] >= 0) {\n         \
     splats.setSh1(mapping[index], sh1);\n              if (sh2) {\n          \
      splats.setSh2(mapping[index], sh2);\n              }\n              if \
(sh3) {\n                splats.setSh3(mapping[index], sh3);\n              \
}\n            }\n          }\n        );\n        break;\n      }\n      \
case SplatFileType.SPLAT:\n        decodeAntiSplat(\n          \
input2.fileBytes,\n          (numSplats) => {\n          },\n          \
(index, x, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, \
r, g, b) => {\n            const center = transformPos2(new THREE.Vector3(x, \
y, z));\n            if (withinClip(center) && withinOpacity(opacity)) {\n    \
          const index2 = splats.pushSplat();\n              \
splats.setCenter(index2, center.x, center.y, center.z);\n              const \
scales = transformScales(\n                new THREE.Vector3(scaleX, scaleY, \
scaleZ)\n              );\n              splats.setScale(index2, scales.x, \
scales.y, scales.z);\n              const quaternion2 = \
transformQuaternion(\n                new THREE.Quaternion(quatX, quatY, \
quatZ, quatW)\n              );\n              splats.setQuaternion(\n        \
        index2,\n                quaternion2.x,\n                \
quaternion2.y,\n                quaternion2.z,\n                \
quaternion2.w\n              );\n              splats.setOpacity(index2, \
opacity);\n              splats.setColor(index2, r, g, b);\n            }\n   \
       }\n        );\n        break;\n      case SplatFileType.KSPLAT: {\n    \
    let lastIndex = null;\n        decodeKsplat(\n          \
input2.fileBytes,\n          (numSplats) => {\n          },\n          \
(index, x, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, \
r, g, b) => {\n            const center = transformPos2(new THREE.Vector3(x, \
y, z));\n            if (withinClip(center) && withinOpacity(opacity)) {\n    \
          lastIndex = splats.pushSplat();\n              \
splats.setCenter(lastIndex, center.x, center.y, center.z);\n              \
const scales = transformScales(\n                new THREE.Vector3(scaleX, \
scaleY, scaleZ)\n              );\n              splats.setScale(lastIndex, \
scales.x, scales.y, scales.z);\n              const quaternion2 = \
transformQuaternion(\n                new THREE.Quaternion(quatX, quatY, \
quatZ, quatW)\n              );\n              splats.setQuaternion(\n        \
        lastIndex,\n                quaternion2.x,\n                \
quaternion2.y,\n                quaternion2.z,\n                \
quaternion2.w\n              );\n              splats.setOpacity(lastIndex, \
opacity);\n              splats.setColor(lastIndex, r, g, b);\n            } \
else {\n              lastIndex = null;\n            }\n          },\n        \
  (index, sh1, sh2, sh3) => {\n            if (lastIndex !== null) {\n        \
      splats.setSh1(lastIndex, sh1);\n              if (sh2) {\n              \
  splats.setSh2(lastIndex, sh2);\n              }\n              if (sh3) {\n \
               splats.setSh3(lastIndex, sh3);\n              }\n            \
}\n          }\n        );\n        break;\n      }\n      default:\n        \
throw new Error(`transcodeSpz not implemented for ${fileType}`);\n    }\n  \
}\n  const shDegree = Math.min(\n    maxSh ?? 3,\n    splats.sh3 ? 3 : \
splats.sh2 ? 2 : splats.sh1 ? 1 : 0\n  );\n  const spz = new SpzWriter({\n    \
numSplats: splats.numSplats,\n    shDegree,\n    fractionalBits,\n    \
flagAntiAlias: true\n  });\n  for (let i = 0; i < splats.numSplats; ++i) {\n  \
  const i3 = i * 3;\n    const i4 = i * 4;\n    spz.setCenter(\n      i,\n    \
  splats.centers[i3],\n      splats.centers[i3 + 1],\n      splats.centers[i3 \
+ 2]\n    );\n    spz.setScale(\n      i,\n      splats.scales[i3],\n      \
splats.scales[i3 + 1],\n      splats.scales[i3 + 2]\n    );\n    \
spz.setQuat(\n      i,\n      splats.quaternions[i4],\n      \
splats.quaternions[i4 + 1],\n      splats.quaternions[i4 + 2],\n      \
splats.quaternions[i4 + 3]\n    );\n    spz.setAlpha(i, \
splats.opacities[i]);\n    spz.setRgb(\n      i,\n      splats.colors[i3],\n  \
    splats.colors[i3 + 1],\n      splats.colors[i3 + 2]\n    );\n    if \
(splats.sh1 && shDegree >= 1) {\n      spz.setSh(\n        i,\n        \
splats.sh1.slice(i * 9, (i + 1) * 9),\n        shDegree >= 2 && splats.sh2 ? \
splats.sh2.slice(i * 15, (i + 1) * 15) : void 0,\n        shDegree >= 3 && \
splats.sh3 ? splats.sh3.slice(i * 21, (i + 1) * 21) : void 0\n      );\n    \
}\n  }\n  const spzBytes = await spz.finalize();\n  return { fileBytes: \
spzBytes, clippedCount: spz.clippedCount };\n}\nclass SplatSkinning {\n  \
constructor(options) {\n    this.mesh = options.mesh;\n    this.numSplats = \
options.numSplats ?? this.mesh.numSplats;\n    const { width, height, depth, \
maxSplats } = getTextureSize(this.numSplats);\n    this.skinData = new \
Uint16Array(maxSplats * 4);\n    this.skinTexture = new \
THREE.DataArrayTexture(\n      this.skinData,\n      width,\n      height,\n  \
    depth\n    );\n    this.skinTexture.format = THREE.RGBAIntegerFormat;\n   \
 this.skinTexture.type = THREE.UnsignedShortType;\n    \
this.skinTexture.internalFormat = \"RGBA16UI\";\n    \
this.skinTexture.needsUpdate = true;\n    this.numBones = options.numBones ?? \
256;\n    this.boneData = new Float32Array(this.numBones * 16);\n    \
this.boneTexture = new THREE.DataTexture(\n      this.boneData,\n      4,\n   \
   this.numBones,\n      THREE.RGBAFormat,\n      THREE.FloatType\n    );\n   \
 this.boneTexture.internalFormat = \"RGBA32F\";\n    \
this.boneTexture.needsUpdate = true;\n    this.uniform = new DynoUniform({\n  \
    key: \"skinning\",\n      type: GsplatSkinning,\n      globals: () => \
[defineGsplatSkinning],\n      value: {\n        numSplats: this.numSplats,\n \
       numBones: this.numBones,\n        skinTexture: this.skinTexture,\n     \
   boneTexture: this.boneTexture\n      }\n    });\n  }\n  // Apply the \
skeletal animation to a Gsplat in a dyno program.\n  modify(gsplat) {\n    \
return applyGsplatSkinning(gsplat, this.uniform);\n  }\n  // Set the \"rest\" \
pose for a bone with position and quaternion orientation.\n  \
setRestQuatPos(boneIndex, quat, pos) {\n    const i16 = boneIndex * 16;\n    \
this.boneData[i16 + 0] = quat.x;\n    this.boneData[i16 + 1] = quat.y;\n    \
this.boneData[i16 + 2] = quat.z;\n    this.boneData[i16 + 3] = quat.w;\n    \
this.boneData[i16 + 4] = pos.x;\n    this.boneData[i16 + 5] = pos.y;\n    \
this.boneData[i16 + 6] = pos.z;\n    this.boneData[i16 + 7] = 0;\n    \
this.boneData[i16 + 8] = 0;\n    this.boneData[i16 + 9] = 0;\n    \
this.boneData[i16 + 10] = 0;\n    this.boneData[i16 + 11] = 1;\n    \
this.boneData[i16 + 12] = 0;\n    this.boneData[i16 + 13] = 0;\n    \
this.boneData[i16 + 14] = 0;\n    this.boneData[i16 + 15] = 0;\n  }\n  // Set \
the \"current\" position and orientation of a bone.\n  \
setBoneQuatPos(boneIndex, quat, pos) {\n    const i16 = boneIndex * 16;\n    \
const origQuat = new THREE.Quaternion(\n      this.boneData[i16 + 0],\n      \
this.boneData[i16 + 1],\n      this.boneData[i16 + 2],\n      \
this.boneData[i16 + 3]\n    );\n    const origPos = new THREE.Vector3(\n      \
this.boneData[i16 + 4],\n      this.boneData[i16 + 5],\n      \
this.boneData[i16 + 6]\n    );\n    const relQuat = \
origQuat.clone().invert();\n    const relPos = pos.clone().sub(origPos);\n    \
relPos.applyQuaternion(relQuat);\n    relQuat.multiply(quat);\n    const dual \
= new THREE.Quaternion(\n      relPos.x,\n      relPos.y,\n      relPos.z,\n  \
    0\n    ).multiply(origQuat);\n    this.boneData[i16 + 8] = relQuat.x;\n   \
 this.boneData[i16 + 9] = relQuat.y;\n    this.boneData[i16 + 10] = \
relQuat.z;\n    this.boneData[i16 + 11] = relQuat.w;\n    this.boneData[i16 + \
12] = 0.5 * dual.x;\n    this.boneData[i16 + 13] = 0.5 * dual.y;\n    \
this.boneData[i16 + 14] = 0.5 * dual.z;\n    this.boneData[i16 + 15] = 0.5 * \
dual.w;\n  }\n  // Set up to 4 bone indices and weights for a Gsplat. For \
fewer than 4 bones,\n  // you can set the remaining weights to 0 (and \
index=0).\n  setSplatBones(splatIndex, boneIndices, weights) {\n    const i4 \
= splatIndex * 4;\n    this.skinData[i4 + 0] = Math.min(255, Math.max(0, \
Math.round(weights.x * 255))) + (boneIndices.x << 8);\n    this.skinData[i4 + \
1] = Math.min(255, Math.max(0, Math.round(weights.y * 255))) + (boneIndices.y \
<< 8);\n    this.skinData[i4 + 2] = Math.min(255, Math.max(0, \
Math.round(weights.z * 255))) + (boneIndices.z << 8);\n    this.skinData[i4 + \
3] = Math.min(255, Math.max(0, Math.round(weights.w * 255))) + (boneIndices.w \
<< 8);\n  }\n  // Call this to indicate that the bones have changed and the \
Gsplats need to be\n  // re-generated with updated skinning.\n  updateBones() \
{\n    this.boneTexture.needsUpdate = true;\n    this.mesh.needsUpdate = \
true;\n  }\n}\nconst GsplatSkinning = { type: \"GsplatSkinning\" };\nconst \
defineGsplatSkinning = unindent(`\n  struct GsplatSkinning {\n    int \
numSplats;\n    int numBones;\n    usampler2DArray skinTexture;\n    \
sampler2D boneTexture;\n  };\n`);\nconst defineApplyGsplatSkinning = \
unindent(`\n  void applyGsplatSkinning(\n    int numSplats, int numBones,\n   \
 usampler2DArray skinTexture, sampler2D boneTexture,\n    int splatIndex, \
inout vec3 center, inout vec4 quaternion\n  ) {\n    if ((splatIndex < 0) || \
(splatIndex >= numSplats)) {\n      return;\n    }\n\n    uvec4 skinData = \
texelFetch(skinTexture, splatTexCoord(splatIndex), 0);\n\n    float \
weights[4];\n    weights[0] = float(skinData.x & 0xffu) / 255.0;\n    \
weights[1] = float(skinData.y & 0xffu) / 255.0;\n    weights[2] = \
float(skinData.z & 0xffu) / 255.0;\n    weights[3] = float(skinData.w & \
0xffu) / 255.0;\n\n    uint boneIndices[4];\n    boneIndices[0] = (skinData.x \
>> 8u) & 0xffu;\n    boneIndices[1] = (skinData.y >> 8u) & 0xffu;\n    \
boneIndices[2] = (skinData.z >> 8u) & 0xffu;\n    boneIndices[3] = \
(skinData.w >> 8u) & 0xffu;\n\n    vec4 quat = vec4(0.0);\n    vec4 dual = \
vec4(0.0);\n    for (int i = 0; i < 4; i++) {\n      if (weights[i] > 0.0) \
{\n        int boneIndex = int(boneIndices[i]);\n        vec4 boneQuat = \
vec4(0.0, 0.0, 0.0, 1.0);\n        vec4 boneDual = vec4(0.0);\n        if \
(boneIndex < numBones) {\n          boneQuat = texelFetch(boneTexture, \
ivec2(2, boneIndex), 0);\n          boneDual = texelFetch(boneTexture, \
ivec2(3, boneIndex), 0);\n        }\n\n        if ((i > 0) && (dot(quat, \
boneQuat) < 0.0)) {\n          // Flip sign if next blend is pointing in the \
opposite direction\n          boneQuat = -boneQuat;\n          boneDual = \
-boneDual;\n        }\n        quat += weights[i] * boneQuat;\n        dual \
+= weights[i] * boneDual;\n      }\n    }\n\n    // Normalize dual \
quaternion\n    float norm = length(quat);\n    quat /= norm;\n    dual /= \
norm;\n    vec3 translate = vec3(\n      2.0 * (-dual.w * quat.x + dual.x * \
quat.w - dual.y * quat.z + dual.z * quat.y),\n      2.0 * (-dual.w * quat.y + \
dual.x * quat.z + dual.y * quat.w - dual.z * quat.x),\n      2.0 * (-dual.w * \
quat.z - dual.x * quat.y + dual.y * quat.x + dual.z * quat.w)\n    );\n\n    \
center = quatVec(quat, center) + translate;\n    quaternion = quatQuat(quat, \
quaternion);\n  }\n`);\nfunction applyGsplatSkinning(gsplat, skinning) {\n  \
const dyno2 = new Dyno({\n    inTypes: { gsplat: Gsplat, skinning: \
GsplatSkinning },\n    outTypes: { gsplat: Gsplat },\n    globals: () => \
[defineGsplatSkinning, defineApplyGsplatSkinning],\n    inputs: { gsplat, \
skinning },\n    statements: ({ inputs, outputs }) => {\n      const { \
skinning: skinning2 } = inputs;\n      const { gsplat: gsplat2 } = outputs;\n \
     return unindentLines(`\n        ${gsplat2} = ${inputs.gsplat};\n        \
if (isGsplatActive(${gsplat2}.flags)) {\n          applyGsplatSkinning(\n     \
       ${skinning2}.numSplats, ${skinning2}.numBones,\n            \
${skinning2}.skinTexture, ${skinning2}.boneTexture,\n            \
${gsplat2}.index, ${gsplat2}.center, ${gsplat2}.quaternion\n          );\n    \
    }\n      `);\n    }\n  });\n  return dyno2.outputs.gsplat;\n}\nfunction \
constructGrid({\n  // PackedSplats object to add splats to\n  splats,\n  // \
min and max box extents of the grid\n  extents,\n  // step size along each \
grid axis\n  stepSize = 1,\n  // spherical radius of each Gsplat\n  \
pointRadius = 0.01,\n  // relative size of the \"shadow copy\" of each Gsplat \
placed behind it\n  pointShadowScale = 2,\n  // Gsplat opacity\n  opacity = \
1,\n  // Gsplat color (THREE.Color) or function to set color for position:\n  \
// ((THREE.Color, THREE.Vector3) => void) (default: RGB-modulated grid)\n  \
color\n}) {\n  const EPSILON = 1e-6;\n  const center = new THREE.Vector3();\n \
 const scales = new THREE.Vector3();\n  const quaternion = new \
THREE.Quaternion(0, 0, 0, 1);\n  if (color == null) {\n    color = (color2, \
point) => color2.set(\n      0.55 + 0.45 * Math.cos(point.x * 1),\n      0.55 \
+ 0.45 * Math.cos(point.y * 1),\n      0.55 + 0.45 * Math.cos(point.z * 1)\n  \
  );\n  }\n  const pointColor = new THREE.Color();\n  for (let z = \
extents.min.z; z < extents.max.z + EPSILON; z += stepSize) {\n    for (let y \
= extents.min.y; y < extents.max.y + EPSILON; y += stepSize) {\n      for \
(let x = extents.min.x; x < extents.max.x + EPSILON; x += stepSize) {\n       \
 center.set(x, y, z);\n        for (let layer = 0; layer < 2; ++layer) {\n    \
      scales.setScalar(pointRadius * (layer ? 1 : pointShadowScale));\n       \
   if (!layer) {\n            pointColor.setScalar(0);\n          } else if \
(typeof color === \"function\") {\n            color(pointColor, center);\n   \
       } else {\n            pointColor.copy(color);\n          }\n          \
splats.pushSplat(center, scales, quaternion, opacity, pointColor);\n        \
}\n      }\n    }\n  }\n}\nfunction constructAxes({\n  // PackedSplats object \
to add splats to\n  splats,\n  // scale (Gsplat scale along axis)\n  scale = \
0.25,\n  // radius of the axes (Gsplat scale orthogonal to axis)\n  \
axisRadius = 75e-4,\n  // relative size of the \"shadow copy\" of each Gsplat \
placed behind it\n  axisShadowScale = 2,\n  // origins of the axes (default \
single axis at origin)\n  origins = [new THREE.Vector3()]\n}) {\n  const \
center = new THREE.Vector3();\n  const scales = new THREE.Vector3();\n  const \
quaternion = new THREE.Quaternion(0, 0, 0, 1);\n  const color = new \
THREE.Color();\n  const opacity = 1;\n  for (const origin of origins) {\n    \
for (let axis = 0; axis < 3; ++axis) {\n      center.set(\n        origin.x + \
(axis === 0 ? scale : 0),\n        origin.y + (axis === 1 ? scale : 0),\n     \
   origin.z + (axis === 2 ? scale : 0)\n      );\n      for (let layer = 0; \
layer < 2; ++layer) {\n        scales.set(\n          (axis === 0 ? scale : \
axisRadius) * (layer ? 1 : axisShadowScale),\n          (axis === 1 ? scale : \
axisRadius) * (layer ? 1 : axisShadowScale),\n          (axis === 2 ? scale : \
axisRadius) * (layer ? 1 : axisShadowScale)\n        );\n        \
color.setRGB(\n          layer === 0 ? 0 : axis === 0 ? 1 : 0,\n          \
layer === 0 ? 0 : axis === 1 ? 1 : 0,\n          layer === 0 ? 0 : axis === 2 \
? 1 : 0\n        );\n        splats.pushSplat(center, scales, quaternion, \
opacity, color);\n      }\n    }\n  }\n}\nfunction constructSpherePoints({\n  \
// PackedSplats object to add splats to\n  splats,\n  // center of the sphere \
(default: origin)\n  origin = new THREE.Vector3(),\n  // radius of the \
sphere\n  radius = 1,\n  // maximum depth of recursion for subdividing the \
sphere\n  // Warning: Gsplat count grows exponentially with depth\n  maxDepth \
= 3,\n  // filter function to apply to each point, for example to select\n  \
// points in a certain direction or other function ((THREE.Vector3) => \
boolean)\n  // (default: null)\n  filter = null,\n  // radius of each \
oriented Gsplat\n  pointRadius = 0.02,\n  // flatness of each oriented \
Gsplat\n  pointThickness = 1e-3,\n  // color of each Gsplat (THREE.Color) or \
function to set color for point:\n  // ((THREE.Color, THREE.Vector3) => void) \
(default: white)\n  color = new THREE.Color(1, 1, 1)\n}) {\n  const \
pointsHash = {};\n  function addPoint(p) {\n    if (filter && !filter(p)) {\n \
     return;\n    }\n    const key = `${p.x},${p.y},${p.z}`;\n    if \
(!pointsHash[key]) {\n      pointsHash[key] = p;\n    }\n  }\n  function \
recurse(depth, p0, p1, p2) {\n    addPoint(p0);\n    addPoint(p1);\n    \
addPoint(p2);\n    if (depth >= maxDepth) {\n      return;\n    }\n    const \
p01 = new THREE.Vector3().addVectors(p0, p1).normalize();\n    const p12 = \
new THREE.Vector3().addVectors(p1, p2).normalize();\n    const p20 = new \
THREE.Vector3().addVectors(p2, p0).normalize();\n    recurse(depth + 1, p0, \
p01, p20);\n    recurse(depth + 1, p01, p1, p12);\n    recurse(depth + 1, \
p20, p12, p2);\n    recurse(depth + 1, p01, p12, p20);\n  }\n  for (const x \
of [-1, 1]) {\n    for (const y of [-1, 1]) {\n      for (const z of [-1, 1]) \
{\n        const p0 = new THREE.Vector3(x, 0, 0);\n        const p1 = new \
THREE.Vector3(0, y, 0);\n        const p2 = new THREE.Vector3(0, 0, z);\n     \
   recurse(0, p0, p1, p2);\n      }\n    }\n  }\n  const points = \
Object.values(pointsHash);\n  const scales = new THREE.Vector3(pointRadius, \
pointRadius, pointThickness);\n  const quaternion = new THREE.Quaternion();\n \
 const pointColor = typeof color === \"function\" ? new THREE.Color() : \
color;\n  for (const point of points) {\n    \
quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, -1), point);\n    if \
(typeof color === \"function\") {\n      color(pointColor, point);\n    }\n   \
 point.multiplyScalar(radius);\n    point.add(origin);\n    \
splats.pushSplat(point, scales, quaternion, 1, pointColor);\n  }\n}\nfunction \
textSplats({\n  // text string to display\n  text,\n  // browser font to \
render text with (default: \"Arial\")\n  font,\n  // font size in \
pixels/Gsplats (default: 32)\n  fontSize,\n  // SplatMesh.recolor tint \
assuming white Gsplats (default: white)\n  color,\n  // Individual Gsplat \
color (default: white)\n  rgb,\n  // Gsplat radius (default: 0.8 covers \
1-unit spacing well)\n  dotRadius,\n  // text alignment: \"left\", \
\"center\", \"right\", \"start\", \"end\" (default: \"start\")\n  \
textAlign,\n  // line spacing multiplier, lines delimited by \"\\n\" \
(default: 1.0)\n  lineHeight,\n  // Coordinate scale in object-space \
(default: 1.0)\n  objectScale\n}) {\n  font = font ?? \"Arial\";\n  fontSize \
= fontSize ?? 32;\n  color = color ?? new THREE.Color(1, 1, 1);\n  dotRadius \
= dotRadius ?? 0.8;\n  textAlign = textAlign ?? \"start\";\n  lineHeight = \
lineHeight ?? 1;\n  objectScale = objectScale ?? 1;\n  const lines = \
text.split(\"\\n\");\n  const canvas = document.createElement(\"canvas\");\n  \
const ctx = canvas.getContext(\"2d\");\n  if (!ctx) {\n    throw new \
Error(\"Failed to create canvas context\");\n  }\n  ctx.font = `${fontSize}px \
${font}`;\n  ctx.textAlign = textAlign;\n  const metrics = \
ctx.measureText(\"\");\n  const fontHeight = metrics.fontBoundingBoxAscent + \
metrics.fontBoundingBoxDescent;\n  let minLeft = Number.POSITIVE_INFINITY;\n  \
let maxRight = Number.NEGATIVE_INFINITY;\n  let minTop = \
Number.POSITIVE_INFINITY;\n  let maxBottom = Number.NEGATIVE_INFINITY;\n  for \
(let line = 0; line < lines.length; ++line) {\n    const metrics2 = \
ctx.measureText(lines[line]);\n    const y = fontHeight * lineHeight * \
line;\n    minLeft = Math.min(minLeft, -metrics2.actualBoundingBoxLeft);\n    \
maxRight = Math.max(maxRight, metrics2.actualBoundingBoxRight);\n    minTop = \
Math.min(minTop, y - metrics2.actualBoundingBoxAscent);\n    maxBottom = \
Math.max(maxBottom, y + metrics2.actualBoundingBoxDescent);\n  }\n  const \
originLeft = Math.floor(minLeft);\n  const originTop = Math.floor(minTop);\n  \
const width = Math.ceil(maxRight) - originLeft;\n  const height = \
Math.ceil(maxBottom) - originTop;\n  canvas.width = width;\n  canvas.height = \
height;\n  ctx.font = `${fontSize}px ${font}`;\n  ctx.textAlign = \
textAlign;\n  ctx.textBaseline = \"alphabetic\";\n  ctx.fillStyle = \
\"#FFFFFF\";\n  for (let i = 0; i < lines.length; ++i) {\n    const y = \
fontHeight * lineHeight * i - originTop;\n    ctx.fillText(lines[i], \
-originLeft, y);\n  }\n  const imageData = ctx.getImageData(0, 0, width, \
height);\n  const rgba = new Uint8Array(imageData.data.buffer);\n  const \
splats = new PackedSplats();\n  const center = new THREE.Vector3();\n  const \
scales = new THREE.Vector3().setScalar(dotRadius * objectScale);\n  const \
quaternion = new THREE.Quaternion(0, 0, 0, 1);\n  rgb = rgb ?? new \
THREE.Color(1, 1, 1);\n  let offset = 0;\n  for (let y = 0; y < height; ++y) \
{\n    for (let x = 0; x < width; ++x) {\n      const a = rgba[offset + 3];\n \
     if (a > 0) {\n        const opacity = a / 255;\n        center.set(x - \
0.5 * (width - 1), 0.5 * (height - 1) - y, 0);\n        \
center.multiplyScalar(objectScale);\n        splats.pushSplat(center, scales, \
quaternion, opacity, rgb);\n      }\n      offset += 4;\n    }\n  }\n  const \
mesh = new SplatMesh({ packedSplats: splats });\n  mesh.recolor = color;\n  \
return mesh;\n}\nfunction imageSplats({\n  // URL of the image to convert to \
splats (example: `url: \"./image.png\"`)\n  url,\n  // Radius of each Gsplat, \
default covers 1-unit spacing well (default: 0.8)\n  dotRadius,\n  // \
Subsampling factor for the image. Higher values reduce resolution,\n  // for \
example 2 will halve the width and height by averaging (default: 1)\n  \
subXY,\n  // Optional callback function to modify each Gsplat before it's \
added.\n  // Return null to skip adding the Gsplat, or a number to set the \
opacity\n  // and add the Gsplat with parameter values in the objects center, \
rgba etc. were\n  // passed into the forEachSplat callback. Ending the \
callback in `return opacity;`\n  // will retain the original opacity.\n  // \
((width: number, height: number, index: number, center: THREE.Vector3, \
scales: THREE.Vector3, quaternion: THREE.Quaternion, opacity: number, color: \
THREE.Color) => number | null)\n  forEachSplat\n}) {\n  dotRadius = dotRadius \
?? 0.8;\n  subXY = Math.max(1, Math.floor(subXY ?? 1));\n  return new \
SplatMesh({\n    constructSplats: async (splats) => {\n      return new \
Promise((resolve, reject) => {\n        const img = new Image();\n        \
img.crossOrigin = \"anonymous\";\n        img.onerror = reject;\n        \
img.onload = () => {\n          const { width, height } = img;\n          \
const canvas = document.createElement(\"canvas\");\n          canvas.width = \
width;\n          canvas.height = height;\n          const ctx = \
canvas.getContext(\"2d\");\n          if (!ctx) {\n            reject(new \
Error(\"Failed to create canvas context\"));\n            return;\n          \
}\n          ctx.imageSmoothingEnabled = true;\n          \
ctx.imageSmoothingQuality = \"high\";\n          const destWidth = \
Math.round(width / subXY);\n          const destHeight = Math.round(height / \
subXY);\n          ctx.drawImage(img, 0, 0, destWidth, destHeight);\n         \
 try {\n            const imageData = ctx.getImageData(0, 0, destWidth, \
destHeight);\n            const rgba = new \
Uint8Array(imageData.data.buffer);\n            const center = new \
THREE.Vector3();\n            const scales = new \
THREE.Vector3().setScalar(dotRadius);\n            const quaternion = new \
THREE.Quaternion(0, 0, 0, 1);\n            const rgb = new THREE.Color();\n   \
         let index = 0;\n            for (let y = 0; y < destHeight; ++y) {\n \
             for (let x = 0; x < destWidth; ++x) {\n                const \
offset = index * 4;\n                const a = rgba[offset + 3];\n            \
    if (a > 0) {\n                  let opacity = a / 255;\n                  \
rgb.set(\n                    rgba[offset + 0] / 255,\n                    \
rgba[offset + 1] / 255,\n                    rgba[offset + 2] / 255\n         \
         );\n                  center.set(\n                    x - 0.5 * \
(destWidth - 1),\n                    0.5 * (destHeight - 1) - y,\n           \
         0\n                  );\n                  \
scales.setScalar(dotRadius);\n                  quaternion.set(0, 0, 0, 1);\n \
                 let push = true;\n                  if (forEachSplat) {\n    \
                const maybeOpacity = forEachSplat(\n                      \
destWidth,\n                      destHeight,\n                      index,\n \
                     center,\n                      scales,\n                 \
     quaternion,\n                      opacity,\n                      rgb\n \
                   );\n                    opacity = maybeOpacity ?? \
opacity;\n                    push = maybeOpacity !== null;\n                 \
 }\n                  if (push) {\n                    \
splats.pushSplat(center, scales, quaternion, opacity, rgb);\n                 \
 }\n                }\n                index += 1;\n              }\n         \
   }\n            resolve();\n          } catch (error) {\n            \
reject(error);\n          }\n        };\n        img.src = url;\n      });\n  \
  }\n  });\n}\nfunction staticBox({\n  box,\n  cells,\n  dotScale,\n  \
color,\n  opacity\n}) {\n  cells.x = Math.max(1, Math.round(cells.x));\n  \
cells.y = Math.max(1, Math.round(cells.y));\n  cells.z = Math.max(1, \
Math.round(cells.z));\n  opacity = opacity ?? 1;\n  const numSplats = cells.x \
* cells.y * cells.z;\n  const dynoX = dynoConst(\"int\", cells.x);\n  const \
dynoY = dynoConst(\"int\", cells.y);\n  dynoConst(\"int\", cells.z);\n  const \
dynoTime = dynoFloat(0);\n  const generator = new SplatGenerator({\n    \
numSplats,\n    generator: dynoBlock(\n      { index: \"int\" },\n      { \
gsplat: Gsplat },\n      ({ index }) => {\n        if (!index) {\n          \
throw new Error(\"index is undefined\");\n        }\n        const cellX = \
imod(index, dynoX);\n        const index2 = div(index, dynoX);\n        const \
cellY = imod(index2, dynoY);\n        const cellZ = div(index2, dynoY);\n     \
   const cell = combine({\n          vectorType: \"ivec3\",\n          x: \
cellX,\n          y: cellY,\n          z: cellZ\n        });\n        const \
intTime = floatBitsToInt(dynoTime);\n        const inputs = combine({ \
vectorType: \"ivec2\", x: index, y: intTime });\n        const random = \
hashVec3(inputs);\n        const min2 = dynoConst(\"vec3\", box.min);\n       \
 const max2 = dynoConst(\"vec3\", box.max);\n        const size = sub(max2, \
min2);\n        const coord = div(add(vec3(cell), random), \
dynoConst(\"vec3\", cells));\n        let r;\n        let g;\n        let \
b;\n        if (color) {\n          r = dynoConst(\"float\", color.r);\n      \
    g = dynoConst(\"float\", color.g);\n          b = dynoConst(\"float\", \
color.b);\n        } else {\n          ({ r, g, b } = \
split(coord).outputs);\n        }\n        const rgba = combine({\n          \
vectorType: \"vec4\",\n          r,\n          g,\n          b,\n          a: \
dynoConst(\"float\", opacity)\n        });\n        const center = add(min2, \
mul(size, coord));\n        const scales = vec3(dynoConst(\"float\", \
dotScale));\n        const quaternion = dynoConst(\"vec4\", new \
THREE.Quaternion(0, 0, 0, 1));\n        let gsplat = combineGsplat({\n        \
  flags: dynoLiteral(\"uint\", \"GSPLAT_FLAG_ACTIVE\"),\n          index,\n   \
       center,\n          scales,\n          quaternion,\n          rgba\n    \
    });\n        gsplat = transformer.applyGsplat(gsplat);\n        return { \
gsplat };\n      },\n      {\n        globals: () => [defineGsplat]\n      \
}\n    ),\n    update: ({ time }) => {\n      dynoTime.value = time;\n      \
transformer.update(generator);\n      generator.updateVersion();\n    }\n  \
});\n  const transformer = new SplatTransformer();\n  return \
generator;\n}\nconst DEFAULT_SNOW = {\n  box: new THREE.Box3(\n    new \
THREE.Vector3(-1, -1, -1),\n    new THREE.Vector3(1, 1, 1)\n  ),\n  density: \
100,\n  fallDirection: new THREE.Vector3(-1, -3, 1).normalize(),\n  \
fallVelocity: 0.02,\n  wanderScale: 0.04,\n  wanderVariance: 2,\n  color1: \
new THREE.Color(1, 1, 1),\n  color2: new THREE.Color(0.5, 0.5, 1),\n  \
minScale: 1e-3,\n  maxScale: 5e-3,\n  anisoScale: new THREE.Vector3(1, 1, \
1)\n};\nconst DEFAULT_RAIN = {\n  box: new THREE.Box3(\n    new \
THREE.Vector3(-2, -1, -2),\n    new THREE.Vector3(2, 5, 2)\n  ),\n  density: \
10,\n  fallDirection: new THREE.Vector3(0, -1, 0),\n  fallVelocity: 2,\n  \
wanderScale: 0.1,\n  wanderVariance: 1,\n  color1: new THREE.Color(1, 1, \
1),\n  color2: new THREE.Color(0.25, 0.25, 0.5),\n  minScale: 5e-3,\n  \
maxScale: 0.01,\n  anisoScale: new THREE.Vector3(0.1, 1, 0.1)\n};\nfunction \
snowBox({\n  // min and max box extents of the snowBox\n  box,\n  // minimum \
y-coordinate to clamp particle position, which can be used to\n  // fake \
hitting a ground plane and lingering there for a bit\n  minY,\n  // number of \
Gsplats to generate (default: calculated from box and density)\n  \
numSplats,\n  // density of Gsplats per unit volume (default: 100)\n  \
density,\n  // The xyz anisotropic scale of the Gsplat, which can be used for \
example\n  // to elongate rain particles (default: (1, 1, 1))\n  \
anisoScale,\n  // Minimum Gsplat particle scale (default: 0.001)\n  \
minScale,\n  // Maximum Gsplat particle scale (default: 0.005)\n  maxScale,\n \
 // The average direction of fall (default: (0, -1, 0))\n  fallDirection,\n  \
// The average speed of the fall (multiplied with fallDirection) (default: \
0.02)\n  fallVelocity,\n  // The world scale of wandering overlay motion \
(default: 0.01)\n  wanderScale,\n  // Controls how uniformly the particles \
wander in sync, more variance mean\n  // more randomness in the motion \
(default: 2)\n  wanderVariance,\n  // Color 1 of the two colors interpolated \
between (default: (1, 1, 1))\n  color1,\n  // Color 2 of the two colors \
interpolated between (default: (0.5, 0.5, 1))\n  color2,\n  // The base \
opacity of the Gsplats (default: 1)\n  opacity,\n  // Optional callback \
function to call each frame.\n  onFrame\n}) {\n  box = box ?? new \
THREE.Box3(new THREE.Vector3(-1, -1, -1), new THREE.Vector3(1, 1, 1));\n  \
const volume = (box.max.x - box.min.x) * (box.max.y - box.min.y) * (box.max.z \
- box.min.z);\n  density = density ?? 100;\n  numSplats = numSplats ?? \
Math.max(1, Math.min(1e6, Math.round(volume * density)));\n  const \
dynoMinScale = dynoFloat(minScale ?? 1e-3);\n  const dynoMaxScale = \
dynoFloat(maxScale ?? 5e-3);\n  const dynoAnisoScale = dynoVec3(\n    \
((anisoScale == null ? void 0 : anisoScale.clone()) ?? new THREE.Vector3(1, \
1, 1)).normalize()\n  );\n  const dynoFallDirection = dynoVec3(\n    \
(fallDirection ?? new THREE.Vector3(0, -1, 0)).normalize()\n  );\n  const \
dynoFallVelocity = dynoFloat(fallVelocity ?? 0.02);\n  const dynoWanderScale \
= dynoFloat(wanderScale ?? 0.01);\n  const dynoWanderVariance = \
dynoFloat(wanderVariance ?? 2);\n  const dynoColor1 = dynoVec3(color1 ?? new \
THREE.Color(1, 1, 1));\n  const dynoColor2 = dynoVec3(color2 ?? new \
THREE.Color(0.5, 0.5, 1));\n  const dynoOpacity = dynoFloat(opacity ?? 1);\n  \
const dynoTime = dynoFloat(0);\n  const globalOffset = dynoVec3(new \
THREE.Vector3(0, 0, 0));\n  const dynoMin = dynoVec3(box.min);\n  const \
dynoMax = dynoVec3(box.max);\n  const dynoMinY = dynoFloat(minY ?? \
Number.NEGATIVE_INFINITY);\n  const minMax = sub(dynoMax, dynoMin);\n  const \
snow = new SplatGenerator({\n    numSplats,\n    generator: dynoBlock(\n      \
{ index: \"int\" },\n      { gsplat: Gsplat },\n      ({ index }) => {\n      \
  if (!index) {\n          throw new Error(\"index not defined\");\n        \
}\n        const random = hashVec4(index);\n        const randomW = \
split(random).outputs.w;\n        let position = vec3(random);\n        let \
size = fract(mul(randomW, dynoConst(\"float\", 100)));\n        size = \
sin(mul(dynoLiteral(\"float\", \"PI\"), size));\n        size = \
add(dynoMinScale, mul(size, sub(dynoMaxScale, dynoMinScale)));\n        const \
scales = mul(size, dynoAnisoScale);\n        const intensity = \
fract(mul(randomW, dynoConst(\"float\", 10)));\n        const hue = \
fract(randomW);\n        const color = mix(dynoColor1, dynoColor2, hue);\n    \
    const rgb = mul(color, intensity);\n        const random2 = hashVec4(\n   \
       combine({\n            vectorType: \"ivec2\",\n            x: index,\n \
           y: dynoConst(\"int\", 6837)\n          })\n        );\n        let \
perturb = vec3(random2);\n        let timeOffset = \
mul(split(random2).outputs.w, dynoWanderVariance);\n        timeOffset = \
add(dynoTime, timeOffset);\n        position = add(position, globalOffset);\n \
       const modulo = mod(\n          position,\n          \
dynoConst(\"vec3\", new THREE.Vector3(1, 1, 1))\n        );\n        position \
= add(dynoMin, mul(minMax, modulo));\n        const quaternion = \
dynoConst(\"vec4\", new THREE.Quaternion(0, 0, 0, 1));\n        perturb = \
sin(add(vec3(timeOffset), perturb));\n        perturb = mul(perturb, \
dynoWanderScale);\n        let center = add(position, perturb);\n        let \
centerY = split(center).outputs.y;\n        centerY = max(dynoMinY, \
centerY);\n        center = combine({ vector: center, y: centerY });\n        \
let gsplat = combineGsplat({\n          flags: dynoLiteral(\"uint\", \
\"GSPLAT_FLAG_ACTIVE\"),\n          index,\n          center,\n          \
scales,\n          quaternion,\n          rgb,\n          opacity: \
dynoOpacity\n        });\n        gsplat = transformer.applyGsplat(gsplat);\n \
       return { gsplat };\n      },\n      {\n        globals: () => \
[defineGsplat]\n      }\n    ),\n    update: ({ object, time, deltaTime }) => \
{\n      dynoTime.value = time;\n      transformer.update(snow);\n      const \
fallDelta = \
dynoFallDirection.value.clone().multiplyScalar(dynoFallVelocity.value * \
deltaTime);\n      globalOffset.value.add(fallDelta);\n      object.visible = \
dynoOpacity.value > 0;\n      onFrame == null ? void 0 : onFrame({ object, \
time, deltaTime });\n      snow.updateVersion();\n    }\n  });\n  const \
transformer = new SplatTransformer();\n  return {\n    snow,\n    min: \
dynoMin,\n    max: dynoMax,\n    minY: dynoMinY,\n    color1: dynoColor1,\n   \
 color2: dynoColor2,\n    opacity: dynoOpacity,\n    fallVelocity: \
dynoFallVelocity,\n    wanderVariance: dynoWanderVariance,\n    wanderScale: \
dynoWanderScale,\n    fallDirection: dynoFallDirection,\n    minScale: \
dynoMinScale,\n    maxScale: dynoMaxScale,\n    anisoScale: dynoAnisoScale\n  \
};\n}\nconst generators = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ \
Object.defineProperty({\n  __proto__: null,\n  DEFAULT_RAIN,\n  \
DEFAULT_SNOW,\n  snowBox,\n  staticBox\n}, Symbol.toStringTag, { value: \
\"Module\" }));\nfunction makeNormalColorModifier(splatToView) {\n  return \
dynoBlock({ gsplat: Gsplat }, { gsplat: Gsplat }, ({ gsplat }) => {\n    if \
(!gsplat) {\n      throw new Error(\"No gsplat input\");\n    }\n    let \
normal = gsplatNormal(gsplat);\n    const viewGsplat = \
splatToView.applyGsplat(gsplat);\n    const viewCenter = \
splitGsplat(viewGsplat).outputs.center;\n    const viewNormal = \
gsplatNormal(viewGsplat);\n    const splatDot = dot(viewCenter, \
viewNormal);\n    const sameDir = greaterThanEqual(splatDot, \
dynoConst(\"float\", 0));\n    normal = select(sameDir, neg(normal), \
normal);\n    const rgb = add(\n      mul(normal, dynoConst(\"float\", \
0.5)),\n      dynoConst(\"float\", 0.5)\n    );\n    gsplat = combineGsplat({ \
gsplat, rgb });\n    return { gsplat };\n  });\n}\nfunction \
setWorldNormalColor(splats) {\n  splats.enableWorldToView = true;\n  \
splats.worldModifier = makeNormalColorModifier(splats.context.worldToView);\n \
 splats.updateGenerator();\n}\nfunction makeDepthColorModifier(splatToView, \
minDepth, maxDepth, reverse) {\n  return dynoBlock({ gsplat: Gsplat }, { \
gsplat: Gsplat }, ({ gsplat }) => {\n    if (!gsplat) {\n      throw new \
Error(\"No gsplat input\");\n    }\n    let { center } = \
splitGsplat(gsplat).outputs;\n    center = splatToView.apply(center);\n    \
const { z } = split(center).outputs;\n    let depth = normalizedDepth(neg(z), \
minDepth, maxDepth);\n    depth = select(reverse, sub(dynoConst(\"float\", \
1), depth), depth);\n    gsplat = combineGsplat({ gsplat, r: depth, g: depth, \
b: depth });\n    return { gsplat };\n  });\n}\nfunction \
setDepthColor(splats, minDepth, maxDepth, reverse) {\n  \
splats.enableWorldToView = true;\n  const dynoMinDepth = dynoConst(\"float\", \
minDepth);\n  const dynoMaxDepth = dynoConst(\"float\", maxDepth);\n  const \
dynoReverse = dynoConst(\"bool\", reverse ?? false);\n  splats.worldModifier \
= makeDepthColorModifier(\n    splats.context.worldToView,\n    \
dynoMinDepth,\n    dynoMaxDepth,\n    dynoReverse\n  );\n  \
splats.updateGenerator();\n  return {\n    minDepth: dynoMinDepth,\n    \
maxDepth: dynoMaxDepth,\n    reverse: dynoReverse\n  };\n}\nconst modifiers = \
/* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  \
__proto__: null,\n  makeDepthColorModifier,\n  makeNormalColorModifier,\n  \
setDepthColor,\n  setWorldNormalColor\n}, Symbol.toStringTag, { value: \
\"Module\" }));\nconst _VRButton = class _VRButton {\n  static \
createButton(renderer, sessionInit = {}) {\n    const navigatorXr = \
navigator.xr;\n    if (!navigatorXr) {\n      return null;\n    }\n    const \
xr = navigatorXr;\n    const button = document.createElement(\"button\");\n   \
 renderer.xr.enabled = true;\n    \
renderer.xr.setReferenceSpaceType(\"local\");\n    function showEnterVR() {\n \
     let currentSession = null;\n      async function \
onSessionStarted(session) {\n        console.log(\"onSessionStarted\");\n     \
   session.addEventListener(\"end\", onSessionEnded);\n        await \
renderer.xr.setSession(session);\n        button.textContent = \"EXIT VR\";\n \
       currentSession = session;\n      }\n      function onSessionEnded() \
{\n        console.log(\"onSessionEnded\");\n        currentSession == null ? \
void 0 : currentSession.removeEventListener(\"end\", onSessionEnded);\n       \
 button.textContent = \"ENTER VR\";\n        currentSession = null;\n      \
}\n      button.style.display = \"\";\n      button.style.cursor = \
\"pointer\";\n      button.style.left = \"calc(50% - 100px)\";\n      \
button.style.width = \"200px\";\n      button.style.height = \"100px\";\n     \
 button.textContent = \"ENTER VR\";\n      const sessionOptions = {\n        \
...sessionInit,\n        optionalFeatures: [\n          // \"local-floor\",\n \
         // \"bounded-floor\",\n          // \"layers\",\n          \
...sessionInit.optionalFeatures || []\n        ]\n      };\n      \
button.onmouseenter = () => {\n        button.style.opacity = \"1.0\";\n      \
};\n      button.onmouseleave = () => {\n        button.style.opacity = \
\"0.5\";\n      };\n      button.onclick = () => {\n        if \
(currentSession === null) {\n          console.log(\"requesting session\");\n \
         xr.requestSession(\"immersive-vr\", sessionOptions).then(\n          \
  onSessionStarted\n          );\n        } else {\n          \
console.log(\"ending session\");\n          currentSession.end();\n        \
}\n      };\n    }\n    function disableButton() {\n      \
button.style.display = \"none\";\n      button.style.cursor = \"auto\";\n     \
 button.style.left = \"calc(50% - 75px)\";\n      button.style.width = \
\"150px\";\n      button.onmouseenter = null;\n      button.onmouseleave = \
null;\n      button.onclick = null;\n    }\n    function showWebXRNotFound() \
{\n      disableButton();\n      button.textContent = \"VR NOT SUPPORTED\";\n \
   }\n    function showVRNotAllowed(exception) {\n      disableButton();\n    \
  console.warn(\n        \"Exception when trying to call \
xr.isSessionSupported\",\n        exception\n      );\n      \
button.textContent = \"VR NOT ALLOWED\";\n    }\n    function \
stylizeElement(element) {\n      element.style.position = \"absolute\";\n     \
 element.style.bottom = \"20px\";\n      element.style.padding = \"12px \
6px\";\n      element.style.border = \"1px solid #fff\";\n      \
element.style.borderRadius = \"4px\";\n      element.style.background = \
\"rgba(0,0,0,0.1)\";\n      element.style.color = \"#fff\";\n      \
element.style.font = \"normal 13px sans-serif\";\n      \
element.style.textAlign = \"center\";\n      element.style.opacity = \
\"0.5\";\n      element.style.outline = \"none\";\n      element.style.zIndex \
= \"999\";\n    }\n    button.id = \"VRButton\";\n    button.style.display = \
\"none\";\n    stylizeElement(button);\n    \
xr.isSessionSupported(\"immersive-vr\").then((supported) => {\n      \
supported ? showEnterVR() : showWebXRNotFound();\n      if (supported && \
_VRButton.xrSessionIsGranted) {\n        button.click();\n      }\n    \
}).catch(showVRNotAllowed);\n    return button;\n  }\n  static \
registerSessionGrantedListener() {\n    const navigatorXr = navigator.xr;\n   \
 if (!navigatorXr) {\n      return null;\n    }\n    const xr = \
navigatorXr;\n    if (/WebXRViewer\\//i.test(navigator.userAgent)) return;\n  \
  xr.addEventListener(\"sessiongranted\", () => {\n      \
_VRButton.xrSessionIsGranted = true;\n    });\n  \
}\n};\n_VRButton.xrSessionIsGranted = false;\nlet VRButton = \
_VRButton;\nVRButton.registerSessionGrantedListener();\nconst \
DEFAULT_MOVE_INERTIA$1 = 0.5;\nconst DEFAULT_ROTATE_INERTIA$1 = 0.5;\nconst \
TOUCH_BIAS = 0;\nvar JointEnum = /* @__PURE__ */ ((JointEnum2) => {\n  \
JointEnum2[\"w\"] = \"wrist\";\n  JointEnum2[\"t0\"] = \
\"thumb-metacarpal\";\n  JointEnum2[\"t1\"] = \"thumb-phalanx-proximal\";\n  \
JointEnum2[\"t2\"] = \"thumb-phalanx-distal\";\n  JointEnum2[\"t3\"] = \
\"thumb-tip\";\n  JointEnum2[\"i0\"] = \"index-finger-metacarpal\";\n  \
JointEnum2[\"i1\"] = \"index-finger-phalanx-proximal\";\n  JointEnum2[\"i2\"] \
= \"index-finger-phalanx-intermediate\";\n  JointEnum2[\"i3\"] = \
\"index-finger-phalanx-distal\";\n  JointEnum2[\"i4\"] = \
\"index-finger-tip\";\n  JointEnum2[\"m0\"] = \"middle-finger-metacarpal\";\n \
 JointEnum2[\"m1\"] = \"middle-finger-phalanx-proximal\";\n  \
JointEnum2[\"m2\"] = \"middle-finger-phalanx-intermediate\";\n  \
JointEnum2[\"m3\"] = \"middle-finger-phalanx-distal\";\n  JointEnum2[\"m4\"] \
= \"middle-finger-tip\";\n  JointEnum2[\"r0\"] = \
\"ring-finger-metacarpal\";\n  JointEnum2[\"r1\"] = \
\"ring-finger-phalanx-proximal\";\n  JointEnum2[\"r2\"] = \
\"ring-finger-phalanx-intermediate\";\n  JointEnum2[\"r3\"] = \
\"ring-finger-phalanx-distal\";\n  JointEnum2[\"r4\"] = \
\"ring-finger-tip\";\n  JointEnum2[\"p0\"] = \"pinky-finger-metacarpal\";\n  \
JointEnum2[\"p1\"] = \"pinky-finger-phalanx-proximal\";\n  JointEnum2[\"p2\"] \
= \"pinky-finger-phalanx-intermediate\";\n  JointEnum2[\"p3\"] = \
\"pinky-finger-phalanx-distal\";\n  JointEnum2[\"p4\"] = \
\"pinky-finger-tip\";\n  return JointEnum2;\n})(JointEnum || {});\nconst \
JOINT_IDS = Object.keys(JointEnum);\nconst NUM_JOINTS = \
JOINT_IDS.length;\nconst JOINT_INDEX = {\n  w: 0,\n  t0: 1,\n  t1: 2,\n  t2: \
3,\n  t3: 4,\n  i0: 5,\n  i1: 6,\n  i2: 7,\n  i3: 8,\n  i4: 9,\n  m0: 10,\n  \
m1: 11,\n  m2: 12,\n  m3: 13,\n  m4: 14,\n  r0: 15,\n  r1: 16,\n  r2: 17,\n  \
r3: 18,\n  r4: 19,\n  p0: 20,\n  p1: 21,\n  p2: 22,\n  p3: 23,\n  p4: \
24\n};\nconst JOINT_RADIUS = {\n  w: 0.02,\n  t0: 0.02,\n  t1: 0.014,\n  t2: \
0.0115,\n  t3: 85e-4,\n  i0: 0.022,\n  i1: 0.012,\n  i2: 85e-4,\n  i3: \
75e-4,\n  i4: 65e-4,\n  m0: 0.021,\n  m1: 0.012,\n  m2: 8e-3,\n  m3: 75e-4,\n \
 m4: 65e-4,\n  r0: 0.019,\n  r1: 0.011,\n  r2: 75e-4,\n  r3: 7e-3,\n  r4: \
6e-3,\n  p0: 0.012,\n  p1: 0.01,\n  p2: 7e-3,\n  p3: 65e-4,\n  p4: \
55e-4\n};\nconst JOINT_SEGMENTS = [\n  [\"w\", \"t0\", \"t1\", \"t2\", \
\"t3\"],\n  [\"w\", \"i0\", \"i1\", \"i2\", \"i3\", \"i4\"],\n  [\"w\", \
\"m0\", \"m1\", \"m2\", \"m3\", \"m4\"],\n  [\"w\", \"r0\", \"r1\", \"r2\", \
\"r3\", \"r4\"],\n  [\"w\", \"p0\", \"p1\", \"p2\", \"p3\", \
\"p4\"]\n];\nconst JOINT_SEGMENT_STEPS = [\n  [8, 10, 8, 6],\n  [8, 19, 14, \
8, 6],\n  [8, 19, 14, 8, 6],\n  [8, 19, 14, 8, 6],\n  [8, 19, 14, 8, \
6]\n];\nconst JOINT_TIPS = [\"t3\", \"i4\", \"m4\", \"r4\", \"p4\"];\nconst \
FINGER_TIPS = [\"i4\", \"m4\", \"r4\", \"p4\"];\nvar Hand = /* @__PURE__ */ \
((Hand2) => {\n  Hand2[\"left\"] = \"left\";\n  Hand2[\"right\"] = \
\"right\";\n  return Hand2;\n})(Hand || {});\nconst HANDS = \
Object.keys(Hand);\nclass XrHands {\n  constructor() {\n    this.hands = \
{};\n    this.last = {};\n    this.values = {};\n    this.tests = {};\n    \
this.lastTests = {};\n    this.updated = false;\n  }\n  update({ xr, xrFrame \
}) {\n    const xrSession = xr.getSession();\n    if (!xrSession) {\n      \
return;\n    }\n    const referenceSpace = xr.getReferenceSpace();\n    if \
(!referenceSpace) {\n      return;\n    }\n    if (!xrFrame.getJointPose) {\n \
     return;\n    }\n    this.last = this.hands;\n    this.lastTests = \
this.tests;\n    this.hands = {};\n    this.values = {};\n    this.tests = \
{};\n    for (const inputSource of xrSession.inputSources) {\n      if \
(!inputSource.hand) {\n        continue;\n      }\n      const hand = \
inputSource.handedness;\n      this.hands[hand] = {};\n      for (const \
jointId of JOINT_IDS) {\n        const jointSpace = \
inputSource.hand.get(JointEnum[jointId]);\n        if (jointSpace) {\n        \
  const jointPose = xrFrame.getJointPose(jointSpace, referenceSpace);\n       \
   if (jointPose) {\n            const { position, orientation } = \
jointPose.transform;\n            this.hands[hand][jointId] = {\n             \
 position: new Vector3(position.x, position.y, position.z),\n              \
quaternion: new Quaternion(\n                orientation.x,\n                \
orientation.y,\n                orientation.z,\n                \
orientation.w\n              ),\n              radius: jointPose.radius || \
1e-3\n            };\n          }\n        }\n      }\n    }\n    for (const \
hand of HANDS) {\n      for (const { key, value } of [\n        { key: \
`${hand}AllTips`, value: this.allTipsTouching(hand) },\n        {\n          \
key: `${hand}IndexThumb`,\n          value: this.touching(hand, \"i4\", hand, \
\"t3\")\n        },\n        {\n          key: `${hand}MiddleThumb`,\n        \
  value: this.touching(hand, \"m4\", hand, \"t3\")\n        },\n        {\n   \
       key: `${hand}RingThumb`,\n          value: this.touching(hand, \"r4\", \
hand, \"t3\")\n        },\n        {\n          key: `${hand}PinkyThumb`,\n   \
       value: this.touching(hand, \"p4\", hand, \"t3\")\n        },\n        \
{ key: `${hand}TriTips`, value: this.triTipsTouching(hand) }\n      ]) {\n    \
    this.values[key] = value;\n        this.tests[key] = value === 1 ? true : \
value === 0 ? false : this.lastTests[key] ?? false;\n      }\n    }\n  }\n  \
makeGhostMesh() {\n    const center = new Vector3();\n    const scales = new \
Vector3(0.01, 0.01, 0.01);\n    const quaternion = new Quaternion(0, 0, 0, \
1);\n    const color = new Color(1, 1, 1);\n    const CYCLE = Math.PI * 3;\n  \
  new Color(1, 1, 1);\n    let opacity = 1;\n    const mesh = new \
SplatMesh({\n      onFrame: () => {\n        let splatIndex = 0;\n        for \
(const handedness of HANDS) {\n          const xrHand = \
this.hands[handedness];\n          for (const [index, segment] of \
JOINT_SEGMENTS.entries()) {\n            for (let i = 1; i < segment.length; \
++i) {\n              const segmentSplats = JOINT_SEGMENT_STEPS[index][i - 1] \
* 2;\n              const lastSegment = i + 1 === segment.length;\n           \
   const jointA = xrHand == null ? void 0 : xrHand[segment[i - 1]];\n         \
     const jointB = xrHand == null ? void 0 : xrHand[segment[i]];\n           \
   for (let j = 0; j < segmentSplats; ++j) {\n                const t = (j + \
0.5) / segmentSplats;\n                opacity = 0;\n                if \
(jointA && jointB) {\n                  \
center.copy(jointA.position).lerp(jointB.position, t);\n                  \
quaternion.copy(jointA.quaternion).slerp(jointB.quaternion, t);\n             \
     const radiusA = JOINT_RADIUS[segment[i - 1]];\n                  const \
radiusB = JOINT_RADIUS[segment[i]];\n                  let radius = (1 - t) * \
radiusA + t * radiusB;\n                  if (lastSegment && t > 0.8) {\n     \
               radius *= Math.sqrt(1 - ((t - 0.8) / 0.2) ** 2);\n             \
     }\n                  scales.set(0.65 * radius, 0.5 * radius, 3e-3);\n    \
              color.set(\n                    0.55 + 0.45 * Math.sin(center.x \
* CYCLE),\n                    0.55 + 0.45 * Math.sin(center.y * CYCLE),\n    \
                0.55 + 0.45 * Math.sin(center.z * CYCLE)\n                  \
);\n                  if (handedness === \"right\") {\n                    \
color.set(1 - color.r, 1 - color.g, 1 - color.b);\n                  }\n      \
            opacity = 0.75;\n                }\n                \
mesh.packedSplats.setSplat(\n                  splatIndex,\n                  \
center,\n                  scales,\n                  quaternion,\n           \
       opacity,\n                  color\n                );\n                \
splatIndex += 1;\n              }\n            }\n          }\n        }\n    \
    mesh.packedSplats.numSplats = splatIndex;\n        \
mesh.packedSplats.needsUpdate = true;\n        mesh.numSplats = splatIndex;\n \
       mesh.updateVersion();\n      }\n    });\n    return mesh;\n  }\n  \
distance(handA, jointA, handB, jointB, last = false) {\n    const hA = last ? \
this.last[handA] : this.hands[handA];\n    const hB = last ? this.last[handB] \
: this.hands[handB];\n    const jA = hA == null ? void 0 : hA[jointA];\n    \
const jB = hB == null ? void 0 : hB[jointB];\n    if (!jA || !jB) {\n      \
return Number.POSITIVE_INFINITY;\n    }\n    return \
jA.position.distanceTo(jB.position);\n  }\n  separation(handA, jointA, handB, \
jointB, last = false) {\n    const d = this.distance(handA, jointA, handB, \
jointB, last);\n    if (d === Number.POSITIVE_INFINITY) {\n      return \
Number.POSITIVE_INFINITY;\n    }\n    return d - JOINT_RADIUS[jointA] - \
JOINT_RADIUS[jointB];\n  }\n  touching(handA, jointA, handB, jointB, last = \
false) {\n    const d = this.separation(handA, jointA, handB, jointB, \
last);\n    if (d === Number.POSITIVE_INFINITY) {\n      return \
Number.POSITIVE_INFINITY;\n    }\n    return 1 - Math.max(0, Math.min(1, d / \
0.01 - TOUCH_BIAS));\n  }\n  allTipsTouching(hand, last = false) {\n    \
return Math.min(\n      this.touching(hand, \"t3\", hand, \"i4\", last),\n    \
  this.touching(hand, \"i4\", hand, \"m4\", last),\n      this.touching(hand, \
\"m4\", hand, \"r4\", last),\n      this.touching(hand, \"r4\", hand, \"p4\", \
last)\n      // this.touching(hand, \"p4\", hand, \"t3\", last),\n    );\n  \
}\n  triTipsTouching(hand, last = false) {\n    return Math.min(\n      \
this.touching(hand, \"t3\", hand, \"i4\", last),\n      this.touching(hand, \
\"i4\", hand, \"m4\", last),\n      this.touching(hand, \"m4\", hand, \"t3\", \
last)\n    );\n  }\n}\nclass HandMovement {\n  constructor({\n    xrHands,\n  \
  control,\n    moveInertia,\n    rotateInertia\n  }) {\n    this.lastGrip = \
{};\n    this.lastPivot = new Vector3();\n    this.rotateVelocity = 0;\n    \
this.velocity = new Vector3();\n    this.xrHands = xrHands;\n    this.control \
= control;\n    this.moveInertia = moveInertia ?? DEFAULT_MOVE_INERTIA$1;\n   \
 this.rotateInertia = rotateInertia ?? DEFAULT_ROTATE_INERTIA$1;\n  }\n  \
update(deltaTime) {\n    var _a2, _b2, _c, _d, _e;\n    const grip = {};\n    \
for (const handedness of HANDS) {\n      const hand = \
this.xrHands.hands[handedness];\n      if (hand && \
this.xrHands.tests[`${handedness}MiddleThumb`]) {\n        grip[handedness] = \
new Vector3().add(((_a2 = hand.t3) == null ? void 0 : _a2.position) ?? new \
Vector3()).add(((_b2 = hand.i4) == null ? void 0 : _b2.position) ?? new \
Vector3()).add(((_c = hand.m4) == null ? void 0 : _c.position) ?? new \
Vector3()).add(((_d = hand.r4) == null ? void 0 : _d.position) ?? new \
Vector3()).add(((_e = hand.p4) == null ? void 0 : _e.position) ?? new \
Vector3()).multiplyScalar(1 / 5);\n      }\n    }\n    if (grip.left && \
grip.right && this.lastGrip.left && this.lastGrip.right) {\n      const mid = \
grip.left.clone().add(grip.right).multiplyScalar(0.5);\n      const lastMid = \
this.lastGrip.left.clone().add(this.lastGrip.right).multiplyScalar(0.5);\n    \
  this.lastPivot = mid;\n      const delta = \
mid.clone().applyMatrix4(this.control.matrix);\n      \
delta.sub(lastMid.clone().applyMatrix4(this.control.matrix));\n      \
delta.multiplyScalar(1 / deltaTime);\n      this.velocity.lerp(delta, 1 - \
Math.exp(-20 * deltaTime));\n      const angle = Math.atan2(grip.left.z - \
mid.z, grip.left.x - mid.x);\n      const lastAngle = Math.atan2(\n        \
this.lastGrip.left.z - lastMid.z,\n        this.lastGrip.left.x - lastMid.x\n \
     );\n      let closestAngle = angle - lastAngle;\n      if (closestAngle \
> Math.PI) {\n        closestAngle -= Math.PI * 2;\n      } else if \
(closestAngle < -Math.PI) {\n        closestAngle += Math.PI * 2;\n      }\n  \
    const rotateVelocity = closestAngle / deltaTime;\n      const blend = \
Math.exp(-20 * deltaTime);\n      this.rotateVelocity = this.rotateVelocity * \
blend + rotateVelocity * (1 - blend);\n    } else {\n      \
this.rotateVelocity *= Math.exp(-deltaTime / this.rotateInertia);\n      if \
(grip.left && this.lastGrip.left) {\n        const delta = \
grip.left.clone().applyMatrix4(this.control.matrix);\n        \
delta.sub(this.lastGrip.left.clone().applyMatrix4(this.control.matrix));\n    \
    delta.multiplyScalar(1 / deltaTime);\n        this.velocity.lerp(delta, 1 \
- Math.exp(-20 * deltaTime));\n      } else if (grip.right && \
this.lastGrip.right) {\n        const delta = \
grip.right.clone().applyMatrix4(this.control.matrix);\n        delta.sub(\n   \
       this.lastGrip.right.clone().applyMatrix4(this.control.matrix)\n        \
);\n        delta.multiplyScalar(1 / deltaTime);\n        \
this.velocity.lerp(delta, 1 - Math.exp(-20 * deltaTime));\n      } else {\n   \
     this.velocity.multiplyScalar(Math.exp(-deltaTime / this.moveInertia));\n \
     }\n    }\n    const negPivot = this.lastPivot.clone().negate();\n    \
const rotate = new Matrix4().makeTranslation(negPivot).premultiply(new \
Matrix4().makeRotationY(this.rotateVelocity * deltaTime)).premultiply(new \
Matrix4().makeTranslation(this.lastPivot));\n    \
this.control.matrix.multiply(rotate);\n    this.control.matrix.decompose(\n   \
   this.control.position,\n      this.control.quaternion,\n      \
this.control.scale\n    );\n    this.control.updateMatrixWorld(true);\n    \
this.control.position.sub(this.velocity.clone().multiplyScalar(deltaTime));\n \
   this.lastGrip = grip;\n  }\n}\nconst DEFAULT_MOVEMENT_SPEED = 1;\nconst \
DEFAULT_ROLL_SPEED = 2;\nconst DEFAULT_ROTATE_SPEED = 2e-3;\nconst \
DEFAULT_SLIDE_SPEED = 6e-3;\nconst DEFAULT_SCROLL_SPEED = 15e-4;\nconst \
DEFAULT_ROTATE_INERTIA = 0.15;\nconst DEFAULT_MOVE_INERTIA = 0.15;\nconst \
DEFAULT_STICK_THRESHOLD = 0.1;\nconst DEFAULT_FPS_ROTATE_SPEED = 2;\nconst \
DEFAULT_POINTER_ROLL_SCALE = 1;\nconst DUAL_PRESS_MS = 200;\nconst \
DOUBLE_PRESS_LIMIT_MS = 400;\nconst DOUBLE_PRESS_DISTANCE = 50;\nconst \
WASD_KEYCODE_MOVE = {\n  KeyW: new THREE.Vector3(0, 0, -1),\n  KeyS: new \
THREE.Vector3(0, 0, 1),\n  KeyA: new THREE.Vector3(-1, 0, 0),\n  KeyD: new \
THREE.Vector3(1, 0, 0),\n  KeyR: new THREE.Vector3(0, 1, 0),\n  KeyF: new \
THREE.Vector3(0, -1, 0)\n};\nconst ARROW_KEYCODE_MOVE = {\n  ArrowUp: new \
THREE.Vector3(0, 0, -1),\n  ArrowDown: new THREE.Vector3(0, 0, 1),\n  \
ArrowLeft: new THREE.Vector3(-1, 0, 0),\n  ArrowRight: new THREE.Vector3(1, \
0, 0),\n  PageUp: new THREE.Vector3(0, 1, 0),\n  PageDown: new \
THREE.Vector3(0, -1, 0)\n};\nconst QE_KEYCODE_ROTATE = {\n  KeyQ: new \
THREE.Vector3(0, 0, 1),\n  KeyE: new THREE.Vector3(0, 0, -1)\n};\nconst \
ARROW_KEYCODE_ROTATE = {\n  Home: new THREE.Vector3(0, -1, 0),\n  End: new \
THREE.Vector3(0, 1, 0),\n  Insert: new THREE.Vector3(-1, 0, 0),\n  Delete: \
new THREE.Vector3(1, 0, 0)\n};\nclass SparkControls {\n  constructor({ canvas \
}) {\n    this.lastTime = 0;\n    this.fpsMovement = new FpsMovement({});\n   \
 this.pointerControls = new PointerControls({ canvas });\n  }\n  \
update(control) {\n    const time = performance.now();\n    const deltaTime = \
(time - (this.lastTime || time)) / 1e3;\n    this.lastTime = time;\n    \
this.fpsMovement.update(deltaTime, control);\n    \
this.pointerControls.update(deltaTime, control);\n  }\n}\nclass FpsMovement \
{\n  constructor({\n    moveSpeed,\n    rollSpeed,\n    stickThreshold,\n    \
rotateSpeed,\n    keycodeMoveMapping,\n    keycodeRotateMapping,\n    \
gamepadMapping,\n    capsMultiplier,\n    shiftMultiplier,\n    \
ctrlMultiplier,\n    xr\n  } = {}) {\n    this.enable = true;\n    \
this.moveSpeed = moveSpeed ?? DEFAULT_MOVEMENT_SPEED;\n    this.rollSpeed = \
rollSpeed ?? DEFAULT_ROLL_SPEED;\n    this.stickThreshold = stickThreshold ?? \
DEFAULT_STICK_THRESHOLD;\n    this.rotateSpeed = rotateSpeed ?? \
DEFAULT_FPS_ROTATE_SPEED;\n    this.keycodeMoveMapping = keycodeMoveMapping \
?? {\n      ...WASD_KEYCODE_MOVE,\n      ...ARROW_KEYCODE_MOVE\n    };\n    \
this.keycodeRotateMapping = keycodeRotateMapping ?? {\n      \
...QE_KEYCODE_ROTATE,\n      ...ARROW_KEYCODE_ROTATE\n    };\n    \
this.gamepadMapping = gamepadMapping ?? {\n      4: \"rollLeft\",\n      5: \
\"rollRight\",\n      6: \"ctrl\",\n      7: \"shift\"\n    };\n    \
this.capsMultiplier = capsMultiplier ?? 10;\n    this.shiftMultiplier = \
shiftMultiplier ?? 5;\n    this.ctrlMultiplier = ctrlMultiplier ?? 1 / 5;\n   \
 this.xr = xr;\n    this.keydown = {};\n    this.keycode = {};\n    \
document.addEventListener(\"keydown\", (event) => {\n      \
this.keydown[event.key] = true;\n      this.keycode[event.code] = true;\n    \
});\n    document.addEventListener(\"keyup\", (event) => {\n      \
this.keydown[event.key] = false;\n      this.keycode[event.code] = false;\n   \
 });\n    window.addEventListener(\"blur\", () => {\n      this.keydown = \
{};\n      this.keycode = {};\n    });\n  }\n  // Call this method in your \
render loop with `control` set to the object to control\n  // (`THREE.Camera` \
or a `THREE.Object3D` that contains it), with `deltaTime`\n  // in seconds \
since the last update.\n  update(deltaTime, control) {\n    var _a2, _b2;\n   \
 if (!this.enable) {\n      return;\n    }\n    const sticks = [new \
THREE.Vector2(), new THREE.Vector2()];\n    const gamepad = \
navigator.getGamepads()[0];\n    if (gamepad) {\n      \
sticks[0].set(gamepad.axes[0], gamepad.axes[1]);\n      \
sticks[1].set(gamepad.axes[2], gamepad.axes[3]);\n    }\n    const \
gamepadButtons = (gamepad == null ? void 0 : gamepad.buttons.map((button) => \
button.pressed)) || [];\n    const xrSources = Array.from(((_b2 = (_a2 = \
this.xr) == null ? void 0 : _a2.getSession()) == null ? void 0 : \
_b2.inputSources) ?? []);\n    for (const source of xrSources) {\n      const \
gamepad2 = source.gamepad;\n      if (gamepad2) {\n        switch \
(source.handedness) {\n          case \"none\": {\n            sticks[0].x += \
gamepad2.axes[0];\n            sticks[0].y += gamepad2.axes[1];\n            \
sticks[1].x += gamepad2.axes[2];\n            sticks[1].y += \
gamepad2.axes[3];\n            break;\n          }\n          case \"left\": \
{\n            sticks[0].x += gamepad2.axes[2];\n            sticks[0].y += \
gamepad2.axes[3];\n            break;\n          }\n          case \"right\": \
{\n            sticks[1].x += gamepad2.axes[2];\n            sticks[1].y += \
gamepad2.axes[3];\n            break;\n          }\n        }\n      }\n    \
}\n    for (const stick of sticks) {\n      stick.x = Math.abs(stick.x) >= \
this.stickThreshold ? stick.x : 0;\n      stick.y = Math.abs(stick.y) >= \
this.stickThreshold ? stick.y : 0;\n    }\n    const rotate = new \
THREE.Vector3(\n      sticks[1].x,\n      sticks[1].y,\n      0\n    \
).multiplyScalar(this.rotateSpeed);\n    for (const [keycode, rot] of \
Object.entries(this.keycodeRotateMapping)) {\n      if \
(this.keycode[keycode]) {\n        rotate.add(rot);\n      }\n    }\n    for \
(const button in this.gamepadMapping) {\n      if \
(gamepadButtons[Number.parseInt(button)]) {\n        switch \
(this.gamepadMapping[button]) {\n          case \"rollLeft\":\n            \
rotate.z += 1;\n            break;\n          case \"rollRight\":\n           \
 rotate.z -= 1;\n            break;\n        }\n      }\n    }\n    \
rotate.multiply(\n      new THREE.Vector3(this.rotateSpeed, this.rotateSpeed, \
this.rollSpeed)\n    );\n    if (rotate.manhattanLength() > 0) {\n      \
rotate.multiplyScalar(deltaTime);\n      const eulers = new \
THREE.Euler().setFromQuaternion(\n        control.quaternion,\n        \
\"YXZ\"\n      );\n      eulers.y -= rotate.x;\n      eulers.x = Math.max(\n  \
      -Math.PI / 2,\n        Math.min(Math.PI / 2, eulers.x - rotate.y)\n     \
 );\n      eulers.z = Math.max(-Math.PI, Math.min(Math.PI, eulers.z + \
rotate.z));\n      control.quaternion.setFromEuler(eulers);\n    }\n    const \
moveVector = new THREE.Vector3(sticks[0].x, 0, sticks[0].y);\n    for (const \
[keycode, move] of Object.entries(this.keycodeMoveMapping)) {\n      if \
(this.keycode[keycode]) {\n        moveVector.add(move);\n      }\n    }\n    \
let speedMultiplier = 1;\n    if (this.keydown.CapsLock) {\n      \
speedMultiplier *= this.capsMultiplier;\n    }\n    if \
(this.keycode.ShiftLeft || this.keycode.ShiftRight) {\n      speedMultiplier \
*= this.shiftMultiplier;\n    }\n    if (this.keycode.ControlLeft || \
this.keycode.ControlRight) {\n      speedMultiplier *= this.ctrlMultiplier;\n \
   }\n    for (const button in this.gamepadMapping) {\n      if \
(gamepadButtons[Number.parseInt(button)]) {\n        switch \
(this.gamepadMapping[button]) {\n          case \"shift\":\n            \
speedMultiplier *= this.shiftMultiplier;\n            break;\n          case \
\"ctrl\":\n            speedMultiplier *= this.ctrlMultiplier;\n            \
break;\n        }\n      }\n    }\n    \
moveVector.applyQuaternion(control.quaternion);\n    control.position.add(\n  \
    moveVector.multiplyScalar(this.moveSpeed * speedMultiplier * deltaTime)\n \
   );\n  }\n}\nclass PointerControls {\n  constructor({\n    // The HTML \
canvas element to attach pointer events to\n    canvas,\n    // Speed of \
rotation (default DEFAULT_ROTATE_SPEED)\n    rotateSpeed,\n    // Speed of \
sliding when dragging with right/middle mouse button or two fingers\n    // \
(default DEFAULT_SLIDE_SPEED)\n    slideSpeed,\n    // Speed of movement when \
using mouse scroll wheel (default DEFAULT_SCROLL_SPEED)\n    scrollSpeed,\n   \
 // Swap the direction of rotation and sliding (default: false)\n    \
swapRotateSlide,\n    // Reverse the direction of rotation (default: false)\n \
   reverseRotate,\n    // Reverse the direction of sliding (default: false)\n \
   reverseSlide,\n    // Reverse the direction of swipe gestures (default: \
false)\n    reverseSwipe,\n    // Reverse the direction of scroll wheel \
movement (default: false)\n    reverseScroll,\n    // Inertia factor for \
movement (default: DEFAULT_MOVE_INERTIA)\n    moveInertia,\n    // Inertia \
factor for rotation (default: DEFAULT_ROTATE_INERTIA)\n    rotateInertia,\n   \
 // Pointer rolling scale factor (default: DEFAULT_POINTER_ROLL_SCALE)\n    \
pointerRollScale,\n    // Callback for double press events (default: () => \
{})\n    doublePress\n  }) {\n    this.enable = true;\n    this.canvas = \
canvas;\n    this.rotateSpeed = rotateSpeed ?? DEFAULT_ROTATE_SPEED;\n    \
this.slideSpeed = slideSpeed ?? DEFAULT_SLIDE_SPEED;\n    this.scrollSpeed = \
scrollSpeed ?? DEFAULT_SCROLL_SPEED;\n    this.swapRotateSlide = \
swapRotateSlide ?? false;\n    this.reverseRotate = reverseRotate ?? false;\n \
   this.reverseSlide = reverseSlide ?? false;\n    this.reverseSwipe = \
reverseSwipe ?? false;\n    this.reverseScroll = reverseScroll ?? false;\n    \
this.moveInertia = moveInertia ?? DEFAULT_MOVE_INERTIA;\n    \
this.rotateInertia = rotateInertia ?? DEFAULT_ROTATE_INERTIA;\n    \
this.pointerRollScale = pointerRollScale ?? DEFAULT_POINTER_ROLL_SCALE;\n    \
this.doublePress = doublePress ?? (() => {\n    });\n    \
this.doublePressLimitMs = DOUBLE_PRESS_LIMIT_MS;\n    \
this.doublePressDistance = DOUBLE_PRESS_DISTANCE;\n    this.lastUp = null;\n  \
  this.rotating = null;\n    this.sliding = null;\n    this.dualPress = \
false;\n    this.scroll = new THREE.Vector3();\n    this.rotateVelocity = new \
THREE.Vector3();\n    this.moveVelocity = new THREE.Vector3();\n    \
canvas.addEventListener(\"pointerdown\", (event) => {\n      const position = \
this.getPointerPosition(event);\n      const initial = position.clone();\n    \
  const last = position.clone();\n      const isRotate = \
!this.swapRotateSlide && !this.rotating && (event.pointerType !== \"mouse\" \
|| event.button === 0) || this.swapRotateSlide && this.sliding && \
!this.rotating && (event.pointerType !== \"mouse\" || event.button === 1);\n  \
    const { pointerId, timeStamp } = event;\n      if (isRotate) {\n        \
this.rotating = { initial, last, position, pointerId, timeStamp };\n        \
canvas.setPointerCapture(event.pointerId);\n        this.dualPress = false;\n \
     } else if (!this.sliding) {\n        const button = event.pointerType \
=== \"mouse\" ? event.button : void 0;\n        this.sliding = {\n          \
initial,\n          last,\n          position,\n          pointerId,\n        \
  button,\n          timeStamp\n        };\n        \
canvas.setPointerCapture(event.pointerId);\n        this.dualPress = \
this.rotating != null && timeStamp - this.rotating.timeStamp < \
DUAL_PRESS_MS;\n      }\n    });\n    const pointerUp = (event) => {\n      \
var _a2, _b2;\n      if (((_a2 = this.rotating) == null ? void 0 : \
_a2.pointerId) === event.pointerId) {\n        this.rotating = null;\n        \
canvas.releasePointerCapture(event.pointerId);\n        if (this.dualPress && \
this.sliding) {\n          \
canvas.releasePointerCapture(this.sliding.pointerId);\n          this.sliding \
= null;\n        }\n      } else if (((_b2 = this.sliding) == null ? void 0 : \
_b2.pointerId) === event.pointerId) {\n        this.sliding = null;\n        \
canvas.releasePointerCapture(event.pointerId);\n        if (this.dualPress && \
this.rotating) {\n          \
canvas.releasePointerCapture(this.rotating.pointerId);\n          \
this.rotating = null;\n        }\n      }\n      const position = \
this.getPointerPosition(event);\n      const lastUp = this.lastUp;\n      \
this.lastUp = { position, time: event.timeStamp };\n      if (lastUp) {\n     \
   const distance2 = lastUp.position.distanceTo(position);\n        if \
(distance2 < this.doublePressDistance) {\n          const intervalMs = \
event.timeStamp - lastUp.time;\n          if (intervalMs < \
this.doublePressLimitMs) {\n            this.lastUp = null;\n            \
this.doublePress({ position, intervalMs });\n          }\n        }\n      \
}\n    };\n    document.addEventListener(\"pointerup\", pointerUp);\n    \
document.addEventListener(\"pointercancel\", pointerUp);\n    \
document.addEventListener(\"pointermove\", (event) => {\n      var _a2, \
_b2;\n      if (((_a2 = this.rotating) == null ? void 0 : _a2.pointerId) === \
event.pointerId) {\n        this.rotating.position = \
this.getPointerPosition(event);\n      } else if (((_b2 = this.sliding) == \
null ? void 0 : _b2.pointerId) === event.pointerId) {\n        \
this.sliding.position = this.getPointerPosition(event);\n      }\n    });\n   \
 canvas.addEventListener(\"contextmenu\", (event) => {\n      \
event.preventDefault();\n    });\n    canvas.addEventListener(\"wheel\", \
(event) => {\n      this.scroll.add(\n        new THREE.Vector3(event.deltaX, \
event.deltaY, event.deltaZ)\n      );\n      event.preventDefault();\n    \
});\n  }\n  getPointerPosition(event) {\n    const rect = \
this.canvas.getBoundingClientRect();\n    return new THREE.Vector2(\n      \
event.clientX - rect.left,\n      event.clientY - rect.top\n    );\n  }\n  \
update(deltaTime, control) {\n    if (!this.enable) {\n      return;\n    }\n \
   if (this.dualPress && this.rotating && this.sliding) {\n      const motion \
= [\n        this.rotating.position.clone().sub(this.rotating.last),\n        \
this.sliding.position.clone().sub(this.sliding.last)\n      ];\n      const \
coincidence = motion[0].dot(motion[1]);\n      if (coincidence >= 0.2) {\n    \
    const totalMotion = motion[0].clone().add(motion[1]);\n        const \
slide = new THREE.Vector3(totalMotion.x, -totalMotion.y, 0);\n        \
slide.multiplyScalar(this.slideSpeed * (this.reverseSwipe ? 1 : -1));\n       \
 slide.applyQuaternion(control.quaternion);\n        \
control.position.add(slide);\n        this.moveVelocity = \
slide.clone().multiplyScalar(1 / deltaTime);\n      } else if (coincidence <= \
-0.2) {\n        const deltaDir = \
this.sliding.last.clone().sub(this.rotating.last);\n        const deltaDist = \
deltaDir.length();\n        deltaDir.multiplyScalar(1 / \
deltaDist).normalize();\n        const orthoDir = new \
THREE.Vector2(-deltaDir.y, deltaDir.x);\n        const motionDir = \
[motion[0].dot(deltaDir), motion[1].dot(deltaDir)];\n        const \
motionOrtho = [motion[0].dot(orthoDir), motion[1].dot(orthoDir)];\n        \
const midpoint = \
this.rotating.last.clone().add(this.sliding.last).multiplyScalar(0.5);\n      \
  let midpointDir = new THREE.Vector3();\n        if (control instanceof \
THREE.Camera) {\n          const ndcMidpoint = new THREE.Vector2(\n           \
 midpoint.x / this.canvas.clientWidth * 2 - 1,\n            -(midpoint.y / \
this.canvas.clientHeight) * 2 + 1\n          );\n          const raycaster = \
new THREE.Raycaster();\n          raycaster.setFromCamera(ndcMidpoint, \
control);\n          midpointDir = raycaster.ray.direction;\n        }\n      \
  const pinchOut = motionDir[1] - motionDir[0];\n        const slide = \
midpointDir.multiplyScalar(pinchOut * this.slideSpeed);\n        \
control.position.add(slide);\n        this.moveVelocity = \
slide.clone().multiplyScalar(1 / deltaTime);\n        const angles = [\n      \
    Math.atan(motionOrtho[0] / (-0.5 * deltaDist)),\n          \
Math.atan(motionOrtho[1] / (0.5 * deltaDist))\n        ];\n        const \
rotate = 0.5 * (angles[0] + angles[1]) * this.pointerRollScale;\n        \
const eulers = new THREE.Euler().setFromQuaternion(\n          \
control.quaternion,\n          \"YXZ\"\n        );\n        eulers.z = \
Math.max(\n          -Math.PI,\n          Math.min(Math.PI, eulers.z + 0.5 * \
rotate)\n        );\n        control.quaternion.setFromEuler(eulers);\n      \
}\n      this.rotating.last.copy(this.rotating.position);\n      \
this.sliding.last.copy(this.sliding.position);\n    } else {\n      const \
rotate = new THREE.Vector3();\n      if (this.rotating && !this.dualPress) \
{\n        const delta = \
this.rotating.position.clone().sub(this.rotating.last);\n        \
this.rotating.last.copy(this.rotating.position);\n        rotate.set(delta.x, \
delta.y, 0);\n        rotate.multiplyScalar(this.rotateSpeed * \
(this.reverseRotate ? -1 : 1));\n        this.rotateVelocity = \
rotate.clone().multiplyScalar(1 / deltaTime);\n      } else {\n        \
this.rotateVelocity.multiplyScalar(\n          Math.exp(-deltaTime / \
this.rotateInertia)\n        );\n        \
rotate.addScaledVector(this.rotateVelocity, deltaTime);\n      }\n      const \
eulers = new THREE.Euler().setFromQuaternion(\n        control.quaternion,\n  \
      \"YXZ\"\n      );\n      eulers.y -= rotate.x;\n      eulers.x = \
Math.max(\n        -Math.PI / 2,\n        Math.min(Math.PI / 2, eulers.x - \
rotate.y)\n      );\n      eulers.z *= Math.exp(-0 * deltaTime);\n      \
control.quaternion.setFromEuler(eulers);\n      if (this.sliding && \
!this.dualPress) {\n        const delta = \
this.sliding.position.clone().sub(this.sliding.last);\n        \
this.sliding.last.copy(this.sliding.position);\n        const slide = \
this.sliding.button !== 2 ? new THREE.Vector3(delta.x, 0, delta.y) : new \
THREE.Vector3(delta.x, -delta.y, 0);\n        \
slide.multiplyScalar(this.slideSpeed * (this.reverseSlide ? -1 : 1));\n       \
 slide.applyQuaternion(control.quaternion);\n        \
control.position.add(slide);\n        this.moveVelocity = \
slide.clone().multiplyScalar(1 / deltaTime);\n      } else {\n        \
this.moveVelocity.multiplyScalar(\n          Math.exp(-deltaTime / \
this.moveInertia)\n        );\n        \
control.position.addScaledVector(this.moveVelocity, deltaTime);\n      }\n    \
}\n    const scroll = this.scroll.multiplyScalar(this.scrollSpeed);\n    \
scroll.set(scroll.x, scroll.z, scroll.y);\n    if (this.reverseScroll) {\n    \
  scroll.multiplyScalar(-1);\n    }\n    \
scroll.applyQuaternion(control.quaternion);\n    \
control.position.add(scroll);\n    this.scroll.set(0, 0, 0);\n  }\n}\n  \
loadSpark = () => SplatMesh;\n  return SplatMesh;\n}\n\ncore.SplatMesh = \
async (args, env) => {\n  const SplatMesh = await loadSpark();\n  const \
splatURL = await interpretate(args[0], env);\n  const butterfly = new \
SplatMesh({ url: splatURL });\n  env.mesh.add(butterfly); \n};", 
    "Display" -> "codemirror", "Hash" -> 
     "57a2937b-0277-4f30-97ae-d1f4798c11e5", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <|"Fade" -> True|>, 
    "PublicFields" -> {"Properties"}, "State" -> "Idle", "Type" -> "Input", 
    "UID" -> Null, "Notebook" -> "86740df4-dd4a-49d0-81ce-da87f3e03e12"|>, 
   <|"Data" -> "\nlet loadSpark = async () => {\n  await \
interpretate.shared.THREE.load();\n  const THREE = \
interpretate.shared.THREE.THREE;\n\n  const { Mesh, OrthographicCamera, \
BufferGeometry, Float32BufferAttribute, Loader, FileLoader, Quaternion, \
Vector3, Color, Matrix4 } = interpretate.shared.THREE.THREE;\n  \nconst \
_camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);\nclass \
FullscreenTriangleGeometry extends BufferGeometry {\n  constructor() {\n    \
super();\n    this.setAttribute(\"position\", new Float32BufferAttribute([-1, \
3, 0, -1, -1, 0, 3, -1, 0], 3));\n    this.setAttribute(\"uv\", new \
Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));\n  }\n}\nconst _geometry = \
new FullscreenTriangleGeometry();\nclass FullScreenQuad {\n  /**\n   * \
Constructs a new full screen quad.\n   *\n   * @param {?Material} material - \
The material to render te full screen quad with.\n   */\n  \
constructor(material) {\n    this._mesh = new Mesh(_geometry, material);\n  \
}\n  /**\n   * Frees the GPU-related resources allocated by this instance. \
Call this\n   * method whenever the instance is no longer used in your app.\n \
  */\n  dispose() {\n    this._mesh.geometry.dispose();\n  }\n  /**\n   * \
Renders the full screen quad.\n   *\n   * @param {WebGLRenderer} renderer - \
The renderer.\n   */\n  render(renderer) {\n    renderer.render(this._mesh, \
_camera);\n  }\n  /**\n   * The quad's material.\n   *\n   * @type \
{?Material}\n   */\n  get material() {\n    return this._mesh.material;\n  \
}\n  set material(value) {\n    this._mesh.material = value;\n  }\n}\nvar u8 \
= Uint8Array, u16 = Uint16Array, i32 = Int32Array;\nvar fleb = new u8([\n  \
0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  1,\n  1,\n  1,\n  1,\n  2,\n  \
2,\n  2,\n  2,\n  3,\n  3,\n  3,\n  3,\n  4,\n  4,\n  4,\n  4,\n  5,\n  5,\n  \
5,\n  5,\n  0,\n  /* unused */\n  0,\n  0,\n  /* impossible */\n  0\n]);\nvar \
fdeb = new u8([\n  0,\n  0,\n  0,\n  0,\n  1,\n  1,\n  2,\n  2,\n  3,\n  3,\n \
 4,\n  4,\n  5,\n  5,\n  6,\n  6,\n  7,\n  7,\n  8,\n  8,\n  9,\n  9,\n  \
10,\n  10,\n  11,\n  11,\n  12,\n  12,\n  13,\n  13,\n  /* unused */\n  0,\n  \
0\n]);\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, \
13, 2, 14, 1, 15]);\nvar freb = function(eb, start) {\n  var b = new \
u16(31);\n  for (var i = 0; i < 31; ++i) {\n    b[i] = start += 1 << eb[i - \
1];\n  }\n  var r = new i32(b[30]);\n  for (var i = 1; i < 30; ++i) {\n    \
for (var j = b[i]; j < b[i + 1]; ++j) {\n      r[j] = j - b[i] << 5 | i;\n    \
}\n  }\n  return { b, r };\n};\nvar _a = freb(fleb, 2), fl = _a.b, revfl = \
_a.r;\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = \
_b.b;\nvar rev = new u16(32768);\nfor (var i = 0; i < 32768; ++i) {\n  var x \
= (i & 43690) >> 1 | (i & 21845) << 1;\n  x = (x & 52428) >> 2 | (x & 13107) \
<< 2;\n  x = (x & 61680) >> 4 | (x & 3855) << 4;\n  rev[i] = ((x & 65280) >> \
8 | (x & 255) << 8) >> 1;\n}\nvar hMap = function(cd, mb, r) {\n  var s = \
cd.length;\n  var i = 0;\n  var l = new u16(mb);\n  for (; i < s; ++i) {\n    \
if (cd[i])\n      ++l[cd[i] - 1];\n  }\n  var le = new u16(mb);\n  for (i = \
1; i < mb; ++i) {\n    le[i] = le[i - 1] + l[i - 1] << 1;\n  }\n  var co;\n  \
if (r) {\n    co = new u16(1 << mb);\n    var rvb = 15 - mb;\n    for (i = 0; \
i < s; ++i) {\n      if (cd[i]) {\n        var sv = i << 4 | cd[i];\n        \
var r_1 = mb - cd[i];\n        var v = le[cd[i] - 1]++ << r_1;\n        for \
(var m = v | (1 << r_1) - 1; v <= m; ++v) {\n          co[rev[v] >> rvb] = \
sv;\n        }\n      }\n    }\n  } else {\n    co = new u16(s);\n    for (i \
= 0; i < s; ++i) {\n      if (cd[i]) {\n        co[i] = rev[le[cd[i] - 1]++] \
>> 15 - cd[i];\n      }\n    }\n  }\n  return co;\n};\nvar flt = new \
u8(288);\nfor (var i = 0; i < 144; ++i)\n  flt[i] = 8;\nfor (var i = 144; i < \
256; ++i)\n  flt[i] = 9;\nfor (var i = 256; i < 280; ++i)\n  flt[i] = 7;\nfor \
(var i = 280; i < 288; ++i)\n  flt[i] = 8;\nvar fdt = new u8(32);\nfor (var i \
= 0; i < 32; ++i)\n  fdt[i] = 5;\nvar flrm = /* @__PURE__ */ hMap(flt, 9, \
1);\nvar fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);\nvar max$1 = function(a) {\n \
 var m = a[0];\n  for (var i = 1; i < a.length; ++i) {\n    if (a[i] > m)\n   \
   m = a[i];\n  }\n  return m;\n};\nvar bits = function(d, p, m) {\n  var o = \
p / 8 | 0;\n  return (d[o] | d[o + 1] << 8) >> (p & 7) & m;\n};\nvar bits16 = \
function(d, p) {\n  var o = p / 8 | 0;\n  return (d[o] | d[o + 1] << 8 | d[o \
+ 2] << 16) >> (p & 7);\n};\nvar shft = function(p) {\n  return (p + 7) / 8 | \
0;\n};\nvar slc = function(v, s, e) {\n  if (s == null || s < 0)\n    s = \
0;\n  if (e == null || e > v.length)\n    e = v.length;\n  return new \
u8(v.subarray(s, e));\n};\nvar ec = [\n  \"unexpected EOF\",\n  \"invalid \
block type\",\n  \"invalid length/literal\",\n  \"invalid distance\",\n  \
\"stream finished\",\n  \"no stream handler\",\n  ,\n  \"no callback\",\n  \
\"invalid UTF-8 data\",\n  \"extra field too long\",\n  \"date not in range \
1980-2099\",\n  \"filename too long\",\n  \"stream finishing\",\n  \"invalid \
zip data\"\n  // determined by unknown compression method\n];\nvar err = \
function(ind, msg, nt) {\n  var e = new Error(msg || ec[ind]);\n  e.code = \
ind;\n  if (Error.captureStackTrace)\n    Error.captureStackTrace(e, err);\n  \
if (!nt)\n    throw e;\n  return e;\n};\nvar inflt = function(dat, st, buf, \
dict) {\n  var sl = dat.length, dl = dict ? dict.length : 0;\n  if (!sl || \
st.f && !st.l)\n    return buf || new u8(0);\n  var noBuf = !buf;\n  var \
resize = noBuf || st.i != 2;\n  var noSt = st.i;\n  if (noBuf)\n    buf = new \
u8(sl * 3);\n  var cbuf = function(l2) {\n    var bl = buf.length;\n    if \
(l2 > bl) {\n      var nbuf = new u8(Math.max(bl * 2, l2));\n      \
nbuf.set(buf);\n      buf = nbuf;\n    }\n  };\n  var final = st.f || 0, pos \
= st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n  \
var tbts = sl * 8;\n  do {\n    if (!lm) {\n      final = bits(dat, pos, \
1);\n      var type = bits(dat, pos + 1, 3);\n      pos += 3;\n      if \
(!type) {\n        var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t \
= s + l;\n        if (t > sl) {\n          if (noSt)\n            err(0);\n   \
       break;\n        }\n        if (resize)\n          cbuf(bt + l);\n      \
  buf.set(dat.subarray(s, t), bt);\n        st.b = bt += l, st.p = pos = t * \
8, st.f = final;\n        continue;\n      } else if (type == 1)\n        lm \
= flrm, dm = fdrm, lbt = 9, dbt = 5;\n      else if (type == 2) {\n        \
var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n   \
     var tl = hLit + bits(dat, pos + 5, 31) + 1;\n        pos += 14;\n        \
var ldt = new u8(tl);\n        var clt = new u8(19);\n        for (var i = 0; \
i < hcLen; ++i) {\n          clt[clim[i]] = bits(dat, pos + i * 3, 7);\n      \
  }\n        pos += hcLen * 3;\n        var clb = max$1(clt), clbmsk = (1 << \
clb) - 1;\n        var clm = hMap(clt, clb, 1);\n        for (var i = 0; i < \
tl; ) {\n          var r = clm[bits(dat, pos, clbmsk)];\n          pos += r & \
15;\n          var s = r >> 4;\n          if (s < 16) {\n            ldt[i++] \
= s;\n          } else {\n            var c = 0, n = 0;\n            if (s == \
16)\n              n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n     \
       else if (s == 17)\n              n = 3 + bits(dat, pos, 7), pos += \
3;\n            else if (s == 18)\n              n = 11 + bits(dat, pos, \
127), pos += 7;\n            while (n--)\n              ldt[i++] = c;\n       \
   }\n        }\n        var lt = ldt.subarray(0, hLit), dt = \
ldt.subarray(hLit);\n        lbt = max$1(lt);\n        dbt = max$1(dt);\n     \
   lm = hMap(lt, lbt, 1);\n        dm = hMap(dt, dbt, 1);\n      } else\n     \
   err(1);\n      if (pos > tbts) {\n        if (noSt)\n          err(0);\n   \
     break;\n      }\n    }\n    if (resize)\n      cbuf(bt + 131072);\n    \
var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n    var lpos = pos;\n    for \
(; ; lpos = pos) {\n      var c = lm[bits16(dat, pos) & lms], sym = c >> 4;\n \
     pos += c & 15;\n      if (pos > tbts) {\n        if (noSt)\n          \
err(0);\n        break;\n      }\n      if (!c)\n        err(2);\n      if \
(sym < 256)\n        buf[bt++] = sym;\n      else if (sym == 256) {\n        \
lpos = pos, lm = null;\n        break;\n      } else {\n        var add2 = \
sym - 254;\n        if (sym > 264) {\n          var i = sym - 257, b = \
fleb[i];\n          add2 = bits(dat, pos, (1 << b) - 1) + fl[i];\n          \
pos += b;\n        }\n        var d = dm[bits16(dat, pos) & dms], dsym = d >> \
4;\n        if (!d)\n          err(3);\n        pos += d & 15;\n        var \
dt = fd[dsym];\n        if (dsym > 3) {\n          var b = fdeb[dsym];\n      \
    dt += bits16(dat, pos) & (1 << b) - 1, pos += b;\n        }\n        if \
(pos > tbts) {\n          if (noSt)\n            err(0);\n          break;\n  \
      }\n        if (resize)\n          cbuf(bt + 131072);\n        var end = \
bt + add2;\n        if (bt < dt) {\n          var shift = dl - dt, dend = \
Math.min(dt, end);\n          if (shift + bt < 0)\n            err(3);\n      \
    for (; bt < dend; ++bt)\n            buf[bt] = dict[shift + bt];\n        \
}\n        for (; bt < end; ++bt)\n          buf[bt] = buf[bt - dt];\n      \
}\n    }\n    st.l = lm, st.p = lpos, st.b = bt, st.f = final;\n    if (lm)\n \
     final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n  } while (!final);\n  \
return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, \
bt);\n};\nvar et = /* @__PURE__ */ new u8(0);\nvar b2 = function(d, b) {\n  \
return d[b] | d[b + 1] << 8;\n};\nvar b4 = function(d, b) {\n  return (d[b] | \
d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;\n};\nvar b8 = \
function(d, b) {\n  return b4(d, b) + b4(d, b + 4) * 4294967296;\n};\nvar gzs \
= function(d) {\n  if (d[0] != 31 || d[1] != 139 || d[2] != 8)\n    err(6, \
\"invalid gzip data\");\n  var flg = d[3];\n  var st = 10;\n  if (flg & 4)\n  \
  st += (d[10] | d[11] << 8) + 2;\n  for (var zs = (flg >> 3 & 1) + (flg >> 4 \
& 1); zs > 0; zs -= !d[st++])\n    ;\n  return st + (flg & 2);\n};\nvar \
Inflate = /* @__PURE__ */ function() {\n  function Inflate2(opts, cb) {\n    \
if (typeof opts == \"function\")\n      cb = opts, opts = {};\n    \
this.ondata = cb;\n    var dict = opts && opts.dictionary && \
opts.dictionary.subarray(-32768);\n    this.s = { i: 0, b: dict ? dict.length \
: 0 };\n    this.o = new u8(32768);\n    this.p = new u8(0);\n    if (dict)\n \
     this.o.set(dict);\n  }\n  Inflate2.prototype.e = function(c) {\n    if \
(!this.ondata)\n      err(5);\n    if (this.d)\n      err(4);\n    if \
(!this.p.length)\n      this.p = c;\n    else if (c.length) {\n      var n = \
new u8(this.p.length + c.length);\n      n.set(this.p), n.set(c, \
this.p.length), this.p = n;\n    }\n  };\n  Inflate2.prototype.c = \
function(final) {\n    this.s.i = +(this.d = final || false);\n    var bts = \
this.s.b;\n    var dt = inflt(this.p, this.s, this.o);\n    \
this.ondata(slc(dt, bts, this.s.b), this.d);\n    this.o = slc(dt, this.s.b - \
32768), this.s.b = this.o.length;\n    this.p = slc(this.p, this.s.p / 8 | \
0), this.s.p &= 7;\n  };\n  Inflate2.prototype.push = function(chunk, final) \
{\n    this.e(chunk), this.c(final);\n  };\n  return \
Inflate2;\n}();\nfunction inflateSync(data, opts) {\n  return inflt(data, { \
i: 2 }, opts && opts.out, opts && opts.dictionary);\n}\nvar Gunzip = /* \
@__PURE__ */ function() {\n  function Gunzip2(opts, cb) {\n    this.v = 1;\n  \
  this.r = 0;\n    Inflate.call(this, opts, cb);\n  }\n  \
Gunzip2.prototype.push = function(chunk, final) {\n    \
Inflate.prototype.e.call(this, chunk);\n    this.r += chunk.length;\n    if \
(this.v) {\n      var p = this.p.subarray(this.v - 1);\n      var s = \
p.length > 3 ? gzs(p) : 4;\n      if (s > p.length) {\n        if (!final)\n  \
        return;\n      } else if (this.v > 1 && this.onmember) {\n        \
this.onmember(this.r - p.length);\n      }\n      this.p = p.subarray(s), \
this.v = 0;\n    }\n    Inflate.prototype.c.call(this, final);\n    if \
(this.s.f && !this.s.l && !final) {\n      this.v = shft(this.s.p) + 9;\n     \
 this.s = { i: 0 };\n      this.o = new u8(0);\n      this.push(new u8(0), \
final);\n    }\n  };\n  return Gunzip2;\n}();\nvar td = typeof TextDecoder != \
\"undefined\" && /* @__PURE__ */ new TextDecoder();\nvar tds = 0;\ntry {\n  \
td.decode(et, { stream: true });\n  tds = 1;\n} catch (e) {\n}\nvar dutf8 = \
function(d) {\n  for (var r = \"\", i = 0; ; ) {\n    var c = d[i++];\n    \
var eb = (c > 127) + (c > 223) + (c > 239);\n    if (i + eb > d.length)\n     \
 return { s: r, r: slc(d, i - 1) };\n    if (!eb)\n      r += \
String.fromCharCode(c);\n    else if (eb == 3) {\n      c = ((c & 15) << 18 | \
(d[i++] & 63) << 12 | (d[i++] & 63) << 6 | d[i++] & 63) - 65536, r += \
String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);\n    } else if (eb & \
1)\n      r += String.fromCharCode((c & 31) << 6 | d[i++] & 63);\n    else\n  \
    r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | d[i++] & \
63);\n  }\n};\nfunction strFromU8(dat, latin1) {\n  if (latin1) {\n    var r \
= \"\";\n    for (var i = 0; i < dat.length; i += 16384)\n      r += \
String.fromCharCode.apply(null, dat.subarray(i, i + 16384));\n    return r;\n \
 } else if (td) {\n    return td.decode(dat);\n  } else {\n    var _a2 = \
dutf8(dat), s = _a2.s, r = _a2.r;\n    if (r.length)\n      err(8);\n    \
return s;\n  }\n}\nvar slzh = function(d, b) {\n  return b + 30 + b2(d, b + \
26) + b2(d, b + 28);\n};\nvar zh = function(d, b, z) {\n  var fnl = b2(d, b + \
28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & \
2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\n  var _a2 = z && bs == \
4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a2[0], \
su = _a2[1], off = _a2[2];\n  return [b2(d, b + 10), sc, su, fn, es + b2(d, b \
+ 30) + b2(d, b + 32), off];\n};\nvar z64e = function(d, b) {\n  for (; b2(d, \
b) != 1; b += 4 + b2(d, b + 2))\n    ;\n  return [b8(d, b + 12), b8(d, b + \
4), b8(d, b + 20)];\n};\nfunction unzipSync(data, opts) {\n  var files = \
{};\n  var e = data.length - 22;\n  for (; b4(data, e) != 101010256; --e) {\n \
   if (!e || data.length - e > 65558)\n      err(13);\n  }\n  var c = \
b2(data, e + 8);\n  if (!c)\n    return {};\n  var o = b4(data, e + 16);\n  \
var z = o == 4294967295 || c == 65535;\n  if (z) {\n    var ze = b4(data, e - \
12);\n    z = b4(data, ze) == 101075792;\n    if (z) {\n      c = b4(data, ze \
+ 32);\n      o = b4(data, ze + 48);\n    }\n  }\n  var fltr = opts && \
opts.filter;\n  for (var i = 0; i < c; ++i) {\n    var _a2 = zh(data, o, z), \
c_2 = _a2[0], sc = _a2[1], su = _a2[2], fn = _a2[3], no = _a2[4], off = \
_a2[5], b = slzh(data, off);\n    o = no;\n    if (!fltr || fltr({\n      \
name: fn,\n      size: sc,\n      originalSize: su,\n      compression: c_2\n \
   })) {\n      if (!c_2)\n        files[fn] = slc(data, b, b + sc);\n      \
else if (c_2 == 8)\n        files[fn] = inflateSync(data.subarray(b, b + sc), \
{ out: new u8(su) });\n      else\n        err(14, \"unknown compression type \
\" + c_2);\n    }\n  }\n  return files;\n}\nlet wasm;\nconst \
cachedTextDecoder = typeof TextDecoder !== \"undefined\" ? new \
TextDecoder(\"utf-8\", { ignoreBOM: true, fatal: true }) : { decode: () => \
{\n  throw Error(\"TextDecoder not available\");\n} };\nif (typeof \
TextDecoder !== \"undefined\") {\n  cachedTextDecoder.decode();\n}\nlet \
cachedUint8ArrayMemory0 = null;\nfunction getUint8ArrayMemory0() {\n  if \
(cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === \
0) {\n    cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\n  \
}\n  return cachedUint8ArrayMemory0;\n}\nfunction getStringFromWasm0(ptr, \
len) {\n  ptr = ptr >>> 0;\n  return \
cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + \
len));\n}\nfunction raycast_splats(origin_x, origin_y, origin_z, dir_x, \
dir_y, dir_z, near, far, num_splats, packed_splats, raycast_ellipsoid, \
ln_scale_min, ln_scale_max) {\n  const ret = wasm.raycast_splats(origin_x, \
origin_y, origin_z, dir_x, dir_y, dir_z, near, far, num_splats, \
packed_splats, raycast_ellipsoid, ln_scale_min, ln_scale_max);\n  return \
ret;\n}\nasync function __wbg_load(module, imports) {\n  if (typeof Response \
=== \"function\" && module instanceof Response) {\n    if (typeof \
WebAssembly.instantiateStreaming === \"function\") {\n      try {\n        \
return await WebAssembly.instantiateStreaming(module, imports);\n      } \
catch (e) {\n        if (module.headers.get(\"Content-Type\") != \
\"application/wasm\") {\n          \
console.warn(\"`WebAssembly.instantiateStreaming` failed because your server \
does not serve Wasm with `application/wasm` MIME type. Falling back to \
`WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n        \
} else {\n          throw e;\n        }\n      }\n    }\n    const bytes = \
await module.arrayBuffer();\n    return await WebAssembly.instantiate(bytes, \
imports);\n  } else {\n    const instance = await \
WebAssembly.instantiate(module, imports);\n    if (instance instanceof \
WebAssembly.Instance) {\n      return { instance, module };\n    } else {\n   \
   return instance;\n    }\n  }\n}\nfunction __wbg_get_imports() {\n  const \
imports = {};\n  imports.wbg = {};\n  \
imports.wbg.__wbg_buffer_609cc3eee51ed158 = function(arg0) {\n    const ret = \
arg0.buffer;\n    return ret;\n  };\n  \
imports.wbg.__wbg_length_3b4f022188ae8db6 = function(arg0) {\n    const ret = \
arg0.length;\n    return ret;\n  };\n  \
imports.wbg.__wbg_length_6ca527665d89694d = function(arg0) {\n    const ret = \
arg0.length;\n    return ret;\n  };\n  \
imports.wbg.__wbg_length_8cfd2c6409af88ad = function(arg0) {\n    const ret = \
arg0.length;\n    return ret;\n  };\n  imports.wbg.__wbg_new_9fee97a409b32b68 \
= function(arg0) {\n    const ret = new Uint16Array(arg0);\n    return ret;\n \
 };\n  imports.wbg.__wbg_new_e3b321dcfef89fc7 = function(arg0) {\n    const \
ret = new Uint32Array(arg0);\n    return ret;\n  };\n  \
imports.wbg.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354 = \
function(arg0, arg1, arg2) {\n    const ret = new Float32Array(arg0, arg1 >>> \
0, arg2 >>> 0);\n    return ret;\n  };\n  \
imports.wbg.__wbg_newwithbyteoffsetandlength_f1dead44d1fc7212 = \
function(arg0, arg1, arg2) {\n    const ret = new Uint32Array(arg0, arg1 >>> \
0, arg2 >>> 0);\n    return ret;\n  };\n  \
imports.wbg.__wbg_newwithlength_5a5efe313cfd59f1 = function(arg0) {\n    \
const ret = new Float32Array(arg0 >>> 0);\n    return ret;\n  };\n  \
imports.wbg.__wbg_set_10bad9bee0e9c58b = function(arg0, arg1, arg2) {\n    \
arg0.set(arg1, arg2 >>> 0);\n  };\n  imports.wbg.__wbg_set_d23661d19148b229 = \
function(arg0, arg1, arg2) {\n    arg0.set(arg1, arg2 >>> 0);\n  };\n  \
imports.wbg.__wbg_set_f4f1f0daa30696fc = function(arg0, arg1, arg2) {\n    \
arg0.set(arg1, arg2 >>> 0);\n  };\n  \
imports.wbg.__wbg_subarray_3aaeec89bb2544f0 = function(arg0, arg1, arg2) {\n  \
  const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);\n    return ret;\n  };\n \
 imports.wbg.__wbg_subarray_769e1e0f81bb259b = function(arg0, arg1, arg2) {\n \
   const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);\n    return ret;\n  \
};\n  imports.wbg.__wbindgen_init_externref_table = function() {\n    const \
table = wasm.__wbindgen_export_0;\n    const offset = table.grow(4);\n    \
table.set(0, void 0);\n    table.set(offset + 0, void 0);\n    \
table.set(offset + 1, null);\n    table.set(offset + 2, true);\n    \
table.set(offset + 3, false);\n  };\n  imports.wbg.__wbindgen_memory = \
function() {\n    const ret = wasm.memory;\n    return ret;\n  };\n  \
imports.wbg.__wbindgen_throw = function(arg0, arg1) {\n    throw new \
Error(getStringFromWasm0(arg0, arg1));\n  };\n  return imports;\n}\nfunction \
__wbg_finalize_init(instance, module) {\n  wasm = instance.exports;\n  \
__wbg_init.__wbindgen_wasm_module = module;\n  cachedUint8ArrayMemory0 = \
null;\n  wasm.__wbindgen_start();\n  return wasm;\n}\nasync function \
__wbg_init(module_or_path) {\n  if (wasm !== void 0) return wasm;\n  if \
(typeof module_or_path !== \"undefined\") {\n    if \
(Object.getPrototypeOf(module_or_path) === Object.prototype) {\n      ({ \
module_or_path } = module_or_path);\n    } else {\n      console.warn(\"using \
deprecated parameters for the initialization function; pass a single object \
instead\");\n    }\n  }\n  if (typeof module_or_path === \"undefined\") {\n   \
 module_or_path = new \
URL(\"data:application/wasm;base64,AGFzbQEAAAABzAEeYAJ/fwF/YAJ/fwBgA39/fwF/YA\
N/f38AYAF/AX9gAX8AYANvf38Bb2AFf39/f38Bf2AFf39/f38AYAFvAW9gA29vfwBgAW8Bf2AAAGA\
AAX9gBH9/f38AYAR/f39/AX9gA39vbwF/YAF/AW9gAAFvYAF9AX1gBn9/f39/fwBgDX19fX19fX19\
f29/fX0Bb2AGf39/f39/AX9gBX9/fX9/AGAEf31/fwBgBX9/fH9/AGAEf3x/fwBgBX9/fn9/AGAEf\
35/fwBgAn19AX0C8gQRA3diZx1fX3diZ19idWZmZXJfNjA5Y2MzZWVlNTFlZDE1OAAJA3diZxpfX3\
diZ19uZXdfOWZlZTk3YTQwOWIzMmI2OAAJA3diZxpfX3diZ19zZXRfZjRmMWYwZGFhMzA2OTZmYwA\
KA3diZx1fX3diZ19sZW5ndGhfOGNmZDJjNjQwOWFmODhhZAALA3diZzFfX3diZ19uZXd3aXRoYnl0\
ZW9mZnNldGFuZGxlbmd0aF9mMWRlYWQ0NGQxZmM3MjEyAAYDd2JnGl9fd2JnX25ld19lM2IzMjFkY\
2ZlZjg5ZmM3AAkDd2JnGl9fd2JnX3NldF9kMjM2NjFkMTkxNDhiMjI5AAoDd2JnHV9fd2JnX2xlbm\
d0aF82Y2E1Mjc2NjVkODk2OTRkAAsDd2JnMV9fd2JnX25ld3dpdGhieXRlb2Zmc2V0YW5kbGVuZ3R\
oX2U2YjdlNjlhY2Q0YzczNTQABgN3YmcaX193Ymdfc2V0XzEwYmFkOWJlZTBlOWM1OGIACgN3Ymcd\
X193YmdfbGVuZ3RoXzNiNGYwMjIxODhhZThkYjYACwN3YmcfX193Ymdfc3ViYXJyYXlfNzY5ZTFlM\
GY4MWJiMjU5YgAGA3diZx9fX3diZ19zdWJhcnJheV8zYWFlZWM4OWJiMjU0NGYwAAYDd2JnJF9fd2\
JnX25ld3dpdGhsZW5ndGhfNWE1ZWZlMzEzY2ZkNTlmMQARA3diZxBfX3diaW5kZ2VuX3Rocm93AAE\
Dd2JnEV9fd2JpbmRnZW5fbWVtb3J5ABIDd2JnH19fd2JpbmRnZW5faW5pdF9leHRlcm5yZWZfdGFi\
bGUADANeXQQAAQcFAgMCEwEBAA0BAwEAAA0BAwgIAwEBBRQBAw4AAwEDAgwMAgABAQcDABUBFhcIG\
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\
4EccSABQf+B/AdxakGBgARsQRB2IARqDwsgAUUEQEEADwsgAUEDcSEDAkAgAUEESQRADAELIAFBfH\
EhBQNAIAQgACACaiIBLAAAQb9/SmogAUEBaiwAAEG/f0pqIAFBAmosAABBv39KaiABQQNqLAAAQb9\
/SmohBCAFIAJBBGoiAkcNAAsLIANFDQAgACACaiEBA0AgBCABLAAAQb9/SmohBCABQQFqIQEgA0EB\
ayIDDQALCyAEC4oGAQZ/IAAoAggiAyABSQRAIAEgAyICayIEIAAoAgAgAmtLBEAgACACIARBBEEEE\
CYgACgCCCECCyAAKAIEIgYgAkECdGohBSAEQQJPBEAgASADQX9zakECdCIHBEAgBUEAIAf8CwALIA\
EgAmpBAnQgA0ECdGsgBmpBBGshBSACIARqQQFrIQILIAVBADYCACAAIAJBAWo2AggLIAAoAhQiAyA\
BSQRAIAEgAyICayIEIAAoAgwgAmtLBEAgAEEMaiACIARBBEEEECYgACgCFCECCyAAKAIQIgYgAkEC\
dGohBSAEQQJPBEAgASADQX9zakECdCIHBEAgBUEAIAf8CwALIAEgAmpBAnQgA0ECdGsgBmpBBGshB\
SACIARqQQFrIQILIAVBADYCACAAIAJBAWo2AhQLIAAoAjgiAyABSQRAIAEgAyICayIEIAAoAjAgAm\
tLBEAgAEEwaiACIARBBEEEECYgACgCOCECCyAAKAI0IgYgAkECdGohBSAEQQJPBEAgASADQX9zakE\
CdCIHBEAgBUEAIAf8CwALIAEgAmpBAnQgA0ECdGsgBmpBBGshBSACIARqQQFrIQILIAVBADYCACAA\
IAJBAWo2AjgLIAAoAiAiA0H//wNNBEAgAyEBQYCABCADayICIAAoAhggA2tLBEAgAEEYaiADIAJBB\
EEEECYgACgCICEBCyAAKAIcIgUgAUECdCIEaiECIANB//8DRwRAQfz/DyADQQJ0IgZrIgcEQCACQQ\
AgB/wLAAsgBCAGayAFakH8/w9qIQIgASADa0H//wNqIQELIAJBADYCACAAIAFBAWo2AiALIAAoAiw\
iA0H//wNNBEAgAyEBQYCABCADayICIAAoAiQgA2tLBEAgAEEkaiADIAJBBEEEECYgACgCLCEBCyAA\
KAIoIgUgAUECdCIEaiECIANB//8DRwRAQfz/DyADQQJ0IgZrIgcEQCACQQAgB/wLAAsgBCAGayAFa\
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\
zYCCCANIAo2AgQgDSAANgIAIA0gDUEEaiIAKAIAEG02AgwgDSANQQhqNgIcIA0gDTYCGCANIAA2Ah\
QgDSANQQxqNgIQIA1BEGohACMAQdAAayIIJAACQAJAAkACQAJAQQBBjIbAACgCABEEACIPBEAgDyg\
CAA0BIAAoAgwhFiAAKAIIIQogACgCACEDIA9BfzYCACAAKAIEIQAgD0EEaiILIAMoAgAQEyAIIABB\
ACAKKAIAEGE2AgggCigCACIAIA8oAgwiCUsNAiAIQQhqIA8oAgggABAzIAhBDGohFSADKAIAIQAgC\
igCACETIwBBMGsiDiQAIAsgABATAkAgCygCCCIAIBNPBEAgCygCBCEKIAsoAhwhAwJAIAsoAiAiDE\
UNACAMQQJ0IgBFDQAgA0EAIAD8CwALIAsoAighFAJAIAsoAiwiEEUNACAQQQJ0IgBFDQAgFEEAIAD\
8CwALIBNBAnQhCSATBEAgCSEEIAohAANAAkAgACgCACIGQYCAgPwHTw0AIAwgBkF/cyIFQf//A3Ei\
BksEQCADIAZBAnRqIgYgBigCAEEBajYCACAQIAVBEHYiBksEQCAUIAZBAnRqIgYgBigCAEEBajYCA\
AwCCyAGIBBB3InAABAxAAsgBiAMQcyJwAAQMQALIABBBGohACAEQQRrIgQNAAsLAkAgDEUEQEEAIQ\
QMAQsgDEEBa0H/////A3EiAEEBaiIEQQdxIQUCQCAAQQdJBEBBACEEIAMhAAwBCyAEQfj///8HcSE\
GQQAhBCADIQADQCAAKAIAIQcgACAENgIAIABBBGoiESgCACESIBEgBCAHaiIENgIAIABBCGoiBygC\
ACERIAcgBCASaiIENgIAIABBDGoiBygCACESIAcgBCARaiIENgIAIABBEGoiBygCACERIAcgBCASa\
iIENgIAIABBFGoiBygCACESIAcgBCARaiIENgIAIABBGGoiBygCACERIAcgBCASaiIENgIAIABBHG\
oiBygCACESIAcgBCARaiIENgIAIAQgEmohBCAAQSBqIQAgBkEIayIGDQALCyAFRQ0AA0AgACgCACE\
GIAAgBDYCACAAQQRqIQAgBCAGaiEEIAVBAWsiBQ0ACwsgDiAENgIEIBMEQCAJIApqIREgCkEEaiEG\
IBNBAWtB/////wNxQQFqIRIgCygCNCEXIAsoAjghB0EAIQUgCiEJA0AgBiEAAkAgCSgCACIJQYCAg\
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\
3I2AgQgByAHKAIEQQFyNgIEIAEgAxAaDAkLQciZwAAoAgAgBGoiBCABSw0HCyADEBEiAUUNASADQX\
xBeCAFKAIAIgJBA3EbIAJBeHFqIgIgAiADSxsiAgRAIAEgACAC/AoAAAsgABAVIAEMCAsgAyABIAE\
gA0sbIgIEQCAIIAAgAvwKAAALIAUoAgAiAkF4cSIDIAFBBEEIIAJBA3EiAhtqSQ0DIAJBACADIAlL\
Gw0EIAAQFQsgCAwGC0HQi8AAQYCMwAAQOgALQZCMwABBwIzAABA6AAtB0IvAAEGAjMAAEDoAC0GQj\
MAAQcCMwAAQOgALIAUgASAGQQFxckECcjYCACABIAJqIgIgBCABayIBQQFyNgIEQciZwAAgATYCAE\
HQmcAAIAI2AgAgAAwBCyAACwsWACAAKAIAIAEgAiAAKAIEKAIMEQIAC4UCAQN/QfCVwAAoAgBFBEA\
CQAJAAn8CQCAARQ0AIAAoAgAgAEEANgIAQQFxRQ0AIAAoAhAhAiAAKAIMIQEgACgCCCEDIAAoAgQM\
AQsCQEGAgMAAEBEiAEUNACAAQQRrLQAAQQNxRQ0AIABBAEGAgMAA/AsACyAAIgFFDQFBgIAQIQJBg\
IAQIQNBAAshAEGAlsAAIAI2AgBB9JXAACAANgIAQfyVwAAoAgAhAkH8lcAAIAE2AgBB+JXAACgCAC\
EAQfiVwAAgAzYCAEHwlcAAKAIAQfCVwABBATYCAEUgAEVyRQRAIAIgAEECdBBgCwwBC0EEQYCAwAB\
B+IXAABBMAAsLQfSVwAALxAQBEX9BrJXAACgCAEUEQAJAIAAEQCAAKAJAIQEgACgCPCECIAAoAjgh\
AyAAKAI0IQQgACgCMCEFIAAoAiwhBiAAKAIoIQcgACgCJCEIIAAoAiAhCSAAKAIcIQogACgCGCELI\
AAoAhQhDCAAKAIQIQ0gACgCDCEOIAAoAgghDyAAKAIEIRAgACgCACAAQQA2AgBBAXENAQtBBCECQQ\
AhAUEAIQNBACEEQQQhBUEAIQZBACEHQQQhCEEAIQlBACEKQQQhC0EAIQxBACENQQQhDkEAIQ9BACE\
QC0HslcAAIAE2AgBB4JXAACAENgIAQdSVwAAgBzYCAEHIlcAAIAo2AgBBvJXAACANNgIAQbCVwAAg\
EDYCAEHolcAAKAIAIQdB6JXAACACNgIAQeSVwAAoAgAhAEHklcAAIAM2AgBB3JXAACgCACEKQdyVw\
AAgBTYCAEHYlcAAKAIAIQFB2JXAACAGNgIAQdCVwAAoAgAhBUHQlcAAIAg2AgBBzJXAACgCACECQc\
yVwAAgCTYCAEHElcAAKAIAIQZBxJXAACALNgIAQcCVwAAoAgAhA0HAlcAAIAw2AgBBuJXAACgCACE\
IQbiVwAAgDjYCAEG0lcAAKAIAIQRBtJXAACAPNgIAQayVwAAoAgAhCUGslcAAQQE2AgACQCAJRQ0A\
IAQEQCAIIARBAnQQYAsgAwRAIAYgA0ECdBBgCyACBEAgBSACQQJ0EGALIAEEQCAKIAFBAnQQYAsgA\
EUNACAHIABBAnQQYAsLQbCVwAAL8gIBCX9BgJXAACgCAEUEQAJ/AkAgAEUNACAAKAIAIABBADYCAE\
EBcUUNACAAKAIoIQEgACgCJCEHIAAoAiAhAiAAKAIcIQMgACgCGCEIIAAoAhQhBCAAKAIQIQUgACg\
CDCEJIAAoAgghBiAAKAIEDAELQQIhCUEEIQdBACEBQQQhCEEACyEAQaiVwAAgATYCAEGclcAAIAM2\
AgBBkJXAACAFNgIAQYSVwAAgADYCAEGklcAAKAIAIQVBpJXAACAHNgIAQaCVwAAoAgAhAEGglcAAI\
AI2AgBBmJXAACgCACEBQZiVwAAgCDYCAEGUlcAAKAIAIQJBlJXAACAENgIAQYyVwAAoAgAhBEGMlc\
AAIAk2AgBBiJXAACgCACEDQYiVwAAgBjYCAEGAlcAAKAIAIQZBgJXAAEEBNgIAAkAgBkUNACADBEA\
gBCADQQF0EGALIAIEQCABIAJBAnQQYAsgAEUNACAFIABBAnQQYAsLQYSVwAALFAAgACgCACABIAAo\
AgQoAgwRAAALFAIBbwF/EA8hABAdIgEgACYBIAELEAAgASAAKAIEIAAoAggQFgsZAAJ/IAFBCU8EQ\
CABIAAQHAwBCyAAEBELCyAAIABC356dmJy3lrgCNwMIIABCoe2sjPn0nLgHNwMACyIAIABC7bqtts\
2F1PXjADcDCCAAQviCmb2V7sbFuX83AwALEwAgAEGAjsAANgIEIAAgATYCAAsQACABIAAoAgAgACg\
CBBBRCxAAIAEgACgCACAAKAIEEBYLEAAgASgCACABKAIEIAAQGAsOACAAJQEgASUBIAIQBgtbAQJ/\
AkACQCAAQQRrKAIAIgJBeHEiA0EEQQggAkEDcSICGyABak8EQCACQQAgAyABQSdqSxsNASAAEBUMA\
gtB0IvAAEGAjMAAEDoAC0GQjMAAQcCMwAAQOgALCx0BAW8gACgCACUBIAEgAhAMIQMQHSIAIAMmAS\
AAC2oBAX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQQI2AgwgA0G0lMAANgIIIANCAjcCFCADIAN\
BBGqtQoCAgIDQAIQ3AyggAyADrUKAgICA0ACENwMgIAMgA0EgajYCECADQQhqIAIQPwALCQAgACAB\
EA4ACw0AIABBuIvAACABEBgLDAAgACABKQIANwMACw0AIABB0I7AACABEBgLDQAgAUHIjsAAQQUQU\
QsZACAAIAFBkJbAACgCACIAQRQgABsRAQAACw0AIAFBpJDAAEEYEBYLoAIBA38gACgCACEAIwBBkA\
FrIgMkAAJ/AkAgASgCCCICQYCAgBBxRQRAIAJBgICAIHENASADQQhqIAAoAgAgA0EQahAfIAFBAUE\
AIAMoAgggAygCDBAUDAILIAAoAgAhAkEAIQADQCAAIANqQY8BaiACQQ9xIgRBMHIgBEHXAGogBEEK\
SRs6AAAgAEEBayEAIAJBD0sgAkEEdiECDQALIAFBt5LAAEECIAAgA2pBkAFqQQAgAGsQFAwBCyAAK\
AIAIQJBACEAA0AgACADakGPAWogAkEPcSIEQTByIARBN2ogBEEKSRs6AAAgAEEBayEAIAJBD0sgAk\
EEdiECDQALIAFBt5LAAEECIAAgA2pBkAFqQQAgAGsQFAsgA0GQAWokAAsJACAAQQA2AgALCAAgACU\
BEAMLCAAgACUBEAcLC/UUAwBBgIDAAAuhD3NwYXJrLWludGVybmFsLXJzL3NyYy9yYXljYXN0LnJz\
AHNwYXJrLWludGVybmFsLXJzL3NyYy9zb3J0LnJzAGxpYnJhcnkvYWxsb2Mvc3JjL2ZtdC5ycwAva\
G9tZS9ydW5uZXIvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2Yj\
ViNTU3Zi93YXNtLWJpbmRnZW4tMC4yLjEwMC9zcmMvY29udmVydC9zbGljZXMucnMAL3J1c3RjLzI\
5NDgzODgzZWVkNjlkNWZiNGRiMDE5NjRjZGYyYWY0ZDg2ZTljYjIvbGlicmFyeS9zdGQvc3JjL3Ro\
cmVhZC9sb2NhbC5ycwBsaWJyYXJ5L2FsbG9jL3NyYy9zdHJpbmcucnMAL3J1c3RjLzI5NDgzODgzZ\
WVkNjlkNWZiNGRiMDE5NjRjZGYyYWY0ZDg2ZTljYjIvbGlicmFyeS9hbGxvYy9zcmMvc2xpY2Uucn\
MAL3J1c3RjLzI5NDgzODgzZWVkNjlkNWZiNGRiMDE5NjRjZGYyYWY0ZDg2ZTljYjIvbGlicmFyeS9\
hbGxvYy9zcmMvcmF3X3ZlYy9tb2QucnMAL3J1c3QvZGVwcy9kbG1hbGxvYy0wLjIuOS9zcmMvZGxt\
YWxsb2MucnMAbGlicmFyeS9zdGQvc3JjL2FsbG9jLnJzAHNwYXJrLWludGVybmFsLXJzL3NyYy9sa\
WIucnMAL2hvbWUvcnVubmVyLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5ND\
ljZjhjNmI1YjU1N2YvanMtc3lzLTAuMy43Ny9zcmMvbGliLnJzAC9ob21lL3J1bm5lci8uY2FyZ28\
vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL29uY2VfY2VsbC0x\
LjIxLjMvc3JjL2xpYi5ycwAAAHwBEABRAAAALgIAABEAAAAQAhAAHQAAABEAAAA9AAAAAQAAAAIAA\
AADAAAAxQAQAFAAAAAZAQAAGQAAAMUAEABQAAAAGAIAACYAAAAxARAASwAAAMEBAAAdAAAAAAAQAC\
EAAAAqAAAAFwAAAAAAEAAhAAAAeAAAABcAAAAAABAAIQAAAH4AAAAcAAAAAAAQACEAAACAAAAAHAA\
AAAAAEAAhAAAAhQAAACAAAAAQAhAAHQAAAB0AAAAzAAAAEAIQAB0AAAAoAAAALQAAAAEAAAAAAAAA\
EAIQAB0AAAA6AAAAMwAAABACEAAdAAAARQAAAC0AAAAQAhAAHQAAAF4AAAAoAAAAIQAQAB4AAAAbA\
AAAHQAAAEV4cGVjdGVkICBhY3RpdmUgc3BsYXRzIGJ1dCBnb3Qg/AMQAAkAAAAFBBAAFwAAACEAEA\
AeAAAAMwAAAB0AAAAhABAAHgAAADMAAAAVAAAAIQAQAB4AAAAkAAAAFAAAACEAEAAeAAAAdAAAABk\
AAAAhABAAHgAAAKcAAAATAAAAIQAQAB4AAACfAAAAEwAAACEAEAAeAAAAogAAAB0AAAAhABAAHgAA\
AKIAAAARAAAAIQAQAB4AAACQAAAAIAAAACEAEAAeAAAAkAAAABQAAAAhABAAHgAAAHwAAAAYAAAAI\
QAQAB4AAAB9AAAAGAAAAC0CEABbAAAA+xgAAAEAAABYABAAbQAAACQBAAAOAAAAY2xvc3VyZSBpbn\
Zva2VkIHJlY3Vyc2l2ZWx5IG9yIGFmdGVyIGJlaW5nIGRyb3BwZWRMYXp5IGluc3RhbmNlIGhhcyB\
wcmV2aW91c2x5IGJlZW4gcG9pc29uZWQ+BRAAKgAAAIgCEABeAAAACAMAABkAAAByZWVudHJhbnQg\
aW5pdAAAgAUQAA4AAACIAhAAXgAAAHoCAAANAAAAfAEQAFEAAAAuAgAAEQAAABUAAAAMAAAABAAAA\
BYAAAAXAAAAGAAAAGFzc2VydGlvbiBmYWlsZWQ6IHBzaXplID49IHNpemUgKyBtaW5fb3ZlcmhlYW\
QAAM0BEAAqAAAAsAQAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA8PSBzaXplICsgbWF4X29\
2ZXJoZWFkAADNARAAKgAAALYEAAANAAAAQWNjZXNzRXJyb3JjYW5ub3QgYWNjZXNzIGEgVGhyZWFk\
IExvY2FsIFN0b3JhZ2UgdmFsdWUgZHVyaW5nIG9yIGFmdGVyIGRlc3RydWN0aW9uOiAAWwYQAEgAA\
ABtZW1vcnkgYWxsb2NhdGlvbiBvZiAgYnl0ZXMgZmFpbGVkAACsBhAAFQAAAMEGEAANAAAA9wEQAB\
kAAABkAQAACQAAABUAAAAMAAAABAAAABkAAAAAAAAACAAAAAQAAAAaAAAAAAAAAAgAAAAEAAAAGwA\
AABwAAAAdAAAAHgAAAB8AAAAQAAAABAAAACAAAAAhAAAAIgAAACMAAABFcnJvcgAAACQAAAAMAAAA\
BAAAACUAAAAmAAAAJwAAAGNhcGFjaXR5IG92ZXJmbG93AAAAaAcQABEAAACsARAAIQAAAC4CAAARA\
AAAFQEQABwAAADoAQAAFwBBrI/AAAu4BQEAAAAoAAAAYSBmb3JtYXR0aW5nIHRyYWl0IGltcGxlbW\
VudGF0aW9uIHJldHVybmVkIGFuIGVycm9yIHdoZW4gdGhlIHVuZGVybHlpbmcgc3RyZWFtIGRpZCB\
ub3QAAD8AEAAZAAAAigIAAA4AAAABAAAAAAAAAFJlZkNlbGwgYWxyZWFkeSBib3Jyb3dlZGluZGV4\
IG91dCBvZiBib3VuZHM6IHRoZSBsZW4gaXMgIGJ1dCB0aGUgaW5kZXggaXMgAAA8CBAAIAAAAFwIE\
AASAAAAAAAAAAQAAAAEAAAALQAAAD09IT1tYXRjaGVzYXNzZXJ0aW9uIGBsZWZ0ICByaWdodGAgZm\
FpbGVkCiAgbGVmdDogCiByaWdodDogAJsIEAAQAAAAqwgQABcAAADCCBAACQAAACByaWdodGAgZmF\
pbGVkOiAKICBsZWZ0OiAAAACbCBAAEAAAAOQIEAAQAAAA9AgQAAkAAADCCBAACQAAADogAAABAAAA\
AAAAACAJEAACAAAAfSB9MHgwMDAxMDIwMzA0MDUwNjA3MDgwOTEwMTExMjEzMTQxNTE2MTcxODE5M\
jAyMTIyMjMyNDI1MjYyNzI4MjkzMDMxMzIzMzM0MzUzNjM3MzgzOTQwNDE0MjQzNDQ0NTQ2NDc0OD\
Q5NTA1MTUyNTM1NDU1NTY1NzU4NTk2MDYxNjI2MzY0NjU2NjY3Njg2OTcwNzE3MjczNzQ3NTc2Nzc\
3ODc5ODA4MTgyODM4NDg1ODY4Nzg4ODk5MDkxOTI5Mzk0OTU5Njk3OTg5OSBvdXQgb2YgcmFuZ2Ug\
Zm9yIHNsaWNlIG9mIGxlbmd0aCByYW5nZSBlbmQgaW5kZXggACMKEAAQAAAAAQoQACIAAACQCBAAk\
ggQAJQIEAACAAAAAgAAAAcAAAAAAAA/AAAAvwBB/JTAAAsBEgB8CXByb2R1Y2VycwIIbGFuZ3VhZ2\
UBBFJ1c3QADHByb2Nlc3NlZC1ieQMFcnVzdGMdMS44OS4wICgyOTQ4Mzg4M2UgMjAyNS0wOC0wNCk\
Gd2FscnVzBjAuMjMuMwx3YXNtLWJpbmRnZW4TMC4yLjEwMCAoMjQwNWVjMmI0KQBrD3RhcmdldF9m\
ZWF0dXJlcwYrD211dGFibGUtZ2xvYmFscysTbm9udHJhcHBpbmctZnB0b2ludCsLYnVsay1tZW1vc\
nkrCHNpZ24tZXh0Kw9yZWZlcmVuY2UtdHlwZXMrCm11bHRpdmFsdWU=\");\n  }\n  const \
imports = __wbg_get_imports();\n  if (typeof module_or_path === \"string\" || \
typeof Request === \"function\" && module_or_path instanceof Request || \
typeof URL === \"function\" && module_or_path instanceof URL) {\n    \
module_or_path = fetch(module_or_path);\n  }\n  const { instance, module } = \
await __wbg_load(await module_or_path, imports);\n  return \
__wbg_finalize_init(instance, module);\n}\nconst LN_SCALE_MIN = -12;\nconst \
LN_SCALE_MAX = 9;\nconst SCALE_MIN = Math.exp(LN_SCALE_MIN);\nconst SCALE_MAX \
= Math.exp(LN_SCALE_MAX);\nconst LN_SCALE_ZERO = -30;\nconst SCALE_ZERO = \
Math.exp(LN_SCALE_ZERO);\nconst SPLAT_TEX_WIDTH_BITS = 11;\nconst \
SPLAT_TEX_HEIGHT_BITS = 11;\nconst SPLAT_TEX_DEPTH_BITS = 11;\nconst \
SPLAT_TEX_LAYER_BITS = SPLAT_TEX_WIDTH_BITS + SPLAT_TEX_HEIGHT_BITS;\nconst \
SPLAT_TEX_WIDTH = 1 << SPLAT_TEX_WIDTH_BITS;\nconst SPLAT_TEX_HEIGHT = 1 << \
SPLAT_TEX_HEIGHT_BITS;\nconst SPLAT_TEX_DEPTH = 1 << \
SPLAT_TEX_DEPTH_BITS;\nconst SPLAT_TEX_MIN_HEIGHT = 1;\nconst \
SPLAT_TEX_WIDTH_MASK = SPLAT_TEX_WIDTH - 1;\nconst SPLAT_TEX_HEIGHT_MASK = \
SPLAT_TEX_HEIGHT - 1;\nconst SPLAT_TEX_DEPTH_MASK = SPLAT_TEX_DEPTH - \
1;\nconst WASM_SPLAT_SORT = true;\nconst USE_COMPILED_PARSER_FUNCTION = \
true;\nconst defines = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ \
Object.defineProperty({\n  __proto__: null,\n  LN_SCALE_MAX,\n  \
LN_SCALE_MIN,\n  LN_SCALE_ZERO,\n  SCALE_MAX,\n  SCALE_MIN,\n  SCALE_ZERO,\n  \
SPLAT_TEX_DEPTH,\n  SPLAT_TEX_DEPTH_BITS,\n  SPLAT_TEX_DEPTH_MASK,\n  \
SPLAT_TEX_HEIGHT,\n  SPLAT_TEX_HEIGHT_BITS,\n  SPLAT_TEX_HEIGHT_MASK,\n  \
SPLAT_TEX_LAYER_BITS,\n  SPLAT_TEX_MIN_HEIGHT,\n  SPLAT_TEX_WIDTH,\n  \
SPLAT_TEX_WIDTH_BITS,\n  SPLAT_TEX_WIDTH_MASK,\n  \
USE_COMPILED_PARSER_FUNCTION,\n  WASM_SPLAT_SORT\n}, Symbol.toStringTag, { \
value: \"Module\" }));\nfunction isBoolType(type) {\n  return type === \
\"bool\" || type === \"bvec2\" || type === \"bvec3\" || type === \
\"bvec4\";\n}\nfunction isScalarType(type) {\n  return type === \"int\" || \
type === \"uint\" || type === \"float\";\n}\nfunction isIntType(type) {\n  \
return type === \"int\" || type === \"ivec2\" || type === \"ivec3\" || type \
=== \"ivec4\";\n}\nfunction isUintType(type) {\n  return type === \"uint\" || \
type === \"uvec2\" || type === \"uvec3\" || type === \"uvec4\";\n}\nfunction \
isFloatType(type) {\n  return type === \"float\" || type === \"vec2\" || type \
=== \"vec3\" || type === \"vec4\";\n}\nfunction isMatFloatType(type) {\n  \
return type === \"mat2\" || type === \"mat2x2\" || type === \"mat2x3\" || \
type === \"mat2x4\" || type === \"mat3\" || type === \"mat3x2\" || type === \
\"mat3x3\" || type === \"mat3x4\" || type === \"mat4\" || type === \"mat4x2\" \
|| type === \"mat4x3\" || type === \"mat4x4\";\n}\nfunction \
isAllFloatType(type) {\n  return isFloatType(type) || \
isMatFloatType(type);\n}\nfunction isVector2Type(type) {\n  return type === \
\"vec2\" || type === \"ivec2\" || type === \"uvec2\";\n}\nfunction \
isVector3Type(type) {\n  return type === \"vec3\" || type === \"ivec3\" || \
type === \"uvec3\";\n}\nfunction isVector4Type(type) {\n  return type === \
\"vec4\" || type === \"ivec4\" || type === \"uvec4\";\n}\nfunction \
isVectorType(type) {\n  return isVector2Type(type) || isVector3Type(type) || \
isVector4Type(type);\n}\nfunction isMat2(type) {\n  return type === \"mat2\" \
|| type === \"mat2x2\";\n}\nfunction isMat3(type) {\n  return type === \
\"mat3\" || type === \"mat3x3\";\n}\nfunction isMat4(type) {\n  return type \
=== \"mat4\" || type === \"mat4x4\";\n}\nfunction vectorElementType(type) {\n \
 switch (type) {\n    case \"vec2\":\n      return \"float\";\n    case \
\"vec3\":\n      return \"float\";\n    case \"vec4\":\n      return \
\"float\";\n    case \"ivec2\":\n      return \"int\";\n    case \"ivec3\":\n \
     return \"int\";\n    case \"ivec4\":\n      return \"int\";\n    case \
\"uvec2\":\n      return \"uint\";\n    case \"uvec3\":\n      return \
\"uint\";\n    case \"uvec4\":\n      return \"uint\";\n    default:\n      \
throw new Error(`Invalid vector type: ${type}`);\n  }\n}\nfunction \
vectorDim(type) {\n  switch (type) {\n    case \"vec2\":\n    case \
\"ivec2\":\n    case \"uvec2\":\n      return 2;\n    case \"vec3\":\n    \
case \"ivec3\":\n    case \"uvec3\":\n      return 3;\n    case \"vec4\":\n   \
 case \"ivec4\":\n    case \"uvec4\":\n      return 4;\n    default:\n      \
throw new Error(`Invalid vector type: ${type}`);\n  }\n}\nfunction \
sameSizeVec(type) {\n  if (isScalarType(type)) {\n    return \"float\";\n  \
}\n  if (isVector2Type(type)) {\n    return \"vec2\";\n  }\n  if \
(isVector3Type(type)) {\n    return \"vec3\";\n  }\n  if \
(isVector4Type(type)) {\n    return \"vec4\";\n  }\n  throw new \
Error(`Invalid vector type: ${type}`);\n}\nfunction sameSizeUvec(type) {\n  \
if (isScalarType(type)) {\n    return \"uint\";\n  }\n  if \
(isVector2Type(type)) {\n    return \"uvec2\";\n  }\n  if \
(isVector3Type(type)) {\n    return \"uvec3\";\n  }\n  if \
(isVector4Type(type)) {\n    return \"uvec4\";\n  }\n  throw new \
Error(`Invalid vector type: ${type}`);\n}\nfunction sameSizeIvec(type) {\n  \
if (isScalarType(type)) {\n    return \"int\";\n  }\n  if \
(isVector2Type(type)) {\n    return \"ivec2\";\n  }\n  if \
(isVector3Type(type)) {\n    return \"ivec3\";\n  }\n  if \
(isVector4Type(type)) {\n    return \"ivec4\";\n  }\n  throw new \
Error(`Invalid vector type: ${type}`);\n}\nfunction typeLiteral(type) {\n  if \
(typeof type === \"string\") {\n    return type;\n  }\n  if (typeof type === \
\"object\" && type.type) {\n    return type.type;\n  }\n  throw new \
Error(`Invalid DynoType: ${String(type)}`);\n}\nfunction numberAsInt(value) \
{\n  return Math.trunc(value).toString();\n}\nfunction numberAsUint(value) \
{\n  const v = Math.max(0, Math.trunc(value));\n  return \
`${v.toString()}u`;\n}\nfunction numberAsFloat(value) {\n  return value === \
Number.POSITIVE_INFINITY ? \"INFINITY\" : value === Number.NEGATIVE_INFINITY \
? \"-INFINITY\" : Number.isInteger(value) ? value.toFixed(1) : \
value.toString();\n}\nfunction valType(val) {\n  if (val instanceof \
DynoValue) {\n    return val.type;\n  }\n  const value = val.dynoOut();\n  \
return value.type;\n}\nclass DynoValue {\n  constructor(type) {\n    \
this.__isDynoValue = true;\n    this.type = type;\n  }\n}\nclass DynoOutput \
extends DynoValue {\n  constructor(dyno2, key) {\n    \
super(dyno2.outTypes[key]);\n    this.dyno = dyno2;\n    this.key = key;\n  \
}\n}\nclass DynoLiteral extends DynoValue {\n  constructor(type, literal) {\n \
   super(type);\n    this.literal = literal;\n  }\n  getLiteral() {\n    \
return this.literal;\n  }\n}\nfunction dynoLiteral(type, literal) {\n  return \
new DynoLiteral(type, literal);\n}\nclass DynoConst extends DynoLiteral {\n  \
constructor(type, value) {\n    super(type, \"\");\n    this.value = value;\n \
 }\n  getLiteral() {\n    const { type, value } = this;\n    switch (type) \
{\n      case \"bool\":\n        return value ? \"true\" : \"false\";\n      \
case \"uint\":\n        return numberAsUint(value);\n      case \"int\":\n    \
    return numberAsInt(value);\n      case \"float\":\n        return \
numberAsFloat(value);\n      case \"bvec2\": {\n        const v = value;\n    \
    return `bvec2(${v[0]}, ${v[1]})`;\n      }\n      case \"uvec2\": {\n     \
   if (value instanceof THREE.Vector2) {\n          return \
`uvec2(${numberAsUint(value.x)}, ${numberAsUint(value.y)})`;\n        }\n     \
   const v = value;\n        return `uvec2(${numberAsUint(v[0])}, \
${numberAsUint(v[1])})`;\n      }\n      case \"ivec2\": {\n        if (value \
instanceof THREE.Vector2) {\n          return `ivec2(${numberAsInt(value.x)}, \
${numberAsInt(value.y)})`;\n        }\n        const v = value;\n        \
return `ivec2(${numberAsInt(v[0])}, ${numberAsInt(v[1])})`;\n      }\n      \
case \"vec2\": {\n        if (value instanceof THREE.Vector2) {\n          \
return `vec2(${numberAsFloat(value.x)}, ${numberAsFloat(value.y)})`;\n        \
}\n        const v = value;\n        return `vec2(${numberAsFloat(v[0])}, \
${numberAsFloat(v[1])})`;\n      }\n      case \"bvec3\": {\n        const v \
= value;\n        return `bvec3(${v[0]}, ${v[1]}, ${v[2]})`;\n      }\n      \
case \"uvec3\": {\n        if (value instanceof THREE.Vector3) {\n          \
return `uvec3(${numberAsUint(value.x)}, ${numberAsUint(value.y)}, \
${numberAsUint(value.z)})`;\n        }\n        const v = value;\n        \
return `uvec3(${numberAsUint(v[0])}, ${numberAsUint(v[1])}, \
${numberAsUint(v[2])})`;\n      }\n      case \"ivec3\": {\n        if (value \
instanceof THREE.Vector3) {\n          return `ivec3(${numberAsInt(value.x)}, \
${numberAsInt(value.y)}, ${numberAsInt(value.z)})`;\n        }\n        const \
v = value;\n        return `ivec3(${numberAsInt(v[0])}, ${numberAsInt(v[1])}, \
${numberAsInt(v[2])})`;\n      }\n      case \"vec3\": {\n        if (value \
instanceof THREE.Vector3) {\n          return \
`vec3(${numberAsFloat(value.x)}, ${numberAsFloat(value.y)}, \
${numberAsFloat(value.z)})`;\n        }\n        const v = value;\n        \
return `vec3(${numberAsFloat(v[0])}, ${numberAsFloat(v[1])}, \
${numberAsFloat(v[2])})`;\n      }\n      case \"bvec4\": {\n        const v \
= value;\n        return `bvec4(${v[0]}, ${v[1]}, ${v[2]}, ${v[3]})`;\n      \
}\n      case \"uvec4\": {\n        if (value instanceof THREE.Vector4) {\n   \
       return `uvec4(${numberAsUint(value.x)}, ${numberAsUint(value.y)}, \
${numberAsUint(value.z)}, ${numberAsUint(value.w)})`;\n        }\n        \
const v = value;\n        return `uvec4(${numberAsUint(v[0])}, \
${numberAsUint(v[1])}, ${numberAsUint(v[2])}, ${numberAsUint(v[3])})`;\n      \
}\n      case \"ivec4\": {\n        if (value instanceof THREE.Vector4) {\n   \
       return `ivec4(${numberAsInt(value.x)}, ${numberAsInt(value.y)}, \
${numberAsInt(value.z)}, ${numberAsInt(value.w)})`;\n        }\n        const \
v = value;\n        return `ivec4(${numberAsInt(v[0])}, ${numberAsInt(v[1])}, \
${numberAsInt(v[2])}, ${numberAsInt(v[3])})`;\n      }\n      case \"vec4\": \
{\n        if (value instanceof THREE.Vector4) {\n          return \
`vec4(${numberAsFloat(value.x)}, ${numberAsFloat(value.y)}, \
${numberAsFloat(value.z)}, ${numberAsFloat(value.w)})`;\n        }\n        \
if (value instanceof THREE.Quaternion) {\n          return \
`vec4(${numberAsFloat(value.x)}, ${numberAsFloat(value.y)}, \
${numberAsFloat(value.z)}, ${numberAsFloat(value.w)})`;\n        }\n        \
const v = value;\n        return `vec4(${numberAsFloat(v[0])}, \
${numberAsFloat(v[1])}, ${numberAsFloat(v[2])}, ${numberAsFloat(v[3])})`;\n   \
   }\n      case \"mat2\":\n      case \"mat2x2\": {\n        const m = \
value;\n        const e = m instanceof THREE.Matrix2 ? m.elements : value;\n  \
      const arg = new Array(4).fill(0).map((_, i) => numberAsFloat(e[i]));\n  \
      return `${type}(${arg.join(\", \")})`;\n      }\n      case \"mat2x3\": \
{\n        const e = value;\n        const arg = new Array(6).fill(0).map((_, \
i) => numberAsFloat(e[i]));\n        return `${type}(${arg.join(\", \")})`;\n \
     }\n      case \"mat2x4\": {\n        const e = value;\n        const arg \
= new Array(8).fill(0).map((_, i) => numberAsFloat(e[i]));\n        return \
`${type}(${arg.join(\", \")})`;\n      }\n      case \"mat3\":\n      case \
\"mat3x3\": {\n        const m = value;\n        const e = m instanceof \
THREE.Matrix3 ? m.elements : value;\n        const arg = new \
Array(9).fill(0).map((_, i) => numberAsFloat(e[i]));\n        return \
`${type}(${arg.join(\", \")})`;\n      }\n      case \"mat3x2\": {\n        \
const e = value;\n        const arg = new Array(6).fill(0).map((_, i) => \
numberAsFloat(e[i]));\n        return `${type}(${arg.join(\", \")})`;\n      \
}\n      case \"mat3x4\": {\n        const e = value;\n        const arg = \
new Array(12).fill(0).map((_, i) => numberAsFloat(e[i]));\n        return \
`${type}(${arg.join(\", \")})`;\n      }\n      case \"mat4\":\n      case \
\"mat4x4\": {\n        const m = value;\n        const e = m instanceof \
THREE.Matrix4 ? m.elements : value;\n        const arg = new \
Array(16).fill(0).map((_, i) => numberAsFloat(e[i]));\n        return \
`${type}(${arg.join(\", \")})`;\n      }\n      case \"mat4x2\": {\n        \
const e = value;\n        const arg = new Array(8).fill(0).map((_, i) => \
numberAsFloat(e[i]));\n        return `${type}(${arg.join(\", \")})`;\n      \
}\n      case \"mat4x3\": {\n        const e = value;\n        const arg = \
new Array(12).fill(0).map((_, i) => numberAsFloat(e[i]));\n        return \
`${type}(${arg.join(\", \")})`;\n      }\n      default:\n        throw new \
Error(`Type not implemented: ${String(type)}`);\n    }\n  }\n}\nfunction \
dynoConst(type, value) {\n  return new DynoConst(type, value);\n}\nfunction \
literalZero(type) {\n  const typeString = String(type);\n  if \
(isBoolType(type)) {\n    return `${typeString}(false)`;\n  }\n  if \
(isAllFloatType(type)) {\n    return `${typeString}(0.0)`;\n  }\n  if \
(isIntType(type)) {\n    return `${typeString}(0)`;\n  }\n  if \
(isUintType(type)) {\n    return `${typeString}(0u)`;\n  }\n  throw new \
Error(`Type not implemented: ${typeString}`);\n}\nfunction literalOne(type) \
{\n  const typeString = String(type);\n  if (isBoolType(type)) {\n    return \
`${typeString}(true)`;\n  }\n  if (isAllFloatType(type)) {\n    return \
`${typeString}(1.0)`;\n  }\n  if (isIntType(type)) {\n    return \
`${typeString}(1)`;\n  }\n  if (isUintType(type)) {\n    return \
`${typeString}(1u)`;\n  }\n  throw new Error(`Type not implemented: \
${typeString}`);\n}\nfunction literalNegOne(type) {\n  const typeString = \
String(type);\n  if (isBoolType(type)) {\n    return `${typeString}(true)`;\n \
 }\n  if (isAllFloatType(type)) {\n    return `${typeString}(-1.0)`;\n  }\n  \
if (isIntType(type)) {\n    return `${typeString}(-1)`;\n  }\n  if \
(isUintType(type)) {\n    return `${typeString}(0xFFFFFFFFu)`;\n  }\n  throw \
new Error(`Type not implemented: ${typeString}`);\n}\nconst DEFAULT_INDENT = \
\"    \";\nclass Compilation {\n  constructor({ indent } = {}) {\n    \
this.globals = /* @__PURE__ */ new Set();\n    this.statements = [];\n    \
this.uniforms = {};\n    this.declares = /* @__PURE__ */ new Set();\n    \
this.updaters = [];\n    this.sequence = 0;\n    this.indent = \
DEFAULT_INDENT;\n    this.indent = indent ?? DEFAULT_INDENT;\n  }\n  \
nextSequence() {\n    return this.sequence++;\n  }\n}\nclass Dyno {\n  \
constructor({\n    inTypes,\n    outTypes,\n    inputs,\n    update,\n    \
globals,\n    statements,\n    generate\n  }) {\n    this.inTypes = inTypes \
?? {};\n    this.outTypes = outTypes ?? {};\n    this.inputs = inputs ?? \
{};\n    this.update = update;\n    this.globals = globals;\n    \
this.statements = statements;\n    this.generate = generate ?? (({ inputs: \
inputs2, outputs, compile }) => {\n      var _a2, _b2;\n      return {\n      \
  globals: (_a2 = this.globals) == null ? void 0 : _a2.call(this, { inputs: \
inputs2, outputs, compile }),\n        statements: (_b2 = this.statements) == \
null ? void 0 : _b2.call(this, { inputs: inputs2, outputs, compile })\n      \
};\n    });\n  }\n  get outputs() {\n    const outputs = {};\n    for (const \
key in this.outTypes) {\n      outputs[key] = new DynoOutput(this, key);\n    \
}\n    return outputs;\n  }\n  apply(inputs) {\n    \
Object.assign(this.inputs, inputs);\n    return this.outputs;\n  }\n  \
compile({\n    inputs,\n    outputs,\n    compile\n  }) {\n    const result = \
[\n      `// ${this.constructor.name}(${Object.values(inputs).join(\", \")}) \
=> (${Object.values(outputs).join(\", \")})`\n    ];\n    const declares = \
[];\n    for (const key in outputs) {\n      const name = outputs[key];\n     \
 if (name && !compile.declares.has(name)) {\n        \
compile.declares.add(name);\n        declares.push(key);\n      }\n    }\n    \
const { globals, statements, uniforms } = this.generate({\n      inputs,\n    \
  outputs,\n      compile\n    });\n    for (const global of globals ?? []) \
{\n      compile.globals.add(global);\n    }\n    for (const key in uniforms) \
{\n      compile.uniforms[key] = uniforms[key];\n    }\n    if (this.update) \
{\n      compile.updaters.push(this.update);\n    }\n    for (const key of \
declares) {\n      const name = outputs[key];\n      if (name) {\n        if \
(!compile.uniforms[name]) {\n          result.push(`${dynoDeclare(name, \
this.outTypes[key])};`);\n        }\n      }\n    }\n    if (statements == \
null ? void 0 : statements.length) {\n      result.push(\"{\");\n      \
result.push(...statements.map((line) => compile.indent + line));\n      \
result.push(\"}\");\n    }\n    return result;\n  }\n}\nclass DynoBlock \
extends Dyno {\n  constructor({\n    inTypes,\n    outTypes,\n    inputs,\n   \
 update,\n    globals,\n    construct\n  }) {\n    super({\n      inTypes,\n  \
    outTypes,\n      inputs,\n      update,\n      globals,\n      generate: \
(args) => this.generateBlock(args)\n    });\n    this.construct = \
construct;\n  }\n  generateBlock({\n    inputs,\n    outputs,\n    compile\n  \
}) {\n    var _a2, _b2;\n    const blockInputs = {};\n    const blockOutputs \
= {};\n    for (const key in inputs) {\n      if (inputs[key] != null) {\n    \
    blockInputs[key] = new DynoLiteral(this.inTypes[key], inputs[key]);\n     \
 }\n    }\n    for (const key in outputs) {\n      if (outputs[key] != null) \
{\n        blockOutputs[key] = new DynoValue(this.outTypes[key]);\n      }\n  \
  }\n    const options = { roots: [] };\n    const returned = \
this.construct(blockInputs, blockOutputs, options);\n    for (const global of \
((_a2 = this.globals) == null ? void 0 : _a2.call(this, { inputs, outputs, \
compile })) ?? []) {\n      compile.globals.add(global);\n    }\n    const \
ordering = [];\n    const nodeOuts = /* @__PURE__ */ new Map();\n    function \
visit(node, outKey, outName) {\n      let outs = nodeOuts.get(node);\n      \
if (!outs) {\n        outs = {\n          sequence: compile.nextSequence(),\n \
         outNames: /* @__PURE__ */ new Map(),\n          newOuts: /* \
@__PURE__ */ new Set()\n        };\n        nodeOuts.set(node, outs);\n       \
 for (const key in node.inputs) {\n          let input = node.inputs[key];\n  \
        while (input) {\n            if (input instanceof DynoValue) {\n      \
        if (input instanceof DynoOutput) {\n                visit(input.dyno, \
input.key);\n              }\n              break;\n            }\n           \
 input = input.dynoOut();\n          }\n        }\n        \
ordering.push(node);\n      }\n      if (outKey) {\n        if (!outName) {\n \
         outs.newOuts.add(outKey);\n        }\n        \
outs.outNames.set(outKey, outName ?? `${outKey}_${outs.sequence}`);\n      \
}\n    }\n    for (const root of options.roots) {\n      visit(root);\n    \
}\n    for (const key in blockOutputs) {\n      let value = (returned == null \
? void 0 : returned[key]) ?? blockOutputs[key];\n      while (value) {\n      \
  if (value instanceof DynoValue) {\n          if (value instanceof \
DynoOutput) {\n            visit(value.dyno, value.key, outputs[key]);\n      \
    }\n          break;\n        }\n        value = value.dynoOut();\n      \
}\n      blockOutputs[key] = value;\n    }\n    const steps = [];\n    for \
(const dyno2 of ordering) {\n      const inputs2 = {};\n      const outputs2 \
= {};\n      for (const key in dyno2.inputs) {\n        let value = \
dyno2.inputs[key];\n        while (value) {\n          if (value instanceof \
DynoValue) {\n            if (value instanceof DynoLiteral) {\n              \
inputs2[key] = value.getLiteral();\n            } else if (value instanceof \
DynoOutput) {\n              const source = (_b2 = nodeOuts.get(value.dyno)) \
== null ? void 0 : _b2.outNames.get(value.key);\n              if (!source) \
{\n                throw new Error(\n                  `Source not found for \
${value.dyno.constructor.name}.${value.key}`\n                );\n            \
  }\n              inputs2[key] = source;\n            }\n            \
break;\n          }\n          value = value.dynoOut();\n        }\n      }\n \
     const outs = nodeOuts.get(dyno2) ?? { outNames: /* @__PURE__ */ new \
Map() };\n      for (const [key, name] of outs.outNames.entries()) {\n        \
outputs2[key] = name;\n      }\n      const newSteps = dyno2.compile({ \
inputs: inputs2, outputs: outputs2, compile });\n      \
steps.push(newSteps);\n    }\n    const literalOutputs = [];\n    for (const \
key in outputs) {\n      if (blockOutputs[key] instanceof DynoLiteral) {\n    \
    literalOutputs.push(\n          `${outputs[key]} = \
${blockOutputs[key].getLiteral()};`\n        );\n      }\n    }\n    if \
(literalOutputs.length > 0) {\n      steps.push(literalOutputs);\n    }\n    \
const statements = steps.flatMap((step2, index) => {\n      return index === \
0 ? step2 : [\"\", ...step2];\n    });\n    return { statements };\n  \
}\n}\nfunction dynoBlock(inTypes, outTypes, construct, { update, globals } = \
{}) {\n  return new DynoBlock({ inTypes, outTypes, construct, update, globals \
});\n}\nfunction dyno$1({\n  inTypes,\n  outTypes,\n  inputs,\n  update,\n  \
globals,\n  statements,\n  generate\n}) {\n  return new Dyno({\n    \
inTypes,\n    outTypes,\n    inputs,\n    update,\n    globals,\n    \
statements,\n    generate\n  });\n}\nfunction dynoDeclare(name, type, count) \
{\n  const typeStr = typeof type === \"string\" ? type : type.type;\n  if \
(!typeStr) {\n    throw new Error(`Invalid DynoType: ${String(type)}`);\n  \
}\n  return `${typeStr} ${name}${count != null ? `[${count}]` : \
\"\"}`;\n}\nfunction unindentLines(s) {\n  var _a2;\n  let seenNonEmpty = \
false;\n  const lines = s.split(\"\\n\").map((line) => {\n    const \
trimmedLine = line.trimEnd();\n    if (seenNonEmpty) {\n      return \
trimmedLine;\n    }\n    if (trimmedLine.length > 0) {\n      seenNonEmpty = \
true;\n      return trimmedLine;\n    }\n    return null;\n  }).filter((line) \
=> line != null);\n  while (lines.length > 0 && lines[lines.length - \
1].length === 0) {\n    lines.pop();\n  }\n  if (lines.length === 0) {\n    \
return [];\n  }\n  const indent = (_a2 = lines[0].match(/^\\s*/)) == null ? \
void 0 : _a2[0];\n  if (!indent) {\n    return lines;\n  }\n  const regex = \
new RegExp(`^${indent}`);\n  return lines.map((line) => line.replace(regex, \
\"\"));\n}\nfunction unindent(s) {\n  return \
unindentLines(s).join(\"\\n\");\n}\nclass UnaryOp extends Dyno {\n  \
constructor({\n    a,\n    outKey,\n    outTypeFunc\n  }) {\n    const \
inTypes = { a: valType(a) };\n    const outType = outTypeFunc(valType(a));\n  \
  const outTypes = { [outKey]: outType };\n    super({ inTypes, outTypes, \
inputs: { a } });\n    this.outKey = outKey;\n  }\n  dynoOut() {\n    return \
new DynoOutput(this, this.outKey);\n  }\n}\nclass BinaryOp extends Dyno {\n  \
constructor({\n    a,\n    b,\n    outKey,\n    outTypeFunc\n  }) {\n    \
const inTypes = { a: valType(a), b: valType(b) };\n    const outType = \
outTypeFunc(valType(a), valType(b));\n    const outTypes = { [outKey]: \
outType };\n    super({ inTypes, outTypes, inputs: { a, b } });\n    \
this.outKey = outKey;\n  }\n  dynoOut() {\n    return new DynoOutput(this, \
this.outKey);\n  }\n}\nclass TrinaryOp extends Dyno {\n  constructor({\n    \
a,\n    b,\n    c,\n    outKey,\n    outTypeFunc\n  }) {\n    const inTypes = \
{ a: valType(a), b: valType(b), c: valType(c) };\n    const outType = \
outTypeFunc(valType(a), valType(b), valType(c));\n    const outTypes = { \
[outKey]: outType };\n    super({ inTypes, outTypes, inputs: { a, b, c } \
});\n    this.outKey = outKey;\n  }\n  dynoOut() {\n    return new \
DynoOutput(this, this.outKey);\n  }\n}\nconst Gsplat = { type: \"Gsplat\" \
};\nconst TPackedSplats = { type: \"PackedSplats\" };\nconst numPackedSplats \
= (packedSplats) => new NumPackedSplats({ packedSplats });\nconst \
readPackedSplat = (packedSplats, index) => new ReadPackedSplat({ \
packedSplats, index });\nconst readPackedSplatRange = (packedSplats, index, \
base, count) => new ReadPackedSplatRange({ packedSplats, index, base, count \
});\nconst splitGsplat = (gsplat) => new SplitGsplat({ gsplat });\nconst \
combineGsplat = ({\n  gsplat,\n  flags,\n  index,\n  center,\n  scales,\n  \
quaternion,\n  rgba,\n  rgb,\n  opacity,\n  x,\n  y,\n  z,\n  r,\n  g,\n  \
b\n}) => {\n  return new CombineGsplat({\n    gsplat,\n    flags,\n    \
index,\n    center,\n    scales,\n    quaternion,\n    rgba,\n    rgb,\n    \
opacity,\n    x,\n    y,\n    z,\n    r,\n    g,\n    b\n  });\n};\nconst \
gsplatNormal = (gsplat) => new GsplatNormal({ gsplat });\nconst \
transformGsplat = (gsplat, {\n  scale,\n  rotate,\n  translate,\n  \
recolor\n}) => {\n  return new TransformGsplat({ gsplat, scale, rotate, \
translate, recolor });\n};\nconst defineGsplat = unindent(`\n  struct Gsplat \
{\n    vec3 center;\n    uint flags;\n    vec3 scales;\n    int index;\n    \
vec4 quaternion;\n    vec4 rgba;\n  };\n  const uint GSPLAT_FLAG_ACTIVE = 1u \
<< 0u;\n\n  bool isGsplatActive(uint flags) {\n    return (flags & \
GSPLAT_FLAG_ACTIVE) != 0u;\n  }\n`);\nconst definePackedSplats = unindent(`\n \
 struct PackedSplats {\n    usampler2DArray texture;\n    int numSplats;\n    \
vec4 rgbMinMaxLnScaleMinMax;\n  };\n`);\nclass NumPackedSplats extends \
UnaryOp {\n  constructor({\n    packedSplats\n  }) {\n    super({ a: \
packedSplats, outKey: \"numSplats\", outTypeFunc: () => \"int\" });\n    \
this.statements = ({ inputs, outputs }) => [\n      `${outputs.numSplats} = \
${inputs.a}.numSplats;`\n    ];\n  }\n}\nconst defineReadPackedSplat = \
unindent(`\n  bool readPackedSplat(usampler2DArray texture, int numSplats, \
vec4 rgbMinMaxLnScaleMinMax, int index, out Gsplat gsplat) {\n    if ((index \
>= 0) && (index < numSplats)) {\n      uvec4 packed = texelFetch(texture, \
splatTexCoord(index), 0);\n      unpackSplatEncoding(packed, gsplat.center, \
gsplat.scales, gsplat.quaternion, gsplat.rgba, rgbMinMaxLnScaleMinMax);\n     \
 return true;\n    } else {\n      return false;\n    }\n  }\n`);\nclass \
ReadPackedSplat extends Dyno {\n  constructor({\n    packedSplats,\n    \
index\n  }) {\n    super({\n      inTypes: { packedSplats: TPackedSplats, \
index: \"int\" },\n      outTypes: { gsplat: Gsplat },\n      inputs: { \
packedSplats, index },\n      globals: () => [defineGsplat, \
definePackedSplats, defineReadPackedSplat],\n      statements: ({ inputs, \
outputs }) => {\n        const { gsplat } = outputs;\n        if (!gsplat) \
{\n          return [];\n        }\n        const { packedSplats: \
packedSplats2, index: index2 } = inputs;\n        let statements;\n        if \
(packedSplats2 && index2) {\n          statements = unindentLines(`\n         \
   if (readPackedSplat(${packedSplats2}.texture, ${packedSplats2}.numSplats, \
${packedSplats2}.rgbMinMaxLnScaleMinMax, ${index2}, ${gsplat})) {\n           \
   bool zeroSize = all(equal(${gsplat}.scales, vec3(0.0, 0.0, 0.0)));\n       \
       ${gsplat}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;\n            } \
else {\n              ${gsplat}.flags = 0u;\n            }\n          `);\n   \
     } else {\n          statements = [`${gsplat}.flags = 0u;`];\n        }\n \
       statements.push(`${gsplat}.index = ${index2 ?? \"0\"};`);\n        \
return statements;\n      }\n    });\n  }\n  dynoOut() {\n    return new \
DynoOutput(this, \"gsplat\");\n  }\n}\nclass ReadPackedSplatRange extends \
Dyno {\n  constructor({\n    packedSplats,\n    index,\n    base,\n    \
count\n  }) {\n    super({\n      inTypes: {\n        packedSplats: \
TPackedSplats,\n        index: \"int\",\n        base: \"int\",\n        \
count: \"int\"\n      },\n      outTypes: { gsplat: Gsplat },\n      inputs: \
{ packedSplats, index, base, count },\n      globals: () => [defineGsplat, \
definePackedSplats, defineReadPackedSplat],\n      statements: ({ inputs, \
outputs }) => {\n        const { gsplat } = outputs;\n        if (!gsplat) \
{\n          return [];\n        }\n        const { packedSplats: \
packedSplats2, index: index2, base: base2, count: count2 } = inputs;\n        \
let statements;\n        if (packedSplats2 && index2 && base2 && count2) {\n  \
        statements = unindentLines(`\n            ${gsplat}.flags = 0u;\n     \
       if ((${index2} >= ${base2}) && (${index2} < (${base2} + ${count2}))) \
{\n              if (readPackedSplat(${packedSplats2}.texture, \
${packedSplats2}.numSplats, ${packedSplats2}.rgbMinMaxLnScaleMinMax, \
${index2}, ${gsplat})) {\n                bool zeroSize = \
all(equal(${gsplat}.scales, vec3(0.0, 0.0, 0.0)));\n                \
${gsplat}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;\n              }\n      \
      }\n          `);\n        } else {\n          statements = \
[`${gsplat}.flags = 0u;`];\n        }\n        \
statements.push(`${gsplat}.index = ${index2 ?? \"0\"};`);\n        return \
statements;\n      }\n    });\n  }\n  dynoOut() {\n    return new \
DynoOutput(this, \"gsplat\");\n  }\n}\nclass SplitGsplat extends Dyno {\n  \
constructor({ gsplat }) {\n    super({\n      inTypes: { gsplat: Gsplat },\n  \
    outTypes: {\n        flags: \"uint\",\n        active: \"bool\",\n        \
index: \"int\",\n        center: \"vec3\",\n        scales: \"vec3\",\n       \
 quaternion: \"vec4\",\n        rgba: \"vec4\",\n        rgb: \"vec3\",\n     \
   opacity: \"float\",\n        x: \"float\",\n        y: \"float\",\n        \
z: \"float\",\n        r: \"float\",\n        g: \"float\",\n        b: \
\"float\"\n      },\n      inputs: { gsplat },\n      globals: () => \
[defineGsplat],\n      statements: ({ inputs, outputs }) => {\n        const \
{ gsplat: gsplat2 } = inputs;\n        const {\n          flags,\n          \
active,\n          index,\n          center,\n          scales,\n          \
quaternion,\n          rgba,\n          rgb,\n          opacity,\n          \
x,\n          y,\n          z,\n          r,\n          g,\n          b\n     \
   } = outputs;\n        return [\n          !flags ? null : `${flags} = \
${gsplat2 ? `${gsplat2}.flags` : \"0u\"};`,\n          !active ? null : \
`${active} = isGsplatActive(${gsplat2 ? `${gsplat2}.flags` : \"0u\"});`,\n    \
      !index ? null : `${index} = ${gsplat2 ? `${gsplat2}.index` : \
\"0\"};`,\n          !center ? null : `${center} = ${gsplat2 ? \
`${gsplat2}.center` : \"vec3(0.0, 0.0, 0.0)\"};`,\n          !scales ? null : \
`${scales} = ${gsplat2 ? `${gsplat2}.scales` : \"vec3(0.0, 0.0, 0.0)\"};`,\n  \
        !quaternion ? null : `${quaternion} = ${gsplat2 ? \
`${gsplat2}.quaternion` : \"vec4(0.0, 0.0, 0.0, 1.0)\"};`,\n          !rgba ? \
null : `${rgba} = ${gsplat2 ? `${gsplat2}.rgba` : \"vec4(0.0, 0.0, 0.0, \
0.0)\"};`,\n          !rgb ? null : `${rgb} = ${gsplat2 ? \
`${gsplat2}.rgba.rgb` : \"vec3(0.0, 0.0, 0.0)\"};`,\n          !opacity ? \
null : `${opacity} = ${gsplat2 ? `${gsplat2}.rgba.a` : \"0.0\"};`,\n          \
!x ? null : `${x} = ${gsplat2 ? `${gsplat2}.center.x` : \"0.0\"};`,\n         \
 !y ? null : `${y} = ${gsplat2 ? `${gsplat2}.center.y` : \"0.0\"};`,\n        \
  !z ? null : `${z} = ${gsplat2 ? `${gsplat2}.center.z` : \"0.0\"};`,\n       \
   !r ? null : `${r} = ${gsplat2 ? `${gsplat2}.rgba.r` : \"0.0\"};`,\n        \
  !g ? null : `${g} = ${gsplat2 ? `${gsplat2}.rgba.g` : \"0.0\"};`,\n         \
 !b ? null : `${b} = ${gsplat2 ? `${gsplat2}.rgba.b` : \"0.0\"};`\n        \
].filter(Boolean);\n      }\n    });\n  }\n}\nclass CombineGsplat extends \
Dyno {\n  constructor({\n    gsplat,\n    flags,\n    index,\n    center,\n   \
 scales,\n    quaternion,\n    rgba,\n    rgb,\n    opacity,\n    x,\n    \
y,\n    z,\n    r,\n    g,\n    b\n  }) {\n    super({\n      inTypes: {\n    \
    gsplat: Gsplat,\n        flags: \"uint\",\n        index: \"int\",\n      \
  center: \"vec3\",\n        scales: \"vec3\",\n        quaternion: \
\"vec4\",\n        rgba: \"vec4\",\n        rgb: \"vec3\",\n        opacity: \
\"float\",\n        x: \"float\",\n        y: \"float\",\n        z: \
\"float\",\n        r: \"float\",\n        g: \"float\",\n        b: \
\"float\"\n      },\n      outTypes: { gsplat: Gsplat },\n      inputs: {\n   \
     gsplat,\n        flags,\n        index,\n        center,\n        \
scales,\n        quaternion,\n        rgba,\n        rgb,\n        opacity,\n \
       x,\n        y,\n        z,\n        r,\n        g,\n        b\n      \
},\n      globals: () => [defineGsplat],\n      statements: ({ inputs, \
outputs }) => {\n        const { gsplat: outGsplat } = outputs;\n        if \
(!outGsplat) {\n          return [];\n        }\n        const {\n          \
gsplat: gsplat2,\n          flags: flags2,\n          index: index2,\n        \
  center: center2,\n          scales: scales2,\n          quaternion: \
quaternion2,\n          rgba: rgba2,\n          rgb: rgb2,\n          \
opacity: opacity2,\n          x: x2,\n          y: y2,\n          z: z2,\n    \
      r: r2,\n          g: g2,\n          b: b22\n        } = inputs;\n       \
 return [\n          `${outGsplat}.flags = ${flags2 ?? (gsplat2 ? \
`${gsplat2}.flags` : \"0u\")};`,\n          `${outGsplat}.index = ${index2 ?? \
(gsplat2 ? `${gsplat2}.index` : \"0\")};`,\n          `${outGsplat}.center = \
${center2 ?? (gsplat2 ? `${gsplat2}.center` : \"vec3(0.0, 0.0, 0.0)\")};`,\n  \
        `${outGsplat}.scales = ${scales2 ?? (gsplat2 ? `${gsplat2}.scales` : \
\"vec3(0.0, 0.0, 0.0)\")};`,\n          `${outGsplat}.quaternion = \
${quaternion2 ?? (gsplat2 ? `${gsplat2}.quaternion` : \"vec4(0.0, 0.0, 0.0, \
1.0)\")};`,\n          `${outGsplat}.rgba = ${rgba2 ?? (gsplat2 ? \
`${gsplat2}.rgba` : \"vec4(0.0, 0.0, 0.0, 0.0)\")};`,\n          !rgb2 ? null \
: `${outGsplat}.rgba.rgb = ${rgb2};`,\n          !opacity2 ? null : \
`${outGsplat}.rgba.a = ${opacity2};`,\n          !x2 ? null : \
`${outGsplat}.center.x = ${x2};`,\n          !y2 ? null : \
`${outGsplat}.center.y = ${y2};`,\n          !z2 ? null : \
`${outGsplat}.center.z = ${z2};`,\n          !r2 ? null : \
`${outGsplat}.rgba.r = ${r2};`,\n          !g2 ? null : `${outGsplat}.rgba.g \
= ${g2};`,\n          !b22 ? null : `${outGsplat}.rgba.b = ${b22};`\n        \
].filter(Boolean);\n      }\n    });\n  }\n  dynoOut() {\n    return new \
DynoOutput(this, \"gsplat\");\n  }\n}\nconst defineGsplatNormal = \
unindent(`\n  vec3 gsplatNormal(vec3 scales, vec4 quaternion) {\n    float \
minScale = min(scales.x, min(scales.y, scales.z));\n    vec3 normal;\n    if \
(scales.z == minScale) {\n      normal = vec3(0.0, 0.0, 1.0);\n    } else if \
(scales.y == minScale) {\n      normal = vec3(0.0, 1.0, 0.0);\n    } else {\n \
     normal = vec3(1.0, 0.0, 0.0);\n    }\n    return quatVec(quaternion, \
normal);\n  }\n`);\nclass GsplatNormal extends UnaryOp {\n  constructor({ \
gsplat }) {\n    super({ a: gsplat, outKey: \"normal\", outTypeFunc: () => \
\"vec3\" });\n    this.globals = () => [defineGsplat, defineGsplatNormal];\n  \
  this.statements = ({ inputs, outputs }) => [\n      `${outputs.normal} = \
gsplatNormal(${inputs.a}.scales, ${inputs.a}.quaternion);`\n    ];\n  \
}\n}\nclass TransformGsplat extends Dyno {\n  constructor({\n    gsplat,\n    \
scale,\n    rotate,\n    translate,\n    recolor\n  }) {\n    super({\n      \
inTypes: {\n        gsplat: Gsplat,\n        scale: \"float\",\n        \
rotate: \"vec4\",\n        translate: \"vec3\",\n        recolor: \"vec4\"\n  \
    },\n      outTypes: { gsplat: Gsplat },\n      inputs: { gsplat, scale, \
rotate, translate, recolor },\n      globals: () => [defineGsplat],\n      \
statements: ({ inputs, outputs, compile }) => {\n        const { gsplat: \
gsplat2 } = outputs;\n        if (!gsplat2 || !inputs.gsplat) {\n          \
return [];\n        }\n        const { scale: scale2, rotate: rotate2, \
translate: translate2, recolor: recolor2 } = inputs;\n        const indent = \
compile.indent;\n        const statements = [\n          `${gsplat2} = \
${inputs.gsplat};`,\n          `if (isGsplatActive(${gsplat2}.flags)) {`,\n   \
       scale2 ? `${indent}${gsplat2}.center *= ${scale2};` : null,\n          \
rotate2 ? `${indent}${gsplat2}.center = quatVec(${rotate2}, \
${gsplat2}.center);` : null,\n          translate2 ? \
`${indent}${gsplat2}.center += ${translate2};` : null,\n          scale2 ? \
`${indent}${gsplat2}.scales *= ${scale2};` : null,\n          rotate2 ? \
`${indent}${gsplat2}.quaternion = quatQuat(${rotate2}, \
${gsplat2}.quaternion);` : null,\n          recolor2 ? \
`${indent}${gsplat2}.rgba *= ${recolor2};` : null,\n          \"}\"\n        \
].filter(Boolean);\n        return statements;\n      }\n    });\n  }\n  \
dynoOut() {\n    return new DynoOutput(this, \"gsplat\");\n  }\n}\nconst \
outputPackedSplat = (gsplat, rgbMinMaxLnScaleMinMax) => new \
OutputPackedSplat({ gsplat, rgbMinMaxLnScaleMinMax });\nconst outputRgba8 = \
(rgba8) => new OutputRgba8({ rgba8 });\nclass OutputPackedSplat extends Dyno \
{\n  constructor({\n    gsplat,\n    rgbMinMaxLnScaleMinMax\n  }) {\n    \
super({\n      inTypes: { gsplat: Gsplat, rgbMinMaxLnScaleMinMax: \"vec4\" \
},\n      inputs: { gsplat, rgbMinMaxLnScaleMinMax },\n      globals: () => \
[defineGsplat],\n      statements: ({ inputs, outputs }) => {\n        const \
{ output } = outputs;\n        if (!output) {\n          return [];\n        \
}\n        const { gsplat: gsplat2, rgbMinMaxLnScaleMinMax: \
rgbMinMaxLnScaleMinMax2 } = inputs;\n        if (gsplat2) {\n          return \
unindentLines(`\n            if (isGsplatActive(${gsplat2}.flags)) {\n        \
      ${output} = packSplatEncoding(${gsplat2}.center, ${gsplat2}.scales, \
${gsplat2}.quaternion, ${gsplat2}.rgba, ${rgbMinMaxLnScaleMinMax2});\n        \
    } else {\n              ${output} = uvec4(0u, 0u, 0u, 0u);\n            \
}\n          `);\n        }\n        return [`${output} = uvec4(0u, 0u, 0u, \
0u);`];\n      }\n    });\n  }\n  dynoOut() {\n    return new \
DynoOutput(this, \"output\");\n  }\n}\nclass OutputRgba8 extends Dyno {\n  \
constructor({ rgba8 }) {\n    super({\n      inTypes: { rgba8: \"vec4\" },\n  \
    inputs: { rgba8 },\n      statements: ({ inputs, outputs }) => [\n        \
`target = ${inputs.rgba8 ?? \"vec4(0.0, 0.0, 0.0, 0.0)\"};`\n      ]\n    \
});\n  }\n  dynoOut() {\n    return new DynoOutput(this, \"rgba8\");\n  \
}\n}\nconst uniform = (key, type, value) => new DynoUniform({ key, type, \
value });\nconst dynoBool = (value = false, key) => new DynoBool({ key, value \
});\nconst dynoUint = (value = 0, key) => new DynoUint({ key, value \
});\nconst dynoInt = (value = 0, key) => new DynoInt({ key, value });\nconst \
dynoFloat = (value = 0, key) => new DynoFloat({ key, value });\nconst \
dynoBvec2 = (value, key) => new DynoBvec2({ key, value });\nconst dynoUvec2 = \
(value, key) => new DynoUvec2({ key, value });\nconst dynoIvec2 = (value, \
key) => new DynoIvec2({ key, value });\nconst dynoVec2 = (value, key) => new \
DynoVec2({ key, value });\nconst dynoBvec3 = (value, key) => new DynoBvec3({ \
key, value });\nconst dynoUvec3 = (value, key) => new DynoUvec3({ key, value \
});\nconst dynoIvec3 = (value, key) => new DynoIvec3({ key, value });\nconst \
dynoVec3 = (value, key) => new DynoVec3({ key, value });\nconst dynoBvec4 = \
(value, key) => new DynoBvec4({ key, value });\nconst dynoUvec4 = (value, \
key) => new DynoUvec4({ key, value });\nconst dynoIvec4 = (value, key) => new \
DynoIvec4({ key, value });\nconst dynoVec4 = (value, key) => new DynoVec4({ \
key, value });\nconst dynoMat2 = (value, key) => new DynoMat2({ key, value \
});\nconst dynoMat2x2 = (value, key) => new DynoMat2x2({ key, value \
});\nconst dynoMat2x3 = (value, key) => new DynoMat2x3({ key, value \
});\nconst dynoMat2x4 = (value, key) => new DynoMat2x4({ key, value \
});\nconst dynoMat3 = (value, key) => new DynoMat3({ key, value });\nconst \
dynoMat3x2 = (value, key) => new DynoMat3x2({ key, value });\nconst \
dynoMat3x3 = (value, key) => new DynoMat3x3({ key, value });\nconst \
dynoMat3x4 = (value, key) => new DynoMat3x4({ key, value });\nconst dynoMat4 \
= (value, key) => new DynoMat4({ key, value });\nconst dynoMat4x2 = (value, \
key) => new DynoMat4x2({ key, value });\nconst dynoMat4x3 = (value, key) => \
new DynoMat4x3({ key, value });\nconst dynoMat4x4 = (value, key) => new \
DynoMat4x4({ key, value });\nconst dynoUsampler2D = (value, key) => new \
DynoUsampler2D({ key, value });\nconst dynoIsampler2D = (value, key) => new \
DynoIsampler2D({ key, value });\nconst dynoSampler2D = (value, key) => new \
DynoSampler2D({ key, value });\nconst dynoUsampler2DArray = (value, key) => \
new DynoUsampler2DArray({ key, value });\nconst dynoIsampler2DArray = (key, \
value) => new DynoIsampler2DArray({ key, value });\nconst dynoSampler2DArray \
= (value, key) => new DynoSampler2DArray({ key, value });\nconst \
dynoUsampler3D = (value, key) => new DynoUsampler3D({ key, value });\nconst \
dynoIsampler3D = (value, key) => new DynoIsampler3D({ key, value });\nconst \
dynoSampler3D = (value, key) => new DynoSampler3D({ key, value });\nconst \
dynoUsamplerCube = (value, key) => new DynoUsamplerCube({ key, value \
});\nconst dynoIsamplerCube = (value, key) => new DynoIsamplerCube({ key, \
value });\nconst dynoSamplerCube = (value, key) => new DynoSamplerCube({ key, \
value });\nconst dynoSampler2DShadow = (value, key) => new \
DynoSampler2DShadow({ key, value });\nconst dynoSampler2DArrayShadow = \
(value, key) => new DynoSampler2DArrayShadow({ key, value });\nconst \
dynoSamplerCubeShadow = (value, key) => new DynoSamplerCubeShadow({ key, \
value });\nclass DynoUniform extends Dyno {\n  constructor({\n    key,\n    \
type,\n    count,\n    value,\n    update,\n    globals\n  }) {\n    key = \
key ?? \"value\";\n    super({\n      outTypes: { [key]: type },\n      \
update: () => {\n        if (update) {\n          const value2 = \
update(this.value);\n          if (value2 !== void 0) {\n            \
this.value = value2;\n          }\n        }\n        this.uniform.value = \
this.value;\n      },\n      generate: ({ inputs, outputs }) => {\n        \
const allGlobals = (globals == null ? void 0 : globals({ inputs, outputs })) \
?? [];\n        const uniforms = {};\n        const name = outputs[key];\n    \
    if (name) {\n          allGlobals.push(`uniform ${dynoDeclare(name, type, \
count)};`);\n          uniforms[name] = this.uniform;\n        }\n        \
return { globals: allGlobals, uniforms };\n      }\n    });\n    this.type = \
type;\n    this.count = count;\n    this.value = value;\n    this.uniform = { \
value };\n    this.outKey = key;\n  }\n  dynoOut() {\n    return new \
DynoOutput(this, this.outKey);\n  }\n}\nclass DynoBool extends DynoUniform \
{\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ \
key, type: \"bool\", value, update });\n  }\n}\nclass DynoUint extends \
DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    \
super({ key, type: \"uint\", value, update });\n  }\n}\nclass DynoInt extends \
DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    \
super({ key, type: \"int\", value, update });\n  }\n}\nclass DynoFloat \
extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  \
}) {\n    super({ key, type: \"float\", value, update });\n  }\n}\nclass \
DynoBvec2 extends DynoUniform {\n  constructor({\n    key,\n    value,\n    \
update\n  }) {\n    super({ key, type: \"bvec2\", value, update });\n  \
}\n}\nclass DynoUvec2 extends DynoUniform {\n  constructor({\n    key,\n    \
value,\n    update\n  }) {\n    super({ key, type: \"uvec2\", value, update \
});\n  }\n}\nclass DynoIvec2 extends DynoUniform {\n  constructor({\n    \
key,\n    value,\n    update\n  }) {\n    super({ key, type: \"ivec2\", \
value, update });\n  }\n}\nclass DynoVec2 extends DynoUniform {\n  \
constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, \
type: \"vec2\", value, update });\n  }\n}\nclass DynoBvec3 extends \
DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    \
super({ key, type: \"bvec3\", value, update });\n  }\n}\nclass DynoUvec3 \
extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  \
}) {\n    super({ key, type: \"uvec3\", value, update });\n  }\n}\nclass \
DynoIvec3 extends DynoUniform {\n  constructor({\n    key,\n    value,\n    \
update\n  }) {\n    super({ key, type: \"ivec3\", value, update });\n  \
}\n}\nclass DynoVec3 extends DynoUniform {\n  constructor({\n    key,\n    \
value,\n    update\n  }) {\n    super({ key, type: \"vec3\", value, update \
});\n  }\n}\nclass DynoBvec4 extends DynoUniform {\n  constructor({\n    \
key,\n    value,\n    update\n  }) {\n    super({ key, type: \"bvec4\", \
value, update });\n  }\n}\nclass DynoUvec4 extends DynoUniform {\n  \
constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, \
type: \"uvec4\", value, update });\n  }\n}\nclass DynoIvec4 extends \
DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    \
super({ key, type: \"ivec4\", value, update });\n  }\n}\nclass DynoVec4 \
extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  \
}) {\n    super({ key, type: \"vec4\", value, update });\n  }\n}\nclass \
DynoMat2 extends DynoUniform {\n  constructor({\n    key,\n    value,\n    \
update\n  }) {\n    super({ key, type: \"mat2\", value, update });\n  \
}\n}\nclass DynoMat2x2 extends DynoUniform {\n  constructor({\n    key,\n    \
value,\n    update\n  }) {\n    super({ key, type: \"mat2x2\", value, update \
});\n  }\n}\nclass DynoMat2x3 extends DynoUniform {\n  constructor({\n    \
key,\n    value,\n    update\n  }) {\n    super({ key, type: \"mat2x3\", \
value, update });\n  }\n}\nclass DynoMat2x4 extends DynoUniform {\n  \
constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, \
type: \"mat2x4\", value, update });\n  }\n}\nclass DynoMat3 extends \
DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    \
super({ key, type: \"mat3\", value, update });\n  }\n}\nclass DynoMat3x2 \
extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  \
}) {\n    super({ key, type: \"mat3x2\", value, update });\n  }\n}\nclass \
DynoMat3x3 extends DynoUniform {\n  constructor({\n    key,\n    value,\n    \
update\n  }) {\n    super({ key, type: \"mat3x3\", value, update });\n  \
}\n}\nclass DynoMat3x4 extends DynoUniform {\n  constructor({\n    key,\n    \
value,\n    update\n  }) {\n    super({ key, type: \"mat3x4\", value, update \
});\n  }\n}\nclass DynoMat4 extends DynoUniform {\n  constructor({\n    \
key,\n    value,\n    update\n  }) {\n    super({ key, type: \"mat4\", value, \
update });\n  }\n}\nclass DynoMat4x2 extends DynoUniform {\n  constructor({\n \
   key,\n    value,\n    update\n  }) {\n    super({ key, type: \"mat4x2\", \
value, update });\n  }\n}\nclass DynoMat4x3 extends DynoUniform {\n  \
constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, \
type: \"mat4x3\", value, update });\n  }\n}\nclass DynoMat4x4 extends \
DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    \
super({ key, type: \"mat4x4\", value, update });\n  }\n}\nclass \
DynoUsampler2D extends DynoUniform {\n  constructor({\n    key,\n    value,\n \
   update\n  }) {\n    super({ key, type: \"usampler2D\", value, update });\n \
 }\n}\nclass DynoIsampler2D extends DynoUniform {\n  constructor({\n    \
key,\n    value,\n    update\n  }) {\n    super({ key, type: \"isampler2D\", \
value, update });\n  }\n}\nclass DynoSampler2D extends DynoUniform {\n  \
constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, \
type: \"sampler2D\", value, update });\n  }\n}\nclass DynoUsampler2DArray \
extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  \
}) {\n    super({ key, type: \"usampler2DArray\", value, update });\n  \
}\n}\nclass DynoIsampler2DArray extends DynoUniform {\n  constructor({\n    \
key,\n    value,\n    update\n  }) {\n    super({ key, type: \
\"isampler2DArray\", value, update });\n  }\n}\nclass DynoSampler2DArray \
extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  \
}) {\n    super({ key, type: \"sampler2DArray\", value, update });\n  \
}\n}\nclass DynoUsampler3D extends DynoUniform {\n  constructor({\n    key,\n \
   value,\n    update\n  }) {\n    super({ key, type: \"usampler3D\", value, \
update });\n  }\n}\nclass DynoIsampler3D extends DynoUniform {\n  \
constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, \
type: \"isampler3D\", value, update });\n  }\n}\nclass DynoSampler3D extends \
DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    \
super({ key, type: \"sampler3D\", value, update });\n  }\n}\nclass \
DynoUsamplerCube extends DynoUniform {\n  constructor({\n    key,\n    \
value,\n    update\n  }) {\n    super({ key, type: \"usamplerCube\", value, \
update });\n  }\n}\nclass DynoIsamplerCube extends DynoUniform {\n  \
constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ key, \
type: \"isamplerCube\", value, update });\n  }\n}\nclass DynoSamplerCube \
extends DynoUniform {\n  constructor({\n    key,\n    value,\n    update\n  \
}) {\n    super({ key, type: \"samplerCube\", value, update });\n  \
}\n}\nclass DynoSampler2DShadow extends DynoUniform {\n  constructor({\n    \
key,\n    value,\n    update\n  }) {\n    super({ key, type: \
\"sampler2DShadow\", value, update });\n  }\n}\nclass \
DynoSampler2DArrayShadow extends DynoUniform {\n  constructor({\n    key,\n   \
 value,\n    update\n  }) {\n    super({ key, type: \"sampler2DArrayShadow\", \
value, update });\n  }\n}\nclass DynoSamplerCubeShadow extends DynoUniform \
{\n  constructor({\n    key,\n    value,\n    update\n  }) {\n    super({ \
key, type: \"samplerCubeShadow\", value, update });\n  }\n}\nconst f32buffer \
= new Float32Array(1);\nconst u32buffer = new \
Uint32Array(f32buffer.buffer);\nconst supportsFloat16Array = \"Float16Array\" \
in globalThis;\nconst f16buffer = supportsFloat16Array ? new \
globalThis[\"Float16Array\"](1) : null;\nconst u16buffer = new \
Uint16Array(f16buffer == null ? void 0 : f16buffer.buffer);\nfunction \
normalize$1(vec) {\n  const norm = Math.sqrt(vec.reduce((acc, v) => acc + v * \
v, 0));\n  return vec.map((v) => v / norm);\n}\nfunction floatBitsToUint$1(f) \
{\n  f32buffer[0] = f;\n  return u32buffer[0];\n}\nfunction \
uintBitsToFloat$1(u) {\n  u32buffer[0] = u;\n  return f32buffer[0];\n}\nconst \
toHalf = supportsFloat16Array ? toHalfNative : toHalfJS;\nconst fromHalf = \
supportsFloat16Array ? fromHalfNative : fromHalfJS;\nfunction toHalfNative(f) \
{\n  f16buffer[0] = f;\n  return u16buffer[0];\n}\nfunction toHalfJS(f) {\n  \
f32buffer[0] = f;\n  const bits2 = u32buffer[0];\n  const sign2 = bits2 >> 31 \
& 1;\n  const exp3 = bits2 >> 23 & 255;\n  const frac = bits2 & 8388607;\n  \
const halfSign = sign2 << 15;\n  if (exp3 === 255) {\n    if (frac !== 0) {\n \
     return halfSign | 32767;\n    }\n    return halfSign | 31744;\n  }\n  \
const newExp = exp3 - 127 + 15;\n  if (newExp >= 31) {\n    return halfSign | \
31744;\n  }\n  if (newExp <= 0) {\n    if (newExp < -10) {\n      return \
halfSign;\n    }\n    const subFrac = (frac | 8388608) >> 1 - newExp + 13;\n  \
  return halfSign | subFrac;\n  }\n  const halfFrac = frac >> 13;\n  return \
halfSign | newExp << 10 | halfFrac;\n}\nfunction fromHalfNative(u) {\n  \
u16buffer[0] = u;\n  return f16buffer[0];\n}\nfunction fromHalfJS(h) {\n  \
const sign2 = h >> 15 & 1;\n  const exp3 = h >> 10 & 31;\n  const frac = h & \
1023;\n  let f32bits;\n  if (exp3 === 0) {\n    if (frac === 0) {\n      \
f32bits = sign2 << 31;\n    } else {\n      let mant = frac;\n      let e = \
-14;\n      while ((mant & 1024) === 0) {\n        mant <<= 1;\n        \
e--;\n      }\n      mant &= 1023;\n      const newExp = e + 127;\n      \
const newFrac = mant << 13;\n      f32bits = sign2 << 31 | newExp << 23 | \
newFrac;\n    }\n  } else if (exp3 === 31) {\n    if (frac === 0) {\n      \
f32bits = sign2 << 31 | 2139095040;\n    } else {\n      f32bits = sign2 << \
31 | 2143289344;\n    }\n  } else {\n    const newExp = exp3 - 15 + 127;\n    \
const newFrac = frac << 13;\n    f32bits = sign2 << 31 | newExp << 23 | \
newFrac;\n  }\n  u32buffer[0] = f32bits;\n  return f32buffer[0];\n}\nfunction \
floatToUint8(v) {\n  return Math.max(0, Math.min(255, Math.round(v * \
255)));\n}\nfunction floatToSint8(v) {\n  return Math.max(-127, Math.min(127, \
Math.round(v * 127)));\n}\nfunction Uint8ToFloat(v) {\n  return v / \
255;\n}\nfunction Sint8ToFloat(v) {\n  return v / 127;\n}\nclass DataCache \
{\n  // Create a DataCache with a given function that fetches data not in the \
cache.\n  constructor({\n    asyncFetch,\n    maxItems = 5\n  }) {\n    \
this.asyncFetch = asyncFetch;\n    this.maxItems = maxItems;\n    this.items \
= [];\n  }\n  // Fetch data for the key, returning cached data if \
available.\n  async getFetch(key) {\n    const index = \
this.items.findIndex((item) => item.key === key);\n    if (index >= 0) {\n    \
  const item = this.items.splice(index, 1)[0];\n      \
this.items.push(item);\n      return item.data;\n    }\n    const data = \
await this.asyncFetch(key);\n    this.items.push({ key, data });\n    while \
(this.items.length > this.maxItems) {\n      this.items.shift();\n    }\n    \
return data;\n  }\n}\nfunction mapObject(obj, fn) {\n  const entries = \
Object.entries(obj).map(([key, value]) => [\n    key,\n    fn(value, key)\n  \
]);\n  return Object.fromEntries(entries);\n}\nfunction mapFilterObject(obj, \
fn) {\n  const entries = Object.entries(obj).map(([key, value]) => [key, \
fn(value, key)]).filter(([_, value]) => value !== void 0);\n  return \
Object.fromEntries(entries);\n}\nfunction getArrayBuffers(ctx) {\n  const \
buffers = [];\n  const seen = /* @__PURE__ */ new Set();\n  function \
traverse(obj) {\n    if (obj && typeof obj === \"object\" && !seen.has(obj)) \
{\n      seen.add(obj);\n      if (obj instanceof ArrayBuffer) {\n        \
buffers.push(obj);\n      } else if (ArrayBuffer.isView(obj)) {\n        \
buffers.push(obj.buffer);\n      } else if (Array.isArray(obj)) {\n        \
obj.forEach(traverse);\n      } else {\n        \
Object.values(obj).forEach(traverse);\n      }\n    }\n  }\n  \
traverse(ctx);\n  return buffers;\n}\nfunction newArray(n, initFunction) {\n  \
return new Array(n).fill(null).map((_, i) => initFunction(i));\n}\nclass \
FreeList {\n  constructor({\n    // Allocate a new item with the given args\n \
   allocate,\n    // Dispose of an item (optional, if GC is enough)\n    \
dispose,\n    // Check if an existing item in the list is valid for the given \
args,\n    // allowing you to store heterogeneous items in the list.\n    \
valid\n  }) {\n    this.items = [];\n    this.allocate = allocate;\n    \
this.dispose = dispose;\n    this.valid = valid;\n  }\n  // Allocate a new \
item from the free list, first checking if a existing item\n  // on the \
freelist is valid for the given args.\n  alloc(args) {\n    while (true) {\n  \
    const item = this.items.pop();\n      if (!item) {\n        break;\n      \
}\n      if (this.valid(item, args)) {\n        return item;\n      }\n      \
if (this.dispose) {\n        this.dispose(item);\n      }\n    }\n    return \
this.allocate(args);\n  }\n  free(item) {\n    this.items.push(item);\n  }\n  \
disposeAll() {\n    let item;\n    item = this.items.pop();\n    while (item) \
{\n      if (this.dispose) {\n        this.dispose(item);\n      }\n      \
item = this.items.pop();\n    }\n  }\n}\nfunction \
setPackedSplat(packedSplats, index, x, y, z, scaleX, scaleY, scaleZ, quatX, \
quatY, quatZ, quatW, opacity, r, g, b, encoding) {\n  const rgbMin = \
(encoding == null ? void 0 : encoding.rgbMin) ?? 0;\n  const rgbMax = \
(encoding == null ? void 0 : encoding.rgbMax) ?? 1;\n  const rgbRange = \
rgbMax - rgbMin;\n  const uR = floatToUint8((r - rgbMin) / rgbRange);\n  \
const uG = floatToUint8((g - rgbMin) / rgbRange);\n  const uB = \
floatToUint8((b - rgbMin) / rgbRange);\n  const uA = floatToUint8(opacity);\n \
 const uQuat = encodeQuatOctXy88R8(\n    tempQuaternion.set(quatX, quatY, \
quatZ, quatW)\n  );\n  const uQuatX = uQuat & 255;\n  const uQuatY = uQuat \
>>> 8 & 255;\n  const uQuatZ = uQuat >>> 16 & 255;\n  const lnScaleMin = \
(encoding == null ? void 0 : encoding.lnScaleMin) ?? LN_SCALE_MIN;\n  const \
lnScaleMax = (encoding == null ? void 0 : encoding.lnScaleMax) ?? \
LN_SCALE_MAX;\n  const lnScaleScale = 254 / (lnScaleMax - lnScaleMin);\n  \
const uScaleX = scaleX < SCALE_ZERO ? 0 : Math.min(\n    255,\n    \
Math.max(\n      1,\n      Math.round((Math.log(scaleX) - lnScaleMin) * \
lnScaleScale) + 1\n    )\n  );\n  const uScaleY = scaleY < SCALE_ZERO ? 0 : \
Math.min(\n    255,\n    Math.max(\n      1,\n      \
Math.round((Math.log(scaleY) - lnScaleMin) * lnScaleScale) + 1\n    )\n  );\n \
 const uScaleZ = scaleZ < SCALE_ZERO ? 0 : Math.min(\n    255,\n    \
Math.max(\n      1,\n      Math.round((Math.log(scaleZ) - lnScaleMin) * \
lnScaleScale) + 1\n    )\n  );\n  const uCenterX = toHalf(x);\n  const \
uCenterY = toHalf(y);\n  const uCenterZ = toHalf(z);\n  const i4 = index * \
4;\n  packedSplats[i4] = uR | uG << 8 | uB << 16 | uA << 24;\n  \
packedSplats[i4 + 1] = uCenterX | uCenterY << 16;\n  packedSplats[i4 + 2] = \
uCenterZ | uQuatX << 16 | uQuatY << 24;\n  packedSplats[i4 + 3] = uScaleX | \
uScaleY << 8 | uScaleZ << 16 | uQuatZ << 24;\n}\nfunction \
setPackedSplatCenter(packedSplats, index, x, y, z) {\n  const uCenterX = \
toHalf(x);\n  const uCenterY = toHalf(y);\n  const uCenterZ = toHalf(z);\n  \
const i4 = index * 4;\n  packedSplats[i4 + 1] = uCenterX | uCenterY << 16;\n  \
packedSplats[i4 + 2] = uCenterZ | packedSplats[i4 + 2] & \
4294901760;\n}\nfunction setPackedSplatScales(packedSplats, index, scaleX, \
scaleY, scaleZ, encoding) {\n  const lnScaleMin = (encoding == null ? void 0 \
: encoding.lnScaleMin) ?? LN_SCALE_MIN;\n  const lnScaleMax = (encoding == \
null ? void 0 : encoding.lnScaleMax) ?? LN_SCALE_MAX;\n  const lnScaleScale = \
254 / (lnScaleMax - lnScaleMin);\n  const uScaleX = scaleX < SCALE_ZERO ? 0 : \
Math.min(\n    255,\n    Math.max(\n      1,\n      \
Math.round((Math.log(scaleX) - lnScaleMin) * lnScaleScale) + 1\n    )\n  );\n \
 const uScaleY = scaleY < SCALE_ZERO ? 0 : Math.min(\n    255,\n    \
Math.max(\n      1,\n      Math.round((Math.log(scaleY) - lnScaleMin) * \
lnScaleScale) + 1\n    )\n  );\n  const uScaleZ = scaleZ < SCALE_ZERO ? 0 : \
Math.min(\n    255,\n    Math.max(\n      1,\n      \
Math.round((Math.log(scaleZ) - lnScaleMin) * lnScaleScale) + 1\n    )\n  );\n \
 const i4 = index * 4;\n  packedSplats[i4 + 3] = uScaleX | uScaleY << 8 | \
uScaleZ << 16 | packedSplats[i4 + 3] & 4278190080;\n}\nconst tempQuaternion = \
new THREE.Quaternion();\nfunction setPackedSplatQuat(packedSplats, index, \
quatX, quatY, quatZ, quatW) {\n  const uQuat = encodeQuatOctXy88R8(\n    \
tempQuaternion.set(quatX, quatY, quatZ, quatW)\n  );\n  const uQuatX = uQuat \
& 255;\n  const uQuatY = uQuat >>> 8 & 255;\n  const uQuatZ = uQuat >>> 16 & \
255;\n  const i4 = index * 4;\n  packedSplats[i4 + 2] = packedSplats[i4 + 2] \
& 65535 | uQuatX << 16 | uQuatY << 24;\n  packedSplats[i4 + 3] = \
packedSplats[i4 + 3] & 16777215 | uQuatZ << 24;\n}\nfunction \
setPackedSplatRgba(packedSplats, index, r, g, b, a, encoding) {\n  const \
rgbMin = (encoding == null ? void 0 : encoding.rgbMin) ?? 0;\n  const rgbMax \
= (encoding == null ? void 0 : encoding.rgbMax) ?? 1;\n  const rgbRange = \
rgbMax - rgbMin;\n  const uR = floatToUint8((r - rgbMin) / rgbRange);\n  \
const uG = floatToUint8((g - rgbMin) / rgbRange);\n  const uB = \
floatToUint8((b - rgbMin) / rgbRange);\n  const uA = floatToUint8(a);\n  \
const i4 = index * 4;\n  packedSplats[i4] = uR | uG << 8 | uB << 16 | uA << \
24;\n}\nfunction setPackedSplatRgb(packedSplats, index, r, g, b, encoding) \
{\n  const rgbMin = (encoding == null ? void 0 : encoding.rgbMin) ?? 0;\n  \
const rgbMax = (encoding == null ? void 0 : encoding.rgbMax) ?? 1;\n  const \
rgbRange = rgbMax - rgbMin;\n  const uR = floatToUint8((r - rgbMin) / \
rgbRange);\n  const uG = floatToUint8((g - rgbMin) / rgbRange);\n  const uB = \
floatToUint8((b - rgbMin) / rgbRange);\n  const i4 = index * 4;\n  \
packedSplats[i4] = uR | uG << 8 | uB << 16 | packedSplats[i4] & \
4278190080;\n}\nfunction setPackedSplatOpacity(packedSplats, index, opacity) \
{\n  const uA = floatToUint8(opacity);\n  const i4 = index * 4;\n  \
packedSplats[i4] = packedSplats[i4] & 16777215 | uA << 24;\n}\nconst \
packedCenter = new THREE.Vector3();\nconst packedScales = new \
THREE.Vector3();\nconst packedQuaternion = new THREE.Quaternion();\nconst \
packedColor = new THREE.Color();\nconst packedFields = {\n  center: \
packedCenter,\n  scales: packedScales,\n  quaternion: packedQuaternion,\n  \
color: packedColor,\n  opacity: 0\n};\nfunction unpackSplat(packedSplats, \
index, encoding) {\n  const result = packedFields;\n  const i4 = index * 4;\n \
 const word0 = packedSplats[i4];\n  const word1 = packedSplats[i4 + 1];\n  \
const word2 = packedSplats[i4 + 2];\n  const word3 = packedSplats[i4 + 3];\n  \
const rgbMin = (encoding == null ? void 0 : encoding.rgbMin) ?? 0;\n  const \
rgbMax = (encoding == null ? void 0 : encoding.rgbMax) ?? 1;\n  const \
rgbRange = rgbMax - rgbMin;\n  result.color.set(\n    rgbMin + (word0 & 255) \
/ 255 * rgbRange,\n    rgbMin + (word0 >>> 8 & 255) / 255 * rgbRange,\n    \
rgbMin + (word0 >>> 16 & 255) / 255 * rgbRange\n  );\n  result.opacity = \
(word0 >>> 24 & 255) / 255;\n  result.center.set(\n    fromHalf(word1 & \
65535),\n    fromHalf(word1 >>> 16 & 65535),\n    fromHalf(word2 & 65535)\n  \
);\n  const lnScaleMin = (encoding == null ? void 0 : encoding.lnScaleMin) ?? \
LN_SCALE_MIN;\n  const lnScaleMax = (encoding == null ? void 0 : \
encoding.lnScaleMax) ?? LN_SCALE_MAX;\n  const lnScaleScale = (lnScaleMax - \
lnScaleMin) / 254;\n  const uScalesX = word3 & 255;\n  result.scales.x = \
uScalesX === 0 ? 0 : Math.exp(lnScaleMin + (uScalesX - 1) * lnScaleScale);\n  \
const uScalesY = word3 >>> 8 & 255;\n  result.scales.y = uScalesY === 0 ? 0 : \
Math.exp(lnScaleMin + (uScalesY - 1) * lnScaleScale);\n  const uScalesZ = \
word3 >>> 16 & 255;\n  result.scales.z = uScalesZ === 0 ? 0 : \
Math.exp(lnScaleMin + (uScalesZ - 1) * lnScaleScale);\n  const uQuat = word2 \
>>> 16 & 65535 | word3 >>> 8 & 16711680;\n  decodeQuatOctXy88R8(uQuat, \
result.quaternion);\n  return result;\n}\nfunction getTextureSize(numSplats) \
{\n  const width = SPLAT_TEX_WIDTH;\n  const height = Math.max(\n    \
SPLAT_TEX_MIN_HEIGHT,\n    Math.min(SPLAT_TEX_HEIGHT, Math.ceil(numSplats / \
width))\n  );\n  const depth = Math.ceil(numSplats / (width * height));\n  \
const maxSplats = width * height * depth;\n  return { width, height, depth, \
maxSplats };\n}\nfunction computeMaxSplats(numSplats) {\n  const width = \
SPLAT_TEX_WIDTH;\n  const height = Math.max(\n    SPLAT_TEX_MIN_HEIGHT,\n    \
Math.min(SPLAT_TEX_HEIGHT, Math.ceil(numSplats / width))\n  );\n  const depth \
= Math.ceil(numSplats / (width * height));\n  return width * height * \
depth;\n}\nfunction isMobile() {\n  if (navigator.maxTouchPoints > 0) {\n    \
return true;\n  }\n  return /Mobi|Android|iPhone|iPad|iPod|Opera \
Mini|IEMobile/.test(\n    navigator.userAgent\n  );\n}\nfunction isAndroid() \
{\n  return /Android/.test(navigator.userAgent);\n}\nfunction isOculus() {\n  \
return /Oculus/.test(navigator.userAgent);\n}\nfunction flipPixels(pixels, \
width, height) {\n  const tempLine = new Uint8Array(width * 4);\n  for (let y \
= 0; y < height / 2; y++) {\n    const topOffset = y * width * 4;\n    const \
bottomOffset = (height - 1 - y) * width * 4;\n    \
tempLine.set(pixels.subarray(topOffset, topOffset + width * 4));\n    \
pixels.set(\n      pixels.subarray(bottomOffset, bottomOffset + width * 4),\n \
     topOffset\n    );\n    pixels.set(tempLine, bottomOffset);\n  }\n  \
return pixels;\n}\nfunction pixelsToPngUrl(pixels, width, height) {\n  const \
canvas = document.createElement(\"canvas\");\n  canvas.width = width;\n  \
canvas.height = height;\n  const ctx = canvas.getContext(\"2d\");\n  if \
(!ctx) {\n    throw new Error(\"Can't get 2d context\");\n  }\n  const \
imageData = ctx.createImageData(width, height);\n  \
imageData.data.set(pixels);\n  ctx.putImageData(imageData, 0, 0);\n  return \
canvas.toDataURL(\"image/png\");\n}\nfunction cloneClock(clock) {\n  const \
newClock = new THREE.Clock(clock.autoStart);\n  newClock.startTime = \
clock.startTime;\n  newClock.oldTime = clock.oldTime;\n  newClock.elapsedTime \
= clock.elapsedTime;\n  newClock.running = clock.running;\n  return \
newClock;\n}\nfunction omitUndefined(obj) {\n  return Object.fromEntries(\n   \
 Object.entries(obj).filter(([_, value]) => value !== void 0)\n  );\n}\nconst \
IDENT_VERTEX_SHADER = unindent(`\n  precision highp float;\n\n  in vec3 \
position;\n\n  void main() {\n    gl_Position = vec4(position.xy, 0.0, \
1.0);\n  }\n`);\nfunction averagePositions(positions) {\n  const sum = new \
THREE.Vector3();\n  for (const position of positions) {\n    \
sum.add(position);\n  }\n  return \
sum.divideScalar(positions.length);\n}\nfunction \
averageQuaternions(quaternions) {\n  if (quaternions.length === 0) {\n    \
return new THREE.Quaternion();\n  }\n  const sum = quaternions[0].clone();\n  \
for (let i = 1; i < quaternions.length; i++) {\n    if \
(quaternions[i].dot(quaternions[0]) < 0) {\n      sum.x -= \
quaternions[i].x;\n      sum.y -= quaternions[i].y;\n      sum.z -= \
quaternions[i].z;\n      sum.w -= quaternions[i].w;\n    } else {\n      \
sum.x += quaternions[i].x;\n      sum.y += quaternions[i].y;\n      sum.z += \
quaternions[i].z;\n      sum.w += quaternions[i].w;\n    }\n  }\n  return \
sum.normalize();\n}\nfunction coinciDist(matrix1, matrix2) {\n  const origin1 \
= new THREE.Vector3(0, 0, 0).applyMatrix4(matrix1);\n  const origin2 = new \
THREE.Vector3(0, 0, 0).applyMatrix4(matrix2);\n  const direction1 = new \
THREE.Vector3(0, 0, -1).applyMatrix4(matrix1).sub(origin1).normalize();\n  \
const direction2 = new THREE.Vector3(0, 0, \
-1).applyMatrix4(matrix2).sub(origin2).normalize();\n  const distance2 = \
origin1.distanceTo(origin2);\n  const coincidence = \
direction1.dot(direction2);\n  return { distance: distance2, coincidence \
};\n}\nfunction withinDist({\n  matrix1,\n  matrix2,\n  maxDistance\n}) {\n  \
const origin1 = new THREE.Vector3(0, 0, 0).applyMatrix4(matrix1);\n  const \
origin2 = new THREE.Vector3(0, 0, 0).applyMatrix4(matrix2);\n  return \
origin1.distanceTo(origin2) <= maxDistance;\n}\nfunction withinCoinciDist({\n \
 matrix1,\n  matrix2,\n  maxDistance,\n  minCoincidence\n}) {\n  const { \
distance: distance2, coincidence } = coinciDist(matrix1, matrix2);\n  return \
distance2 <= maxDistance && (minCoincidence == null || coincidence >= \
minCoincidence);\n}\nfunction coorientDist(matrix1, matrix2) {\n  const \
[origin1, rotate1] = [new THREE.Vector3(), new THREE.Quaternion()];\n  const \
[origin2, rotate2] = [new THREE.Vector3(), new THREE.Quaternion()];\n  \
matrix1.decompose(origin1, rotate1, new THREE.Vector3());\n  \
matrix2.decompose(origin2, rotate2, new THREE.Vector3());\n  const distance2 \
= origin1.distanceTo(origin2);\n  const coorient = \
Math.abs(rotate1.dot(rotate2));\n  return { distance: distance2, coorient \
};\n}\nfunction withinCoorientDist({\n  matrix1,\n  matrix2,\n  \
maxDistance,\n  minCoorient\n}) {\n  const { distance: distance2, coorient } \
= coorientDist(matrix1, matrix2);\n  return distance2 <= maxDistance && \
(minCoorient == null || coorient >= minCoorient);\n}\nfunction \
epsilonSign(value, epsilon = 1e-3) {\n  if (Math.abs(value) < epsilon) {\n    \
return 0;\n  }\n  return Math.sign(value);\n}\nfunction encodeQuatXyz888(q) \
{\n  const negQuat = q.w < 0;\n  const iQuatX = floatToSint8(negQuat ? -q.x : \
q.x);\n  const iQuatY = floatToSint8(negQuat ? -q.y : q.y);\n  const iQuatZ = \
floatToSint8(negQuat ? -q.z : q.z);\n  const uQuatX = iQuatX & 255;\n  const \
uQuatY = iQuatY & 255;\n  const uQuatZ = iQuatZ & 255;\n  return uQuatX | \
uQuatY << 8 | uQuatZ << 16;\n}\nfunction decodeQuatXyz888(encoded, out) {\n  \
const iQuatX = encoded << 24 >> 24;\n  const iQuatY = encoded << 16 >> 24;\n  \
const iQuatZ = encoded << 8 >> 24;\n  out.set(iQuatX / 127, iQuatY / 127, \
iQuatZ / 127, 0);\n  const dotSelf = out.x * out.x + out.y * out.y + out.z * \
out.z;\n  out.w = Math.sqrt(Math.max(0, 1 - dotSelf));\n  return \
out;\n}\nconst tempNormalizedQuaternion = new THREE.Quaternion();\nconst \
tempAxis = new THREE.Vector3();\nfunction encodeQuatOctXy88R8(q) {\n  const \
qnorm = tempNormalizedQuaternion.copy(q).normalize();\n  if (qnorm.w < 0) {\n \
   qnorm.set(-qnorm.x, -qnorm.y, -qnorm.z, -qnorm.w);\n  }\n  const theta = 2 \
* Math.acos(qnorm.w);\n  const xyz_norm = Math.sqrt(\n    qnorm.x * qnorm.x + \
qnorm.y * qnorm.y + qnorm.z * qnorm.z\n  );\n  const axis = xyz_norm < 1e-6 ? \
tempAxis.set(1, 0, 0) : tempAxis.set(qnorm.x, qnorm.y, \
qnorm.z).divideScalar(xyz_norm);\n  const sum = Math.abs(axis.x) + \
Math.abs(axis.y) + Math.abs(axis.z);\n  let p_x = axis.x / sum;\n  let p_y = \
axis.y / sum;\n  if (axis.z < 0) {\n    const tmp = p_x;\n    p_x = (1 - \
Math.abs(p_y)) * (p_x >= 0 ? 1 : -1);\n    p_y = (1 - Math.abs(tmp)) * (p_y \
>= 0 ? 1 : -1);\n  }\n  const u_f = p_x * 0.5 + 0.5;\n  const v_f = p_y * 0.5 \
+ 0.5;\n  const quantU = Math.round(u_f * 255);\n  const quantV = \
Math.round(v_f * 255);\n  const angleInt = Math.round(theta * (255 / \
Math.PI));\n  return angleInt << 16 | quantV << 8 | quantU;\n}\nfunction \
decodeQuatOctXy88R8(encoded, out) {\n  const quantU = encoded & 255;\n  const \
quantV = encoded >>> 8 & 255;\n  const angleInt = encoded >>> 16 & 255;\n  \
const u_f = quantU / 255;\n  const v_f = quantV / 255;\n  let f_x = (u_f - \
0.5) * 2;\n  let f_y = (v_f - 0.5) * 2;\n  const f_z = 1 - (Math.abs(f_x) + \
Math.abs(f_y));\n  const t = Math.max(-f_z, 0);\n  f_x += f_x >= 0 ? -t : \
t;\n  f_y += f_y >= 0 ? -t : t;\n  const axis = tempAxis.set(f_x, f_y, \
f_z).normalize();\n  const theta = angleInt / 255 * Math.PI;\n  const \
halfTheta = theta * 0.5;\n  const s = Math.sin(halfTheta);\n  const w = \
Math.cos(halfTheta);\n  out.set(axis.x * s, axis.y * s, axis.z * s, w);\n  \
return out;\n}\nfunction encodeQuatEulerXyz888(q) {\n  const qNorm = \
q.clone().normalize();\n  const sinr_cosp = 2 * (qNorm.w * qNorm.x + qNorm.y \
* qNorm.z);\n  const cosr_cosp = 1 - 2 * (qNorm.x * qNorm.x + qNorm.y * \
qNorm.y);\n  const roll = Math.atan2(sinr_cosp, cosr_cosp);\n  const sinp = 2 \
* (qNorm.w * qNorm.y - qNorm.z * qNorm.x);\n  const pitch = Math.abs(sinp) >= \
1 ? Math.sign(sinp) * (Math.PI / 2) : Math.asin(sinp);\n  const siny_cosp = 2 \
* (qNorm.w * qNorm.z + qNorm.x * qNorm.y);\n  const cosy_cosp = 1 - 2 * \
(qNorm.y * qNorm.y + qNorm.z * qNorm.z);\n  const yaw = Math.atan2(siny_cosp, \
cosy_cosp);\n  const normRoll = (roll + Math.PI) / (2 * Math.PI);\n  const \
normPitch = (pitch + Math.PI) / (2 * Math.PI);\n  const normYaw = (yaw + \
Math.PI) / (2 * Math.PI);\n  const rollQ = Math.round(normRoll * 255);\n  \
const pitchQ = Math.round(normPitch * 255);\n  const yawQ = \
Math.round(normYaw * 255);\n  return yawQ << 16 | pitchQ << 8 | \
rollQ;\n}\nfunction decodeQuatEulerXyz888(encoded, out) {\n  const rollQ = \
encoded & 255;\n  const pitchQ = encoded >>> 8 & 255;\n  const yawQ = encoded \
>>> 16 & 255;\n  const normRoll = rollQ / 255;\n  const normPitch = pitchQ / \
255;\n  const normYaw = yawQ / 255;\n  const roll = normRoll * (2 * Math.PI) \
- Math.PI;\n  const pitch = normPitch * (2 * Math.PI) - Math.PI;\n  const yaw \
= normYaw * (2 * Math.PI) - Math.PI;\n  const cr = Math.cos(roll * 0.5);\n  \
const sr = Math.sin(roll * 0.5);\n  const cp = Math.cos(pitch * 0.5);\n  \
const sp = Math.sin(pitch * 0.5);\n  const cy = Math.cos(yaw * 0.5);\n  const \
sy = Math.sin(yaw * 0.5);\n  out.w = cr * cp * cy + sr * sp * sy;\n  out.x = \
sr * cp * cy - cr * sp * sy;\n  out.y = cr * sp * cy + sr * cp * sy;\n  out.z \
= cr * cp * sy - sr * sp * cy;\n  out.normalize();\n  return \
out;\n}\nfunction packSint8Bytes(b0, b1, b22, b3) {\n  const clampedB0 = \
Math.max(-127, Math.min(127, b0 * 127));\n  const clampedB1 = Math.max(-127, \
Math.min(127, b1 * 127));\n  const clampedB2 = Math.max(-127, Math.min(127, \
b22 * 127));\n  const clampedB3 = Math.max(-127, Math.min(127, b3 * 127));\n  \
return clampedB0 & 255 | (clampedB1 & 255) << 8 | (clampedB2 & 255) << 16 | \
(clampedB3 & 255) << 24;\n}\nfunction encodeSh1Rgb(sh1Array, index, sh1Rgb, \
encoding) {\n  const sh1Min = (encoding == null ? void 0 : encoding.sh1Min) \
?? -1;\n  const sh1Max = (encoding == null ? void 0 : encoding.sh1Max) ?? \
1;\n  const sh1Mid = 0.5 * (sh1Min + sh1Max);\n  const sh1Scale = 126 / \
(sh1Max - sh1Min);\n  const base = index * 2;\n  for (let i = 0; i < 9; ++i) \
{\n    const s = (sh1Rgb[i] - sh1Mid) * sh1Scale;\n    const value = \
Math.round(Math.max(-63, Math.min(63, s))) & 127;\n    const bitStart = i * \
7;\n    const bitEnd = bitStart + 7;\n    const wordStart = \
Math.floor(bitStart / 32);\n    const bitOffset = bitStart - wordStart * \
32;\n    const firstWord = value << bitOffset & 4294967295;\n    \
sh1Array[base + wordStart] |= firstWord;\n    if (bitEnd > wordStart * 32 + \
32) {\n      const secondWord = value >>> 32 - bitOffset & 4294967295;\n      \
sh1Array[base + wordStart + 1] |= secondWord;\n    }\n  }\n}\nfunction \
encodeSh2Rgb(sh2Array, index, sh2Rgb, encoding) {\n  const sh2Min = (encoding \
== null ? void 0 : encoding.sh2Min) ?? -1;\n  const sh2Max = (encoding == \
null ? void 0 : encoding.sh2Max) ?? 1;\n  const sh2Mid = 0.5 * (sh2Min + \
sh2Max);\n  const sh2Scale = 2 / (sh2Max - sh2Min);\n  sh2Array[index * 4 + \
0] = packSint8Bytes(\n    (sh2Rgb[0] - sh2Mid) * sh2Scale,\n    (sh2Rgb[1] - \
sh2Mid) * sh2Scale,\n    (sh2Rgb[2] - sh2Mid) * sh2Scale,\n    (sh2Rgb[3] - \
sh2Mid) * sh2Scale\n  );\n  sh2Array[index * 4 + 1] = packSint8Bytes(\n    \
(sh2Rgb[4] - sh2Mid) * sh2Scale,\n    (sh2Rgb[5] - sh2Mid) * sh2Scale,\n    \
(sh2Rgb[6] - sh2Mid) * sh2Scale,\n    (sh2Rgb[7] - sh2Mid) * sh2Scale\n  );\n \
 sh2Array[index * 4 + 2] = packSint8Bytes(\n    (sh2Rgb[8] - sh2Mid) * \
sh2Scale,\n    (sh2Rgb[9] - sh2Mid) * sh2Scale,\n    (sh2Rgb[10] - sh2Mid) * \
sh2Scale,\n    (sh2Rgb[11] - sh2Mid) * sh2Scale\n  );\n  sh2Array[index * 4 + \
3] = packSint8Bytes(\n    (sh2Rgb[12] - sh2Mid) * sh2Scale,\n    (sh2Rgb[13] \
- sh2Mid) * sh2Scale,\n    (sh2Rgb[14] - sh2Mid) * sh2Scale,\n    0\n  \
);\n}\nfunction encodeSh3Rgb(sh3Array, index, sh3Rgb, encoding) {\n  const \
sh3Min = (encoding == null ? void 0 : encoding.sh3Min) ?? -1;\n  const sh3Max \
= (encoding == null ? void 0 : encoding.sh3Max) ?? 1;\n  const sh3Mid = 0.5 * \
(sh3Min + sh3Max);\n  const sh3Scale = 62 / (sh3Max - sh3Min);\n  const base \
= index * 4;\n  for (let i = 0; i < 21; ++i) {\n    const s = (sh3Rgb[i] - \
sh3Mid) * sh3Scale;\n    const value = Math.round(Math.max(-31, Math.min(31, \
s))) & 63;\n    const bitStart = i * 6;\n    const bitEnd = bitStart + 6;\n   \
 const wordStart = Math.floor(bitStart / 32);\n    const bitOffset = bitStart \
- wordStart * 32;\n    const firstWord = value << bitOffset & 4294967295;\n   \
 sh3Array[base + wordStart] |= firstWord;\n    if (bitEnd > wordStart * 32 + \
32) {\n      const secondWord = value >>> 32 - bitOffset & 4294967295;\n      \
sh3Array[base + wordStart + 1] |= secondWord;\n    }\n  }\n}\nfunction \
decompressPartialGzip(fileBytes, numBytes) {\n  const chunks = [];\n  let \
totalBytes = 0;\n  let result = null;\n  const gunzip = new Gunzip((data, \
final) => {\n    chunks.push(data);\n    totalBytes += data.length;\n    if \
(final || totalBytes >= numBytes) {\n      const allBytes = new \
Uint8Array(totalBytes);\n      let offset2 = 0;\n      for (const chunk of \
chunks) {\n        allBytes.set(chunk, offset2);\n        offset2 += \
chunk.length;\n      }\n      result = allBytes.slice(0, numBytes);\n    }\n  \
});\n  const CHUNK_SIZE = 1024;\n  let offset = 0;\n  while (result == null \
&& offset < fileBytes.length) {\n    const chunk = fileBytes.slice(offset, \
offset + CHUNK_SIZE);\n    gunzip.push(chunk, false);\n    offset += \
CHUNK_SIZE;\n  }\n  if (result == null) {\n    gunzip.push(new Uint8Array(), \
true);\n    if (result == null) {\n      throw new Error(\"Failed to \
decompress partial gzip\");\n    }\n  }\n  return result;\n}\nclass \
GunzipReader {\n  constructor({\n    fileBytes,\n    chunkBytes = 64 * 1024\n \
 }) {\n    this.fileBytes = fileBytes;\n    this.chunkBytes = chunkBytes;\n   \
 this.chunks = [];\n    this.totalBytes = 0;\n    const ds = new \
DecompressionStream(\"gzip\");\n    const decompressionStream = new \
Blob([fileBytes]).stream().pipeThrough(ds);\n    this.reader = \
decompressionStream.getReader();\n  }\n  async read(numBytes) {\n    while \
(this.totalBytes < numBytes) {\n      const { value: chunk, done: readerDone \
} = await this.reader.read();\n      if (readerDone) {\n        break;\n      \
}\n      this.chunks.push(chunk);\n      this.totalBytes += chunk.length;\n   \
 }\n    if (this.totalBytes < numBytes) {\n      throw new Error(\n        \
`Unexpected EOF: needed ${numBytes}, got ${this.totalBytes}`\n      );\n    \
}\n    const allBytes = new Uint8Array(this.totalBytes);\n    let outOffset = \
0;\n    for (const chunk of this.chunks) {\n      allBytes.set(chunk, \
outOffset);\n      outOffset += chunk.length;\n    }\n    const result = \
allBytes.subarray(0, numBytes);\n    this.chunks = \
[allBytes.subarray(numBytes)];\n    this.totalBytes -= numBytes;\n    return \
result;\n  }\n}\nconst utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ \
Object.defineProperty({\n  __proto__: null,\n  DataCache,\n  FreeList,\n  \
GunzipReader,\n  IDENT_VERTEX_SHADER,\n  Sint8ToFloat,\n  Uint8ToFloat,\n  \
averagePositions,\n  averageQuaternions,\n  cloneClock,\n  coinciDist,\n  \
computeMaxSplats,\n  coorientDist,\n  decodeQuatEulerXyz888,\n  \
decodeQuatOctXy88R8,\n  decodeQuatXyz888,\n  decompressPartialGzip,\n  \
encodeQuatEulerXyz888,\n  encodeQuatOctXy88R8,\n  encodeQuatXyz888,\n  \
encodeSh1Rgb,\n  encodeSh2Rgb,\n  encodeSh3Rgb,\n  epsilonSign,\n  \
flipPixels,\n  floatBitsToUint: floatBitsToUint$1,\n  floatToSint8,\n  \
floatToUint8,\n  fromHalf,\n  getArrayBuffers,\n  getTextureSize,\n  \
isAndroid,\n  isMobile,\n  isOculus,\n  mapFilterObject,\n  mapObject,\n  \
newArray,\n  normalize: normalize$1,\n  omitUndefined,\n  pixelsToPngUrl,\n  \
setPackedSplat,\n  setPackedSplatCenter,\n  setPackedSplatOpacity,\n  \
setPackedSplatQuat,\n  setPackedSplatRgb,\n  setPackedSplatRgba,\n  \
setPackedSplatScales,\n  toHalf,\n  uintBitsToFloat: uintBitsToFloat$1,\n  \
unpackSplat,\n  withinCoinciDist,\n  withinCoorientDist,\n  withinDist\n}, \
Symbol.toStringTag, { value: \"Module\" }));\nclass DynoProgram {\n  \
constructor({\n    graph,\n    inputs,\n    outputs,\n    template\n  }) {\n  \
  this.graph = graph;\n    this.template = template;\n    this.inputs = \
inputs ?? {};\n    this.outputs = outputs ?? {};\n    const compile = new \
Compilation({ indent: this.template.indent });\n    for (const key in \
this.outputs) {\n      if (this.outputs[key]) {\n        \
compile.declares.add(this.outputs[key]);\n      }\n    }\n    const \
statements = graph.compile({\n      inputs: this.inputs,\n      outputs: \
this.outputs,\n      compile\n    });\n    this.shader = template.generate({ \
globals: compile.globals, statements });\n    this.uniforms = \
compile.uniforms;\n    this.updaters = compile.updaters;\n  }\n  \
prepareMaterial() {\n    return getMaterial(this);\n  }\n  update() {\n    \
for (const updater of this.updaters) {\n      updater();\n    }\n  \
}\n}\nclass DynoProgramTemplate {\n  constructor(template) {\n    const \
globals = template.match(/^([ \\t]*)\\{\\{\\s*GLOBALS\\s*\\}\\}/m);\n    \
const statements = template.match(/^([ \
\\t]*)\\{\\{\\s*STATEMENTS\\s*\\}\\}/m);\n    if (!globals || !statements) \
{\n      throw new Error(\n        \"Template must contain {{ GLOBALS }} and \
{{ STATEMENTS }}\"\n      );\n    }\n    this.before = template.substring(0, \
globals.index);\n    this.between = template.substring(\n      globals.index \
+ globals[0].length,\n      statements.index\n    );\n    this.after = \
template.substring(\n      statements.index + statements[0].length\n    );\n  \
  this.indent = statements[1];\n  }\n  generate({\n    globals,\n    \
statements\n  }) {\n    return this.before + \
Array.from(globals).join(\"\\n\\n\") + this.between + statements.map((s) => \
this.indent + s).join(\"\\n\") + this.after;\n  }\n}\nconst programMaterial = \
/* @__PURE__ */ new Map();\nfunction getMaterial(program) {\n  let material = \
programMaterial.get(program);\n  if (material) {\n    return material;\n  }\n \
 material = new THREE.RawShaderMaterial({\n    glslVersion: THREE.GLSL3,\n    \
vertexShader: IDENT_VERTEX_SHADER,\n    fragmentShader: program.shader,\n    \
uniforms: program.uniforms\n  });\n  programMaterial.set(program, \
material);\n  return material;\n}\nfunction addOutputType(a, b, operation = \
\"add\") {\n  const error = () => {\n    throw new Error(`Invalid \
${operation} types: ${a}, ${b}`);\n  };\n  if (a === b) return a;\n  if (a \
=== \"int\") {\n    if (isIntType(b)) return b;\n    error();\n  }\n  if (b \
=== \"int\") {\n    if (isIntType(a)) return a;\n    error();\n  }\n  if (a \
=== \"uint\") {\n    if (isUintType(b)) return b;\n    error();\n  }\n  if (b \
=== \"uint\") {\n    if (isUintType(a)) return a;\n    error();\n  }\n  if (a \
=== \"float\") {\n    if (isAllFloatType(b)) return b;\n    error();\n  }\n  \
if (b === \"float\") {\n    if (isAllFloatType(a)) return a;\n    error();\n  \
}\n  throw new Error(`Invalid ${operation} types: ${a}, ${b}`);\n}\nfunction \
subOutputType(a, b) {\n  return addOutputType(a, b, \"sub\");\n}\nfunction \
mulOutputType(a, b) {\n  const error = () => {\n    throw new Error(`Invalid \
mul types: ${a}, ${b}`);\n  };\n  const result = (value) => value;\n  if (a \
=== \"int\") {\n    if (isIntType(b)) return result(b);\n    error();\n  }\n  \
if (b === \"int\") {\n    if (isIntType(a)) return result(a);\n    error();\n \
 }\n  if (a === \"uint\") {\n    if (isUintType(b)) return result(b);\n    \
error();\n  }\n  if (b === \"uint\") {\n    if (isUintType(a)) return \
result(a);\n    error();\n  }\n  if (a === \"float\") {\n    if \
(isAllFloatType(b)) return result(b);\n    error();\n  }\n  if (b === \
\"float\") {\n    if (isAllFloatType(a)) return result(a);\n    error();\n  \
}\n  if (isIntType(a) || isUintType(a) || isIntType(b) || isUintType(b)) {\n  \
  if (a === b) return result(a);\n    error();\n  }\n  if (a === \"vec2\") \
{\n    if (b === \"vec2\" || isMat2(b)) return result(\"vec2\");\n    if (b \
=== \"mat3x2\") return result(\"vec3\");\n    if (b === \"mat4x2\") return \
result(\"vec4\");\n    error();\n  }\n  if (a === \"vec3\") {\n    if (b === \
\"mat2x3\") return result(\"vec2\");\n    if (b === \"vec3\" || isMat3(b)) \
return result(\"vec3\");\n    if (b === \"mat4x3\") return \
result(\"vec4\");\n    error();\n  }\n  if (a === \"vec4\") {\n    if (b === \
\"mat2x4\") return result(\"vec2\");\n    if (b === \"mat3x4\") return \
result(\"vec3\");\n    if (b === \"vec4\" || isMat4(b)) return \
result(\"vec4\");\n    error();\n  }\n  if (b === \"vec2\") {\n    if \
(isMat2(a)) return result(\"vec2\");\n    if (a === \"mat2x3\") return \
result(\"vec3\");\n    if (a === \"mat2x4\") return result(\"vec4\");\n    \
error();\n  }\n  if (b === \"vec3\") {\n    if (a === \"mat3x2\") return \
result(\"vec2\");\n    if (isMat3(a)) return result(\"vec3\");\n    if (a === \
\"mat3x4\") return result(\"vec4\");\n    error();\n  }\n  if (b === \
\"vec4\") {\n    if (a === \"mat4x2\") return result(\"vec2\");\n    if (a \
=== \"mat4x3\") return result(\"vec3\");\n    if (isMat4(a)) return \
result(\"vec4\");\n    error();\n  }\n  if (isMat2(a)) {\n    if (isMat2(b)) \
return result(\"mat2\");\n    if (b === \"mat3x2\") return \
result(\"mat3x2\");\n    if (b === \"mat4x2\") return result(\"mat4x2\");\n   \
 error();\n  }\n  if (a === \"mat2x3\") {\n    if (isMat2(b)) return \
result(\"mat2x3\");\n    if (b === \"mat3x2\") return result(\"mat3\");\n    \
if (b === \"mat4x2\") return result(\"mat4x3\");\n    error();\n  }\n  if (a \
=== \"mat2x4\") {\n    if (isMat2(b)) return result(\"mat2x4\");\n    if (b \
=== \"mat3x2\") return result(\"mat3x4\");\n    if (b === \"mat4x2\") return \
result(\"mat4\");\n    error();\n  }\n  if (a === \"mat3x2\") {\n    if (b \
=== \"mat2x3\") return result(\"mat2\");\n    if (isMat3(b)) return \
result(\"mat3x2\");\n    if (b === \"mat4x3\") return result(\"mat4x2\");\n   \
 error();\n  }\n  if (isMat3(a)) {\n    if (b === \"mat2x3\") return \
result(\"mat2x3\");\n    if (isMat3(b)) return result(\"mat3\");\n    if (b \
=== \"mat4x3\") return result(\"mat4x3\");\n    error();\n  }\n  if (a === \
\"mat3x4\") {\n    if (b === \"mat2x3\") return result(\"mat2x4\");\n    if \
(isMat3(b)) return result(\"mat3x4\");\n    if (b === \"mat4x3\") return \
result(\"mat4\");\n    error();\n  }\n  if (a === \"mat4x2\") {\n    if (b \
=== \"mat2x4\") return result(\"mat2\");\n    if (b === \"mat3x4\") return \
result(\"mat3x2\");\n    if (isMat4(b)) return result(\"mat4x2\");\n    \
error();\n  }\n  if (a === \"mat4x3\") {\n    if (b === \"mat2x4\") return \
result(\"mat2x3\");\n    if (b === \"mat3x4\") return result(\"mat3\");\n    \
if (isMat4(b)) return result(\"mat4x3\");\n    error();\n  }\n  if \
(isMat4(a)) {\n    if (b === \"mat2x4\") return result(\"mat2x4\");\n    if \
(b === \"mat3x4\") return result(\"mat3x4\");\n    if (isMat4(b)) return \
result(\"mat4\");\n    error();\n  }\n  throw new Error(`Invalid mul types: \
${a}, ${b}`);\n}\nfunction divOutputType(a, b) {\n  return addOutputType(a, \
b, \"div\");\n}\nfunction imodOutputType(a, b) {\n  if (a === b) return a;\n  \
if (a === \"int\") {\n    if (isIntType(b)) return b;\n  } else if (b === \
\"int\") {\n    if (isIntType(a)) return a;\n  } else if (a === \"uint\") {\n \
   if (isUintType(b)) return b;\n  } else if (b === \"uint\") {\n    if \
(isUintType(a)) return a;\n  }\n  throw new Error(`Invalid imod types: ${a}, \
${b}`);\n}\nfunction modOutputType(a, b) {\n  if (a === b || b === \"float\") \
return a;\n  throw new Error(`Invalid mod types: ${a}, ${b}`);\n}\nfunction \
modfOutputType(a) {\n  return a;\n}\nfunction negOutputType(a) {\n  return \
a;\n}\nfunction absOutputType(a) {\n  return a;\n}\nfunction \
signOutputType(a) {\n  return a;\n}\nfunction floorOutputType(a) {\n  return \
a;\n}\nfunction ceilOutputType(a) {\n  return a;\n}\nfunction \
truncOutputType(a) {\n  return a;\n}\nfunction roundOutputType(a) {\n  return \
a;\n}\nfunction fractOutputType(a) {\n  return a;\n}\nfunction \
powOutputType(a) {\n  return a;\n}\nfunction expOutputType(a) {\n  return \
a;\n}\nfunction exp2OutputType(a) {\n  return a;\n}\nfunction \
logOutputType(a) {\n  return a;\n}\nfunction log2OutputType(a) {\n  return \
a;\n}\nfunction sqrOutputType(a) {\n  return a;\n}\nfunction \
sqrtOutputType(a) {\n  return a;\n}\nfunction inversesqrtOutputType(a) {\n  \
return a;\n}\nfunction minOutputType(a, b, operation = \"min\") {\n  if (a \
=== b) return a;\n  if (b === \"float\") {\n    if (isFloatType(a)) return \
a;\n  } else if (b === \"int\") {\n    if (isIntType(a)) return a;\n  } else \
if (b === \"uint\") {\n    if (isUintType(a)) return a;\n  }\n  throw new \
Error(`Invalid ${operation} types: ${a}, ${b}`);\n}\nfunction \
maxOutputType(a, b) {\n  return minOutputType(a, b, \"max\");\n}\nfunction \
clampOutputType(a, b, _c) {\n  if (b === \"float\") {\n    if \
(isFloatType(a)) return a;\n  } else if (b === \"int\") {\n    if \
(isIntType(a)) return a;\n  } else if (b === \"uint\") {\n    if \
(isUintType(a)) return a;\n  }\n  throw new Error(`Invalid clamp types: ${a}, \
${b}`);\n}\nfunction mixOutputType(a, b, c) {\n  if (c === a) return a;\n  if \
(c === \"float\") return a;\n  if (c === \"bool\" && a === \"float\") return \
a;\n  if (c === \"bvec2\" && a === \"vec2\") return a;\n  if (c === \"bvec3\" \
&& a === \"vec3\") return a;\n  if (c === \"bvec4\" && a === \"vec4\") return \
a;\n  throw new Error(`Invalid mix types: ${a}, ${b}, ${c}`);\n}\nfunction \
stepOutputType(a, b) {\n  if (a === b || b === \"float\") return b;\n  throw \
new Error(`Invalid step types: ${a}, ${b}`);\n}\nfunction \
smoothstepOutputType(a, b, c) {\n  if (a === b) {\n    if (a === c || a === \
\"float\") return c;\n  }\n  throw new Error(`Invalid smoothstep types: ${a}, \
${b}, ${c}`);\n}\nfunction isNanOutputType(a, operation = \"isNan\") {\n  if \
(a === \"float\") return \"bool\";\n  if (a === \"vec2\") return \"bvec2\";\n \
 if (a === \"vec3\") return \"bvec3\";\n  if (a === \"vec4\") return \
\"bvec4\";\n  throw new Error(`Invalid ${operation} types: \
${a}`);\n}\nfunction isInfOutputType(a) {\n  return isNanOutputType(a, \
\"isInf\");\n}\nconst add = (a, b) => new Add({ a, b });\nconst sub = (a, b) \
=> new Sub({ a, b });\nconst mul = (a, b) => new Mul({ a, b });\nconst div = \
(a, b) => new Div({ a, b });\nconst imod = (a, b) => new IMod({ a, b \
});\nconst mod = (a, b) => new Mod({ a, b });\nconst modf = (a) => new Modf({ \
a }).outputs;\nconst neg = (a) => new Neg({ a });\nconst abs = (a) => new \
Abs({ a });\nconst sign = (a) => new Sign({ a });\nconst floor = (a) => new \
Floor({ a });\nconst ceil = (a) => new Ceil({ a });\nconst trunc = (a) => new \
Trunc({ a });\nconst round = (a) => new Round({ a });\nconst fract = (a) => \
new Fract({ a });\nconst pow = (a, b) => new Pow({ a, b });\nconst exp = (a) \
=> new Exp({ a });\nconst exp2 = (a) => new Exp2({ a });\nconst log = (a) => \
new Log({ a });\nconst log2 = (a) => new Log2({ a });\nconst sqr = (a) => new \
Sqr({ a });\nconst sqrt = (a) => new Sqrt({ a });\nconst inversesqrt = (a) => \
new InverseSqrt({ a });\nconst min = (a, b) => new Min({ a, b });\nconst max \
= (a, b) => new Max({ a, b });\nconst clamp = (a, min2, max2) => new Clamp({ \
a, min: min2, max: max2 });\nconst mix = (a, b, t) => new Mix({ a, b, t \
});\nconst step = (edge, x) => new Step({ edge, x });\nconst smoothstep = \
(edge0, edge1, x) => new Smoothstep({ edge0, edge1, x });\nconst isNan = (a) \
=> new IsNan({ a });\nconst isInf = (a) => new IsInf({ a });\nclass Add \
extends BinaryOp {\n  constructor({ a, b }) {\n    super({ a, b, outKey: \
\"sum\", outTypeFunc: addOutputType });\n    this.statements = ({ inputs, \
outputs }) => {\n      return [`${outputs.sum} = ${inputs.a} + \
${inputs.b};`];\n    };\n  }\n}\nclass Sub extends BinaryOp {\n  \
constructor({ a, b }) {\n    super({ a, b, outKey: \"difference\", \
outTypeFunc: subOutputType });\n    this.statements = ({ inputs, outputs }) \
=> {\n      return [`${outputs.difference} = ${inputs.a} - ${inputs.b};`];\n  \
  };\n  }\n}\nclass Mul extends BinaryOp {\n  constructor({ a, b }) {\n    \
super({ a, b, outKey: \"product\", outTypeFunc: mulOutputType });\n    \
this.statements = ({ inputs, outputs }) => {\n      return \
[`${outputs.product} = ${inputs.a} * ${inputs.b};`];\n    };\n  }\n}\nclass \
Div extends BinaryOp {\n  constructor({ a, b }) {\n    super({ a, b, outKey: \
\"quotient\", outTypeFunc: divOutputType });\n    this.statements = ({ \
inputs, outputs }) => {\n      return [`${outputs.quotient} = ${inputs.a} / \
${inputs.b};`];\n    };\n  }\n}\nclass IMod extends BinaryOp {\n  \
constructor({ a, b }) {\n    super({ a, b, outKey: \"remainder\", \
outTypeFunc: imodOutputType });\n    this.statements = ({ inputs, outputs }) \
=> {\n      return [`${outputs.remainder} = ${inputs.a} % ${inputs.b};`];\n   \
 };\n  }\n}\nclass Mod extends BinaryOp {\n  constructor({ a, b }) {\n    \
super({ a, b, outKey: \"remainder\", outTypeFunc: modOutputType });\n    \
this.statements = ({ inputs, outputs }) => {\n      return \
[`${outputs.remainder} = mod(${inputs.a}, ${inputs.b});`];\n    };\n  \
}\n}\nclass Modf extends Dyno {\n  constructor({ a }) {\n    const inTypes = \
{ a: valType(a) };\n    const outType = modfOutputType(inTypes.a);\n    const \
outTypes = {\n      fract: outType,\n      integer: outType\n    };\n    \
super({ inTypes, outTypes, inputs: { a } });\n    this.statements = ({ \
inputs, outputs }) => {\n      return [`${outputs.fract} = modf(${inputs.a}, \
${outputs.integer});`];\n    };\n  }\n}\nclass Neg extends UnaryOp {\n  \
constructor({ a }) {\n    super({ a, outKey: \"neg\", outTypeFunc: \
negOutputType });\n    this.statements = ({ inputs, outputs }) => {\n      \
return [`${outputs.neg} = -${inputs.a};`];\n    };\n  }\n}\nclass Abs extends \
UnaryOp {\n  constructor({ a }) {\n    super({ a, outKey: \"abs\", \
outTypeFunc: absOutputType });\n    this.statements = ({ inputs, outputs }) \
=> {\n      return [`${outputs.abs} = abs(${inputs.a});`];\n    };\n  \
}\n}\nclass Sign extends UnaryOp {\n  constructor({ a }) {\n    super({ a, \
outKey: \"sign\", outTypeFunc: signOutputType });\n    this.statements = ({ \
inputs, outputs }) => {\n      return [`${outputs.sign} = \
sign(${inputs.a});`];\n    };\n  }\n}\nclass Floor extends UnaryOp {\n  \
constructor({ a }) {\n    super({ a, outKey: \"floor\", outTypeFunc: \
floorOutputType });\n    this.statements = ({ inputs, outputs }) => {\n      \
return [`${outputs.floor} = floor(${inputs.a});`];\n    };\n  }\n}\nclass \
Ceil extends UnaryOp {\n  constructor({ a }) {\n    super({ a, outKey: \
\"ceil\", outTypeFunc: ceilOutputType });\n    this.statements = ({ inputs, \
outputs }) => {\n      return [`${outputs.ceil} = ceil(${inputs.a});`];\n    \
};\n  }\n}\nclass Trunc extends UnaryOp {\n  constructor({ a }) {\n    \
super({ a, outKey: \"trunc\", outTypeFunc: truncOutputType });\n    \
this.statements = ({ inputs, outputs }) => {\n      return [`${outputs.trunc} \
= trunc(${inputs.a});`];\n    };\n  }\n}\nclass Round extends UnaryOp {\n  \
constructor({ a }) {\n    super({ a, outKey: \"round\", outTypeFunc: \
roundOutputType });\n    this.statements = ({ inputs, outputs }) => {\n      \
return [`${outputs.round} = round(${inputs.a});`];\n    };\n  }\n}\nclass \
Fract extends UnaryOp {\n  constructor({ a }) {\n    super({ a, outKey: \
\"fract\", outTypeFunc: fractOutputType });\n    this.statements = ({ inputs, \
outputs }) => {\n      return [`${outputs.fract} = fract(${inputs.a});`];\n   \
 };\n  }\n}\nclass Pow extends BinaryOp {\n  constructor({ a, b }) {\n    \
super({ a, b, outKey: \"power\", outTypeFunc: powOutputType });\n    \
this.statements = ({ inputs, outputs }) => {\n      return [`${outputs.power} \
= pow(${inputs.a}, ${inputs.b});`];\n    };\n  }\n}\nclass Exp extends \
UnaryOp {\n  constructor({ a }) {\n    super({ a, outKey: \"exp\", \
outTypeFunc: expOutputType });\n    this.statements = ({ inputs, outputs }) \
=> {\n      return [`${outputs.exp} = exp(${inputs.a});`];\n    };\n  \
}\n}\nclass Exp2 extends UnaryOp {\n  constructor({ a }) {\n    super({ a, \
outKey: \"exp2\", outTypeFunc: exp2OutputType });\n    this.statements = ({ \
inputs, outputs }) => {\n      return [`${outputs.exp2} = \
exp2(${inputs.a});`];\n    };\n  }\n}\nclass Log extends UnaryOp {\n  \
constructor({ a }) {\n    super({ a, outKey: \"log\", outTypeFunc: \
logOutputType });\n    this.statements = ({ inputs, outputs }) => {\n      \
return [`${outputs.log} = log(${inputs.a});`];\n    };\n  }\n}\nclass Log2 \
extends UnaryOp {\n  constructor({ a }) {\n    super({ a, outKey: \"log2\", \
outTypeFunc: log2OutputType });\n    this.statements = ({ inputs, outputs }) \
=> {\n      return [`${outputs.log2} = log2(${inputs.a});`];\n    };\n  \
}\n}\nclass Sqr extends UnaryOp {\n  constructor({ a }) {\n    super({ a, \
outKey: \"sqr\", outTypeFunc: sqrOutputType });\n    this.statements = ({ \
inputs, outputs }) => {\n      return [`${outputs.sqr} = ${inputs.a} * \
${inputs.a};`];\n    };\n  }\n}\nclass Sqrt extends UnaryOp {\n  \
constructor({ a }) {\n    super({ a, outKey: \"sqrt\", outTypeFunc: \
sqrtOutputType });\n    this.statements = ({ inputs, outputs }) => {\n      \
return [`${outputs.sqrt} = sqrt(${inputs.a});`];\n    };\n  }\n}\nclass \
InverseSqrt extends UnaryOp {\n  constructor({ a }) {\n    super({ a, outKey: \
\"inversesqrt\", outTypeFunc: inversesqrtOutputType });\n    this.statements \
= ({ inputs, outputs }) => {\n      return [`${outputs.inversesqrt} = \
inversesqrt(${inputs.a});`];\n    };\n  }\n}\nclass Min extends BinaryOp {\n  \
constructor({ a, b }) {\n    super({ a, b, outKey: \"min\", outTypeFunc: \
minOutputType });\n    this.statements = ({ inputs, outputs }) => {\n      \
return [`${outputs.min} = min(${inputs.a}, ${inputs.b});`];\n    };\n  \
}\n}\nclass Max extends BinaryOp {\n  constructor({ a, b }) {\n    super({ a, \
b, outKey: \"max\", outTypeFunc: maxOutputType });\n    this.statements = ({ \
inputs, outputs }) => {\n      return [`${outputs.max} = max(${inputs.a}, \
${inputs.b});`];\n    };\n  }\n}\nclass Clamp extends TrinaryOp {\n  \
constructor({\n    a,\n    min: min2,\n    max: max2\n  }) {\n    super({\n   \
   a,\n      b: min2,\n      c: max2,\n      outKey: \"clamp\",\n      \
outTypeFunc: clampOutputType\n    });\n    this.statements = ({ inputs, \
outputs }) => {\n      const { a: a2, b: min3, c: max3 } = inputs;\n      \
return [`${outputs.clamp} = clamp(${a2}, ${min3}, ${max3});`];\n    };\n  \
}\n}\nclass Mix extends TrinaryOp {\n  constructor({ a, b, t }) {\n    \
super({ a, b, c: t, outKey: \"mix\", outTypeFunc: mixOutputType });\n    \
this.statements = ({ inputs, outputs }) => {\n      const { a: a2, b: b22, c: \
t2 } = inputs;\n      return [`${outputs.mix} = mix(${a2}, ${b22}, \
${t2});`];\n    };\n  }\n}\nclass Step extends BinaryOp {\n  constructor({ \
edge, x }) {\n    super({\n      a: edge,\n      b: x,\n      outKey: \
\"step\",\n      outTypeFunc: stepOutputType\n    });\n    this.statements = \
({ inputs, outputs }) => {\n      const { a: edge2, b: x2 } = inputs;\n      \
return [`${outputs.step} = step(${edge2}, ${x2});`];\n    };\n  }\n}\nclass \
Smoothstep extends TrinaryOp {\n  constructor({\n    edge0,\n    edge1,\n    \
x\n  }) {\n    super({\n      a: edge0,\n      b: edge1,\n      c: x,\n      \
outKey: \"smoothstep\",\n      outTypeFunc: smoothstepOutputType\n    });\n   \
 this.statements = ({ inputs, outputs }) => {\n      const { a: edge02, b: \
edge12, c: x2 } = inputs;\n      return [`${outputs.smoothstep} = \
smoothstep(${edge02}, ${edge12}, ${x2});`];\n    };\n  }\n}\nclass IsNan \
extends UnaryOp {\n  constructor({ a }) {\n    super({ a, outKey: \"isNan\", \
outTypeFunc: isNanOutputType });\n    this.statements = ({ inputs, outputs }) \
=> {\n      return [`${outputs.isNan} = isNan(${inputs.a});`];\n    };\n  \
}\n}\nclass IsInf extends UnaryOp {\n  constructor({ a }) {\n    super({ a, \
outKey: \"isInf\", outTypeFunc: isInfOutputType });\n    this.statements = ({ \
inputs, outputs }) => {\n      return [`${outputs.isInf} = \
isInf(${inputs.a});`];\n    };\n  }\n}\nconst and = (a, b) => new And({ a, b \
});\nconst or = (a, b) => new Or({ a, b });\nconst xor = (a, b) => new Xor({ \
a, b });\nconst not = (a) => new Not({ a });\nconst lessThan = (a, b) => new \
LessThan({ a, b });\nconst lessThanEqual = (a, b) => new LessThanEqual({ a, b \
});\nconst greaterThan = (a, b) => new GreaterThan({ a, b });\nconst \
greaterThanEqual = (a, b) => new GreaterThanEqual({ a, b });\nconst equal = \
(a, b) => new Equal({ a, b });\nconst notEqual = (a, b) => new NotEqual({ a, \
b });\nconst any = (a) => new Any({ a });\nconst all = (a) => new All({ a \
});\nconst select = (cond, t, f) => new Select({ cond, t, f });\nconst \
compXor = (a) => new CompXor({ a });\nclass And extends BinaryOp {\n  \
constructor({ a, b }) {\n    super({ a, b, outTypeFunc: (aType, bType) => \
aType, outKey: \"and\" });\n    this.statements = ({ inputs, outputs }) => \
{\n      if (this.outTypes.and === \"bool\") {\n        return \
[`${outputs.and} = ${inputs.a} && ${inputs.b};`];\n      }\n      return \
[`${outputs.and} = ${inputs.a} & ${inputs.b};`];\n    };\n  }\n}\nclass Or \
extends BinaryOp {\n  constructor({ a, b }) {\n    super({ a, b, outTypeFunc: \
(aType, bType) => aType, outKey: \"or\" });\n    this.statements = ({ inputs, \
outputs }) => {\n      if (this.outTypes.or === \"bool\") {\n        return \
[`${outputs.or} = ${inputs.a} || ${inputs.b};`];\n      }\n      return \
[`${outputs.or} = ${inputs.a} | ${inputs.b};`];\n    };\n  }\n}\nclass Xor \
extends BinaryOp {\n  constructor({ a, b }) {\n    super({ a, b, outTypeFunc: \
(aType, bType) => aType, outKey: \"xor\" });\n    this.statements = ({ \
inputs, outputs }) => {\n      if (this.outTypes.xor === \"bool\") {\n        \
return [`${outputs.xor} = ${inputs.a} ^^ ${inputs.b};`];\n      }\n      \
return [`${outputs.xor} = ${inputs.a} ^ ${inputs.b};`];\n    };\n  \
}\n}\nclass Not extends UnaryOp {\n  constructor({ a }) {\n    super({ a, \
outTypeFunc: (aType) => aType, outKey: \"not\" });\n    this.statements = ({ \
inputs, outputs }) => {\n      if (this.outTypes.not === \"bool\") {\n        \
return [`${outputs.not} = !${inputs.a};`];\n      }\n      return \
[`${outputs.not} = not(${inputs.a});`];\n    };\n  }\n}\nclass LessThan \
extends BinaryOp {\n  constructor({ a, b }) {\n    super({\n      a,\n      \
b,\n      outTypeFunc: (aType, bType) => compareOutputType(aType, \
\"lessThan\"),\n      outKey: \"lessThan\"\n    });\n    this.statements = ({ \
inputs, outputs }) => {\n      if (this.outTypes.lessThan === \"bool\") {\n   \
     return [`${outputs.lessThan} = ${inputs.a} < ${inputs.b};`];\n      }\n  \
    return [`${outputs.lessThan} = lessThan(${inputs.a}, ${inputs.b});`];\n   \
 };\n  }\n}\nclass LessThanEqual extends BinaryOp {\n  constructor({ a, b }) \
{\n    super({\n      a,\n      b,\n      outTypeFunc: (aType, bType) => \
compareOutputType(aType, \"lessThanEqual\"),\n      outKey: \
\"lessThanEqual\"\n    });\n    this.statements = ({ inputs, outputs }) => \
{\n      if (this.outTypes.lessThanEqual === \"bool\") {\n        return \
[`${outputs.lessThanEqual} = ${inputs.a} <= ${inputs.b};`];\n      }\n      \
return [\n        `${outputs.lessThanEqual} = lessThanEqual(${inputs.a}, \
${inputs.b});`\n      ];\n    };\n  }\n}\nclass GreaterThan extends BinaryOp \
{\n  constructor({ a, b }) {\n    super({\n      a,\n      b,\n      \
outTypeFunc: (aType, bType) => compareOutputType(aType, \"greaterThan\"),\n   \
   outKey: \"greaterThan\"\n    });\n    this.statements = ({ inputs, outputs \
}) => {\n      if (this.outTypes.greaterThan === \"bool\") {\n        return \
[`${outputs.greaterThan} = ${inputs.a} > ${inputs.b};`];\n      }\n      \
return [\n        `${outputs.greaterThan} = greaterThan(${inputs.a}, \
${inputs.b});`\n      ];\n    };\n  }\n}\nclass GreaterThanEqual extends \
BinaryOp {\n  constructor({ a, b }) {\n    super({\n      a,\n      b,\n      \
outTypeFunc: (aType, bType) => compareOutputType(aType, \
\"greaterThanEqual\"),\n      outKey: \"greaterThanEqual\"\n    });\n    \
this.statements = ({ inputs, outputs }) => {\n      if \
(this.outTypes.greaterThanEqual === \"bool\") {\n        return \
[`${outputs.greaterThanEqual} = ${inputs.a} >= ${inputs.b};`];\n      }\n     \
 return [\n        `${outputs.greaterThanEqual} = \
greaterThanEqual(${inputs.a}, ${inputs.b});`\n      ];\n    };\n  }\n}\nclass \
Equal extends BinaryOp {\n  constructor({ a, b }) {\n    super({ a, b, \
outTypeFunc: equalOutputType, outKey: \"equal\" });\n    this.statements = ({ \
inputs, outputs }) => {\n      if (this.outTypes.equal === \"bool\") {\n      \
  return [`${outputs.equal} = ${inputs.a} == ${inputs.b};`];\n      }\n      \
return [`${outputs.equal} = equal(${inputs.a}, ${inputs.b});`];\n    };\n  \
}\n}\nclass NotEqual extends BinaryOp {\n  constructor({ a, b }) {\n    \
super({ a, b, outTypeFunc: notEqualOutputType, outKey: \"notEqual\" });\n    \
this.statements = ({ inputs, outputs }) => {\n      if \
(this.outTypes.notEqual === \"bool\") {\n        return [`${outputs.notEqual} \
= ${inputs.a} != ${inputs.b};`];\n      }\n      return [`${outputs.notEqual} \
= notEqual(${inputs.a}, ${inputs.b});`];\n    };\n  }\n}\nclass Any extends \
UnaryOp {\n  constructor({ a }) {\n    super({ a, outTypeFunc: (aType) => \
\"bool\", outKey: \"any\" });\n    this.statements = ({ inputs, outputs }) => \
{\n      return [`${outputs.any} = any(${inputs.a});`];\n    };\n  \
}\n}\nclass All extends UnaryOp {\n  constructor({ a }) {\n    super({ a, \
outTypeFunc: (aType) => \"bool\", outKey: \"all\" });\n    this.statements = \
({ inputs, outputs }) => {\n      return [`${outputs.all} = \
all(${inputs.a});`];\n    };\n  }\n}\nclass Select extends TrinaryOp {\n  \
constructor({\n    cond,\n    t,\n    f\n  }) {\n    super({\n      a: \
cond,\n      b: t,\n      c: f,\n      outKey: \"select\",\n      \
outTypeFunc: (aType, bType, cType) => bType\n    });\n    this.statements = \
({ inputs, outputs }) => {\n      const { a: cond2, b: t2, c: f2 } = \
inputs;\n      return [`${outputs.select} = (${cond2}) ? (${t2}) : \
(${f2});`];\n    };\n  }\n}\nfunction compareOutputType(type, operator) {\n  \
if (isScalarType(type)) {\n    return \"bool\";\n  }\n  if (type === \
\"ivec2\" || type === \"uvec2\" || type === \"vec2\") {\n    return \
\"bvec2\";\n  }\n  if (type === \"ivec3\" || type === \"uvec3\" || type === \
\"vec3\") {\n    return \"bvec3\";\n  }\n  if (type === \"ivec4\" || type === \
\"uvec4\" || type === \"vec4\") {\n    return \"bvec4\";\n  }\n  throw new \
Error(`Invalid ${operator} type: ${type}`);\n}\nfunction \
equalOutputType(type, operator = \"equal\") {\n  if (isScalarType(type)) {\n  \
  return \"bool\";\n  }\n  if (isBoolType(type)) {\n    return type;\n  }\n  \
if (type === \"ivec2\" || type === \"uvec2\" || type === \"vec2\") {\n    \
return \"bvec2\";\n  }\n  if (type === \"ivec3\" || type === \"uvec3\" || \
type === \"vec3\") {\n    return \"bvec3\";\n  }\n  if (type === \"ivec4\" || \
type === \"uvec4\" || type === \"vec4\") {\n    return \"bvec4\";\n  }\n  \
throw new Error(`Invalid ${operator} type: ${type}`);\n}\nfunction \
notEqualOutputType(type) {\n  return equalOutputType(type, \
\"notEqual\");\n}\nfunction compXorOutputType(type) {\n  if \
(isBoolType(type)) {\n    return \"bool\";\n  }\n  if (isIntType(type)) {\n   \
 return \"int\";\n  }\n  if (isUintType(type)) {\n    return \"uint\";\n  }\n \
 throw new Error(`Invalid compXor type: ${type}`);\n}\nclass CompXor extends \
UnaryOp {\n  constructor({ a }) {\n    const outType = \
compXorOutputType(valType(a));\n    super({ a, outTypeFunc: (aType) => \
outType, outKey: \"compXor\" });\n    this.statements = ({ inputs, outputs }) \
=> {\n      if (isScalarType(this.outTypes.compXor)) {\n        return \
[`${outputs.compXor} = ${inputs.a};`];\n      }\n      const components = \
isVector2Type(outType) ? [\"x\", \"y\"] : isVector3Type(outType) ? [\"x\", \
\"y\", \"z\"] : [\"x\", \"y\", \"z\", \"w\"];\n      const operands = \
components.map((c) => `${inputs.a}.${c}`);\n      const operator = \
isBoolType(outType) ? \"^^\" : \"^\";\n      return [`${outputs.compXor} = \
${operands.join(` ${operator} `)};`];\n    };\n  }\n}\nconst bool = (value) \
=> new Bool({ value });\nconst int = (value) => new Int({ value });\nconst \
uint = (value) => new Uint({ value });\nconst float = (value) => new Float({ \
value });\nconst bvec2 = (value) => new BVec2({ value });\nconst bvec3 = \
(value) => new BVec3({ value });\nconst bvec4 = (value) => new BVec4({ value \
});\nconst ivec2 = (value) => new IVec2({ value });\nconst ivec3 = (value) => \
new IVec3({ value });\nconst ivec4 = (value) => new IVec4({ value });\nconst \
uvec2 = (value) => new UVec2({ value });\nconst uvec3 = (value) => new \
UVec3({ value });\nconst uvec4 = (value) => new UVec4({ value });\nconst vec2 \
= (value) => new Vec2({ value });\nconst vec3 = (value) => new Vec3({ value \
});\nconst vec4 = (value) => new Vec4({ value });\nconst mat2 = (value) => \
new Mat2({ value });\nconst mat3 = (value) => new Mat3({ value });\nconst \
mat4 = (value) => new Mat4({ value });\nconst floatBitsToInt = (value) => new \
FloatBitsToInt({ value });\nconst floatBitsToUint = (value) => new \
FloatBitsToUint({ value });\nconst intBitsToFloat = (value) => new \
IntBitsToFloat({ value });\nconst uintBitsToFloat = (value) => new \
UintBitsToFloat({ value });\nconst packSnorm2x16 = (value) => new \
PackSnorm2x16({ value });\nconst unpackSnorm2x16 = (value) => new \
UnpackSnorm2x16({ value });\nconst packUnorm2x16 = (value) => new \
PackUnorm2x16({ value });\nconst unpackUnorm2x16 = (value) => new \
UnpackUnorm2x16({ value });\nconst packHalf2x16 = (value) => new \
PackHalf2x16({ value });\nconst unpackHalf2x16 = (value) => new \
UnpackHalf2x16({ value });\nconst uintToRgba8 = (value) => new UintToRgba8({ \
value });\nclass SimpleCast extends UnaryOp {\n  constructor({\n    value,\n  \
  outType,\n    outKey\n  }) {\n    super({ a: value, outTypeFunc: () => \
outType, outKey });\n    this.statements = ({ inputs, outputs }) => [\n      \
`${outputs[outKey]} = ${typeLiteral(outType)}(${inputs.a});`\n    ];\n  \
}\n}\nclass Bool extends SimpleCast {\n  constructor({\n    value\n  }) {\n   \
 super({ value, outType: \"bool\", outKey: \"bool\" });\n  }\n}\nclass Int \
extends SimpleCast {\n  constructor({\n    value\n  }) {\n    super({ value, \
outType: \"int\", outKey: \"int\" });\n  }\n}\nclass Uint extends SimpleCast \
{\n  constructor({\n    value\n  }) {\n    super({ value, outType: \"uint\", \
outKey: \"uint\" });\n  }\n}\nclass Float extends SimpleCast {\n  \
constructor({\n    value\n  }) {\n    super({ value, outType: \"float\", \
outKey: \"float\" });\n  }\n}\nclass BVec2 extends SimpleCast {\n  \
constructor({\n    value\n  }) {\n    super({ value, outType: \"bvec2\", \
outKey: \"bvec2\" });\n  }\n}\nclass BVec3 extends SimpleCast {\n  \
constructor({\n    value\n  }) {\n    super({ value, outType: \"bvec3\", \
outKey: \"bvec3\" });\n  }\n}\nclass BVec4 extends SimpleCast {\n  \
constructor({\n    value\n  }) {\n    super({ value, outType: \"bvec4\", \
outKey: \"bvec4\" });\n  }\n}\nclass IVec2 extends SimpleCast {\n  \
constructor({\n    value\n  }) {\n    super({ value, outType: \"ivec2\", \
outKey: \"ivec2\" });\n  }\n}\nclass IVec3 extends SimpleCast {\n  \
constructor({\n    value\n  }) {\n    super({ value, outType: \"ivec3\", \
outKey: \"ivec3\" });\n  }\n}\nclass IVec4 extends SimpleCast {\n  \
constructor({\n    value\n  }) {\n    super({ value, outType: \"ivec4\", \
outKey: \"ivec4\" });\n  }\n}\nclass UVec2 extends SimpleCast {\n  \
constructor({\n    value\n  }) {\n    super({ value, outType: \"uvec2\", \
outKey: \"uvec2\" });\n  }\n}\nclass UVec3 extends SimpleCast {\n  \
constructor({\n    value\n  }) {\n    super({ value, outType: \"uvec3\", \
outKey: \"uvec3\" });\n  }\n}\nclass UVec4 extends SimpleCast {\n  \
constructor({\n    value\n  }) {\n    super({ value, outType: \"uvec4\", \
outKey: \"uvec4\" });\n  }\n}\nclass Vec2 extends SimpleCast {\n  \
constructor({\n    value\n  }) {\n    super({ value, outType: \"vec2\", \
outKey: \"vec2\" });\n  }\n}\nclass Vec3 extends SimpleCast {\n  \
constructor({\n    value\n  }) {\n    super({ value, outType: \"vec3\", \
outKey: \"vec3\" });\n  }\n}\nclass Vec4 extends SimpleCast {\n  \
constructor({\n    value\n  }) {\n    super({ value, outType: \"vec4\", \
outKey: \"vec4\" });\n  }\n}\nclass Mat2 extends SimpleCast {\n  \
constructor({\n    value\n  }) {\n    super({ value, outType: \"mat2\", \
outKey: \"mat2\" });\n  }\n}\nclass Mat3 extends SimpleCast {\n  \
constructor({\n    value\n  }) {\n    super({ value, outType: \"mat3\", \
outKey: \"mat3\" });\n  }\n}\nclass Mat4 extends SimpleCast {\n  \
constructor({\n    value\n  }) {\n    super({ value, outType: \"mat4\", \
outKey: \"mat4\" });\n  }\n}\nclass FloatBitsToInt extends UnaryOp {\n  \
constructor({ value }) {\n    super({ a: value, outKey: \"int\", outTypeFunc: \
() => \"int\" });\n    this.statements = ({ inputs, outputs }) => {\n      \
return [`${outputs.int} = floatBitsToInt(${inputs.a});`];\n    };\n  \
}\n}\nclass FloatBitsToUint extends UnaryOp {\n  constructor({ value }) {\n   \
 super({ a: value, outKey: \"uint\", outTypeFunc: () => \"uint\" });\n    \
this.statements = ({ inputs, outputs }) => {\n      return [`${outputs.uint} \
= floatBitsToUint(${inputs.a});`];\n    };\n  }\n}\nclass IntBitsToFloat \
extends UnaryOp {\n  constructor({ value }) {\n    super({ a: value, outKey: \
\"float\", outTypeFunc: () => \"float\" });\n    this.statements = ({ inputs, \
outputs }) => {\n      return [`${outputs.float} = \
intBitsToFloat(${inputs.a});`];\n    };\n  }\n}\nclass UintBitsToFloat \
extends UnaryOp {\n  constructor({ value }) {\n    super({ a: value, outKey: \
\"float\", outTypeFunc: () => \"float\" });\n    this.statements = ({ inputs, \
outputs }) => {\n      return [`${outputs.float} = \
uintBitsToFloat(${inputs.a});`];\n    };\n  }\n}\nclass PackSnorm2x16 extends \
UnaryOp {\n  constructor({ value }) {\n    super({ a: value, outKey: \
\"uint\", outTypeFunc: () => \"uint\" });\n    this.statements = ({ inputs, \
outputs }) => {\n      return [`${outputs.uint} = \
packSnorm2x16(${inputs.a});`];\n    };\n  }\n}\nclass UnpackSnorm2x16 extends \
UnaryOp {\n  constructor({ value }) {\n    super({ a: value, outKey: \
\"vec2\", outTypeFunc: () => \"vec2\" });\n    this.statements = ({ inputs, \
outputs }) => {\n      return [`${outputs.vec2} = \
unpackSnorm2x16(${inputs.a});`];\n    };\n  }\n}\nclass PackUnorm2x16 extends \
UnaryOp {\n  constructor({ value }) {\n    super({ a: value, outKey: \
\"uint\", outTypeFunc: () => \"uint\" });\n    this.statements = ({ inputs, \
outputs }) => {\n      return [`${outputs.uint} = \
packUnorm2x16(${inputs.a});`];\n    };\n  }\n}\nclass UnpackUnorm2x16 extends \
UnaryOp {\n  constructor({ value }) {\n    super({ a: value, outKey: \
\"vec2\", outTypeFunc: () => \"vec2\" });\n    this.statements = ({ inputs, \
outputs }) => {\n      return [`${outputs.vec2} = \
unpackUnorm2x16(${inputs.a});`];\n    };\n  }\n}\nclass PackHalf2x16 extends \
UnaryOp {\n  constructor({ value }) {\n    super({ a: value, outKey: \
\"uint\", outTypeFunc: () => \"uint\" });\n    this.statements = ({ inputs, \
outputs }) => {\n      return [`${outputs.uint} = \
packHalf2x16(${inputs.a});`];\n    };\n  }\n}\nclass UnpackHalf2x16 extends \
UnaryOp {\n  constructor({ value }) {\n    super({ a: value, outKey: \
\"vec2\", outTypeFunc: () => \"vec2\" });\n    this.statements = ({ inputs, \
outputs }) => {\n      return [`${outputs.vec2} = \
unpackHalf2x16(${inputs.a});`];\n    };\n  }\n}\nclass UintToRgba8 extends \
UnaryOp {\n  constructor({ value }) {\n    super({ a: value, outKey: \
\"rgba8\", outTypeFunc: () => \"vec4\" });\n    this.statements = ({ inputs, \
outputs }) => {\n      return [\n        `uvec4 uRgba = uvec4(${inputs.a} & \
0xffu, (${inputs.a} >> 8u) & 0xffu, (${inputs.a} >> 16u) & 0xffu, \
(${inputs.a} >> 24u) & 0xffu);`,\n        `${outputs.rgba8} = vec4(uRgba) / \
255.0;`\n      ];\n    };\n  }\n}\nconst length = (a) => new Length({ a \
});\nconst distance = (a, b) => new Distance({ a, b });\nconst dot = (a, b) \
=> new Dot({ a, b });\nconst cross = (a, b) => new Cross({ a, b });\nconst \
normalize = (a) => new Normalize({ a });\nconst faceforward = (a, b, c) => \
new FaceForward({ a, b, c });\nconst reflectVec = (incident, normal) => new \
ReflectVec({ incident, normal });\nconst refractVec = (incident, normal, eta) \
=> new RefractVec({ incident, normal, eta });\nconst split = (vector) => new \
Split({ vector });\nconst combine = ({\n  vector,\n  vectorType,\n  x,\n  \
y,\n  z,\n  w,\n  r,\n  g,\n  b,\n  a\n}) => new Combine({ vector, \
vectorType, x, y, z, w, r, g, b, a });\nconst projectH = (a) => new \
ProjectH({ a });\nconst extendVec = (a, b) => new ExtendVec({ a, b });\nconst \
swizzle = (a, select2) => new Swizzle({ vector: a, select: select2 });\nconst \
compMult = (a, b) => new CompMult({ a, b });\nconst outer = (a, b) => new \
Outer({ a, b });\nconst transpose = (a) => new Transpose({ a });\nconst \
determinant = (a) => new Determinant({ a });\nconst inverse = (a) => new \
Inverse({ a });\nclass Length extends UnaryOp {\n  constructor({ a }) {\n    \
super({ a, outTypeFunc: (aType) => \"float\", outKey: \"length\" });\n    \
this.statements = ({ inputs, outputs }) => [\n      `${outputs.length} = \
length(${inputs.a});`\n    ];\n  }\n}\nclass Distance extends BinaryOp {\n  \
constructor({ a, b }) {\n    super({ a, b, outKey: \"distance\", outTypeFunc: \
(aType, bType) => \"float\" });\n    this.statements = ({ inputs, outputs }) \
=> [\n      `${outputs.distance} = distance(${inputs.a}, ${inputs.b});`\n    \
];\n  }\n}\nclass Dot extends BinaryOp {\n  constructor({ a, b }) {\n    \
super({ a, b, outKey: \"dot\", outTypeFunc: (aType, bType) => \"float\" });\n \
   this.statements = ({ inputs, outputs }) => [\n      `${outputs.dot} = \
dot(${inputs.a}, ${inputs.b});`\n    ];\n  }\n}\nclass Cross extends BinaryOp \
{\n  constructor({ a, b }) {\n    super({ a, b, outKey: \"cross\", \
outTypeFunc: (aType, bType) => \"vec3\" });\n    this.statements = ({ inputs, \
outputs }) => [\n      `${outputs.cross} = cross(${inputs.a}, \
${inputs.b});`\n    ];\n  }\n}\nclass Normalize extends UnaryOp {\n  \
constructor({ a }) {\n    super({ a, outTypeFunc: (aType) => aType, outKey: \
\"normalize\" });\n    this.statements = ({ inputs, outputs }) => [\n      \
`${outputs.normalize} = normalize(${inputs.a});`\n    ];\n  }\n}\nfunction \
projectHOutputType(type) {\n  if (type === \"vec3\") {\n    return \
\"vec2\";\n  }\n  if (type === \"vec4\") {\n    return \"vec3\";\n  }\n  \
throw new Error(\"Invalid type\");\n}\nclass ProjectH extends UnaryOp {\n  \
constructor({ a }) {\n    super({\n      a,\n      outTypeFunc: (aType) => \
projectHOutputType(aType),\n      outKey: \"projected\"\n    });\n    \
this.statements = ({ inputs, outputs }) => {\n      if (this.inTypes.a === \
\"vec3\") {\n        return [`${outputs.projected} = ${inputs.a}.xy / \
${inputs.a}.z;`];\n      }\n      if (this.inTypes.a === \"vec4\") {\n        \
return [`${outputs.projected} = ${inputs.a}.xyz / ${inputs.a}.w;`];\n      \
}\n      throw new Error(\"Invalid type\");\n    };\n  }\n}\nfunction \
extendVecOutputType(type) {\n  if (type === \"float\") return \"vec2\";\n  if \
(type === \"vec2\") return \"vec3\";\n  if (type === \"vec3\") return \
\"vec4\";\n  throw new Error(\"Invalid type\");\n}\nclass ExtendVec extends \
BinaryOp {\n  constructor({ a, b }) {\n    const type = valType(a);\n    \
const outType = extendVecOutputType(type);\n    super({ a, b, outKey: \
\"extend\", outTypeFunc: () => outType });\n    this.statements = ({ inputs, \
outputs }) => [\n      `${outputs.extend} = ${outType}(${inputs.a}, \
${inputs.b});`\n    ];\n  }\n}\nclass FaceForward extends TrinaryOp {\n  \
constructor({ a, b, c }) {\n    super({\n      a,\n      b,\n      c,\n      \
outKey: \"forward\",\n      outTypeFunc: (aType, bType, cType) => aType\n    \
});\n    this.statements = ({ inputs, outputs }) => [\n      \
`${outputs.forward} = faceforward(${inputs.a}, ${inputs.b}, ${inputs.c});`\n  \
  ];\n  }\n}\nclass ReflectVec extends BinaryOp {\n  constructor({\n    \
incident,\n    normal\n  }) {\n    super({\n      a: incident,\n      b: \
normal,\n      outKey: \"reflection\",\n      outTypeFunc: (aType, bType) => \
aType\n    });\n    this.statements = ({ inputs, outputs }) => [\n      \
`${outputs.reflection} = reflect(${inputs.a}, ${inputs.b});`\n    ];\n  \
}\n}\nclass RefractVec extends TrinaryOp {\n  constructor({\n    incident,\n  \
  normal,\n    eta\n  }) {\n    super({\n      a: incident,\n      b: \
normal,\n      c: eta,\n      outKey: \"refraction\",\n      outTypeFunc: \
(aType, bType, cType) => aType\n    });\n    this.statements = ({ inputs, \
outputs }) => [\n      `${outputs.refraction} = refract(${inputs.a}, \
${inputs.b}, ${inputs.c});`\n    ];\n  }\n}\nclass CompMult extends BinaryOp \
{\n  constructor({ a, b }) {\n    super({ a, b, outKey: \"product\", \
outTypeFunc: (aType, bType) => aType });\n    this.statements = ({ inputs, \
outputs }) => [\n      `${outputs.product} = matrixCompMult(${a}, ${b});`\n   \
 ];\n  }\n}\nfunction outerOutputType(aType, bType) {\n  if (aType === \
\"vec2\") {\n    if (bType === \"vec2\") return \"mat2\";\n    if (bType === \
\"vec3\") return \"mat3x2\";\n    if (bType === \"vec4\") return \
\"mat4x2\";\n  }\n  if (aType === \"vec3\") {\n    if (bType === \"vec2\") \
return \"mat2x3\";\n    if (bType === \"vec3\") return \"mat3\";\n    if \
(bType === \"vec4\") return \"mat4x3\";\n  }\n  if (aType === \"vec4\") {\n   \
 if (bType === \"vec2\") return \"mat2x4\";\n    if (bType === \"vec3\") \
return \"mat3x4\";\n    if (bType === \"vec4\") return \"mat4\";\n  }\n  \
throw new Error(`Invalid outer type: ${aType}, ${bType}`);\n}\nclass Outer \
extends BinaryOp {\n  constructor({ a, b }) {\n    super({ a, b, outKey: \
\"outer\", outTypeFunc: outerOutputType });\n    this.statements = ({ inputs, \
outputs }) => [\n      `${outputs.outer} = outerProduct(${inputs.a}, \
${inputs.b});`\n    ];\n  }\n}\nfunction transposeOutputType(type) {\n  if \
(type === \"mat2\") return \"mat2\";\n  if (type === \"mat3\") return \
\"mat3\";\n  if (type === \"mat4\") return \"mat4\";\n  if (type === \
\"mat2x2\") return \"mat2x2\";\n  if (type === \"mat2x3\") return \
\"mat3x2\";\n  if (type === \"mat2x4\") return \"mat4x2\";\n  if (type === \
\"mat3x2\") return \"mat2x3\";\n  if (type === \"mat3x3\") return \
\"mat3x3\";\n  if (type === \"mat3x4\") return \"mat4x3\";\n  if (type === \
\"mat4x2\") return \"mat2x4\";\n  if (type === \"mat4x3\") return \
\"mat3x4\";\n  if (type === \"mat4x4\") return \"mat4x4\";\n  throw new \
Error(`Invalid transpose type: ${type}`);\n}\nclass Transpose extends UnaryOp \
{\n  constructor({ a }) {\n    super({ a, outKey: \"transpose\", outTypeFunc: \
transposeOutputType });\n    this.statements = ({ inputs, outputs }) => [\n   \
   `${outputs.transpose} = transpose(${inputs.a});`\n    ];\n  }\n}\nclass \
Determinant extends UnaryOp {\n  constructor({ a }) {\n    super({ a, outKey: \
\"det\", outTypeFunc: (aType) => \"float\" });\n    this.statements = ({ \
inputs, outputs }) => [\n      `${outputs.det} = determinant(${inputs.a});`\n \
   ];\n  }\n}\nclass Inverse extends UnaryOp {\n  constructor({ a }) {\n    \
super({ a, outKey: \"inverse\", outTypeFunc: (aType) => aType });\n    \
this.statements = ({ inputs, outputs }) => [\n      `${outputs.inverse} = \
inverse(${a});`\n    ];\n  }\n}\nfunction splitOutTypes(type) {\n  const \
result = (value) => value;\n  switch (type) {\n    case \"vec2\":\n      \
return result({ x: \"float\", y: \"float\", r: \"float\", g: \"float\" });\n  \
  case \"vec3\":\n      return result({\n        x: \"float\",\n        y: \
\"float\",\n        z: \"float\",\n        r: \"float\",\n        g: \
\"float\",\n        b: \"float\"\n      });\n    case \"vec4\":\n      return \
result({\n        x: \"float\",\n        y: \"float\",\n        z: \
\"float\",\n        w: \"float\",\n        r: \"float\",\n        g: \
\"float\",\n        b: \"float\",\n        a: \"float\"\n      });\n    case \
\"ivec2\":\n      return result({ x: \"int\", y: \"int\", r: \"int\", g: \
\"int\" });\n    case \"ivec3\":\n      return result({\n        x: \
\"int\",\n        y: \"int\",\n        z: \"int\",\n        r: \"int\",\n     \
   g: \"int\",\n        b: \"int\"\n      });\n    case \"ivec4\":\n      \
return result({\n        x: \"int\",\n        y: \"int\",\n        z: \
\"int\",\n        w: \"int\",\n        r: \"int\",\n        g: \"int\",\n     \
   b: \"int\",\n        a: \"int\"\n      });\n    case \"uvec2\":\n      \
return result({ x: \"uint\", y: \"uint\", r: \"uint\", g: \"uint\" });\n    \
case \"uvec3\":\n      return result({\n        x: \"uint\",\n        y: \
\"uint\",\n        z: \"uint\",\n        r: \"uint\",\n        g: \"uint\",\n \
       b: \"uint\"\n      });\n    case \"uvec4\":\n      return result({\n   \
     x: \"uint\",\n        y: \"uint\",\n        z: \"uint\",\n        w: \
\"uint\",\n        r: \"uint\",\n        g: \"uint\",\n        b: \"uint\",\n \
       a: \"uint\"\n      });\n    default:\n      throw new Error(`Invalid \
vector type: ${type}`);\n  }\n}\nclass Split extends Dyno {\n  constructor({ \
vector }) {\n    const type = valType(vector);\n    const inTypes = { vector: \
type };\n    const outTypes = splitOutTypes(inTypes.vector);\n    super({ \
inTypes, outTypes, inputs: { vector } });\n    this.statements = ({ inputs, \
outputs }) => {\n      const { x, y, z, w, r, g, b, a } = outputs;\n      \
const { vector: vector2 } = inputs;\n      return [\n        x ? `${x} = \
${vector2}.x;` : null,\n        y ? `${y} = ${vector2}.y;` : null,\n        z \
? `${z} = ${vector2}.z;` : null,\n        w ? `${w} = ${vector2}.w;` : \
null,\n        r ? `${r} = ${vector2}.r;` : null,\n        g ? `${g} = \
${vector2}.g;` : null,\n        b ? `${b} = ${vector2}.b;` : null,\n        a \
? `${a} = ${vector2}.a;` : null\n      ].filter(Boolean);\n    };\n  \
}\n}\nclass Combine extends Dyno {\n  constructor({\n    vector,\n    \
vectorType,\n    x,\n    y,\n    z,\n    w,\n    r,\n    g,\n    b,\n    a\n  \
}) {\n    if (!vector && !vectorType) {\n      throw new Error(\"Either \
vector or vectorType must be provided\");\n    }\n    const vType = \
vectorType ?? valType(vector);\n    const elType = \
vectorElementType(vType);\n    const dim = vectorDim(vType);\n    const \
inTypes = {\n      vector: vType,\n      x: elType,\n      y: elType,\n      \
r: elType,\n      g: elType\n    };\n    const inputs = { vector, x, y, r, g \
};\n    if (dim >= 3) {\n      Object.assign(inTypes, { z: elType, b: elType \
});\n      Object.assign(inputs, { z, b });\n    }\n    if (dim >= 4) {\n     \
 Object.assign(inTypes, { w: elType, a: elType });\n      \
Object.assign(inputs, { w, a });\n    }\n    super({ inTypes, outTypes: { \
vector: vType }, inputs });\n    this.statements = ({ inputs: inputs2, \
outputs }) => {\n      const { vector: vector2 } = outputs;\n      const {\n  \
      vector: input,\n        x: x2,\n        y: y2,\n        z: z2,\n        \
w: w2,\n        r: r2,\n        g: g2,\n        b: b22,\n        a: a2\n      \
} = inputs2;\n      const statements = [\n        `${vector2}.x = ${x2 ?? r2 \
?? (input ? `${input}.x` : literalZero(elType))};`,\n        `${vector2}.y = \
${y2 ?? g2 ?? (input ? `${input}.y` : literalZero(elType))};`\n      ];\n     \
 if (dim >= 3)\n        statements.push(\n          `${vector2}.z = ${z2 ?? \
b22 ?? (input ? `${input}.z` : literalZero(elType))};`\n        );\n      if \
(dim >= 4)\n        statements.push(\n          `${vector2}.w = ${w2 ?? a2 ?? \
(input ? `${input}.w` : literalZero(elType))};`\n        );\n      return \
statements;\n    };\n  }\n  dynoOut() {\n    return new DynoOutput(\n      \
this,\n      \"vector\"\n    );\n  }\n}\nfunction swizzleOutputType(type, \
swizzle2) {\n  let result = null;\n  if (isFloatType(type)) {\n    result = \
swizzle2.length === 1 ? \"float\" : swizzle2.length === 2 ? \"vec2\" : \
swizzle2.length === 3 ? \"vec3\" : swizzle2.length === 4 ? \"vec4\" : null;\n \
 } else if (isIntType(type)) {\n    result = swizzle2.length === 1 ? \"int\" \
: swizzle2.length === 2 ? \"ivec2\" : swizzle2.length === 3 ? \"ivec3\" : \
swizzle2.length === 4 ? \"ivec4\" : null;\n  } else if (isUintType(type)) {\n \
   result = swizzle2.length === 1 ? \"uint\" : swizzle2.length === 2 ? \
\"uvec2\" : swizzle2.length === 3 ? \"uvec3\" : swizzle2.length === 4 ? \
\"uvec4\" : null;\n  }\n  if (result == null) {\n    throw new Error(`Invalid \
swizzle: ${swizzle2}`);\n  }\n  return result;\n}\nclass Swizzle extends \
UnaryOp {\n  constructor({ vector, select: select2 }) {\n    super({\n      \
a: vector,\n      outKey: \"swizzle\",\n      outTypeFunc: (aType) => \
swizzleOutputType(aType, select2)\n    });\n    this.statements = ({ inputs, \
outputs }) => [\n      `${outputs.swizzle} = ${inputs.a}.${select2};`\n    \
];\n  }\n}\nconst remapIndex = (index, from, to) => {\n  return new \
DynoRemapIndex({ index, from, to });\n};\nconst pcgMix = (value) => {\n  \
return new PcgMix({ value });\n};\nconst pcgNext = (state) => {\n  return new \
PcgNext({ state });\n};\nconst pcgHash = (state) => {\n  return new PcgHash({ \
state });\n};\nconst hash = (value) => {\n  return new Hash({ value \
});\n};\nconst hash2 = (value) => {\n  return new Hash2({ value \
});\n};\nconst hash3 = (value) => {\n  return new Hash3({ value \
});\n};\nconst hash4 = (value) => {\n  return new Hash4({ value \
});\n};\nconst hashFloat = (value) => {\n  return new HashFloat({ value \
});\n};\nconst hashVec2 = (value) => {\n  return new HashVec2({ value \
});\n};\nconst hashVec3 = (value) => {\n  return new HashVec3({ value \
});\n};\nconst hashVec4 = (value) => {\n  return new HashVec4({ value \
});\n};\nconst normalizedDepth = (z, zNear, zFar) => {\n  return new \
NormalizedDepth({ z, zNear, zFar }).outputs.depth;\n};\nclass DynoRemapIndex \
extends Dyno {\n  constructor({\n    from,\n    to,\n    index\n  }) {\n    \
super({\n      inTypes: { from: \"int\", to: \"int\", index: \"int\" },\n     \
 outTypes: { index: \"int\" },\n      inputs: { from, to, index },\n      \
statements: ({ inputs, outputs }) => {\n        return [\n          \
`${outputs.index} = ${inputs.index} - ${inputs.from} + ${inputs.to};`\n       \
 ];\n      }\n    });\n  }\n  dynoOut() {\n    return new DynoOutput(this, \
\"index\");\n  }\n}\nclass PcgNext extends Dyno {\n  constructor({ state }) \
{\n    const type = valType(state);\n    super({\n      inTypes: { state: \
type },\n      outTypes: { state: \"uint\" },\n      inputs: { state },\n     \
 globals: () => [\n        unindent(`\n          uint pcg_next(uint state) \
{\n            return state * 747796405u + 2891336453u;\n          }\n        \
`)\n      ],\n      statements: ({ inputs, outputs }) => {\n        const \
toUint = type === \"uint\" ? `${inputs.state}` : type === \"int\" ? \
`uint(${inputs.state})` : `floatBitsToUint(${inputs.state})`;\n        return \
[`${outputs.state} = pcg_next(${toUint});`];\n      }\n    });\n  }\n  \
dynoOut() {\n    return new DynoOutput(this, \"state\");\n  }\n}\nclass \
PcgHash extends Dyno {\n  constructor({ state }) {\n    super({\n      \
inTypes: { state: \"uint\" },\n      outTypes: { hash: \"uint\" },\n      \
inputs: { state },\n      globals: () => [\n        unindent(`\n          \
uint pcg_hash(uint state) {\n            uint hash = ((state >> ((state >> \
28u) + 4u)) ^ state) * 277803737u;\n            return (hash >> 22u) ^ \
hash;\n          }\n        `)\n      ],\n      statements: ({ inputs, \
outputs }) => [\n        `${outputs.hash} = pcg_hash(${inputs.state});`\n     \
 ]\n    });\n  }\n  dynoOut() {\n    return new DynoOutput(this, \"hash\");\n \
 }\n}\nclass PcgMix extends Dyno {\n  constructor({ value }) {\n    const \
type = valType(value);\n    const tempType = sameSizeUvec(type);\n    \
super({\n      inTypes: { value: type },\n      outTypes: { state: \"uint\" \
},\n      inputs: { value },\n      globals: () => [\n        unindent(`\n    \
      uint pcg_mix(uint value) {\n            return value;\n          }\n    \
      uint pcg_mix(uvec2 value) {\n            return value.x + 0x9e3779b9u * \
value.y;\n          }\n          uint pcg_mix(uvec3 value) {\n            \
return value.x + 0x9e3779b9u * value.y + 0x85ebca6bu * value.z;\n          \
}\n          uint pcg_mix(uvec4 value) {\n            return value.x + \
0x9e3779b9u * value.y + 0x85ebca6bu * value.z + 0xc2b2ae35u * value.w;\n      \
    }\n        `)\n      ],\n      statements: ({ inputs, outputs }) => {\n   \
     const toUvec = isUintType(type) ? `${inputs.value}` : isIntType(type) ? \
`${tempType}(${inputs.value})` : `floatBitsToUint(${inputs.value})`;\n        \
return [\n          `${tempType} bits = ${toUvec};`,\n          \
`${outputs.state} = pcg_mix(bits);`\n        ];\n      }\n    });\n  }\n  \
dynoOut() {\n    return new DynoOutput(this, \"state\");\n  }\n}\nclass Hash \
extends DynoBlock {\n  constructor({ value }) {\n    super({\n      inTypes: \
{ value: valType(value) },\n      outTypes: { hash: \"uint\" },\n      \
inputs: { value },\n      construct: ({ value: value2 }) => {\n        if \
(!value2) {\n          throw new Error(\"value is required\");\n        }\n   \
     let state = new PcgMix({ value: value2 }).outputs.state;\n        state \
= new PcgNext({ state }).outputs.state;\n        return new PcgHash({ state \
}).outputs;\n      }\n    });\n  }\n  dynoOut() {\n    return new \
DynoOutput(this, \"hash\");\n  }\n}\nclass Hash2 extends DynoBlock {\n  \
constructor({ value }) {\n    super({\n      inTypes: { value: valType(value) \
},\n      outTypes: { hash: \"uvec2\" },\n      inputs: { value },\n      \
construct: ({ value: value2 }) => {\n        if (!value2) {\n          throw \
new Error(\"value is required\");\n        }\n        let state = new \
PcgMix({ value: value2 }).outputs.state;\n        state = new PcgNext({ state \
}).outputs.state;\n        const x = new PcgHash({ state }).outputs.hash;\n   \
     state = new PcgNext({ state }).outputs.state;\n        const y = new \
PcgHash({ state }).outputs.hash;\n        return { hash: combine({ \
vectorType: \"uvec2\", x, y }) };\n      }\n    });\n  }\n  dynoOut() {\n    \
return new DynoOutput(this, \"hash\");\n  }\n}\nclass Hash3 extends DynoBlock \
{\n  constructor({ value }) {\n    super({\n      inTypes: { value: \
valType(value) },\n      outTypes: { hash: \"uvec3\" },\n      inputs: { \
value },\n      construct: ({ value: value2 }) => {\n        if (!value2) {\n \
         throw new Error(\"value is required\");\n        }\n        let \
state = new PcgMix({ value: value2 }).outputs.state;\n        state = new \
PcgNext({ state }).outputs.state;\n        const x = new PcgHash({ state \
}).outputs.hash;\n        state = new PcgNext({ state }).outputs.state;\n     \
   const y = new PcgHash({ state }).outputs.hash;\n        state = new \
PcgNext({ state }).outputs.state;\n        const z = new PcgHash({ state \
}).outputs.hash;\n        return { hash: combine({ vectorType: \"uvec3\", x, \
y, z }) };\n      }\n    });\n  }\n  dynoOut() {\n    return new \
DynoOutput(this, \"hash\");\n  }\n}\nclass Hash4 extends DynoBlock {\n  \
constructor({ value }) {\n    super({\n      inTypes: { value: valType(value) \
},\n      outTypes: { hash: \"uvec4\" },\n      inputs: { value },\n      \
construct: ({ value: value2 }) => {\n        if (!value2) {\n          throw \
new Error(\"value is required\");\n        }\n        let state = new \
PcgMix({ value: value2 }).outputs.state;\n        state = new PcgNext({ state \
}).outputs.state;\n        const x = new PcgHash({ state }).outputs.hash;\n   \
     state = new PcgNext({ state }).outputs.state;\n        const y = new \
PcgHash({ state }).outputs.hash;\n        state = new PcgNext({ state \
}).outputs.state;\n        const z = new PcgHash({ state }).outputs.hash;\n   \
     state = new PcgNext({ state }).outputs.state;\n        const w = new \
PcgHash({ state }).outputs.hash;\n        return { hash: combine({ \
vectorType: \"uvec4\", x, y, z, w }) };\n      }\n    });\n  }\n  dynoOut() \
{\n    return new DynoOutput(this, \"hash\");\n  }\n}\nclass HashFloat \
extends DynoBlock {\n  constructor({ value }) {\n    super({\n      inTypes: \
{ value: valType(value) },\n      outTypes: { hash: \"float\" },\n      \
inputs: { value },\n      construct: ({ value: value2 }) => {\n        if \
(!value2) {\n          throw new Error(\"value is required\");\n        }\n   \
     const word = hash(value2);\n        return { hash: mul(float(word), \
dynoConst(\"float\", 1 / 2 ** 32)) };\n      }\n    });\n  }\n  dynoOut() {\n \
   return new DynoOutput(this, \"hash\");\n  }\n}\nclass HashVec2 extends \
DynoBlock {\n  constructor({ value }) {\n    super({\n      inTypes: { value: \
valType(value) },\n      outTypes: { hash: \"vec2\" },\n      inputs: { value \
},\n      construct: ({ value: value2 }) => {\n        if (!value2) {\n       \
   throw new Error(\"value is required\");\n        }\n        const words = \
hash2(value2);\n        return { hash: mul(vec2(words), dynoConst(\"float\", \
1 / 2 ** 32)) };\n      }\n    });\n  }\n  dynoOut() {\n    return new \
DynoOutput(this, \"hash\");\n  }\n}\nclass HashVec3 extends DynoBlock {\n  \
constructor({ value }) {\n    super({\n      inTypes: { value: valType(value) \
},\n      outTypes: { hash: \"vec3\" },\n      inputs: { value },\n      \
construct: ({ value: value2 }) => {\n        if (!value2) {\n          throw \
new Error(\"value is required\");\n        }\n        const words = \
hash3(value2);\n        return { hash: mul(vec3(words), dynoConst(\"float\", \
1 / 2 ** 32)) };\n      }\n    });\n  }\n  dynoOut() {\n    return new \
DynoOutput(this, \"hash\");\n  }\n}\nclass HashVec4 extends DynoBlock {\n  \
constructor({ value }) {\n    super({\n      inTypes: { value: valType(value) \
},\n      outTypes: { hash: \"vec4\" },\n      inputs: { value },\n      \
construct: ({ value: value2 }) => {\n        if (!value2) {\n          throw \
new Error(\"value is required\");\n        }\n        const words = \
hash4(value2);\n        return { hash: mul(vec4(words), dynoConst(\"float\", \
1 / 2 ** 32)) };\n      }\n    });\n  }\n  dynoOut() {\n    return new \
DynoOutput(this, \"hash\");\n  }\n}\nclass NormalizedDepth extends Dyno {\n  \
constructor({\n    z,\n    zNear,\n    zFar\n  }) {\n    super({\n      \
inTypes: { z: \"float\", zNear: \"float\", zFar: \"float\" },\n      \
outTypes: { depth: \"float\" },\n      inputs: { z, zNear, zFar },\n      \
statements: ({ inputs, outputs }) => [\n        `float clamped = \
clamp(${inputs.z}, ${inputs.zNear}, ${inputs.zFar});`,\n        \
`${outputs.depth} = (log2(clamped + 1.0) - log2(${inputs.zNear} + 1.0)) / \
(log2(${inputs.zFar} + 1.0) - log2(${inputs.zNear} + 1.0));`\n      ]\n    \
});\n  }\n  dynoOut() {\n    return new DynoOutput(this, \"depth\");\n  \
}\n}\nconst transformPos = (position, {\n  scale,\n  scales,\n  rotate,\n  \
translate\n}) => {\n  return new TransformPosition({ position, scale, scales, \
rotate, translate }).outputs.position;\n};\nconst transformDir = (dir, {\n  \
scale,\n  scales,\n  rotate\n}) => {\n  return new TransformDir({ dir, scale, \
scales, rotate }).outputs.dir;\n};\nconst transformQuat = (quaternion, { \
rotate }) => {\n  return new TransformQuaternion({ quaternion, rotate \
}).outputs.quaternion;\n};\nclass TransformPosition extends Dyno {\n  \
constructor({\n    position,\n    scale,\n    scales,\n    rotate,\n    \
translate\n  }) {\n    super({\n      inTypes: {\n        position: \
\"vec3\",\n        scale: \"float\",\n        scales: \"vec3\",\n        \
rotate: \"vec4\",\n        translate: \"vec3\"\n      },\n      outTypes: { \
position: \"vec3\" },\n      inputs: { position, scale, scales, rotate, \
translate },\n      statements: ({ inputs, outputs }) => {\n        const { \
position: position2 } = outputs;\n        if (!position2) {\n          return \
[];\n        }\n        const { scale: scale2, scales: scales2, rotate: \
rotate2, translate: translate2 } = inputs;\n        return [\n          \
`${position2} = ${inputs.position ?? \"vec3(0.0, 0.0, 0.0)\"};`,\n          \
!scale2 ? null : `${position2} *= ${scale2};`,\n          !scales2 ? null : \
`${position2} *= ${scales2};`,\n          !rotate2 ? null : `${position2} = \
quatVec(${rotate2}, ${position2});`,\n          !translate2 ? null : \
`${position2} += ${translate2};`\n        ].filter(Boolean);\n      }\n    \
});\n  }\n}\nclass TransformDir extends Dyno {\n  constructor({\n    dir,\n   \
 scale,\n    scales,\n    rotate\n  }) {\n    super({\n      inTypes: { dir: \
\"vec3\", scale: \"float\", scales: \"vec3\", rotate: \"vec4\" },\n      \
outTypes: { dir: \"vec3\" },\n      inputs: { dir, scale, scales, rotate },\n \
     statements: ({ inputs, outputs }) => {\n        const { dir: dir2 } = \
outputs;\n        if (!dir2) {\n          return [];\n        }\n        \
const { scale: scale2, scales: scales2, rotate: rotate2 } = inputs;\n        \
return [\n          `${dir2} = ${inputs.dir ?? \"vec3(0.0, 0.0, 0.0)\"};`,\n  \
        !scale2 ? null : `${dir2} *= ${scale2};`,\n          !scales2 ? null \
: `${dir2} *= ${scales2};`,\n          !rotate2 ? null : `${dir2} = \
quatVec(${rotate2}, ${dir2});`\n        ].filter(Boolean);\n      }\n    \
});\n  }\n}\nclass TransformQuaternion extends Dyno {\n  constructor({\n    \
quaternion,\n    rotate\n  }) {\n    super({\n      inTypes: { quaternion: \
\"vec4\", rotate: \"vec4\" },\n      outTypes: { quaternion: \"vec4\" },\n    \
  inputs: { quaternion, rotate },\n      statements: ({ inputs, outputs }) => \
{\n        const { quaternion: quaternion2 } = outputs;\n        if \
(!quaternion2) {\n          return [];\n        }\n        return [\n         \
 `${quaternion2} = ${inputs.quaternion ?? \"vec4(0.0, 0.0, 0.0, 1.0)\"};`,\n  \
        !rotate ? null : `${quaternion2} = quatQuat(${inputs.rotate}, \
${quaternion2});`\n        ].filter(Boolean);\n      }\n    });\n  \
}\n}\nconst dynoIf = () => {\n  throw new Error(\"Not \
implemented\");\n};\nconst dynoSwitch = () => {\n  throw new Error(\"Not \
implemented\");\n};\nconst dynoFor = () => {\n  throw new Error(\"Not \
implemented\");\n};\nconst comment = () => {\n  throw new Error(\"Not \
implemented\");\n};\nconst arrayIndex = () => {\n  throw new Error(\"Not \
implemented\");\n};\nconst arrayLength = () => {\n  throw new Error(\"Not \
implemented\");\n};\nconst textureSize = (texture2, lod) => new TextureSize({ \
texture: texture2, lod });\nconst texture = (texture2, coord, bias) => new \
Texture({ texture: texture2, coord, bias });\nconst texelFetch = (texture2, \
coord, lod) => new TexelFetch({ texture: texture2, coord, lod });\nclass \
TextureSize extends Dyno {\n  constructor({ texture: texture2, lod }) {\n    \
const textureType = valType(texture2);\n    super({\n      inTypes: { \
texture: textureType, lod: \"int\" },\n      outTypes: { size: \
textureSizeType(textureType) },\n      inputs: { texture: texture2, lod },\n  \
    statements: ({ inputs, outputs }) => [\n        `${outputs.size} = \
textureSize(${inputs.texture}, ${inputs.lod ?? \"0\"});`\n      ]\n    });\n  \
}\n  dynoOut() {\n    return new DynoOutput(this, \"size\");\n  }\n}\nclass \
Texture extends Dyno {\n  constructor({\n    texture: texture2,\n    coord,\n \
   bias\n  }) {\n    const textureType = valType(texture2);\n    super({\n    \
  inTypes: {\n        texture: textureType,\n        coord: \
textureCoordType(textureType),\n        bias: \"float\"\n      },\n      \
outTypes: { sample: textureReturnType(textureType) },\n      inputs: { \
texture: texture2, coord, bias },\n      statements: ({ inputs, outputs }) => \
[\n        `${outputs.sample} = texture(${inputs.texture}, \
${inputs.coord}${inputs.bias ? `, ${inputs.bias}` : \"\"});`\n      ]\n    \
});\n  }\n  dynoOut() {\n    return new DynoOutput(this, \"sample\");\n  \
}\n}\nclass TexelFetch extends Dyno {\n  constructor({\n    texture: \
texture2,\n    coord,\n    lod\n  }) {\n    const textureType = \
valType(texture2);\n    super({\n      inTypes: {\n        texture: \
textureType,\n        coord: textureSizeType(textureType),\n        lod: \
\"int\"\n      },\n      outTypes: { texel: textureReturnType(textureType) \
},\n      inputs: { texture: texture2, coord, lod },\n      statements: ({ \
inputs, outputs }) => [\n        `${outputs.texel} = \
texelFetch(${inputs.texture}, ${inputs.coord}, ${inputs.lod ?? \"0\"});`\n    \
  ]\n    });\n  }\n  dynoOut() {\n    return new DynoOutput(this, \
\"texel\");\n  }\n}\nfunction textureSizeType(textureType) {\n  switch \
(textureType) {\n    case \"sampler2D\":\n    case \"usampler2D\":\n    case \
\"isampler2D\":\n    case \"samplerCube\":\n    case \"usamplerCube\":\n    \
case \"isamplerCube\":\n    case \"sampler2DShadow\":\n    case \
\"samplerCubeShadow\":\n      return \"ivec2\";\n    case \"sampler3D\":\n    \
case \"usampler3D\":\n    case \"isampler3D\":\n    case \
\"sampler2DArray\":\n    case \"usampler2DArray\":\n    case \
\"isampler2DArray\":\n    case \"sampler2DArrayShadow\":\n      return \
\"ivec3\";\n    default:\n      throw new Error(`Invalid texture type: \
${textureType}`);\n  }\n}\nfunction textureCoordType(textureType) {\n  switch \
(textureType) {\n    case \"sampler2D\":\n    case \"usampler2D\":\n    case \
\"isampler2D\":\n      return \"vec2\";\n    case \"sampler3D\":\n    case \
\"usampler3D\":\n    case \"isampler3D\":\n    case \"samplerCube\":\n    \
case \"usamplerCube\":\n    case \"isamplerCube\":\n    case \
\"sampler2DArray\":\n    case \"usampler2DArray\":\n    case \
\"isampler2DArray\":\n    case \"sampler2DShadow\":\n      return \"vec3\";\n \
   case \"samplerCubeShadow\":\n    case \"sampler2DArrayShadow\":\n      \
return \"vec4\";\n    default:\n      throw new Error(`Invalid texture type: \
${textureType}`);\n  }\n}\nfunction textureReturnType(textureType) {\n  \
switch (textureType) {\n    case \"sampler2D\":\n    case \
\"sampler2DArray\":\n    case \"sampler3D\":\n    case \"samplerCube\":\n    \
case \"sampler2DShadow\":\n      return \"vec4\";\n    case \"usampler2D\":\n \
   case \"usampler2DArray\":\n    case \"usampler3D\":\n    case \
\"usamplerCube\":\n      return \"uvec4\";\n    case \"isampler2D\":\n    \
case \"isampler2DArray\":\n    case \"isampler3D\":\n    case \
\"isamplerCube\":\n      return \"ivec4\";\n    case \"samplerCubeShadow\":\n \
   case \"sampler2DArrayShadow\":\n      return \"float\";\n    default:\n    \
  throw new Error(`Invalid texture type: ${textureType}`);\n  }\n}\nconst \
radians = (degrees2) => new Radians({ degrees: degrees2 });\nconst degrees = \
(radians2) => new Degrees({ radians: radians2 });\nconst sin = (radians2) => \
new Sin({ radians: radians2 });\nconst cos = (radians2) => new Cos({ radians: \
radians2 });\nconst tan = (radians2) => new Tan({ radians: radians2 \
});\nconst asin = (sin2) => new Asin({ sin: sin2 });\nconst acos = (cos2) => \
new Acos({ cos: cos2 });\nconst atan = (tan2) => new Atan({ tan: tan2 \
});\nconst atan2 = (y, x) => new Atan2({ y, x });\nconst sinh = (x) => new \
Sinh({ x });\nconst cosh = (x) => new Cosh({ x });\nconst tanh = (x) => new \
Tanh({ x });\nconst asinh = (x) => new Asinh({ x });\nconst acosh = (x) => \
new Acosh({ x });\nconst atanh = (x) => new Atanh({ x });\nclass Radians \
extends UnaryOp {\n  constructor({ degrees: degrees2 }) {\n    super({ a: \
degrees2, outTypeFunc: (aType) => aType, outKey: \"radians\" });\n    \
this.statements = ({ inputs, outputs }) => [\n      `${outputs.radians} = \
radians(${inputs.a});`\n    ];\n  }\n}\nclass Degrees extends UnaryOp {\n  \
constructor({ radians: radians2 }) {\n    super({ a: radians2, outTypeFunc: \
(aType) => aType, outKey: \"degrees\" });\n    this.statements = ({ inputs, \
outputs }) => [\n      `${outputs.degrees} = degrees(${inputs.a});`\n    ];\n \
 }\n}\nclass Sin extends UnaryOp {\n  constructor({ radians: radians2 }) {\n  \
  super({ a: radians2, outTypeFunc: (aType) => aType, outKey: \"sin\" });\n   \
 this.statements = ({ inputs, outputs }) => [\n      `${outputs.sin} = \
sin(${inputs.a});`\n    ];\n  }\n}\nclass Cos extends UnaryOp {\n  \
constructor({ radians: radians2 }) {\n    super({ a: radians2, outTypeFunc: \
(aType) => aType, outKey: \"cos\" });\n    this.statements = ({ inputs, \
outputs }) => [\n      `${outputs.cos} = cos(${inputs.a});`\n    ];\n  \
}\n}\nclass Tan extends UnaryOp {\n  constructor({ radians: radians2 }) {\n   \
 super({ a: radians2, outTypeFunc: (aType) => aType, outKey: \"tan\" });\n    \
this.statements = ({ inputs, outputs }) => [\n      `${outputs.tan} = \
tan(${inputs.a});`\n    ];\n  }\n}\nclass Asin extends UnaryOp {\n  \
constructor({ sin: sin2 }) {\n    super({ a: sin2, outTypeFunc: (aType) => \
aType, outKey: \"asin\" });\n    this.statements = ({ inputs, outputs }) => \
[\n      `${outputs.asin} = asin(${inputs.a});`\n    ];\n  }\n}\nclass Acos \
extends UnaryOp {\n  constructor({ cos: cos2 }) {\n    super({ a: cos2, \
outTypeFunc: (aType) => aType, outKey: \"acos\" });\n    this.statements = ({ \
inputs, outputs }) => [\n      `${outputs.acos} = acos(${inputs.a});`\n    \
];\n  }\n}\nclass Atan extends UnaryOp {\n  constructor({ tan: tan2 }) {\n    \
super({ a: tan2, outTypeFunc: (aType) => aType, outKey: \"atan\" });\n    \
this.statements = ({ inputs, outputs }) => [\n      `${outputs.atan} = \
atan(${inputs.a});`\n    ];\n  }\n}\nclass Atan2 extends BinaryOp {\n  \
constructor({ y, x }) {\n    super({\n      a: y,\n      b: x,\n      \
outTypeFunc: (aType, bType) => aType,\n      outKey: \"atan2\"\n    });\n    \
this.statements = ({ inputs, outputs }) => [\n      `${outputs.atan2} = \
atan2(${inputs.a}, ${inputs.b});`\n    ];\n  }\n}\nclass Sinh extends UnaryOp \
{\n  constructor({ x }) {\n    super({ a: x, outTypeFunc: (aType) => aType, \
outKey: \"sinh\" });\n    this.statements = ({ inputs, outputs }) => [\n      \
`${outputs.sinh} = sinh(${inputs.a});`\n    ];\n  }\n}\nclass Cosh extends \
UnaryOp {\n  constructor({ x }) {\n    super({ a: x, outTypeFunc: (aType) => \
aType, outKey: \"cosh\" });\n    this.statements = ({ inputs, outputs }) => \
[\n      `${outputs.cosh} = cosh(${inputs.a});`\n    ];\n  }\n}\nclass Tanh \
extends UnaryOp {\n  constructor({ x }) {\n    super({ a: x, outTypeFunc: \
(aType) => aType, outKey: \"tanh\" });\n    this.statements = ({ inputs, \
outputs }) => [\n      `${outputs.tanh} = tanh(${inputs.a});`\n    ];\n  \
}\n}\nclass Asinh extends UnaryOp {\n  constructor({ x }) {\n    super({ a: \
x, outTypeFunc: (aType) => aType, outKey: \"asinh\" });\n    this.statements \
= ({ inputs, outputs }) => [\n      `${outputs.asinh} = \
asinh(${inputs.a});`\n    ];\n  }\n}\nclass Acosh extends UnaryOp {\n  \
constructor({ x }) {\n    super({ a: x, outTypeFunc: (aType) => aType, \
outKey: \"acosh\" });\n    this.statements = ({ inputs, outputs }) => [\n     \
 `${outputs.acosh} = acosh(${inputs.a});`\n    ];\n  }\n}\nclass Atanh \
extends UnaryOp {\n  constructor({ x }) {\n    super({ a: x, outTypeFunc: \
(aType) => aType, outKey: \"atanh\" });\n    this.statements = ({ inputs, \
outputs }) => [\n      `${outputs.atanh} = atanh(${inputs.a});`\n    ];\n  \
}\n}\nconst dyno = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ \
Object.defineProperty({\n  __proto__: null,\n  Abs,\n  Acos,\n  Acosh,\n  \
Add,\n  All,\n  And,\n  Any,\n  Asin,\n  Asinh,\n  Atan,\n  Atan2,\n  \
Atanh,\n  BVec2,\n  BVec3,\n  BVec4,\n  BinaryOp,\n  Bool,\n  Ceil,\n  \
Clamp,\n  Combine,\n  CombineGsplat,\n  CompMult,\n  CompXor,\n  \
Compilation,\n  Cos,\n  Cosh,\n  Cross,\n  Degrees,\n  Determinant,\n  \
Distance,\n  Div,\n  Dot,\n  Dyno,\n  DynoBlock,\n  DynoBool,\n  DynoBvec2,\n \
 DynoBvec3,\n  DynoBvec4,\n  DynoConst,\n  DynoFloat,\n  DynoInt,\n  \
DynoIsampler2D,\n  DynoIsampler2DArray,\n  DynoIsampler3D,\n  \
DynoIsamplerCube,\n  DynoIvec2,\n  DynoIvec3,\n  DynoIvec4,\n  DynoLiteral,\n \
 DynoMat2,\n  DynoMat2x2,\n  DynoMat2x3,\n  DynoMat2x4,\n  DynoMat3,\n  \
DynoMat3x2,\n  DynoMat3x3,\n  DynoMat3x4,\n  DynoMat4,\n  DynoMat4x2,\n  \
DynoMat4x3,\n  DynoMat4x4,\n  DynoOutput,\n  DynoProgram,\n  \
DynoProgramTemplate,\n  DynoRemapIndex,\n  DynoSampler2D,\n  \
DynoSampler2DArray,\n  DynoSampler2DArrayShadow,\n  DynoSampler2DShadow,\n  \
DynoSampler3D,\n  DynoSamplerCube,\n  DynoSamplerCubeShadow,\n  DynoUint,\n  \
DynoUniform,\n  DynoUsampler2D,\n  DynoUsampler2DArray,\n  DynoUsampler3D,\n  \
DynoUsamplerCube,\n  DynoUvec2,\n  DynoUvec3,\n  DynoUvec4,\n  DynoValue,\n  \
DynoVec2,\n  DynoVec3,\n  DynoVec4,\n  Equal,\n  Exp,\n  Exp2,\n  \
ExtendVec,\n  FaceForward,\n  Float,\n  FloatBitsToInt,\n  FloatBitsToUint,\n \
 Floor,\n  Fract,\n  GreaterThan,\n  GreaterThanEqual,\n  Gsplat,\n  \
GsplatNormal,\n  Hash,\n  Hash2,\n  Hash3,\n  Hash4,\n  HashFloat,\n  \
HashVec2,\n  HashVec3,\n  HashVec4,\n  IMod,\n  IVec2,\n  IVec3,\n  IVec4,\n  \
Int,\n  IntBitsToFloat,\n  Inverse,\n  InverseSqrt,\n  IsInf,\n  IsNan,\n  \
Length,\n  LessThan,\n  LessThanEqual,\n  Log,\n  Log2,\n  Mat2,\n  Mat3,\n  \
Mat4,\n  Max,\n  Min,\n  Mix,\n  Mod,\n  Modf,\n  Mul,\n  Neg,\n  \
Normalize,\n  NormalizedDepth,\n  Not,\n  NotEqual,\n  NumPackedSplats,\n  \
Or,\n  Outer,\n  OutputPackedSplat,\n  OutputRgba8,\n  PackHalf2x16,\n  \
PackSnorm2x16,\n  PackUnorm2x16,\n  PcgHash,\n  PcgMix,\n  PcgNext,\n  Pow,\n \
 ProjectH,\n  Radians,\n  ReadPackedSplat,\n  ReadPackedSplatRange,\n  \
ReflectVec,\n  RefractVec,\n  Round,\n  Select,\n  Sign,\n  SimpleCast,\n  \
Sin,\n  Sinh,\n  Smoothstep,\n  Split,\n  SplitGsplat,\n  Sqr,\n  Sqrt,\n  \
Step,\n  Sub,\n  Swizzle,\n  TPackedSplats,\n  Tan,\n  Tanh,\n  TexelFetch,\n \
 Texture,\n  TextureSize,\n  TransformDir,\n  TransformGsplat,\n  \
TransformPosition,\n  TransformQuaternion,\n  Transpose,\n  TrinaryOp,\n  \
Trunc,\n  UVec2,\n  UVec3,\n  UVec4,\n  Uint,\n  UintBitsToFloat,\n  \
UintToRgba8,\n  UnaryOp,\n  UnpackHalf2x16,\n  UnpackSnorm2x16,\n  \
UnpackUnorm2x16,\n  Vec2,\n  Vec3,\n  Vec4,\n  Xor,\n  abs,\n  acos,\n  \
acosh,\n  add,\n  all,\n  and,\n  any,\n  arrayIndex,\n  arrayLength,\n  \
asin,\n  asinh,\n  atan,\n  atan2,\n  atanh,\n  bool,\n  bvec2,\n  bvec3,\n  \
bvec4,\n  ceil,\n  clamp,\n  combine,\n  combineGsplat,\n  comment,\n  \
compMult,\n  compXor,\n  cos,\n  cosh,\n  cross,\n  defineGsplat,\n  \
defineGsplatNormal,\n  definePackedSplats,\n  degrees,\n  determinant,\n  \
distance,\n  div,\n  dot,\n  dyno: dyno$1,\n  dynoBlock,\n  dynoBool,\n  \
dynoBvec2,\n  dynoBvec3,\n  dynoBvec4,\n  dynoConst,\n  dynoDeclare,\n  \
dynoFloat,\n  dynoFor,\n  dynoIf,\n  dynoInt,\n  dynoIsampler2D,\n  \
dynoIsampler2DArray,\n  dynoIsampler3D,\n  dynoIsamplerCube,\n  dynoIvec2,\n  \
dynoIvec3,\n  dynoIvec4,\n  dynoLiteral,\n  dynoMat2,\n  dynoMat2x2,\n  \
dynoMat2x3,\n  dynoMat2x4,\n  dynoMat3,\n  dynoMat3x2,\n  dynoMat3x3,\n  \
dynoMat3x4,\n  dynoMat4,\n  dynoMat4x2,\n  dynoMat4x3,\n  dynoMat4x4,\n  \
dynoSampler2D,\n  dynoSampler2DArray,\n  dynoSampler2DArrayShadow,\n  \
dynoSampler2DShadow,\n  dynoSampler3D,\n  dynoSamplerCube,\n  \
dynoSamplerCubeShadow,\n  dynoSwitch,\n  dynoUint,\n  dynoUsampler2D,\n  \
dynoUsampler2DArray,\n  dynoUsampler3D,\n  dynoUsamplerCube,\n  dynoUvec2,\n  \
dynoUvec3,\n  dynoUvec4,\n  dynoVec2,\n  dynoVec3,\n  dynoVec4,\n  equal,\n  \
exp,\n  exp2,\n  extendVec,\n  faceforward,\n  float,\n  floatBitsToInt,\n  \
floatBitsToUint,\n  floor,\n  fract,\n  greaterThan,\n  greaterThanEqual,\n  \
gsplatNormal,\n  hash,\n  hash2,\n  hash3,\n  hash4,\n  hashFloat,\n  \
hashVec2,\n  hashVec3,\n  hashVec4,\n  imod,\n  int,\n  intBitsToFloat,\n  \
inverse,\n  inversesqrt,\n  isAllFloatType,\n  isBoolType,\n  isFloatType,\n  \
isInf,\n  isIntType,\n  isMat2,\n  isMat3,\n  isMat4,\n  isMatFloatType,\n  \
isNan,\n  isScalarType,\n  isUintType,\n  isVector2Type,\n  isVector3Type,\n  \
isVector4Type,\n  isVectorType,\n  ivec2,\n  ivec3,\n  ivec4,\n  length,\n  \
lessThan,\n  lessThanEqual,\n  literalNegOne,\n  literalOne,\n  \
literalZero,\n  log,\n  log2,\n  mat2,\n  mat3,\n  mat4,\n  max,\n  min,\n  \
mix,\n  mod,\n  modf,\n  mul,\n  neg,\n  normalize,\n  normalizedDepth,\n  \
not,\n  notEqual,\n  numPackedSplats,\n  numberAsFloat,\n  numberAsInt,\n  \
numberAsUint,\n  or,\n  outer,\n  outputPackedSplat,\n  outputRgba8,\n  \
packHalf2x16,\n  packSnorm2x16,\n  packUnorm2x16,\n  pcgHash,\n  pcgMix,\n  \
pcgNext,\n  pow,\n  projectH,\n  radians,\n  readPackedSplat,\n  \
readPackedSplatRange,\n  reflectVec,\n  refractVec,\n  remapIndex,\n  \
round,\n  sameSizeIvec,\n  sameSizeUvec,\n  sameSizeVec,\n  select,\n  \
sign,\n  sin,\n  sinh,\n  smoothstep,\n  split,\n  splitGsplat,\n  sqr,\n  \
sqrt,\n  step,\n  sub,\n  swizzle,\n  tan,\n  tanh,\n  texelFetch,\n  \
texture,\n  textureSize,\n  transformDir,\n  transformGsplat,\n  \
transformPos,\n  transformQuat,\n  transpose,\n  trunc,\n  typeLiteral,\n  \
uint,\n  uintBitsToFloat,\n  uintToRgba8,\n  uniform,\n  unindent,\n  \
unindentLines,\n  unpackHalf2x16,\n  unpackSnorm2x16,\n  unpackUnorm2x16,\n  \
uvec2,\n  uvec3,\n  uvec4,\n  valType,\n  vec2,\n  vec3,\n  vec4,\n  \
vectorDim,\n  vectorElementType,\n  xor\n}, Symbol.toStringTag, { value: \
\"Module\" }));\nvar computeVec4_default = \"precision highp \
float;\\nprecision highp int;\\nprecision highp sampler2D;\\nprecision highp \
usampler2D;\\nprecision highp isampler2D;\\nprecision highp \
sampler2DArray;\\nprecision highp usampler2DArray;\\nprecision highp \
isampler2DArray;\\nprecision highp sampler3D;\\nprecision highp \
usampler3D;\\nprecision highp isampler3D;\\n\\n#include \
<splatDefines>\\n\\nuniform uint targetLayer;\\nuniform int \
targetBase;\\nuniform int targetCount;\\n\\nout vec4 target;\\n\\n{{ GLOBALS \
}}\\n\\nvoid computeReadback(int index) {\\n    {{ STATEMENTS \
}}\\n}\\n\\nvoid main() {\\n    int targetIndex = int(targetLayer << \
SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + \
int(gl_FragCoord.x);\\n    int index = targetIndex - targetBase;\\n\\n    if \
((index >= 0) && (index < targetCount)) {\\n        \
computeReadback(index);\\n    } else {\\n        target = vec4(0.0, 0.0, 0.0, \
0.0);\\n    }\\n}\";\nconst _Readback = class _Readback {\n  constructor({ \
renderer } = {}) {\n    this.renderer = renderer;\n    this.capacity = 0;\n   \
 this.count = 0;\n  }\n  dispose() {\n    if (this.target) {\n      \
this.target.dispose();\n      this.target = void 0;\n    }\n  }\n  // Ensure \
we have a buffer large enough for the readback of count indices.\n  // Pass \
in previous bufer of the desired type.\n  ensureBuffer(count, buffer) {\n    \
const roundedCount = Math.ceil(Math.max(1, count) / SPLAT_TEX_WIDTH) * \
SPLAT_TEX_WIDTH;\n    const bytes = roundedCount * 4;\n    if \
(buffer.byteLength >= bytes) {\n      return buffer;\n    }\n    const \
newBuffer = new ArrayBuffer(bytes);\n    if (buffer instanceof ArrayBuffer) \
{\n      return newBuffer;\n    }\n    const ctor = buffer.constructor;\n    \
return new ctor(newBuffer);\n  }\n  // Ensure our render target is large \
enough for the readback of capacity indices.\n  ensureCapacity(capacity) {\n  \
  const { width, height, depth, maxSplats } = getTextureSize(capacity);\n    \
if (!this.target || maxSplats > this.capacity) {\n      this.dispose();\n     \
 this.capacity = maxSplats;\n      this.target = new \
THREE.WebGLArrayRenderTarget(width, height, depth, {\n        depthBuffer: \
false,\n        stencilBuffer: false,\n        generateMipmaps: false,\n      \
  magFilter: THREE.NearestFilter,\n        minFilter: THREE.NearestFilter\n   \
   });\n      this.target.texture.format = THREE.RGBAFormat;\n      \
this.target.texture.type = THREE.UnsignedByteType;\n      \
this.target.texture.internalFormat = \"RGBA8\";\n      \
this.target.scissorTest = true;\n    }\n  }\n  // Get a program and \
THREE.RawShaderMaterial for a given Rgba8Readback,\n  // generating it if \
necessary and caching the result.\n  prepareProgramMaterial(reader) {\n    \
let program = _Readback.readbackProgram.get(reader);\n    if (!program) {\n   \
   const graph = dynoBlock(\n        { index: \"int\" },\n        { rgba8: \
\"vec4\" },\n        ({ index }) => {\n          reader.inputs.index = \
index;\n          const rgba8 = new OutputRgba8({ rgba8: reader.outputs.rgba8 \
});\n          return { rgba8 };\n        }\n      );\n      if \
(!_Readback.programTemplate) {\n        _Readback.programTemplate = new \
DynoProgramTemplate(computeVec4_default);\n      }\n      program = new \
DynoProgram({\n        graph,\n        inputs: { index: \"index\" },\n        \
outputs: { rgba8: \"target\" },\n        template: \
_Readback.programTemplate\n      });\n      Object.assign(program.uniforms, \
{\n        targetLayer: { value: 0 },\n        targetBase: { value: 0 },\n    \
    targetCount: { value: 0 }\n      });\n      \
_Readback.readbackProgram.set(reader, program);\n    }\n    const material = \
program.prepareMaterial();\n    _Readback.fullScreenQuad.material = \
material;\n    return { program, material };\n  }\n  \
saveRenderState(renderer) {\n    return {\n      xrEnabled: \
renderer.xr.enabled,\n      autoClear: renderer.autoClear\n    };\n  }\n  \
resetRenderState(renderer, state) {\n    renderer.setRenderTarget(null);\n    \
renderer.xr.enabled = state.xrEnabled;\n    renderer.autoClear = \
state.autoClear;\n  }\n  process({\n    count,\n    material\n  }) {\n    \
const renderer = this.renderer;\n    if (!renderer) {\n      throw new \
Error(\"No renderer\");\n    }\n    if (!this.target) {\n      throw new \
Error(\"No target\");\n    }\n    const layerSize = SPLAT_TEX_WIDTH * \
SPLAT_TEX_HEIGHT;\n    material.uniforms.targetBase.value = 0;\n    \
material.uniforms.targetCount.value = count;\n    let baseIndex = 0;\n    \
while (baseIndex < count) {\n      const layer = Math.floor(baseIndex / \
layerSize);\n      const layerBase = layer * layerSize;\n      const \
layerYEnd = Math.min(\n        SPLAT_TEX_HEIGHT,\n        Math.ceil((count - \
layerBase) / SPLAT_TEX_WIDTH)\n      );\n      \
material.uniforms.targetLayer.value = layer;\n      \
this.target.scissor.set(0, 0, SPLAT_TEX_WIDTH, layerYEnd);\n      \
renderer.setRenderTarget(this.target, layer);\n      renderer.xr.enabled = \
false;\n      renderer.autoClear = false;\n      \
_Readback.fullScreenQuad.render(renderer);\n      baseIndex += \
SPLAT_TEX_WIDTH * layerYEnd;\n    }\n    this.count = count;\n  }\n  async \
read({\n    readback\n  }) {\n    const renderer = this.renderer;\n    if \
(!renderer) {\n      throw new Error(\"No renderer\");\n    }\n    if \
(!this.target) {\n      throw new Error(\"No target\");\n    }\n    const \
roundedCount = Math.ceil(this.count / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n   \
 if (readback.byteLength < roundedCount * 4) {\n      throw new Error(\n      \
  `Readback buffer too small: ${readback.byteLength} < ${roundedCount * 4}`\n \
     );\n    }\n    const readbackUint8 = new Uint8Array(\n      readback \
instanceof ArrayBuffer ? readback : readback.buffer\n    );\n    const \
layerSize = SPLAT_TEX_WIDTH * SPLAT_TEX_HEIGHT;\n    let baseIndex = 0;\n    \
const promises = [];\n    while (baseIndex < this.count) {\n      const layer \
= Math.floor(baseIndex / layerSize);\n      const layerBase = layer * \
layerSize;\n      const layerYEnd = Math.min(\n        SPLAT_TEX_HEIGHT,\n    \
    Math.ceil((this.count - layerBase) / SPLAT_TEX_WIDTH)\n      );\n      \
renderer.setRenderTarget(this.target, layer);\n      const readbackSize = \
SPLAT_TEX_WIDTH * layerYEnd * 4;\n      const subReadback = \
readbackUint8.subarray(\n        layerBase * 4,\n        layerBase * 4 + \
readbackSize\n      );\n      const promise = renderer == null ? void 0 : \
renderer.readRenderTargetPixelsAsync(\n        this.target,\n        0,\n     \
   0,\n        SPLAT_TEX_WIDTH,\n        layerYEnd,\n        subReadback\n    \
  );\n      promises.push(promise);\n      baseIndex += SPLAT_TEX_WIDTH * \
layerYEnd;\n    }\n    return Promise.all(promises).then(() => readback);\n  \
}\n  // Perform render operation to run the Rgba8Readback program\n  // but \
don't perform the readback yet.\n  render({\n    reader,\n    count,\n    \
renderer\n  }) {\n    this.renderer = renderer || this.renderer;\n    if \
(!this.renderer) {\n      throw new Error(\"No renderer\");\n    }\n    \
this.ensureCapacity(count);\n    const { program, material } = \
this.prepareProgramMaterial(reader);\n    program.update();\n    const \
renderState = this.saveRenderState(this.renderer);\n    this.process({ count, \
material });\n    this.resetRenderState(this.renderer, renderState);\n  }\n  \
// Perform a readback of the render target, returning a buffer of the\n  // \
given type.\n  async readback({\n    readback\n  }) {\n    if \
(!this.renderer) {\n      throw new Error(\"No renderer\");\n    }\n    const \
renderState = this.saveRenderState(this.renderer);\n    const promise = \
this.read({ readback });\n    this.resetRenderState(this.renderer, \
renderState);\n    return promise;\n  }\n  // Perform a render and readback \
operation for the given Rgba8Readback,\n  // and readback buffer (call \
ensureBuffer first).\n  async renderReadback({\n    reader,\n    count,\n    \
renderer,\n    readback\n  }) {\n    this.renderer = renderer || \
this.renderer;\n    if (!this.renderer) {\n      throw new Error(\"No \
renderer\");\n    }\n    this.ensureCapacity(count);\n    const { program, \
material } = this.prepareProgramMaterial(reader);\n    program.update();\n    \
const renderState = this.saveRenderState(this.renderer);\n    this.process({ \
count, material });\n    const promise = this.read({ readback });\n    \
this.resetRenderState(this.renderer, renderState);\n    return promise;\n  \
}\n  getTexture() {\n    var _a2;\n    return (_a2 = this.target) == null ? \
void 0 : _a2.texture;\n  }\n};\n_Readback.programTemplate = \
null;\n_Readback.readbackProgram = /* @__PURE__ */ new \
Map();\n_Readback.fullScreenQuad = new FullScreenQuad(\n  new \
THREE.RawShaderMaterial({ visible: false })\n);\nlet Readback = \
_Readback;\nconst _RgbaArray = class _RgbaArray {\n  constructor(options = \
{}) {\n    this.capacity = 0;\n    this.count = 0;\n    this.array = null;\n  \
  this.readback = null;\n    this.source = null;\n    this.needsUpdate = \
true;\n    this.dyno = new DynoUniform({\n      key: \"rgbaArray\",\n      \
type: TRgbaArray,\n      globals: () => [defineRgbaArray],\n      value: {\n  \
      texture: _RgbaArray.getEmpty(),\n        count: 0\n      },\n      \
update: (value) => {\n        var _a2;\n        value.texture = ((_a2 = \
this.readback) == null ? void 0 : _a2.getTexture()) ?? this.source ?? \
_RgbaArray.getEmpty();\n        value.count = this.count;\n        return \
value;\n      }\n    });\n    if (options.array) {\n      this.array = \
options.array;\n      this.capacity = Math.floor(this.array.length / 4);\n    \
  this.capacity = Math.floor(this.capacity / SPLAT_TEX_WIDTH) * \
SPLAT_TEX_WIDTH;\n      this.count = Math.min(\n        this.capacity,\n      \
  options.count ?? Number.POSITIVE_INFINITY\n      );\n    } else {\n      \
this.capacity = options.capacity ?? 0;\n      this.count = 0;\n    }\n  }\n  \
// Free up resources\n  dispose() {\n    if (this.readback) {\n      \
this.readback.dispose();\n      this.readback = null;\n    }\n    if \
(this.source) {\n      this.source.dispose();\n      this.source = null;\n    \
}\n  }\n  // Ensure that our array is large enough to hold capacity RGBA8 \
values.\n  ensureCapacity(capacity) {\n    var _a2;\n    if (!this.array || \
capacity > (((_a2 = this.array) == null ? void 0 : _a2.length) ?? 0) / 4) {\n \
     this.capacity = getTextureSize(capacity).maxSplats;\n      const \
newArray2 = new Uint8Array(this.capacity * 4);\n      if (this.array) {\n     \
   newArray2.set(this.array);\n      }\n      this.array = newArray2;\n    \
}\n    return this.array;\n  }\n  // Get the THREE.DataArrayTexture from \
either the readback or the source.\n  getTexture() {\n    var _a2;\n    let \
texture2 = (_a2 = this.readback) == null ? void 0 : _a2.getTexture();\n    if \
(this.source || this.array) {\n      texture2 = this.maybeUpdateSource();\n   \
 }\n    return texture2 ?? _RgbaArray.getEmpty();\n  }\n  // Create or get a \
THREE.DataArrayTexture from the data array.\n  maybeUpdateSource() {\n    if \
(!this.array) {\n      throw new Error(\"No array\");\n    }\n    if \
(this.needsUpdate || !this.source) {\n      this.needsUpdate = false;\n      \
if (this.source) {\n        const { width, height, depth } = \
this.source.image;\n        if (this.capacity !== width * height * depth) {\n \
         this.source.dispose();\n          this.source = null;\n        }\n   \
   }\n      if (!this.source) {\n        const { width, height, depth } = \
getTextureSize(this.capacity);\n        this.source = new \
THREE.DataArrayTexture(\n          this.array,\n          width,\n          \
height,\n          depth\n        );\n        this.source.format = \
THREE.RGBAFormat;\n        this.source.type = THREE.UnsignedByteType;\n       \
 this.source.internalFormat = \"RGBA8\";\n        this.source.needsUpdate = \
true;\n      } else if (this.array.buffer !== this.source.image.data.buffer) \
{\n        this.source.image.data = new Uint8Array(this.array.buffer);\n      \
}\n      this.source.needsUpdate = true;\n    }\n    return this.source;\n  \
}\n  // Generate the RGBA8 values from a Rgba8Readback dyno program.\n  \
render({\n    reader,\n    count,\n    renderer\n  }) {\n    if \
(!this.readback) {\n      this.readback = new Readback({ renderer });\n    \
}\n    this.readback.render({ reader, count, renderer });\n    this.capacity \
= this.readback.capacity;\n    this.count = this.readback.count;\n  }\n  // \
Extract the RGBA8 values from a PackedSplats collection.\n  \
fromPackedSplats({\n    packedSplats,\n    base,\n    count,\n    renderer\n  \
}) {\n    const { dynoSplats, dynoBase, dynoCount, reader } = \
_RgbaArray.makeDynos();\n    dynoSplats.packedSplats = packedSplats;\n    \
dynoBase.value = base;\n    dynoCount.value = count;\n    this.render({ \
reader, count, renderer });\n    return this;\n  }\n  // Read back the RGBA8 \
values from the readback buffer.\n  async read() {\n    if (!this.readback) \
{\n      throw new Error(\"No readback\");\n    }\n    if (!this.array || \
this.array.length < this.count * 4) {\n      this.array = new \
Uint8Array(this.capacity * 4);\n    }\n    const result = await \
this.readback.readback({ readback: this.array });\n    return \
result.subarray(0, this.count * 4);\n  }\n  // Can be used where you need an \
uninitialized THREE.DataArrayTexture like\n  // a uniform you will update \
with the result of this.getTexture() later.\n  static getEmpty() {\n    if \
(!_RgbaArray.emptySource) {\n      const emptyArray = new Uint8Array(1 * \
4);\n      _RgbaArray.emptySource = new THREE.DataArrayTexture(emptyArray, 1, \
1, 1);\n      _RgbaArray.emptySource.format = THREE.RGBAFormat;\n      \
_RgbaArray.emptySource.type = THREE.UnsignedByteType;\n      \
_RgbaArray.emptySource.internalFormat = \"RGBA8\";\n      \
_RgbaArray.emptySource.needsUpdate = true;\n    }\n    return \
_RgbaArray.emptySource;\n  }\n  // Create a dyno program that can extract \
RGBA8 values from a PackedSplats\n  static makeDynos() {\n    if \
(!_RgbaArray.dynos) {\n      const dynoSplats = new DynoPackedSplats();\n     \
 const dynoBase = new DynoInt({ value: 0 });\n      const dynoCount = new \
DynoInt({ value: 0 });\n      const reader = dynoBlock(\n        { index: \
\"int\" },\n        { rgba8: \"vec4\" },\n        ({ index }) => {\n          \
if (!index) {\n            throw new Error(\"index is undefined\");\n         \
 }\n          index = add(index, dynoBase);\n          const gsplat = \
readPackedSplatRange(\n            dynoSplats,\n            index,\n          \
  dynoBase,\n            dynoCount\n          );\n          return { rgba8: \
splitGsplat(gsplat).outputs.rgba };\n        }\n      );\n      \
_RgbaArray.dynos = { dynoSplats, dynoBase, dynoCount, reader };\n    }\n    \
return _RgbaArray.dynos;\n  }\n};\n_RgbaArray.emptySource = \
null;\n_RgbaArray.dynos = null;\nlet RgbaArray = _RgbaArray;\nconst \
TRgbaArray = { type: \"RgbaArray\" };\nconst defineRgbaArray = unindent(`\n  \
struct RgbaArray {\n    sampler2DArray texture;\n    int count;\n  \
};\n`);\nfunction readRgbaArray(rgba, index) {\n  const dyno2 = new Dyno({\n  \
  inTypes: { rgba: TRgbaArray, index: \"int\" },\n    outTypes: { rgba: \
\"vec4\" },\n    inputs: { rgba, index },\n    globals: () => \
[defineRgbaArray],\n    statements: ({ inputs, outputs }) => \
unindentLines(`\n        if ((index >= 0) && (index < ${inputs.rgba}.count)) \
{\n          ${outputs.rgba} = texelFetch(${inputs.rgba}.texture, \
splatTexCoord(index), 0);\n        } else {\n          ${outputs.rgba} = \
vec4(0.0, 0.0, 0.0, 0.0);\n        }\n      `)\n  });\n  return \
dyno2.outputs.rgba;\n}\nvar SplatEditSdfType = /* @__PURE__ */ \
((SplatEditSdfType2) => {\n  SplatEditSdfType2[\"ALL\"] = \"all\";\n  \
SplatEditSdfType2[\"PLANE\"] = \"plane\";\n  SplatEditSdfType2[\"SPHERE\"] = \
\"sphere\";\n  SplatEditSdfType2[\"BOX\"] = \"box\";\n  \
SplatEditSdfType2[\"ELLIPSOID\"] = \"ellipsoid\";\n  \
SplatEditSdfType2[\"CYLINDER\"] = \"cylinder\";\n  \
SplatEditSdfType2[\"CAPSULE\"] = \"capsule\";\n  \
SplatEditSdfType2[\"INFINITE_CONE\"] = \"infinite_cone\";\n  return \
SplatEditSdfType2;\n})(SplatEditSdfType || {});\nfunction \
sdfTypeToNumber(type) {\n  switch (type) {\n    case \"all\":\n      return \
0;\n    case \"plane\":\n      return 1;\n    case \"sphere\":\n      return \
2;\n    case \"box\":\n      return 3;\n    case \"ellipsoid\":\n      return \
4;\n    case \"cylinder\":\n      return 5;\n    case \"capsule\":\n      \
return 6;\n    case \"infinite_cone\":\n      return 7;\n    default:\n      \
throw new Error(`Unknown SDF type: ${type}`);\n  }\n}\nvar \
SplatEditRgbaBlendMode = /* @__PURE__ */ ((SplatEditRgbaBlendMode2) => {\n  \
SplatEditRgbaBlendMode2[\"MULTIPLY\"] = \"multiply\";\n  \
SplatEditRgbaBlendMode2[\"SET_RGB\"] = \"set_rgb\";\n  \
SplatEditRgbaBlendMode2[\"ADD_RGBA\"] = \"add_rgba\";\n  return \
SplatEditRgbaBlendMode2;\n})(SplatEditRgbaBlendMode || {});\nfunction \
rgbaBlendModeToNumber(mode) {\n  switch (mode) {\n    case \"multiply\":\n    \
  return 0;\n    case \"set_rgb\":\n      return 1;\n    case \"add_rgba\":\n \
     return 2;\n    default:\n      throw new Error(`Unknown blend mode: \
${mode}`);\n  }\n}\nclass SplatEditSdf extends THREE.Object3D {\n  \
constructor(options = {}) {\n    super();\n    const { type, invert, opacity, \
color, displace, radius } = options;\n    this.type = type ?? \"sphere\";\n   \
 this.invert = invert ?? false;\n    this.opacity = opacity ?? 1;\n    \
this.color = color ?? new THREE.Color(1, 1, 1);\n    this.displace = displace \
?? new THREE.Vector3(0, 0, 0);\n    this.radius = radius ?? 0;\n  }\n}\nconst \
_SplatEdit = class _SplatEdit extends THREE.Object3D {\n  constructor(options \
= {}) {\n    const {\n      name,\n      rgbaBlendMode = \"multiply\",\n      \
sdfSmooth = 0,\n      softEdge = 0,\n      invert = false,\n      sdfs = \
null\n    } = options;\n    super();\n    this.rgbaBlendMode = \
rgbaBlendMode;\n    this.sdfSmooth = sdfSmooth;\n    this.softEdge = \
softEdge;\n    this.invert = invert;\n    this.sdfs = sdfs;\n    \
this.ordering = _SplatEdit.nextOrdering++;\n    this.name = name ?? `Edit \
${this.ordering}`;\n  }\n  addSdf(sdf) {\n    if (this.sdfs == null) {\n      \
this.sdfs = [];\n    }\n    if (!this.sdfs.includes(sdf)) {\n      \
this.sdfs.push(sdf);\n    }\n  }\n  removeSdf(sdf) {\n    if (this.sdfs == \
null) {\n      return;\n    }\n    this.sdfs = this.sdfs.filter((s) => s !== \
sdf);\n  }\n};\n_SplatEdit.nextOrdering = 1;\nlet SplatEdit = \
_SplatEdit;\nclass SplatEdits {\n  constructor({ maxSdfs, maxEdits }) {\n    \
this.maxSdfs = Math.max(16, maxSdfs ?? 0);\n    this.numSdfs = 0;\n    \
this.sdfData = new Uint32Array(this.maxSdfs * 8 * 4);\n    this.sdfFloatData \
= new Float32Array(this.sdfData.buffer);\n    this.sdfTexture = \
this.newSdfTexture(this.sdfData, this.maxSdfs);\n    this.dynoSdfArray = new \
DynoUniform({\n      key: \"sdfArray\",\n      type: SdfArray,\n      \
globals: () => [defineSdfArray],\n      value: {\n        numSdfs: 0,\n       \
 sdfTexture: this.sdfTexture\n      },\n      update: (uniform2) => {\n       \
 uniform2.numSdfs = this.numSdfs;\n        uniform2.sdfTexture = \
this.sdfTexture;\n        return uniform2;\n      }\n    });\n    \
this.maxEdits = Math.max(16, maxEdits ?? 0);\n    this.numEdits = 0;\n    \
this.editData = new Uint32Array(this.maxEdits * 4);\n    this.editFloatData = \
new Float32Array(this.editData.buffer);\n    this.dynoNumEdits = new \
DynoInt({ value: 0 });\n    this.dynoEdits = this.newEdits(this.editData, \
this.maxEdits);\n  }\n  newSdfTexture(data, maxSdfs) {\n    const texture2 = \
new THREE.DataTexture(\n      data,\n      8,\n      maxSdfs,\n      \
THREE.RGBAIntegerFormat,\n      THREE.UnsignedIntType\n    );\n    \
texture2.internalFormat = \"RGBA32UI\";\n    texture2.needsUpdate = true;\n   \
 return texture2;\n  }\n  newEdits(data, maxEdits) {\n    return new \
DynoUniform({\n      key: \"edits\",\n      type: \"uvec4\",\n      count: \
maxEdits,\n      globals: () => [defineEdit],\n      value: data\n    });\n  \
}\n  // Ensure our SDF texture and edits uniform array have enough \
capacity.\n  // Reallocate if not.\n  ensureCapacity({\n    maxSdfs,\n    \
maxEdits\n  }) {\n    let dynoUpdated = false;\n    if (maxSdfs > \
this.sdfTexture.image.height) {\n      this.sdfTexture.dispose();\n      \
this.maxSdfs = Math.max(this.maxSdfs * 2, maxSdfs);\n      this.sdfData = new \
Uint32Array(this.maxSdfs * 8 * 4);\n      this.sdfFloatData = new \
Float32Array(this.sdfData.buffer);\n      this.sdfTexture = \
this.newSdfTexture(this.sdfData, this.maxSdfs);\n    }\n    if (maxEdits > \
(this.dynoEdits.count ?? 0)) {\n      this.maxEdits = Math.max(this.maxEdits \
* 2, maxEdits);\n      this.editData = new Uint32Array(this.maxEdits * 4);\n  \
    this.editFloatData = new Float32Array(this.editData.buffer);\n      \
this.dynoEdits = this.newEdits(this.editData, this.maxEdits);\n      \
dynoUpdated = true;\n    }\n    return dynoUpdated;\n  }\n  \
updateEditData(offset, value) {\n    const updated = this.editData[offset] \
!== value;\n    this.editData[offset] = value;\n    return updated;\n  }\n  \
updateEditFloatData(offset, value) {\n    tempFloat32[0] = value;\n    const \
updated = this.editFloatData[offset] !== tempFloat32[0];\n    if (updated) \
{\n      this.editFloatData[offset] = tempFloat32[0];\n    }\n    return \
updated;\n  }\n  encodeEdit(editIndex, {\n    sdfFirst,\n    sdfCount,\n    \
invert,\n    rgbaBlendMode,\n    softEdge,\n    sdfSmooth\n  }) {\n    const \
base = editIndex * 4;\n    let updated = false;\n    updated = \
this.updateEditData(base + 0, rgbaBlendMode | (invert ? 1 << 8 : 0)) || \
updated;\n    updated = this.updateEditData(base + 1, sdfFirst | sdfCount << \
16) || updated;\n    updated = this.updateEditFloatData(base + 2, softEdge) \
|| updated;\n    updated = this.updateEditFloatData(base + 3, sdfSmooth) || \
updated;\n    return updated;\n  }\n  updateSdfData(offset, value) {\n    \
const updated = this.sdfData[offset] !== value;\n    this.sdfData[offset] = \
value;\n    return updated;\n  }\n  updateSdfFloatData(offset, value) {\n    \
tempFloat32[0] = value;\n    const updated = this.sdfFloatData[offset] !== \
tempFloat32[0];\n    if (updated) {\n      this.sdfFloatData[offset] = \
tempFloat32[0];\n    }\n    return updated;\n  }\n  encodeSdf(sdfIndex, {\n   \
 sdfType,\n    invert,\n    center,\n    quaternion,\n    scale,\n    sizes\n \
 }, values) {\n    const base = sdfIndex * (8 * 4);\n    const flags = \
sdfType | (invert ? 1 << 8 : 0);\n    let updated = false;\n    updated = \
this.updateSdfFloatData(base + 0, (center == null ? void 0 : center.x) ?? 0) \
|| updated;\n    updated = this.updateSdfFloatData(base + 1, (center == null \
? void 0 : center.y) ?? 0) || updated;\n    updated = \
this.updateSdfFloatData(base + 2, (center == null ? void 0 : center.z) ?? 0) \
|| updated;\n    updated = this.updateSdfData(base + 3, flags) || updated;\n  \
  updated = this.updateSdfFloatData(base + 4, (quaternion == null ? void 0 : \
quaternion.x) ?? 0) || updated;\n    updated = this.updateSdfFloatData(base + \
5, (quaternion == null ? void 0 : quaternion.y) ?? 0) || updated;\n    \
updated = this.updateSdfFloatData(base + 6, (quaternion == null ? void 0 : \
quaternion.z) ?? 0) || updated;\n    updated = this.updateSdfFloatData(base + \
7, (quaternion == null ? void 0 : quaternion.w) ?? 0) || updated;\n    \
updated = this.updateSdfFloatData(base + 8, (scale == null ? void 0 : \
scale.x) ?? 0) || updated;\n    updated = this.updateSdfFloatData(base + 9, \
(scale == null ? void 0 : scale.y) ?? 0) || updated;\n    updated = \
this.updateSdfFloatData(base + 10, (scale == null ? void 0 : scale.z) ?? 0) \
|| updated;\n    updated = this.updateSdfData(base + 11, 0) || updated;\n    \
updated = this.updateSdfFloatData(base + 12, (sizes == null ? void 0 : \
sizes.x) ?? 0) || updated;\n    updated = this.updateSdfFloatData(base + 13, \
(sizes == null ? void 0 : sizes.y) ?? 0) || updated;\n    updated = \
this.updateSdfFloatData(base + 14, (sizes == null ? void 0 : sizes.z) ?? 0) \
|| updated;\n    updated = this.updateSdfFloatData(base + 15, (sizes == null \
? void 0 : sizes.w) ?? 0) || updated;\n    const nValues = Math.min(4, \
values.length);\n    for (let i = 0; i < nValues; ++i) {\n      const vBase = \
base + 16 + i * 4;\n      updated = this.updateSdfFloatData(vBase + 0, \
values[i].x) || updated;\n      updated = this.updateSdfFloatData(vBase + 1, \
values[i].y) || updated;\n      updated = this.updateSdfFloatData(vBase + 2, \
values[i].z) || updated;\n      updated = this.updateSdfFloatData(vBase + 3, \
values[i].w) || updated;\n    }\n    return updated;\n  }\n  // Update the \
SDFs and edits from an array of SplatEdits and their\n  // associated \
SplatEditSdfs, updating it for the dyno shader program.\n  update(edits) {\n  \
  const sdfCount = edits.reduce((total, { sdfs }) => total + sdfs.length, \
0);\n    const dynoUpdated = this.ensureCapacity({\n      maxEdits: \
edits.length,\n      maxSdfs: sdfCount\n    });\n    const values = [new \
THREE.Vector4(), new THREE.Vector4()];\n    const center = new \
THREE.Vector3();\n    const quaternion = new THREE.Quaternion();\n    const \
scale = new THREE.Vector3();\n    const sizes = new THREE.Vector4();\n    let \
sdfIndex = 0;\n    let updated = dynoUpdated;\n    if (edits.length !== \
this.dynoNumEdits.value) {\n      this.dynoNumEdits.value = edits.length;\n   \
   this.numEdits = edits.length;\n      updated = true;\n    }\n    for \
(const [editIndex, { edit, sdfs }] of edits.entries()) {\n      updated = \
this.encodeEdit(editIndex, {\n        sdfFirst: sdfIndex,\n        sdfCount: \
sdfs.length,\n        invert: edit.invert,\n        rgbaBlendMode: \
rgbaBlendModeToNumber(edit.rgbaBlendMode),\n        softEdge: \
edit.softEdge,\n        sdfSmooth: edit.sdfSmooth\n      }) || updated;\n     \
 let sdfUpdated = false;\n      for (const sdf of sdfs) {\n        \
sizes.set(sdf.scale.x, sdf.scale.y, sdf.scale.z, sdf.radius);\n        \
sdf.scale.setScalar(1);\n        sdf.updateMatrixWorld();\n        const \
worldToSdf = sdf.matrixWorld.clone().invert();\n        \
worldToSdf.decompose(center, quaternion, scale);\n        \
sdf.scale.set(sizes.x, sizes.y, sizes.z);\n        sdf.updateMatrixWorld();\n \
       values[0].set(sdf.color.r, sdf.color.g, sdf.color.b, sdf.opacity);\n   \
     values[1].set(sdf.displace.x, sdf.displace.y, sdf.displace.z, 1);\n      \
  sdfUpdated = this.encodeSdf(\n          sdfIndex,\n          {\n            \
sdfType: sdfTypeToNumber(sdf.type),\n            invert: sdf.invert,\n        \
    center,\n            quaternion,\n            scale,\n            sizes\n \
         },\n          values\n        ) || sdfUpdated;\n        sdfIndex += \
1;\n      }\n      this.numSdfs = sdfIndex;\n      if (sdfUpdated) {\n        \
this.sdfTexture.needsUpdate = true;\n      }\n      updated || (updated = \
sdfUpdated);\n    }\n    return { updated, dynoUpdated };\n  }\n  // Modify a \
Gsplat in a dyno shader program using the current edits and SDFs.\n  \
modify(gsplat) {\n    return applyGsplatRgbaDisplaceEdits(\n      gsplat,\n   \
   this.dynoSdfArray,\n      this.dynoNumEdits,\n      this.dynoEdits\n    \
);\n  }\n}\nconst SdfArray = { type: \"SdfArray\" };\nconst defineSdfArray = \
unindent(`\n  struct SdfArray {\n    int numSdfs;\n    usampler2D \
sdfTexture;\n  };\n\n  void unpackSdfArray(\n    usampler2D sdfTexture, int \
sdfIndex, out uint flags,\n    out vec3 center, out vec4 quaternion, out vec3 \
scale, out vec4 sizes,\n    int numValues, out vec4 values[4]\n  ) {\n    \
uvec4 temp = texelFetch(sdfTexture, ivec2(0, sdfIndex), 0);\n    flags = \
temp.w;\n    center = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), \
uintBitsToFloat(temp.z));\n\n    temp = texelFetch(sdfTexture, ivec2(1, \
sdfIndex), 0);\n    quaternion = vec4(uintBitsToFloat(temp.x), \
uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), \
uintBitsToFloat(temp.w));\n\n    temp = texelFetch(sdfTexture, ivec2(2, \
sdfIndex), 0);\n    scale = vec3(uintBitsToFloat(temp.x), \
uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));\n\n    temp = \
texelFetch(sdfTexture, ivec2(3, sdfIndex), 0);\n    sizes = \
vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), \
uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n\n    for (int i = 0; i < \
numValues; ++i) {\n      temp = texelFetch(sdfTexture, ivec2(4 + i, \
sdfIndex), 0);\n      values[i] = vec4(uintBitsToFloat(temp.x), \
uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n \
   }\n  }\n\n  const uint SDF_FLAG_TYPE = 0xFFu;\n  const uint \
SDF_FLAG_INVERT = 1u << 8u;\n\n  const uint SDF_TYPE_ALL = 0u;\n  const uint \
SDF_TYPE_PLANE = 1u;\n  const uint SDF_TYPE_SPHERE = 2u;\n  const uint \
SDF_TYPE_BOX = 3u;\n  const uint SDF_TYPE_ELLIPSOID = 4u;\n  const uint \
SDF_TYPE_CYLINDER = 5u;\n  const uint SDF_TYPE_CAPSULE = 6u;\n  const uint \
SDF_TYPE_INFINITE_CONE = 7u;\n\n  float evaluateSdfArray(\n    usampler2D \
sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,\n    float \
smoothK, int numValues, out vec4 outValues[4]\n  ) {\n    float distanceAccum \
= (smoothK == 0.0) ? 1.0 / 0.0 : 0.0;\n    float maxExp = -1.0 / 0.0;\n    \
for (int i = 0; i < numValues; ++i) {\n        outValues[i] = vec4(0.0);\n    \
}\n\n    uint flags;\n    vec3 center, scale;\n    vec4 quaternion, sizes;\n  \
  vec4 values[4];\n\n    int sdfLast = min(sdfFirst + sdfCount, numSdfs);\n   \
 for (int index = sdfFirst; index < sdfLast; ++index) {\n      \
unpackSdfArray(sdfTexture, index, flags, center, quaternion, scale, sizes, \
numValues, values);\n      uint sdfType = flags & SDF_FLAG_TYPE;\n      vec3 \
sdfPos = quatVec(quaternion, pos * scale) + center;\n\n      float \
distance;\n      switch (sdfType) {\n        case SDF_TYPE_ALL:\n          \
distance = -1.0 / 0.0;\n          break;\n        case SDF_TYPE_PLANE: {\n    \
      distance = sdfPos.z;\n          break;\n        }\n        case \
SDF_TYPE_SPHERE: {\n          distance = length(sdfPos) - sizes.w;\n          \
break;\n        }\n        case SDF_TYPE_BOX: {\n          vec3 q = \
abs(sdfPos) - sizes.xyz + sizes.w;\n          distance = length(max(q, 0.0)) \
+ min(max(q.x, max(q.y, q.z)), 0.0) - sizes.w;\n          break;\n        }\n \
       case SDF_TYPE_ELLIPSOID: {\n          vec3 sizes = sizes.xyz;\n        \
  float k0 = length(sdfPos / sizes);\n          float k1 = length(sdfPos / \
dot(sizes, sizes));\n          distance = k0 * (k0 - 1.0) / k1;\n          \
break;\n        }\n        case SDF_TYPE_CYLINDER: {\n          vec2 d = \
abs(vec2(length(sdfPos.xz), sdfPos.y)) - sizes.wy;\n          distance = \
min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n          break;\n        }\n \
       case SDF_TYPE_CAPSULE: {\n          sdfPos.y -= clamp(sdfPos.y, -0.5 * \
sizes.y, 0.5 * sizes.y);\n          distance = length(sdfPos) - sizes.w;\n    \
      break;\n        }\n        case SDF_TYPE_INFINITE_CONE: {\n          \
float angle = 0.25 * PI * sizes.w;\n          vec2 c = vec2(sin(angle), \
cos(angle));\n          vec2 q = vec2(length(sdfPos.xy), -sdfPos.z);\n        \
  float d = length(q - c * max(dot(q, c), 0.0));\n          distance = d * \
(((q.x * c.y - q.y * c.x) < 0.0) ? -1.0 : 1.0);\n          break;\n        \
}\n      }\n\n      if ((flags & SDF_FLAG_INVERT) != 0u) {\n        distance \
= -distance;\n      }\n\n      if (smoothK == 0.0) {\n        if (distance < \
distanceAccum) {\n          distanceAccum = distance;\n          for (int i = \
0; i < numValues; ++i) {\n            outValues[i] = values[i];\n          \
}\n        }\n      } else {\n        float scaledDistance = -distance / \
smoothK;\n        if (scaledDistance > maxExp) {\n          float scale = \
exp(maxExp - scaledDistance);\n          distanceAccum *= scale;\n          \
for (int i = 0; i < numValues; ++i) {\n            outValues[i] *= scale;\n   \
       }\n          maxExp = scaledDistance;\n        }\n\n        float \
weight = exp(scaledDistance - maxExp);\n        distanceAccum += weight;\n    \
    for (int i = 0; i < numValues; ++i) {\n          outValues[i] += weight * \
values[i];\n        }\n      }\n    }\n\n    if (smoothK == 0.0) {\n      \
return distanceAccum;\n    } else {\n      // Very distant SDFs may result in \
0 accumulation\n      if (distanceAccum == 0.0) {\n        return 1.0 / \
0.0;\n      }\n      for (int i = 0; i < numValues; ++i) {\n        \
outValues[i] /= distanceAccum;\n      }\n      return (-log(distanceAccum) - \
maxExp) * smoothK;\n    }\n  }\n\n  float modulateSdfArray(\n    usampler2D \
sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,\n    float \
smoothK, int numValues, out vec4 values[4],\n    float softEdge, bool \
invert\n  ) {\n    float distance = evaluateSdfArray(sdfTexture, numSdfs, \
sdfFirst, sdfCount, pos, smoothK, numValues, values);\n    if (invert) {\n    \
  distance = -distance;\n    }\n\n    return (softEdge == 0.0) ? ((distance < \
0.0) ? 1.0 : 0.0)\n      : clamp(-distance / softEdge + 0.5, 0.0, 1.0);\n  \
}\n`);\nconst defineEdit = unindent(`\n  const uint EDIT_FLAG_BLEND = \
0xFFu;\n  const uint EDIT_BLEND_MULTIPLY = 0u;\n  const uint \
EDIT_BLEND_SET_RGB = 1u;\n  const uint EDIT_BLEND_ADD_RGBA = 2u;\n  const \
uint EDIT_FLAG_INVERT = 0x100u;\n\n  void decodeEdit(\n    uvec4 packedEdit, \
out int sdfFirst, out int sdfCount,\n    out bool invert, out uint \
rgbaBlendMode, out float softEdge, out float sdfSmooth\n  ) {\n    \
rgbaBlendMode = packedEdit.x & EDIT_FLAG_BLEND;\n    invert = (packedEdit.x & \
EDIT_FLAG_INVERT) != 0u;\n\n    sdfFirst = int(packedEdit.y & 0xFFFFu);\n    \
sdfCount = int(packedEdit.y >> 16u);\n\n    softEdge = \
uintBitsToFloat(packedEdit.z);\n    sdfSmooth = \
uintBitsToFloat(packedEdit.w);\n  }\n\n  void applyRgbaDisplaceEdit(\n    \
usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, inout vec3 \
pos,\n    float smoothK, float softEdge, bool invert, uint rgbaBlendMode, \
inout vec4 rgba\n  ) {\n    vec4 values[4];\n    float modulate = \
modulateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, 2, \
values, softEdge, invert);\n    // On Android, moving values[0] is necessary \
to work around a compiler bug.\n    vec4 sdfRgba = values[0];\n    vec4 \
sdfDisplaceScale = values[1];\n\n    vec4 target;\n    switch (rgbaBlendMode) \
{\n      case EDIT_BLEND_MULTIPLY:\n        target = rgba * sdfRgba;\n        \
break;\n      case EDIT_BLEND_SET_RGB:\n        target = vec4(sdfRgba.rgb, \
rgba.a * sdfRgba.a);\n        break;\n      case EDIT_BLEND_ADD_RGBA:\n       \
 target = rgba + sdfRgba;\n        break;\n      default:\n        // Debug \
output if blend mode not set\n        target = vec4(fract(pos), 1.0);\n    \
}\n    rgba = mix(rgba, target, modulate);\n    pos += sdfDisplaceScale.xyz * \
modulate;\n  }\n\n  void applyPackedRgbaDisplaceEdit(uvec4 packedEdit, \
usampler2D sdfTexture, int numSdfs, inout vec3 pos, inout vec4 rgba) {\n    \
int sdfFirst, sdfCount;\n    bool invert;\n    uint rgbaBlendMode;\n    float \
softEdge, sdfSmooth;\n    decodeEdit(packedEdit, sdfFirst, sdfCount, invert, \
rgbaBlendMode, softEdge, sdfSmooth);\n    applyRgbaDisplaceEdit(sdfTexture, \
numSdfs, sdfFirst, sdfCount, pos, sdfSmooth, softEdge, invert, rgbaBlendMode, \
rgba);\n  }\n`);\nfunction applyGsplatRgbaDisplaceEdits(gsplat, sdfArray, \
numEdits, rgbaDisplaceEdits) {\n  const dyno2 = new Dyno({\n    inTypes: {\n  \
    gsplat: Gsplat,\n      sdfArray: SdfArray,\n      numEdits: \"int\",\n    \
  rgbaDisplaceEdits: \"uvec4\"\n    },\n    outTypes: { gsplat: Gsplat },\n   \
 globals: () => [defineSdfArray, defineEdit],\n    inputs: { gsplat, \
sdfArray, numEdits, rgbaDisplaceEdits },\n    statements: ({ inputs, outputs \
}) => {\n      const { sdfArray: sdfArray2, numEdits: numEdits2, \
rgbaDisplaceEdits: rgbaDisplaceEdits2 } = inputs;\n      const { gsplat: \
gsplat2 } = outputs;\n      return unindentLines(`\n        ${gsplat2} = \
${inputs.gsplat};\n        if (isGsplatActive(${gsplat2}.flags)) {\n          \
for (int editIndex = 0; editIndex < ${numEdits2}; ++editIndex) {\n            \
applyPackedRgbaDisplaceEdit(\n              ${rgbaDisplaceEdits2}[editIndex], \
${sdfArray2}.sdfTexture, ${sdfArray2}.numSdfs,\n              \
${gsplat2}.center, ${gsplat2}.rgba\n            );\n          }\n        }\n  \
    `);\n    }\n  });\n  return dyno2.outputs.gsplat;\n}\nconst tempFloat32 = \
new Float32Array(1);\nclass SplatModifier {\n  constructor(modifier) {\n    \
this.modifier = modifier;\n    this.cache = /* @__PURE__ */ new Map();\n  }\n \
 apply(generator) {\n    let modified = this.cache.get(generator);\n    if \
(!modified) {\n      modified = dynoBlock(\n        { index: \"int\" },\n     \
   { gsplat: Gsplat },\n        ({ index }) => {\n          const { gsplat } \
= generator.apply({ index });\n          return this.modifier.apply({ gsplat \
});\n        }\n      );\n      this.cache.set(generator, modified);\n    }\n \
   return modified;\n  }\n}\nclass SplatTransformer {\n  // Create the dyno \
uniforms that parameterize the transform, setting them\n  // to initial \
values that are different from any valid transform.\n  constructor() {\n    \
this.scale = new DynoFloat({ value: Number.NEGATIVE_INFINITY });\n    \
this.rotate = new DynoVec4({\n      value: new THREE.Quaternion(\n        \
Number.POSITIVE_INFINITY,\n        Number.POSITIVE_INFINITY,\n        \
Number.POSITIVE_INFINITY,\n        Number.POSITIVE_INFINITY\n      )\n    \
});\n    this.translate = new DynoVec3({\n      value: new THREE.Vector3(\n   \
     Number.POSITIVE_INFINITY,\n        Number.POSITIVE_INFINITY,\n        \
Number.POSITIVE_INFINITY\n      )\n    });\n  }\n  // Apply the transform to \
a Vec3 position in a dyno program.\n  apply(position) {\n    return \
transformPos(position, {\n      scale: this.scale,\n      rotate: \
this.rotate,\n      translate: this.translate\n    });\n  }\n  applyDir(dir) \
{\n    return transformDir(dir, {\n      rotate: this.rotate\n    });\n  }\n  \
// Apply the transform to a Gsplat in a dyno program.\n  applyGsplat(gsplat) \
{\n    return transformGsplat(gsplat, {\n      scale: this.scale,\n      \
rotate: this.rotate,\n      translate: this.translate\n    });\n  }\n  // \
Update the uniforms to match the given transform matrix.\n  \
updateFromMatrix(transform) {\n    const scale = new THREE.Vector3();\n    \
const quaternion = new THREE.Quaternion();\n    const position = new \
THREE.Vector3();\n    transform.decompose(position, quaternion, scale);\n    \
const newScale = (scale.x + scale.y + scale.z) / 3;\n    let updated = \
false;\n    if (newScale !== this.scale.value) {\n      this.scale.value = \
newScale;\n      updated = true;\n    }\n    if \
(!position.equals(this.translate.value)) {\n      \
this.translate.value.copy(position);\n      updated = true;\n    }\n    if \
(!quaternion.equals(this.rotate.value)) {\n      \
this.rotate.value.copy(quaternion);\n      updated = true;\n    }\n    return \
updated;\n  }\n  // Update this transform to match the object's to-world \
transform.\n  update(object) {\n    object.updateMatrixWorld();\n    return \
this.updateFromMatrix(object.matrixWorld);\n  }\n}\nclass SplatGenerator \
extends THREE.Object3D {\n  constructor({\n    numSplats,\n    generator,\n   \
 construct,\n    update\n  }) {\n    super();\n    this.numSplats = numSplats \
?? 0;\n    this.generator = generator;\n    this.frameUpdate = update;\n    \
this.version = 0;\n    if (construct) {\n      const constructed = \
construct(this);\n      Object.assign(this, constructed);\n    }\n  }\n  \
updateVersion() {\n    this.version += 1;\n  }\n  set needsUpdate(value) {\n  \
  if (value) {\n      this.updateVersion();\n    }\n  }\n}\nconst _SplatMesh \
= class _SplatMesh extends SplatGenerator {\n  constructor(options = {}) {\n  \
  const transform = new SplatTransformer();\n    const viewToWorld = new \
SplatTransformer();\n    const worldToView = new SplatTransformer();\n    \
const viewToObject = new SplatTransformer();\n    const recolor = new \
DynoVec4({\n      value: new THREE.Vector4(\n        \
Number.NEGATIVE_INFINITY,\n        Number.NEGATIVE_INFINITY,\n        \
Number.NEGATIVE_INFINITY,\n        Number.NEGATIVE_INFINITY\n      )\n    \
});\n    const time = new DynoFloat({ value: 0 });\n    const deltaTime = new \
DynoFloat({ value: 0 });\n    const context = {\n      transform,\n      \
viewToWorld,\n      worldToView,\n      viewToObject,\n      recolor,\n      \
time,\n      deltaTime\n    };\n    super({\n      update: ({ time: time2, \
deltaTime: deltaTime2, viewToWorld: viewToWorld2, globalEdits }) => \
this.update({ time: time2, deltaTime: deltaTime2, viewToWorld: viewToWorld2, \
globalEdits })\n    });\n    this.isInitialized = false;\n    this.recolor = \
new THREE.Color(1, 1, 1);\n    this.opacity = 1;\n    this.enableViewToObject \
= false;\n    this.enableViewToWorld = false;\n    this.enableWorldToView = \
false;\n    this.skinning = null;\n    this.edits = null;\n    \
this.rgbaDisplaceEdits = null;\n    this.splatRgba = null;\n    this.maxSh = \
3;\n    this.packedSplats = options.packedSplats ?? new PackedSplats();\n    \
this.packedSplats.splatEncoding = options.splatEncoding ?? {\n      \
...DEFAULT_SPLAT_ENCODING\n    };\n    this.numSplats = \
this.packedSplats.numSplats;\n    this.editable = options.editable ?? true;\n \
   this.onFrame = options.onFrame;\n    this.context = context;\n    \
this.objectModifier = options.objectModifier;\n    this.worldModifier = \
options.worldModifier;\n    this.updateGenerator();\n    if (options.url || \
options.fileBytes || options.constructSplats || options.packedSplats && \
!options.packedSplats.isInitialized) {\n      this.initialized = \
this.asyncInitialize(options).then(async () => {\n        \
this.updateGenerator();\n        this.isInitialized = true;\n        if \
(options.onLoad) {\n          const maybePromise = options.onLoad(this);\n    \
      if (maybePromise instanceof Promise) {\n            await \
maybePromise;\n          }\n        }\n        return this;\n      });\n    } \
else {\n      this.isInitialized = true;\n      this.initialized = \
Promise.resolve(this);\n      if (options.onLoad) {\n        const \
maybePromise = options.onLoad(this);\n        if (maybePromise instanceof \
Promise) {\n          this.initialized = maybePromise.then(() => this);\n     \
   }\n      }\n    }\n    this.add(createRendererDetectionMesh());\n  }\n  \
async asyncInitialize(options) {\n    const {\n      url,\n      fileBytes,\n \
     fileType,\n      fileName,\n      maxSplats,\n      constructSplats,\n   \
   splatEncoding\n    } = options;\n    if (url || fileBytes || \
constructSplats) {\n      const packedSplatsOptions = {\n        url,\n       \
 fileBytes,\n        fileType,\n        fileName,\n        maxSplats,\n       \
 construct: constructSplats,\n        splatEncoding\n      };\n      \
this.packedSplats.reinitialize(packedSplatsOptions);\n    }\n    if \
(this.packedSplats) {\n      await this.packedSplats.initialized;\n      \
this.numSplats = this.packedSplats.numSplats;\n      \
this.updateGenerator();\n    }\n  }\n  static async staticInitialize() {\n    \
await __wbg_init();\n    _SplatMesh.isStaticInitialized = true;\n  }\n  // \
Creates a new Gsplat with the provided parameters (all values in \"float\" \
space,\n  // i.e. 0-1 for opacity and color) and adds it to the end of the \
packedSplats,\n  // increasing numSplats by 1. If necessary, reallocates the \
buffer with an exponential\n  // doubling strategy to fit the new data, so \
it's fairly efficient to just\n  // pushSplat(...) each Gsplat you want to \
create in a loop.\n  pushSplat(center, scales, quaternion, opacity, color) \
{\n    this.packedSplats.pushSplat(center, scales, quaternion, opacity, \
color);\n  }\n  // This method iterates over all Gsplats in this instance's \
packedSplats,\n  // invoking the provided callback with index: number in \
0..=(this.numSplats-1) and\n  // center: THREE.Vector3, scales: \
THREE.Vector3, quaternion: THREE.Quaternion,\n  // opacity: number (0..1), \
and color: THREE.Color (rgb values in 0..1).\n  // Note that the objects \
passed in as center etc. are the same for every callback\n  // invocation: \
these objects are reused for efficiency. Changing these values has\n  // no \
effect as they are decoded/unpacked copies of the underlying data. To \
update\n  // the packedSplats, call .packedSplats.setSplat(index, center, \
scales,\n  // quaternion, opacity, color).\n  forEachSplat(callback) {\n    \
this.packedSplats.forEachSplat(callback);\n  }\n  // Call this when you are \
finished with the SplatMesh and want to free\n  // any buffers it holds (via \
packedSplats).\n  dispose() {\n    this.packedSplats.dispose();\n  }\n  // \
Returns axis-aligned bounding box of the SplatMesh. If centers_only is \
true,\n  // only the centers of the splats are used to compute the bounding \
box.\n  // IMPORTANT: This should only be called after the SplatMesh is \
initialized.\n  getBoundingBox(centers_only = true) {\n    if \
(!this.initialized) {\n      throw new Error(\n        \"Cannot get bounding \
box before SplatMesh is initialized\"\n      );\n    }\n    const minVec = \
new THREE.Vector3(\n      Number.POSITIVE_INFINITY,\n      \
Number.POSITIVE_INFINITY,\n      Number.POSITIVE_INFINITY\n    );\n    const \
maxVec = new THREE.Vector3(\n      Number.NEGATIVE_INFINITY,\n      \
Number.NEGATIVE_INFINITY,\n      Number.NEGATIVE_INFINITY\n    );\n    const \
corners = new THREE.Vector3();\n    const signs = [-1, 1];\n    \
this.packedSplats.forEachSplat(\n      (_index, center, scales, quaternion, \
_opacity, _color) => {\n        if (centers_only) {\n          \
minVec.min(center);\n          maxVec.max(center);\n        } else {\n        \
  for (const x of signs) {\n            for (const y of signs) {\n            \
  for (const z of signs) {\n                corners.set(x * scales.x, y * \
scales.y, z * scales.z);\n                \
corners.applyQuaternion(quaternion);\n                corners.add(center);\n  \
              minVec.min(corners);\n                maxVec.max(corners);\n    \
          }\n            }\n          }\n        }\n      }\n    );\n    \
const box = new THREE.Box3(minVec, maxVec);\n    return box;\n  }\n  \
constructGenerator(context) {\n    const { transform, viewToObject, recolor } \
= context;\n    const generator = dynoBlock(\n      { index: \"int\" },\n     \
 { gsplat: Gsplat },\n      ({ index }) => {\n        if (!index) {\n         \
 throw new Error(\"index is undefined\");\n        }\n        let gsplat = \
readPackedSplat(this.packedSplats.dyno, index);\n        if (this.maxSh >= 1) \
{\n          const { sh1Texture, sh2Texture, sh3Texture } = \
this.ensureShTextures();\n          if (sh1Texture) {\n            let \
rescaleSh = function(sNorm, minMax) {\n              const { x: min2, y: max2 \
} = split(minMax).outputs;\n              const mid = mul(add(min2, max2), \
dynoConst(\"float\", 0.5));\n              const scale = mul(sub(max2, min2), \
dynoConst(\"float\", 0.5));\n              return add(mid, mul(sNorm, \
scale));\n            };\n            const viewCenterInObject = \
viewToObject.translate;\n            const { center } = \
splitGsplat(gsplat).outputs;\n            const viewDir = \
normalize(sub(center, viewCenterInObject));\n            const sh1Snorm = \
evaluateSH1(gsplat, sh1Texture, viewDir);\n            let rgb = \
rescaleSh(sh1Snorm, this.packedSplats.dynoSh1MinMax);\n            if \
(this.maxSh >= 2 && sh2Texture) {\n              const sh2Snorm = \
evaluateSH2(gsplat, sh2Texture, viewDir);\n              rgb = add(\n         \
       rgb,\n                rescaleSh(sh2Snorm, \
this.packedSplats.dynoSh2MinMax)\n              );\n            }\n           \
 if (this.maxSh >= 3 && sh3Texture) {\n              const sh3Snorm = \
evaluateSH3(gsplat, sh3Texture, viewDir);\n              rgb = add(\n         \
       rgb,\n                rescaleSh(sh3Snorm, \
this.packedSplats.dynoSh3MinMax)\n              );\n            }\n           \
 let { rgba } = splitGsplat(gsplat).outputs;\n            rgba = add(rgba, \
extendVec(rgb, dynoConst(\"float\", 0)));\n            gsplat = \
combineGsplat({ gsplat, rgba });\n          }\n        }\n        if \
(this.splatRgba) {\n          const rgba = readRgbaArray(this.splatRgba.dyno, \
index);\n          gsplat = combineGsplat({ gsplat, rgba });\n        }\n     \
   if (this.skinning) {\n          gsplat = this.skinning.modify(gsplat);\n   \
     }\n        if (this.objectModifier) {\n          gsplat = \
this.objectModifier.apply({ gsplat }).gsplat;\n        }\n        gsplat = \
transform.applyGsplat(gsplat);\n        const recolorRgba = mul(recolor, \
splitGsplat(gsplat).outputs.rgba);\n        gsplat = combineGsplat({ gsplat, \
rgba: recolorRgba });\n        if (this.rgbaDisplaceEdits) {\n          \
gsplat = this.rgbaDisplaceEdits.modify(gsplat);\n        }\n        if \
(this.worldModifier) {\n          gsplat = this.worldModifier.apply({ gsplat \
}).gsplat;\n        }\n        return { gsplat };\n      }\n    );\n    \
this.generator = generator;\n  }\n  // Call this whenever something changes \
in the Gsplat processing pipeline,\n  // for example changing maxSh or \
updating objectModifier or worldModifier.\n  // Compiled generators are \
cached for efficiency and re-use when the same\n  // pipeline structure \
emerges after successive changes.\n  updateGenerator() {\n    \
this.constructGenerator(this.context);\n  }\n  // This is called \
automatically by SparkRenderer and you should not have to\n  // call it. It \
updates parameters for the generated pipeline and calls\n  // \
updateGenerator() if the pipeline needs to change.\n  update({\n    time,\n   \
 viewToWorld,\n    deltaTime,\n    globalEdits\n  }) {\n    var _a2;\n    \
this.numSplats = this.packedSplats.numSplats;\n    this.context.time.value = \
time;\n    this.context.deltaTime.value = deltaTime;\n    \
_SplatMesh.dynoTime.value = time;\n    const { transform, viewToObject, \
recolor } = this.context;\n    let updated = transform.update(this);\n    if \
(this.context.viewToWorld.updateFromMatrix(viewToWorld) && \
this.enableViewToWorld) {\n      updated = true;\n    }\n    const \
worldToView = viewToWorld.clone().invert();\n    if \
(this.context.worldToView.updateFromMatrix(worldToView) && \
this.enableWorldToView) {\n      updated = true;\n    }\n    const \
objectToWorld = new THREE.Matrix4().compose(\n      \
transform.translate.value,\n      transform.rotate.value,\n      new \
THREE.Vector3().setScalar(transform.scale.value)\n    );\n    const \
worldToObject = objectToWorld.invert();\n    const viewToObjectMatrix = \
worldToObject.multiply(viewToWorld);\n    if \
(viewToObject.updateFromMatrix(viewToObjectMatrix) && \
(this.enableViewToObject || this.packedSplats.extra.sh1)) {\n      updated = \
true;\n    }\n    const newRecolor = new THREE.Vector4(\n      \
this.recolor.r,\n      this.recolor.g,\n      this.recolor.b,\n      \
this.opacity\n    );\n    if (!newRecolor.equals(recolor.value)) {\n      \
recolor.value.copy(newRecolor);\n      updated = true;\n    }\n    const \
edits = this.editable ? (this.edits ?? []).concat(globalEdits) : [];\n    if \
(this.editable && !this.edits) {\n      this.traverseVisible((node) => {\n    \
    if (node instanceof SplatEdit) {\n          edits.push(node);\n        \
}\n      });\n    }\n    edits.sort((a, b) => a.ordering - b.ordering);\n    \
const editsSdfs = edits.map((edit) => {\n      if (edit.sdfs != null) {\n     \
   return { edit, sdfs: edit.sdfs };\n      }\n      const sdfs = [];\n      \
edit.traverseVisible((node) => {\n        if (node instanceof SplatEditSdf) \
{\n          sdfs.push(node);\n        }\n      });\n      return { edit, \
sdfs };\n    });\n    if (editsSdfs.length > 0 && !this.rgbaDisplaceEdits) \
{\n      const edits2 = editsSdfs.length;\n      const sdfs = \
editsSdfs.reduce(\n        (total, edit) => total + edit.sdfs.length,\n       \
 0\n      );\n      this.rgbaDisplaceEdits = new SplatEdits({\n        \
maxEdits: edits2,\n        maxSdfs: sdfs\n      });\n      \
this.updateGenerator();\n    }\n    if (this.rgbaDisplaceEdits) {\n      \
const editResult = this.rgbaDisplaceEdits.update(editsSdfs);\n      updated \
|| (updated = editResult.updated);\n      if (editResult.dynoUpdated) {\n     \
   this.updateGenerator();\n      }\n    }\n    if (updated) {\n      \
this.updateVersion();\n    }\n    (_a2 = this.onFrame) == null ? void 0 : \
_a2.call(this, { mesh: this, time, deltaTime });\n  }\n  // This method \
conforms to the standard THREE.Raycaster API, performing object-ray\n  // \
intersections using this method to populate the provided intersects[] array\n \
 // with each intersection point.\n  raycast(raycaster, intersects) {\n    \
var _a2, _b2;\n    if (!this.packedSplats.packedArray || \
!this.packedSplats.numSplats) {\n      return;\n    }\n    const { near, far, \
ray } = raycaster;\n    const worldToMesh = \
this.matrixWorld.clone().invert();\n    const worldToMeshRot = new \
THREE.Matrix3().setFromMatrix4(worldToMesh);\n    const origin = \
ray.origin.clone().applyMatrix4(worldToMesh);\n    const direction = \
ray.direction.clone().applyMatrix3(worldToMeshRot);\n    const scales = new \
THREE.Vector3();\n    worldToMesh.decompose(new THREE.Vector3(), new \
THREE.Quaternion(), scales);\n    (scales.x * scales.y * scales.z) ** (1 / \
3);\n    const RAYCAST_ELLIPSOID = true;\n    const distances = \
raycast_splats(\n      origin.x,\n      origin.y,\n      origin.z,\n      \
direction.x,\n      direction.y,\n      direction.z,\n      near,\n      \
far,\n      this.packedSplats.numSplats,\n      \
this.packedSplats.packedArray,\n      RAYCAST_ELLIPSOID,\n      ((_a2 = \
this.packedSplats.splatEncoding) == null ? void 0 : _a2.lnScaleMin) ?? \
LN_SCALE_MIN,\n      ((_b2 = this.packedSplats.splatEncoding) == null ? void \
0 : _b2.lnScaleMax) ?? LN_SCALE_MAX\n    );\n    for (const distance2 of \
distances) {\n      const point = \
ray.direction.clone().multiplyScalar(distance2).add(ray.origin);\n      \
intersects.push({\n        distance: distance2,\n        point,\n        \
object: this\n      });\n    }\n  }\n  ensureShTextures() {\n    if \
(!this.packedSplats.extra.sh1) {\n      return {};\n    }\n    let sh1Texture \
= this.packedSplats.extra.sh1Texture;\n    if (!sh1Texture) {\n      let sh1 \
= this.packedSplats.extra.sh1;\n      const { width, height, depth, maxSplats \
} = getTextureSize(\n        sh1.length / 2\n      );\n      if (sh1.length < \
maxSplats * 2) {\n        const newSh1 = new Uint32Array(maxSplats * 2);\n    \
    newSh1.set(sh1);\n        this.packedSplats.extra.sh1 = newSh1;\n        \
sh1 = newSh1;\n      }\n      const texture2 = new \
THREE.DataArrayTexture(sh1, width, height, depth);\n      texture2.format = \
THREE.RGIntegerFormat;\n      texture2.type = THREE.UnsignedIntType;\n      \
texture2.internalFormat = \"RG32UI\";\n      texture2.needsUpdate = true;\n   \
   sh1Texture = new DynoUsampler2DArray({\n        value: texture2,\n        \
key: \"sh1\"\n      });\n      this.packedSplats.extra.sh1Texture = \
sh1Texture;\n    }\n    if (!this.packedSplats.extra.sh2) {\n      return { \
sh1Texture };\n    }\n    let sh2Texture = \
this.packedSplats.extra.sh2Texture;\n    if (!sh2Texture) {\n      let sh2 = \
this.packedSplats.extra.sh2;\n      const { width, height, depth, maxSplats } \
= getTextureSize(\n        sh2.length / 4\n      );\n      if (sh2.length < \
maxSplats * 4) {\n        const newSh2 = new Uint32Array(maxSplats * 4);\n    \
    newSh2.set(sh2);\n        this.packedSplats.extra.sh2 = newSh2;\n        \
sh2 = newSh2;\n      }\n      const texture2 = new \
THREE.DataArrayTexture(sh2, width, height, depth);\n      texture2.format = \
THREE.RGBAIntegerFormat;\n      texture2.type = THREE.UnsignedIntType;\n      \
texture2.internalFormat = \"RGBA32UI\";\n      texture2.needsUpdate = true;\n \
     sh2Texture = new DynoUsampler2DArray({\n        value: texture2,\n       \
 key: \"sh2\"\n      });\n      this.packedSplats.extra.sh2Texture = \
sh2Texture;\n    }\n    if (!this.packedSplats.extra.sh3) {\n      return { \
sh1Texture, sh2Texture };\n    }\n    let sh3Texture = \
this.packedSplats.extra.sh3Texture;\n    if (!sh3Texture) {\n      let sh3 = \
this.packedSplats.extra.sh3;\n      const { width, height, depth, maxSplats } \
= getTextureSize(\n        sh3.length / 4\n      );\n      if (sh3.length < \
maxSplats * 4) {\n        const newSh3 = new Uint32Array(maxSplats * 4);\n    \
    newSh3.set(sh3);\n        this.packedSplats.extra.sh3 = newSh3;\n        \
sh3 = newSh3;\n      }\n      const texture2 = new \
THREE.DataArrayTexture(sh3, width, height, depth);\n      texture2.format = \
THREE.RGBAIntegerFormat;\n      texture2.type = THREE.UnsignedIntType;\n      \
texture2.internalFormat = \"RGBA32UI\";\n      texture2.needsUpdate = true;\n \
     sh3Texture = new DynoUsampler2DArray({\n        value: texture2,\n       \
 key: \"sh3\"\n      });\n      this.packedSplats.extra.sh3Texture = \
sh3Texture;\n    }\n    return { sh1Texture, sh2Texture, sh3Texture };\n  \
}\n};\n_SplatMesh.staticInitialized = \
_SplatMesh.staticInitialize();\n_SplatMesh.isStaticInitialized = \
false;\n_SplatMesh.dynoTime = new DynoFloat({ value: 0 });\nlet SplatMesh = \
_SplatMesh;\nconst defineEvaluateSH1 = unindent(`\n  vec3 evaluateSH1(Gsplat \
gsplat, usampler2DArray sh1, vec3 viewDir) {\n    // Extract sint7 values \
packed into 2 x uint32\n    uvec2 packed = texelFetch(sh1, \
splatTexCoord(gsplat.index), 0).rg;\n    vec3 sh1_0 = vec3(ivec3(\n      \
int(packed.x << 25u) >> 25,\n      int(packed.x << 18u) >> 25,\n      \
int(packed.x << 11u) >> 25\n    )) / 63.0;\n    vec3 sh1_1 = vec3(ivec3(\n    \
  int(packed.x << 4u) >> 25,\n      int((packed.x >> 3u) | (packed.y << 29u)) \
>> 25,\n      int(packed.y << 22u) >> 25\n    )) / 63.0;\n    vec3 sh1_2 = \
vec3(ivec3(\n      int(packed.y << 15u) >> 25,\n      int(packed.y << 8u) >> \
25,\n      int(packed.y << 1u) >> 25\n    )) / 63.0;\n\n    return sh1_0 * \
(-0.4886025 * viewDir.y)\n      + sh1_1 * (0.4886025 * viewDir.z)\n      + \
sh1_2 * (-0.4886025 * viewDir.x);\n  }\n`);\nconst defineEvaluateSH2 = \
unindent(`\n  vec3 evaluateSH2(Gsplat gsplat, usampler2DArray sh2, vec3 \
viewDir) {\n    // Extract sint8 values packed into 4 x uint32\n    uvec4 \
packed = texelFetch(sh2, splatTexCoord(gsplat.index), 0);\n    vec3 sh2_0 = \
vec3(ivec3(\n      int(packed.x << 24u) >> 24,\n      int(packed.x << 16u) >> \
24,\n      int(packed.x << 8u) >> 24\n    )) / 127.0;\n    vec3 sh2_1 = \
vec3(ivec3(\n      int(packed.x) >> 24,\n      int(packed.y << 24u) >> 24,\n  \
    int(packed.y << 16u) >> 24\n    )) / 127.0;\n    vec3 sh2_2 = \
vec3(ivec3(\n      int(packed.y << 8u) >> 24,\n      int(packed.y) >> 24,\n   \
   int(packed.z << 24u) >> 24\n    )) / 127.0;\n    vec3 sh2_3 = \
vec3(ivec3(\n      int(packed.z << 16u) >> 24,\n      int(packed.z << 8u) >> \
24,\n      int(packed.z) >> 24\n    )) / 127.0;\n    vec3 sh2_4 = \
vec3(ivec3(\n      int(packed.w << 24u) >> 24,\n      int(packed.w << 16u) >> \
24,\n      int(packed.w << 8u) >> 24\n    )) / 127.0;\n\n    return sh2_0 * \
(1.0925484 * viewDir.x * viewDir.y)\n      + sh2_1 * (-1.0925484 * viewDir.y \
* viewDir.z)\n      + sh2_2 * (0.3153915 * (2.0 * viewDir.z * viewDir.z - \
viewDir.x * viewDir.x - viewDir.y * viewDir.y))\n      + sh2_3 * (-1.0925484 \
* viewDir.x * viewDir.z)\n      + sh2_4 * (0.5462742 * (viewDir.x * viewDir.x \
- viewDir.y * viewDir.y));\n  }\n`);\nconst defineEvaluateSH3 = unindent(`\n  \
vec3 evaluateSH3(Gsplat gsplat, usampler2DArray sh3, vec3 viewDir) {\n    // \
Extract sint6 values packed into 4 x uint32\n    uvec4 packed = \
texelFetch(sh3, splatTexCoord(gsplat.index), 0);\n    vec3 sh3_0 = \
vec3(ivec3(\n      int(packed.x << 26u) >> 26,\n      int(packed.x << 20u) >> \
26,\n      int(packed.x << 14u) >> 26\n    )) / 31.0;\n    vec3 sh3_1 = \
vec3(ivec3(\n      int(packed.x << 8u) >> 26,\n      int(packed.x << 2u) >> \
26,\n      int((packed.x >> 4u) | (packed.y << 28u)) >> 26\n    )) / 31.0;\n  \
  vec3 sh3_2 = vec3(ivec3(\n      int(packed.y << 22u) >> 26,\n      \
int(packed.y << 16u) >> 26,\n      int(packed.y << 10u) >> 26\n    )) / \
31.0;\n    vec3 sh3_3 = vec3(ivec3(\n      int(packed.y << 4u) >> 26,\n      \
int((packed.y >> 2u) | (packed.z << 30u)) >> 26,\n      int(packed.z << 24u) \
>> 26\n    )) / 31.0;\n    vec3 sh3_4 = vec3(ivec3(\n      int(packed.z << \
18u) >> 26,\n      int(packed.z << 12u) >> 26,\n      int(packed.z << 6u) >> \
26\n    )) / 31.0;\n    vec3 sh3_5 = vec3(ivec3(\n      int(packed.z) >> \
26,\n      int(packed.w << 26u) >> 26,\n      int(packed.w << 20u) >> 26\n    \
)) / 31.0;\n    vec3 sh3_6 = vec3(ivec3(\n      int(packed.w << 14u) >> 26,\n \
     int(packed.w << 8u) >> 26,\n      int(packed.w << 2u) >> 26\n    )) / \
31.0;\n\n    float xx = viewDir.x * viewDir.x;\n    float yy = viewDir.y * \
viewDir.y;\n    float zz = viewDir.z * viewDir.z;\n    float xy = viewDir.x * \
viewDir.y;\n    float yz = viewDir.y * viewDir.z;\n    float zx = viewDir.z * \
viewDir.x;\n\n    return sh3_0 * (-0.5900436 * viewDir.y * (3.0 * xx - yy))\n \
     + sh3_1 * (2.8906114 * xy * viewDir.z) +\n      + sh3_2 * (-0.4570458 * \
viewDir.y * (4.0 * zz - xx - yy))\n      + sh3_3 * (0.3731763 * viewDir.z * \
(2.0 * zz - 3.0 * xx - 3.0 * yy))\n      + sh3_4 * (-0.4570458 * viewDir.x * \
(4.0 * zz - xx - yy))\n      + sh3_5 * (1.4453057 * viewDir.z * (xx - yy))\n  \
    + sh3_6 * (-0.5900436 * viewDir.x * (xx - 3.0 * yy));\n  }\n`);\nfunction \
evaluateSH1(gsplat, sh1, viewDir) {\n  return dyno$1({\n    inTypes: { \
gsplat: Gsplat, sh1: \"usampler2DArray\", viewDir: \"vec3\" },\n    outTypes: \
{ rgb: \"vec3\" },\n    inputs: { gsplat, sh1, viewDir },\n    globals: () => \
[defineGsplat, defineEvaluateSH1],\n    statements: ({ inputs, outputs }) => \
{\n      const statements = unindentLines(`\n        if \
(isGsplatActive(${inputs.gsplat}.flags)) {\n          ${outputs.rgb} = \
evaluateSH1(${inputs.gsplat}, ${inputs.sh1}, ${inputs.viewDir});\n        } \
else {\n          ${outputs.rgb} = vec3(0.0);\n        }\n      `);\n      \
return statements;\n    }\n  }).outputs.rgb;\n}\nfunction evaluateSH2(gsplat, \
sh2, viewDir) {\n  return dyno$1({\n    inTypes: { gsplat: Gsplat, sh2: \
\"usampler2DArray\", viewDir: \"vec3\" },\n    outTypes: { rgb: \"vec3\" },\n \
   inputs: { gsplat, sh2, viewDir },\n    globals: () => [defineGsplat, \
defineEvaluateSH2],\n    statements: ({ inputs, outputs }) => \
unindentLines(`\n        if (isGsplatActive(${inputs.gsplat}.flags)) {\n      \
    ${outputs.rgb} = evaluateSH2(${inputs.gsplat}, ${inputs.sh2}, \
${inputs.viewDir});\n        } else {\n          ${outputs.rgb} = \
vec3(0.0);\n        }\n      `)\n  }).outputs.rgb;\n}\nfunction \
evaluateSH3(gsplat, sh3, viewDir) {\n  return dyno$1({\n    inTypes: { \
gsplat: Gsplat, sh3: \"usampler2DArray\", viewDir: \"vec3\" },\n    outTypes: \
{ rgb: \"vec3\" },\n    inputs: { gsplat, sh3, viewDir },\n    globals: () => \
[defineGsplat, defineEvaluateSH3],\n    statements: ({ inputs, outputs }) => \
unindentLines(`\n        if (isGsplatActive(${inputs.gsplat}.flags)) {\n      \
    ${outputs.rgb} = evaluateSH3(${inputs.gsplat}, ${inputs.sh3}, \
${inputs.viewDir});\n        } else {\n          ${outputs.rgb} = \
vec3(0.0);\n        }\n      `)\n  }).outputs.rgb;\n}\nconst EMPTY_GEOMETRY$1 \
= new THREE.BufferGeometry();\nconst EMPTY_MATERIAL = new \
THREE.ShaderMaterial();\nfunction createRendererDetectionMesh() {\n  const \
mesh = new THREE.Mesh(EMPTY_GEOMETRY$1, EMPTY_MATERIAL);\n  \
mesh.frustumCulled = false;\n  mesh.onBeforeRender = function(renderer, \
scene) {\n    if (!scene.isScene) {\n      this.removeFromParent();\n      \
return;\n    }\n    let hasSparkRenderer = false;\n    scene.traverse((c) => \
{\n      if (c instanceof SparkRenderer) {\n        hasSparkRenderer = \
true;\n      }\n    });\n    if (!hasSparkRenderer) {\n      scene.add(new \
SparkRenderer({ renderer }));\n    }\n    this.removeFromParent();\n  };\n  \
return mesh;\n}\nconst PLY_PROPERTY_TYPES = [\n  \"char\",\n  \"uchar\",\n  \
\"short\",\n  \"ushort\",\n  \"int\",\n  \"uint\",\n  \"float\",\n  \
\"double\"\n];\nconst _PlyReader = class _PlyReader {\n  // Create a \
PlyReader from a Uint8Array/ArrayBuffer, no parsing done yet\n  constructor({ \
fileBytes }) {\n    this.header = \"\";\n    this.littleEndian = true;\n    \
this.elements = {};\n    this.comments = [];\n    this.data = null;\n    \
this.numSplats = 0;\n    this.fileBytes = fileBytes instanceof ArrayBuffer ? \
new Uint8Array(fileBytes) : fileBytes;\n  }\n  // Identify and parse the PLY \
text header (assumed to be <64KB in size).\n  // this.elements will contain \
all the elements in the file, typically\n  // \"vertex\" contains the Gsplat \
data.\n  async parseHeader() {\n    const bufferStream = new \
ReadableStream({\n      start: (controller) => {\n        \
controller.enqueue(this.fileBytes.slice(0, 65536));\n        \
controller.close();\n      }\n    });\n    const decoder = \
bufferStream.pipeThrough(new TextDecoderStream()).getReader();\n    \
this.header = \"\";\n    const headerTerminator = \"end_header\\n\";\n    \
while (true) {\n      const { value, done } = await decoder.read();\n      if \
(done) {\n        throw new Error(\"Failed to read header\");\n      }\n      \
this.header += value;\n      const endHeader = \
this.header.indexOf(headerTerminator);\n      if (endHeader >= 0) {\n        \
this.header = this.header.slice(0, endHeader + headerTerminator.length);\n    \
    break;\n      }\n    }\n    const headerLen = new \
TextEncoder().encode(this.header).length;\n    this.data = new \
DataView(this.fileBytes.buffer, headerLen);\n    this.elements = {};\n    let \
curElement = null;\n    this.comments = [];\n    \
this.header.trim().split(\"\\n\").forEach((line, lineIndex) => {\n      const \
trimmedLine = line.trim();\n      if (lineIndex === 0) {\n        if \
(trimmedLine !== \"ply\") {\n          throw new Error(\"Invalid PLY \
header\");\n        }\n        return;\n      }\n      if (trimmedLine.length \
=== 0) {\n        return;\n      }\n      const fields = trimmedLine.split(\" \
\");\n      switch (fields[0]) {\n        case \"format\":\n          if \
(fields[1] === \"binary_little_endian\") {\n            this.littleEndian = \
true;\n          } else if (fields[1] === \"binary_big_endian\") {\n          \
  this.littleEndian = false;\n          } else {\n            throw new \
Error(`Unsupported PLY format: ${fields[1]}`);\n          }\n          if \
(fields[2] !== \"1.0\") {\n            throw new Error(`Unsupported PLY \
version: ${fields[2]}`);\n          }\n          break;\n        case \
\"end_header\":\n          break;\n        case \"comment\":\n          \
this.comments.push(trimmedLine.slice(\"comment \".length));\n          \
break;\n        case \"element\": {\n          const name = fields[1];\n      \
    curElement = {\n            name,\n            count: \
Number.parseInt(fields[2]),\n            properties: {}\n          };\n       \
   this.elements[name] = curElement;\n          break;\n        }\n        \
case \"property\":\n          if (curElement == null) {\n            throw \
new Error(\"Property must be inside an element\");\n          }\n          if \
(fields[1] === \"list\") {\n            curElement.properties[fields[4]] = \
{\n              isList: true,\n              type: fields[3],\n              \
countType: fields[2]\n            };\n          } else {\n            \
curElement.properties[fields[2]] = {\n              isList: false,\n          \
    type: fields[1]\n            };\n          }\n          break;\n      }\n \
   });\n    if (this.elements.vertex) {\n      this.numSplats = \
this.elements.vertex.count;\n    }\n  }\n  parseData(elementCallback) {\n    \
let offset = 0;\n    const data = this.data;\n    if (data == null) {\n      \
throw new Error(\"No data to parse\");\n    }\n    for (const elementName in \
this.elements) {\n      const element = this.elements[elementName];\n      \
const { count, properties } = element;\n      const item = \
createEmptyItem(properties);\n      const parseFn = createParseFn(properties, \
this.littleEndian);\n      const callback = elementCallback(element) ?? (() \
=> {\n      });\n      for (let index = 0; index < count; index++) {\n        \
offset = parseFn(data, offset, item);\n        callback(index, item);\n      \
}\n    }\n  }\n  // Parse all the Gsplat data in the PLY file in go, invoking \
the given\n  // callbacks for each Gsplat.\n  parseSplats(splatCallback, \
shCallback) {\n    if (this.elements.vertex == null) {\n      throw new \
Error(\"No vertex element found\");\n    }\n    let isSuperSplat = false;\n   \
 const ssChunks = [];\n    let numSh = 0;\n    let sh1Props = [];\n    let \
sh2Props = [];\n    let sh3Props = [];\n    let sh1 = void 0;\n    let sh2 = \
void 0;\n    let sh3 = void 0;\n    function prepareSh() {\n      const \
num_f_rest = NUM_SH_TO_NUM_F_REST[numSh];\n      sh1Props = new \
Array(3).fill(null).flatMap((_, k) => [0, 1, 2].map((_2, d) => k + d * \
num_f_rest / 3));\n      sh2Props = new Array(5).fill(null).flatMap(\n        \
(_, k) => [0, 1, 2].map((_2, d) => 3 + k + d * num_f_rest / 3)\n      );\n    \
  sh3Props = new Array(7).fill(null).flatMap(\n        (_, k) => [0, 1, \
2].map((_2, d) => 8 + k + d * num_f_rest / 3)\n      );\n      sh1 = numSh >= \
1 ? new Float32Array(3 * 3) : void 0;\n      sh2 = numSh >= 2 ? new \
Float32Array(5 * 3) : void 0;\n      sh3 = numSh >= 3 ? new Float32Array(7 * \
3) : void 0;\n    }\n    function ssShCallback(index, item) {\n      if \
(!sh1) {\n        throw new Error(\"Missing sh1\");\n      }\n      const sh \
= item.f_rest;\n      for (let i = 0; i < sh1Props.length; i++) {\n        \
sh1[i] = sh[sh1Props[i]] * 8 / 255 - 4;\n      }\n      if (sh2) {\n        \
for (let i = 0; i < sh2Props.length; i++) {\n          sh2[i] = \
sh[sh2Props[i]] * 8 / 255 - 4;\n        }\n      }\n      if (sh3) {\n        \
for (let i = 0; i < sh3Props.length; i++) {\n          sh3[i] = \
sh[sh3Props[i]] * 8 / 255 - 4;\n        }\n      }\n      shCallback == null \
? void 0 : shCallback(index, sh1, sh2, sh3);\n    }\n    function \
initSuperSplat(element) {\n      const {\n        min_x,\n        min_y,\n    \
    min_z,\n        max_x,\n        max_y,\n        max_z,\n        \
min_scale_x,\n        min_scale_y,\n        min_scale_z,\n        \
max_scale_x,\n        max_scale_y,\n        max_scale_z\n      } = \
element.properties;\n      if (!min_x || !min_y || !min_z || !max_x || !max_y \
|| !max_z || !min_scale_x || !min_scale_y || !min_scale_z || !max_scale_x || \
!max_scale_y || !max_scale_z) {\n        throw new Error(\"Missing PLY chunk \
properties\");\n      }\n      isSuperSplat = true;\n      return (index, \
item) => {\n        const {\n          min_x: min_x2,\n          min_y: \
min_y2,\n          min_z: min_z2,\n          max_x: max_x2,\n          max_y: \
max_y2,\n          max_z: max_z2,\n          min_scale_x: min_scale_x2,\n     \
     min_scale_y: min_scale_y2,\n          min_scale_z: min_scale_z2,\n       \
   max_scale_x: max_scale_x2,\n          max_scale_y: max_scale_y2,\n         \
 max_scale_z: max_scale_z2,\n          min_r,\n          min_g,\n          \
min_b,\n          max_r,\n          max_g,\n          max_b\n        } = \
item;\n        ssChunks.push({\n          min_x: min_x2,\n          min_y: \
min_y2,\n          min_z: min_z2,\n          max_x: max_x2,\n          max_y: \
max_y2,\n          max_z: max_z2,\n          min_scale_x: min_scale_x2,\n     \
     min_scale_y: min_scale_y2,\n          min_scale_z: min_scale_z2,\n       \
   max_scale_x: max_scale_x2,\n          max_scale_y: max_scale_y2,\n         \
 max_scale_z: max_scale_z2,\n          min_r,\n          min_g,\n          \
min_b,\n          max_r,\n          max_g,\n          max_b\n        });\n    \
  };\n    }\n    function decodeSuperSplat(element) {\n      if (shCallback \
&& element.name === \"sh\") {\n        numSh = \
getNumSh(element.properties);\n        prepareSh();\n        return \
ssShCallback;\n      }\n      if (element.name !== \"vertex\") {\n        \
return null;\n      }\n      const { packed_position, packed_rotation, \
packed_scale, packed_color } = element.properties;\n      if \
(!packed_position || !packed_rotation || !packed_scale || !packed_color) {\n  \
      throw new Error(\n          \"Missing PLY properties: packed_position, \
packed_rotation, packed_scale, packed_color\"\n        );\n      }\n      \
const SQRT2 = Math.sqrt(2);\n      return (index, item) => {\n        const \
chunk = ssChunks[index >>> 8];\n        if (chunk == null) {\n          throw \
new Error(\"Missing PLY chunk\");\n        }\n        const {\n          \
min_x,\n          min_y,\n          min_z,\n          max_x,\n          \
max_y,\n          max_z,\n          min_scale_x,\n          min_scale_y,\n    \
      min_scale_z,\n          max_scale_x,\n          max_scale_y,\n          \
max_scale_z,\n          min_r,\n          min_g,\n          min_b,\n          \
max_r,\n          max_g,\n          max_b\n        } = chunk;\n        const \
{ packed_position: packed_position2, packed_rotation: packed_rotation2, \
packed_scale: packed_scale2, packed_color: packed_color2 } = item;\n        \
const x = (packed_position2 >>> 21 & 2047) / 2047 * (max_x - min_x) + \
min_x;\n        const y = (packed_position2 >>> 11 & 1023) / 1023 * (max_y - \
min_y) + min_y;\n        const z = (packed_position2 & 2047) / 2047 * (max_z \
- min_z) + min_z;\n        const r0 = ((packed_rotation2 >>> 20 & 1023) / \
1023 - 0.5) * SQRT2;\n        const r1 = ((packed_rotation2 >>> 10 & 1023) / \
1023 - 0.5) * SQRT2;\n        const r2 = ((packed_rotation2 & 1023) / 1023 - \
0.5) * SQRT2;\n        const rr = Math.sqrt(Math.max(0, 1 - r0 * r0 - r1 * r1 \
- r2 * r2));\n        const rOrder = packed_rotation2 >>> 30;\n        const \
quatX = rOrder === 0 ? r0 : rOrder === 1 ? rr : r1;\n        const quatY = \
rOrder <= 1 ? r1 : rOrder === 2 ? rr : r2;\n        const quatZ = rOrder <= 2 \
? r2 : rr;\n        const quatW = rOrder === 0 ? rr : r0;\n        const \
scaleX = Math.exp(\n          (packed_scale2 >>> 21 & 2047) / 2047 * \
(max_scale_x - min_scale_x) + min_scale_x\n        );\n        const scaleY = \
Math.exp(\n          (packed_scale2 >>> 11 & 1023) / 1023 * (max_scale_y - \
min_scale_y) + min_scale_y\n        );\n        const scaleZ = Math.exp(\n    \
      (packed_scale2 & 2047) / 2047 * (max_scale_z - min_scale_z) + \
min_scale_z\n        );\n        const r = (packed_color2 >>> 24 & 255) / 255 \
* ((max_r ?? 1) - (min_r ?? 0)) + (min_r ?? 0);\n        const g = \
(packed_color2 >>> 16 & 255) / 255 * ((max_g ?? 1) - (min_g ?? 0)) + (min_g \
?? 0);\n        const b = (packed_color2 >>> 8 & 255) / 255 * ((max_b ?? 1) - \
(min_b ?? 0)) + (min_b ?? 0);\n        const opacity = (packed_color2 & 255) \
/ 255;\n        splatCallback(\n          index,\n          x,\n          \
y,\n          z,\n          scaleX,\n          scaleY,\n          scaleZ,\n   \
       quatX,\n          quatY,\n          quatZ,\n          quatW,\n         \
 opacity,\n          r,\n          g,\n          b\n        );\n      };\n    \
}\n    const elementCallback = (element) => {\n      if (element.name === \
\"chunk\") {\n        return initSuperSplat(element);\n      }\n      if \
(isSuperSplat) {\n        return decodeSuperSplat(element);\n      }\n      \
if (element.name !== \"vertex\") {\n        return null;\n      }\n      \
const {\n        x,\n        y,\n        z,\n        scale_0,\n        \
scale_1,\n        scale_2,\n        rot_0,\n        rot_1,\n        rot_2,\n  \
      rot_3,\n        opacity,\n        f_dc_0,\n        f_dc_1,\n        \
f_dc_2,\n        red,\n        green,\n        blue,\n        alpha\n      } \
= element.properties;\n      if (!x || !y || !z) {\n        throw new \
Error(\"Missing PLY properties: x, y, z\");\n      }\n      const hasScales = \
scale_0 && scale_1 && scale_2;\n      const hasRots = rot_0 && rot_1 && rot_2 \
&& rot_3;\n      const alphaDiv = alpha != null ? FIELD_SCALE[alpha.type] : \
1;\n      const redDiv = red != null ? FIELD_SCALE[red.type] : 1;\n      \
const greenDiv = green != null ? FIELD_SCALE[green.type] : 1;\n      const \
blueDiv = blue != null ? FIELD_SCALE[blue.type] : 1;\n      numSh = \
getNumSh(element.properties);\n      prepareSh();\n      return (index, item) \
=> {\n        const scaleX = hasScales ? Math.exp(item.scale_0) : \
_PlyReader.defaultPointScale;\n        const scaleY = hasScales ? \
Math.exp(item.scale_1) : _PlyReader.defaultPointScale;\n        const scaleZ \
= hasScales ? Math.exp(item.scale_2) : _PlyReader.defaultPointScale;\n        \
const quatX = hasRots ? item.rot_1 : 0;\n        const quatY = hasRots ? \
item.rot_2 : 0;\n        const quatZ = hasRots ? item.rot_3 : 0;\n        \
const quatW = hasRots ? item.rot_0 : 1;\n        const op = opacity != null ? \
1 / (1 + Math.exp(-item.opacity)) : alpha != null ? item.alpha / alphaDiv : \
1;\n        const r = f_dc_0 != null ? item.f_dc_0 * SH_C0$1 + 0.5 : red != \
null ? item.red / redDiv : 1;\n        const g = f_dc_1 != null ? item.f_dc_1 \
* SH_C0$1 + 0.5 : green != null ? item.green / greenDiv : 1;\n        const b \
= f_dc_2 != null ? item.f_dc_2 * SH_C0$1 + 0.5 : blue != null ? item.blue / \
blueDiv : 1;\n        splatCallback(\n          index,\n          item.x,\n   \
       item.y,\n          item.z,\n          scaleX,\n          scaleY,\n     \
     scaleZ,\n          quatX,\n          quatY,\n          quatZ,\n          \
quatW,\n          op,\n          r,\n          g,\n          b\n        );\n  \
      if (shCallback && sh1) {\n          const sh = item.f_rest;\n          \
if (sh1) {\n            for (let i = 0; i < sh1Props.length; i++) {\n         \
     sh1[i] = sh[sh1Props[i]];\n            }\n          }\n          if \
(sh2) {\n            for (let i = 0; i < sh2Props.length; i++) {\n            \
  sh2[i] = sh[sh2Props[i]];\n            }\n          }\n          if (sh3) \
{\n            for (let i = 0; i < sh3Props.length; i++) {\n              \
sh3[i] = sh[sh3Props[i]];\n            }\n          }\n          \
shCallback(index, sh1, sh2, sh3);\n        }\n      };\n    };\n    \
this.parseData(elementCallback);\n  }\n  // Inject RGBA values into original \
PLY file, which can be used to modify\n  // the color/opacity of the Gsplats \
and write out the modified PLY file.\n  injectRgba(rgba) {\n    let offset = \
0;\n    const data = this.data;\n    if (data == null) {\n      throw new \
Error(\"No parsed data\");\n    }\n    if (rgba.length !== this.numSplats * \
4) {\n      throw new Error(\"Invalid RGBA array length\");\n    }\n    for \
(const elementName in this.elements) {\n      const element = \
this.elements[elementName];\n      const { count, properties } = element;\n   \
   const parsers = [];\n      let rgbaOffset = 0;\n      const isVertex = \
elementName === \"vertex\";\n      if (isVertex) {\n        for (const name \
of [\"opacity\", \"f_dc_0\", \"f_dc_1\", \"f_dc_2\"]) {\n          if \
(!properties[name] || properties[name].type !== \"float\") {\n            \
throw new Error(`Can't injectRgba due to property: ${name}`);\n          }\n  \
      }\n      }\n      for (const [propertyName, property] of \
Object.entries(properties)) {\n        if (!property.isList) {\n          if \
(isVertex) {\n            if (propertyName === \"f_dc_0\" || propertyName === \
\"f_dc_1\" || propertyName === \"f_dc_2\") {\n              const component = \
Number.parseInt(\n                propertyName.slice(\"f_dc_\".length)\n      \
        );\n              parsers.push(() => {\n                const value = \
(rgba[rgbaOffset + component] / 255 - 0.5) / SH_C0$1;\n                \
SET_FIELD[property.type](\n                  data,\n                  \
offset,\n                  this.littleEndian,\n                  value\n      \
          );\n              });\n            } else if (propertyName === \
\"opacity\") {\n              parsers.push(() => {\n                const \
value = Math.max(\n                  -100,\n                  Math.min(\n     \
               100,\n                    -Math.log(1 / (rgba[rgbaOffset + 3] \
/ 255) - 1)\n                  )\n                );\n                \
SET_FIELD[property.type](\n                  data,\n                  \
offset,\n                  this.littleEndian,\n                  value\n      \
          );\n              });\n            }\n          }\n          \
parsers.push(() => {\n            offset += FIELD_BYTES[property.type];\n     \
     });\n        } else {\n          parsers.push(() => {\n            const \
length2 = PARSE_FIELD[property.countType](\n              data,\n             \
 offset,\n              this.littleEndian\n            );\n            offset \
+= FIELD_BYTES[property.countType];\n            offset += length2 * \
FIELD_BYTES[property.type];\n          });\n        }\n      }\n      for \
(let index = 0; index < count; index++) {\n        for (const parser of \
parsers) {\n          parser();\n        }\n        if (isVertex) {\n         \
 rgbaOffset += 4;\n        }\n      }\n    }\n  \
}\n};\n_PlyReader.defaultPointScale = 1e-3;\nlet PlyReader = \
_PlyReader;\nconst SH_C0$1 = 0.28209479177387814;\nconst PARSE_FIELD = {\n  \
char: (data, offset, littleEndian) => {\n    return data.getInt8(offset);\n  \
},\n  uchar: (data, offset, littleEndian) => {\n    return \
data.getUint8(offset);\n  },\n  short: (data, offset, littleEndian) => {\n    \
return data.getInt16(offset, littleEndian);\n  },\n  ushort: (data, offset, \
littleEndian) => {\n    return data.getUint16(offset, littleEndian);\n  },\n  \
int: (data, offset, littleEndian) => {\n    return data.getInt32(offset, \
littleEndian);\n  },\n  uint: (data, offset, littleEndian) => {\n    return \
data.getUint32(offset, littleEndian);\n  },\n  float: (data, offset, \
littleEndian) => {\n    return data.getFloat32(offset, littleEndian);\n  },\n \
 double: (data, offset, littleEndian) => {\n    return \
data.getFloat64(offset, littleEndian);\n  }\n};\nconst SET_FIELD = {\n  char: \
(data, offset, littleEndian, value) => {\n    data.setInt8(offset, value);\n  \
},\n  uchar: (data, offset, littleEndian, value) => {\n    \
data.setUint8(offset, value);\n  },\n  short: (data, offset, littleEndian, \
value) => {\n    data.setInt16(offset, value, littleEndian);\n  },\n  ushort: \
(data, offset, littleEndian, value) => {\n    data.setUint16(offset, value, \
littleEndian);\n  },\n  int: (data, offset, littleEndian, value) => {\n    \
data.setInt32(offset, value, littleEndian);\n  },\n  uint: (data, offset, \
littleEndian, value) => {\n    data.setUint32(offset, value, littleEndian);\n \
 },\n  float: (data, offset, littleEndian, value) => {\n    \
data.setFloat32(offset, value, littleEndian);\n  },\n  double: (data, offset, \
littleEndian, value) => {\n    data.setFloat64(offset, value, \
littleEndian);\n  }\n};\nconst FIELD_BYTES = {\n  char: 1,\n  uchar: 1,\n  \
short: 2,\n  ushort: 2,\n  int: 4,\n  uint: 4,\n  float: 4,\n  double: \
8\n};\nconst FIELD_SCALE = {\n  char: 127,\n  uchar: 255,\n  short: 32767,\n  \
ushort: 65535,\n  int: 2147483647,\n  uint: 4294967295,\n  float: 1,\n  \
double: 1\n};\nconst NUM_F_REST_TO_NUM_SH = {\n  0: 0,\n  9: 1,\n  24: 2,\n  \
45: 3\n};\nconst NUM_SH_TO_NUM_F_REST = {\n  0: 0,\n  1: 9,\n  2: 24,\n  3: \
45\n};\nconst F_REST_REGEX = /^f_rest_([0-9]{1,2})$/;\nfunction \
createEmptyItem(properties) {\n  const item = {};\n  for (const \
[propertyName, property] of Object.entries(properties)) {\n    if \
(F_REST_REGEX.test(propertyName)) {\n      item.f_rest = new \
Array(getNumSh(properties));\n    } else {\n      item[propertyName] = \
property.isList ? [] : 0;\n    }\n  }\n  return item;\n}\nfunction \
createParseFn(properties, littleEndian) {\n  if (safeToCompile(properties)) \
{\n    return createCompiledParserFn(properties, littleEndian);\n  }\n  \
return createDynamicParserFn(properties, littleEndian);\n}\nconst \
UNSAFE_EVAL_ALLOWED = (() => {\n  try {\n    new Function(\"return 42;\");\n  \
} catch (e) {\n    return false;\n  }\n  return true;\n})();\nconst \
PROPERTY_NAME_REGEX = /^[a-zA-Z0-9_]+$/;\nfunction safeToCompile(properties) \
{\n  if (!UNSAFE_EVAL_ALLOWED) {\n    return false;\n  }\n  for (const \
[propertyName, property] of Object.entries(properties)) {\n    if \
(!PROPERTY_NAME_REGEX.test(propertyName)) {\n      return false;\n    }\n    \
if (property.isList && !PLY_PROPERTY_TYPES.includes(property.countType)) {\n  \
    return false;\n    }\n    if \
(!PLY_PROPERTY_TYPES.includes(property.type)) {\n      return false;\n    }\n \
 }\n  return true;\n}\nfunction createCompiledParserFn(properties, \
littleEndian) {\n  const parserSrc = [\"let list;\"];\n  for (const \
[propertyName, property] of Object.entries(properties)) {\n    const \
fRestMatch = propertyName.match(F_REST_REGEX);\n    if (fRestMatch) {\n      \
const fRestIndex = +fRestMatch[1];\n      parserSrc.push(\n        /*js*/\n   \
     `\n        item.f_rest[${fRestIndex}] = \
PARSE_FIELD['${property.type}'](data, offset, ${littleEndian});\n        \
offset += ${FIELD_BYTES[property.type]};\n      `\n      );\n    } else if \
(!property.isList) {\n      parserSrc.push(\n        /*js*/\n        `\n      \
  item['${propertyName}'] = PARSE_FIELD['${property.type}'](data, offset, \
${littleEndian});\n        offset += ${FIELD_BYTES[property.type]};\n      \
`\n      );\n    } else {\n      parserSrc.push(\n        /*js*/\n        `\n \
       list = item['${propertyName}'];\n        list.length = \
PARSE_FIELD['${property.countType}'](data, offset, ${littleEndian});\n        \
offset += ${FIELD_BYTES[property.countType]};\n        for (let i = 0; i < \
list.length; i++) {\n          list[i] = \
PARSE_FIELD['${property.type}'](data, offset, ${littleEndian});\n          \
offset += ${FIELD_BYTES[property.type]};\n        }\n      `\n      );\n    \
}\n  }\n  parserSrc.push(\"return offset;\");\n  const fn = new Function(\n   \
 \"data\",\n    \"offset\",\n    \"item\",\n    \"PARSE_FIELD\",\n    \
parserSrc.join(\"\\n\")\n  );\n  return (data, offset, item) => fn(data, \
offset, item, PARSE_FIELD);\n}\nfunction createDynamicParserFn(properties, \
littleEndian) {\n  const parsers = [];\n  for (const [propertyName, property] \
of Object.entries(properties)) {\n    const fRestMatch = \
propertyName.match(F_REST_REGEX);\n    if (fRestMatch) {\n      const \
fRestIndex = +fRestMatch[1];\n      parsers.push(\n        (data, offset, \
item) => {\n          item.f_rest[fRestIndex] = PARSE_FIELD[property.type](\n \
           data,\n            offset,\n            littleEndian\n          \
);\n          return offset + FIELD_BYTES[property.type];\n        }\n      \
);\n    } else if (!property.isList) {\n      parsers.push(\n        (data, \
offset, item) => {\n          item[propertyName] = \
PARSE_FIELD[property.type](\n            data,\n            offset,\n         \
   littleEndian\n          );\n          return offset + \
FIELD_BYTES[property.type];\n        }\n      );\n    } else {\n      \
parsers.push(\n        (data, offset, item) => {\n          const list = \
item[propertyName];\n          list.length = \
PARSE_FIELD[property.countType](\n            data,\n            offset,\n    \
        littleEndian\n          );\n          let currentOffset = offset + \
FIELD_BYTES[property.countType];\n          for (let i = 0; i < list.length; \
i++) {\n            list[i] = PARSE_FIELD[property.type](\n              \
data,\n              currentOffset,\n              littleEndian\n            \
);\n            currentOffset += FIELD_BYTES[property.type];\n          }\n   \
       return currentOffset;\n        }\n      );\n    }\n  }\n  return \
(data, offset, item) => {\n    let currentOffset = offset;\n    for (let \
parserIndex = 0; parserIndex < parsers.length; parserIndex++) {\n      \
currentOffset = parsers[parserIndex](data, currentOffset, item);\n    }\n    \
return currentOffset;\n  };\n}\nfunction getNumSh(properties) {\n  let \
num_f_rest = 0;\n  while (properties[`f_rest_${num_f_rest}`]) {\n    \
num_f_rest += 1;\n  }\n  const numSh = NUM_F_REST_TO_NUM_SH[num_f_rest];\n  \
if (numSh == null) {\n    throw new Error(`Unsupported number of SH \
coefficients: ${num_f_rest}`);\n  }\n  return numSh;\n}\nconst jsContent = \
'(function() {\\n  \"use strict\";\\n  let wasm;\\n  const cachedTextDecoder \
= typeof TextDecoder !== \"undefined\" ? new TextDecoder(\"utf-8\", { \
ignoreBOM: true, fatal: true }) : { decode: () => {\\n    throw \
Error(\"TextDecoder not available\");\\n  } };\\n  if (typeof TextDecoder !== \
\"undefined\") {\\n    cachedTextDecoder.decode();\\n  }\\n  let \
cachedUint8ArrayMemory0 = null;\\n  function getUint8ArrayMemory0() {\\n    \
if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength \
=== 0) {\\n      cachedUint8ArrayMemory0 = new \
Uint8Array(wasm.memory.buffer);\\n    }\\n    return \
cachedUint8ArrayMemory0;\\n  }\\n  function getStringFromWasm0(ptr, len) {\\n \
   ptr = ptr >>> 0;\\n    return \
cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));\\n \
 }\\n  function sort_splats(num_splats, readback, ordering) {\\n    const ret \
= wasm.sort_splats(num_splats, readback, ordering);\\n    return ret >>> \
0;\\n  }\\n  function sort32_splats(num_splats, readback, ordering) {\\n    \
const ret = wasm.sort32_splats(num_splats, readback, ordering);\\n    return \
ret >>> 0;\\n  }\\n  async function __wbg_load(module, imports) {\\n    if \
(typeof Response === \"function\" && module instanceof Response) {\\n      if \
(typeof WebAssembly.instantiateStreaming === \"function\") {\\n        try \
{\\n          return await WebAssembly.instantiateStreaming(module, \
imports);\\n        } catch (e) {\\n          if \
(module.headers.get(\"Content-Type\") != \"application/wasm\") {\\n           \
 console.warn(\"`WebAssembly.instantiateStreaming` failed because your server \
does not serve Wasm with `application/wasm` MIME type. Falling back to \
`WebAssembly.instantiate` which is slower. Original error:\\\\n\", e);\\n     \
     } else {\\n            throw e;\\n          }\\n        }\\n      }\\n   \
   const bytes = await module.arrayBuffer();\\n      return await \
WebAssembly.instantiate(bytes, imports);\\n    } else {\\n      const \
instance = await WebAssembly.instantiate(module, imports);\\n      if \
(instance instanceof WebAssembly.Instance) {\\n        return { instance, \
module };\\n      } else {\\n        return instance;\\n      }\\n    }\\n  \
}\\n  function __wbg_get_imports() {\\n    const imports = {};\\n    \
imports.wbg = {};\\n    imports.wbg.__wbg_buffer_609cc3eee51ed158 = \
function(arg0) {\\n      const ret = arg0.buffer;\\n      return ret;\\n    \
};\\n    imports.wbg.__wbg_length_3b4f022188ae8db6 = function(arg0) {\\n      \
const ret = arg0.length;\\n      return ret;\\n    };\\n    \
imports.wbg.__wbg_length_6ca527665d89694d = function(arg0) {\\n      const \
ret = arg0.length;\\n      return ret;\\n    };\\n    \
imports.wbg.__wbg_length_8cfd2c6409af88ad = function(arg0) {\\n      const \
ret = arg0.length;\\n      return ret;\\n    };\\n    \
imports.wbg.__wbg_new_9fee97a409b32b68 = function(arg0) {\\n      const ret = \
new Uint16Array(arg0);\\n      return ret;\\n    };\\n    \
imports.wbg.__wbg_new_e3b321dcfef89fc7 = function(arg0) {\\n      const ret = \
new Uint32Array(arg0);\\n      return ret;\\n    };\\n    \
imports.wbg.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354 = \
function(arg0, arg1, arg2) {\\n      const ret = new Float32Array(arg0, arg1 \
>>> 0, arg2 >>> 0);\\n      return ret;\\n    };\\n    \
imports.wbg.__wbg_newwithbyteoffsetandlength_f1dead44d1fc7212 = \
function(arg0, arg1, arg2) {\\n      const ret = new Uint32Array(arg0, arg1 \
>>> 0, arg2 >>> 0);\\n      return ret;\\n    };\\n    \
imports.wbg.__wbg_newwithlength_5a5efe313cfd59f1 = function(arg0) {\\n      \
const ret = new Float32Array(arg0 >>> 0);\\n      return ret;\\n    };\\n    \
imports.wbg.__wbg_set_10bad9bee0e9c58b = function(arg0, arg1, arg2) {\\n      \
arg0.set(arg1, arg2 >>> 0);\\n    };\\n    \
imports.wbg.__wbg_set_d23661d19148b229 = function(arg0, arg1, arg2) {\\n      \
arg0.set(arg1, arg2 >>> 0);\\n    };\\n    \
imports.wbg.__wbg_set_f4f1f0daa30696fc = function(arg0, arg1, arg2) {\\n      \
arg0.set(arg1, arg2 >>> 0);\\n    };\\n    \
imports.wbg.__wbg_subarray_3aaeec89bb2544f0 = function(arg0, arg1, arg2) {\\n \
     const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);\\n      return \
ret;\\n    };\\n    imports.wbg.__wbg_subarray_769e1e0f81bb259b = \
function(arg0, arg1, arg2) {\\n      const ret = arg0.subarray(arg1 >>> 0, \
arg2 >>> 0);\\n      return ret;\\n    };\\n    \
imports.wbg.__wbindgen_init_externref_table = function() {\\n      const \
table = wasm.__wbindgen_export_0;\\n      const offset = table.grow(4);\\n    \
  table.set(0, void 0);\\n      table.set(offset + 0, void 0);\\n      \
table.set(offset + 1, null);\\n      table.set(offset + 2, true);\\n      \
table.set(offset + 3, false);\\n    };\\n    imports.wbg.__wbindgen_memory = \
function() {\\n      const ret = wasm.memory;\\n      return ret;\\n    };\\n \
   imports.wbg.__wbindgen_throw = function(arg0, arg1) {\\n      throw new \
Error(getStringFromWasm0(arg0, arg1));\\n    };\\n    return imports;\\n  \
}\\n  function __wbg_finalize_init(instance, module) {\\n    wasm = \
instance.exports;\\n    __wbg_init.__wbindgen_wasm_module = module;\\n    \
cachedUint8ArrayMemory0 = null;\\n    wasm.__wbindgen_start();\\n    return \
wasm;\\n  }\\n  async function __wbg_init(module_or_path) {\\n    if (wasm \
!== void 0) return wasm;\\n    if (typeof module_or_path !== \"undefined\") \
{\\n      if (Object.getPrototypeOf(module_or_path) === Object.prototype) \
{\\n        ({ module_or_path } = module_or_path);\\n      } else {\\n        \
console.warn(\"using deprecated parameters for the initialization function; \
pass a single object instead\");\\n      }\\n    }\\n    if (typeof \
module_or_path === \"undefined\") {\\n      module_or_path = new \
URL(\"data:application/wasm;base64,AGFzbQEAAAABzAEeYAJ/fwF/YAJ/fwBgA39/fwF/YA\
N/f38AYAF/AX9gAX8AYANvf38Bb2AFf39/f38Bf2AFf39/f38AYAFvAW9gA29vfwBgAW8Bf2AAAGA\
AAX9gBH9/f38AYAR/f39/AX9gA39vbwF/YAF/AW9gAAFvYAF9AX1gBn9/f39/fwBgDX19fX19fX19\
f29/fX0Bb2AGf39/f39/AX9gBX9/fX9/AGAEf31/fwBgBX9/fH9/AGAEf3x/fwBgBX9/fn9/AGAEf\
35/fwBgAn19AX0C8gQRA3diZx1fX3diZ19idWZmZXJfNjA5Y2MzZWVlNTFlZDE1OAAJA3diZxpfX3\
diZ19uZXdfOWZlZTk3YTQwOWIzMmI2OAAJA3diZxpfX3diZ19zZXRfZjRmMWYwZGFhMzA2OTZmYwA\
KA3diZx1fX3diZ19sZW5ndGhfOGNmZDJjNjQwOWFmODhhZAALA3diZzFfX3diZ19uZXd3aXRoYnl0\
ZW9mZnNldGFuZGxlbmd0aF9mMWRlYWQ0NGQxZmM3MjEyAAYDd2JnGl9fd2JnX25ld19lM2IzMjFkY\
2ZlZjg5ZmM3AAkDd2JnGl9fd2JnX3NldF9kMjM2NjFkMTkxNDhiMjI5AAoDd2JnHV9fd2JnX2xlbm\
d0aF82Y2E1Mjc2NjVkODk2OTRkAAsDd2JnMV9fd2JnX25ld3dpdGhieXRlb2Zmc2V0YW5kbGVuZ3R\
oX2U2YjdlNjlhY2Q0YzczNTQABgN3YmcaX193Ymdfc2V0XzEwYmFkOWJlZTBlOWM1OGIACgN3Ymcd\
X193YmdfbGVuZ3RoXzNiNGYwMjIxODhhZThkYjYACwN3YmcfX193Ymdfc3ViYXJyYXlfNzY5ZTFlM\
GY4MWJiMjU5YgAGA3diZx9fX3diZ19zdWJhcnJheV8zYWFlZWM4OWJiMjU0NGYwAAYDd2JnJF9fd2\
JnX25ld3dpdGhsZW5ndGhfNWE1ZWZlMzEzY2ZkNTlmMQARA3diZxBfX3diaW5kZ2VuX3Rocm93AAE\
Dd2JnEV9fd2JpbmRnZW5fbWVtb3J5ABIDd2JnH19fd2JpbmRnZW5faW5pdF9leHRlcm5yZWZfdGFi\
bGUADANeXQQAAQcFAgMCEwEBAA0BAwEAAA0BAwgIAwEBBRQBAw4AAwEDAgwMAgABAQcDABUBFhcIG\
RsHBQ4CEBAFAx0FBA8CBAQEAA0AAAEBAQAAAAMBAgMBAAEAAAEAAAEEBAQJAnABLi5vAIABBQMBAB\
EGCQF/AUGAgMAACwdiBgZtZW1vcnkCAAtzb3J0X3NwbGF0cwBJDXNvcnQzMl9zcGxhdHMASg5yYXl\
jYXN0X3NwbGF0cwA+E19fd2JpbmRnZW5fZXhwb3J0XzABARBfX3diaW5kZ2VuX3N0YXJ0ABAJMwEA\
QQELLVRTUlc4RSxCRUBIR0JCQUNETj0ySzQhZFlaXDlbZUYwJCprSzciZmdpVV1eagwBAwqx2wFdp\
iQCCX8BfiMAQRBrIggkAAJ/AkACQAJAAkACQAJAIABB9QFPBEBBACAAQcz/e0sNBxogAEELaiIBQX\
hxIQVBwJnAACgCACIJRQ0EQR8hB0EAIAVrIQQgAEH0//8HTQRAIAVBBiABQQh2ZyIAa3ZBAXEgAEE\
BdGtBPmohBwsgB0ECdEGklsAAaigCACIBRQRAQQAhAAwCC0EAIQAgBUEZIAdBAXZrQQAgB0EfRxt0\
IQMDQAJAIAEoAgRBeHEiBiAFSQ0AIAYgBWsiBiAETw0AIAEhAiAGIgQNAEEAIQQgASEADAQLIAEoA\
hQiBiAAIAYgASADQR12QQRxaigCECIBRxsgACAGGyEAIANBAXQhAyABDQALDAELQbyZwAAoAgAiAk\
EQIABBC2pB+ANxIABBC0kbIgVBA3YiAHYiAUEDcQRAAkAgAUF/c0EBcSAAaiIGQQN0IgBBtJfAAGo\
iAyAAQbyXwABqKAIAIgEoAggiBEcEQCAEIAM2AgwgAyAENgIIDAELQbyZwAAgAkF+IAZ3cTYCAAsg\
ASAAQQNyNgIEIAAgAWoiACAAKAIEQQFyNgIEIAFBCGoMBwsgBUHEmcAAKAIATQ0DAkACQCABRQRAQ\
cCZwAAoAgAiAEUNBiAAaEECdEGklsAAaigCACICKAIEQXhxIAVrIQQgAiEBA0ACQCACKAIQIgANAC\
ACKAIUIgANACABKAIYIQcCQAJAIAEgASgCDCIARgRAIAFBFEEQIAEoAhQiABtqKAIAIgINAUEAIQA\
MAgsgASgCCCICIAA2AgwgACACNgIIDAELIAFBFGogAUEQaiAAGyEDA0AgAyEGIAIiAEEUaiAAQRBq\
IAAoAhQiAhshAyAAQRRBECACG2ooAgAiAg0ACyAGQQA2AgALIAdFDQQCQCABKAIcQQJ0QaSWwABqI\
gIoAgAgAUcEQCABIAcoAhBHBEAgByAANgIUIAANAgwHCyAHIAA2AhAgAA0BDAYLIAIgADYCACAARQ\
0ECyAAIAc2AhggASgCECICBEAgACACNgIQIAIgADYCGAsgASgCFCICRQ0EIAAgAjYCFCACIAA2Ahg\
MBAsgACgCBEF4cSAFayICIAQgAiAESSICGyEEIAAgASACGyEBIAAhAgwACwALAkBBAiAAdCIDQQAg\
A2tyIAEgAHRxaCIGQQN0IgFBtJfAAGoiAyABQbyXwABqKAIAIgAoAggiBEcEQCAEIAM2AgwgAyAEN\
gIIDAELQbyZwAAgAkF+IAZ3cTYCAAsgACAFQQNyNgIEIAAgBWoiBiABIAVrIgNBAXI2AgQgACABai\
ADNgIAQcSZwAAoAgAiBARAIARBeHFBtJfAAGohAUHMmcAAKAIAIQICf0G8mcAAKAIAIgVBASAEQQN\
2dCIEcUUEQEG8mcAAIAQgBXI2AgAgAQwBCyABKAIICyEEIAEgAjYCCCAEIAI2AgwgAiABNgIMIAIg\
BDYCCAtBzJnAACAGNgIAQcSZwAAgAzYCACAAQQhqDAgLQcCZwABBwJnAACgCAEF+IAEoAhx3cTYCA\
AsCQAJAIARBEE8EQCABIAVBA3I2AgQgASAFaiIDIARBAXI2AgQgAyAEaiAENgIAQcSZwAAoAgAiBk\
UNASAGQXhxQbSXwABqIQBBzJnAACgCACECAn9BvJnAACgCACIFQQEgBkEDdnQiBnFFBEBBvJnAACA\
FIAZyNgIAIAAMAQsgACgCCAshBiAAIAI2AgggBiACNgIMIAIgADYCDCACIAY2AggMAQsgASAEIAVq\
IgBBA3I2AgQgACABaiIAIAAoAgRBAXI2AgQMAQtBzJnAACADNgIAQcSZwAAgBDYCAAsgAUEIagwGC\
yAAIAJyRQRAQQAhAkECIAd0IgBBACAAa3IgCXEiAEUNAyAAaEECdEGklsAAaigCACEACyAARQ0BCw\
NAIAAgAiAAKAIEQXhxIgMgBWsiBiAESSIHGyEJIAAoAhAiAUUEQCAAKAIUIQELIAIgCSADIAVJIgA\
bIQIgBCAGIAQgBxsgABshBCABIgANAAsLIAJFDQAgBUHEmcAAKAIAIgBNIAQgACAFa09xDQAgAigC\
GCEHAkACQCACIAIoAgwiAEYEQCACQRRBECACKAIUIgAbaigCACIBDQFBACEADAILIAIoAggiASAAN\
gIMIAAgATYCCAwBCyACQRRqIAJBEGogABshAwNAIAMhBiABIgBBFGogAEEQaiAAKAIUIgEbIQMgAE\
EUQRAgARtqKAIAIgENAAsgBkEANgIACyAHRQ0CAkAgAigCHEECdEGklsAAaiIBKAIAIAJHBEAgAiA\
HKAIQRwRAIAcgADYCFCAADQIMBQsgByAANgIQIAANAQwECyABIAA2AgAgAEUNAgsgACAHNgIYIAIo\
AhAiAQRAIAAgATYCECABIAA2AhgLIAIoAhQiAUUNAiAAIAE2AhQgASAANgIYDAILAkACQAJAAkACQ\
CAFQcSZwAAoAgAiAUsEQCAFQciZwAAoAgAiAE8EQCAFQa+ABGpBgIB8cSIAQRB2IABB//8DcUEAR2\
oiAkAAIQAgCEEEaiIBQQA2AgggAUEAIAJBEHQgAEF/RiICGzYCBCABQQAgAEEQdCACGzYCAEEAIAg\
oAgQiAUUNCRogCCgCDCEGQdSZwAAgCCgCCCIEQdSZwAAoAgBqIgA2AgBB2JnAACAAQdiZwAAoAgAi\
AiAAIAJLGzYCAAJAAkBB0JnAACgCACICBEBBpJfAACEAA0AgASAAKAIAIgMgACgCBCIHakYNAiAAK\
AIIIgANAAsMAgtB4JnAACgCACIAQQAgACABTRtFBEBB4JnAACABNgIAC0HkmcAAQf8fNgIAQbCXwA\
AgBjYCAEGol8AAIAQ2AgBBpJfAACABNgIAQcCXwABBtJfAADYCAEHIl8AAQbyXwAA2AgBBvJfAAEG\
0l8AANgIAQdCXwABBxJfAADYCAEHEl8AAQbyXwAA2AgBB2JfAAEHMl8AANgIAQcyXwABBxJfAADYC\
AEHgl8AAQdSXwAA2AgBB1JfAAEHMl8AANgIAQeiXwABB3JfAADYCAEHcl8AAQdSXwAA2AgBB8JfAA\
EHkl8AANgIAQeSXwABB3JfAADYCAEH4l8AAQeyXwAA2AgBB7JfAAEHkl8AANgIAQYCYwABB9JfAAD\
YCAEH0l8AAQeyXwAA2AgBB/JfAAEH0l8AANgIAQYiYwABB/JfAADYCAEGEmMAAQfyXwAA2AgBBkJj\
AAEGEmMAANgIAQYyYwABBhJjAADYCAEGYmMAAQYyYwAA2AgBBlJjAAEGMmMAANgIAQaCYwABBlJjA\
ADYCAEGcmMAAQZSYwAA2AgBBqJjAAEGcmMAANgIAQaSYwABBnJjAADYCAEGwmMAAQaSYwAA2AgBBr\
JjAAEGkmMAANgIAQbiYwABBrJjAADYCAEG0mMAAQayYwAA2AgBBwJjAAEG0mMAANgIAQciYwABBvJ\
jAADYCAEG8mMAAQbSYwAA2AgBB0JjAAEHEmMAANgIAQcSYwABBvJjAADYCAEHYmMAAQcyYwAA2AgB\
BzJjAAEHEmMAANgIAQeCYwABB1JjAADYCAEHUmMAAQcyYwAA2AgBB6JjAAEHcmMAANgIAQdyYwABB\
1JjAADYCAEHwmMAAQeSYwAA2AgBB5JjAAEHcmMAANgIAQfiYwABB7JjAADYCAEHsmMAAQeSYwAA2A\
gBBgJnAAEH0mMAANgIAQfSYwABB7JjAADYCAEGImcAAQfyYwAA2AgBB/JjAAEH0mMAANgIAQZCZwA\
BBhJnAADYCAEGEmcAAQfyYwAA2AgBBmJnAAEGMmcAANgIAQYyZwABBhJnAADYCAEGgmcAAQZSZwAA\
2AgBBlJnAAEGMmcAANgIAQaiZwABBnJnAADYCAEGcmcAAQZSZwAA2AgBBsJnAAEGkmcAANgIAQaSZ\
wABBnJnAADYCAEG4mcAAQayZwAA2AgBBrJnAAEGkmcAANgIAQdCZwAAgAUEPakF4cSIAQQhrIgI2A\
gBBtJnAAEGsmcAANgIAQciZwAAgBEEoayIDIAEgAGtqQQhqIgA2AgAgAiAAQQFyNgIEIAEgA2pBKD\
YCBEHcmcAAQYCAgAE2AgAMCAsgAiADSSABIAJNcg0AIAAoAgwiA0EBcQ0AIANBAXYgBkYNAwtB4Jn\
AAEHgmcAAKAIAIgAgASAAIAFJGzYCACABIARqIQNBpJfAACEAAkACQANAIAMgACgCACIHRwRAIAAo\
AggiAA0BDAILCyAAKAIMIgNBAXENACADQQF2IAZGDQELQaSXwAAhAANAAkAgAiAAKAIAIgNPBEAgA\
iADIAAoAgRqIgdJDQELIAAoAgghAAwBCwtB0JnAACABQQ9qQXhxIgBBCGsiAzYCAEHImcAAIARBKG\
siCSABIABrakEIaiIANgIAIAMgAEEBcjYCBCABIAlqQSg2AgRB3JnAAEGAgIABNgIAIAIgB0Ega0F\
4cUEIayIAIAAgAkEQakkbIgNBGzYCBEGkl8AAKQIAIQogA0EQakGsl8AAKQIANwIAIAMgCjcCCEGw\
l8AAIAY2AgBBqJfAACAENgIAQaSXwAAgATYCAEGsl8AAIANBCGo2AgAgA0EcaiEAA0AgAEEHNgIAI\
ABBBGoiACAHSQ0ACyACIANGDQcgAyADKAIEQX5xNgIEIAIgAyACayIAQQFyNgIEIAMgADYCACAAQY\
ACTwRAIAIgABAgDAgLIABB+AFxQbSXwABqIQECf0G8mcAAKAIAIgNBASAAQQN2dCIAcUUEQEG8mcA\
AIAAgA3I2AgAgAQwBCyABKAIICyEAIAEgAjYCCCAAIAI2AgwgAiABNgIMIAIgADYCCAwHCyAAIAE2\
AgAgACAAKAIEIARqNgIEIAFBD2pBeHFBCGsiAiAFQQNyNgIEIAdBD2pBeHFBCGsiBCACIAVqIgBrI\
QUgBEHQmcAAKAIARg0DIARBzJnAACgCAEYNBCAEKAIEIgFBA3FBAUYEQCAEIAFBeHEiARAeIAEgBW\
ohBSABIARqIgQoAgQhAQsgBCABQX5xNgIEIAAgBUEBcjYCBCAAIAVqIAU2AgAgBUGAAk8EQCAAIAU\
QIAwGCyAFQfgBcUG0l8AAaiEBAn9BvJnAACgCACIDQQEgBUEDdnQiBHFFBEBBvJnAACADIARyNgIA\
IAEMAQsgASgCCAshAyABIAA2AgggAyAANgIMIAAgATYCDCAAIAM2AggMBQtByJnAACAAIAVrIgE2A\
gBB0JnAAEHQmcAAKAIAIgAgBWoiAjYCACACIAFBAXI2AgQgACAFQQNyNgIEIABBCGoMCAtBzJnAAC\
gCACEAAkAgASAFayICQQ9NBEBBzJnAAEEANgIAQcSZwABBADYCACAAIAFBA3I2AgQgACABaiIBIAE\
oAgRBAXI2AgQMAQtBxJnAACACNgIAQcyZwAAgACAFaiIDNgIAIAMgAkEBcjYCBCAAIAFqIAI2AgAg\
ACAFQQNyNgIECyAAQQhqDAcLIAAgBCAHajYCBEHQmcAAQdCZwAAoAgAiAEEPakF4cSIBQQhrIgI2A\
gBByJnAAEHImcAAKAIAIARqIgMgACABa2pBCGoiATYCACACIAFBAXI2AgQgACADakEoNgIEQdyZwA\
BBgICAATYCAAwDC0HQmcAAIAA2AgBByJnAAEHImcAAKAIAIAVqIgE2AgAgACABQQFyNgIEDAELQcy\
ZwAAgADYCAEHEmcAAQcSZwAAoAgAgBWoiATYCACAAIAFBAXI2AgQgACABaiABNgIACyACQQhqDAML\
QQBByJnAACgCACIAIAVNDQIaQciZwAAgACAFayIBNgIAQdCZwABB0JnAACgCACIAIAVqIgI2AgAgA\
iABQQFyNgIEIAAgBUEDcjYCBCAAQQhqDAILQcCZwABBwJnAACgCAEF+IAIoAhx3cTYCAAsCQCAEQR\
BPBEAgAiAFQQNyNgIEIAIgBWoiACAEQQFyNgIEIAAgBGogBDYCACAEQYACTwRAIAAgBBAgDAILIAR\
B+AFxQbSXwABqIQECf0G8mcAAKAIAIgNBASAEQQN2dCIEcUUEQEG8mcAAIAMgBHI2AgAgAQwBCyAB\
KAIICyEDIAEgADYCCCADIAA2AgwgACABNgIMIAAgAzYCCAwBCyACIAQgBWoiAEEDcjYCBCAAIAJqI\
gAgACgCBEEBcjYCBAsgAkEIagsgCEEQaiQAC88GAQh/AkACQCABIABBA2pBfHEiAyAAayIISQ0AIA\
EgCGsiBkEESQ0AIAZBA3EhB0EAIQECQCAAIANGIgkNAAJAIAAgA2siBUF8SwRAQQAhAwwBC0EAIQM\
DQCABIAAgA2oiAiwAAEG/f0pqIAJBAWosAABBv39KaiACQQJqLAAAQb9/SmogAkEDaiwAAEG/f0pq\
IQEgA0EEaiIDDQALCyAJDQAgACADaiECA0AgASACLAAAQb9/SmohASACQQFqIQIgBUEBaiIFDQALC\
yAAIAhqIQACQCAHRQ0AIAAgBkF8cWoiAywAAEG/f0ohBCAHQQFGDQAgBCADLAABQb9/SmohBCAHQQ\
JGDQAgBCADLAACQb9/SmohBAsgBkECdiEFIAEgBGohBANAIAAhAyAFRQ0CQcABIAUgBUHAAU8bIgZ\
BA3EhByAGQQJ0IQhBACECIAVBBE8EQCAAIAhB8AdxaiEJIAAhAQNAIAEoAgAiAEF/c0EHdiAAQQZ2\
ckGBgoQIcSACaiABQQRqKAIAIgBBf3NBB3YgAEEGdnJBgYKECHFqIAFBCGooAgAiAEF/c0EHdiAAQ\
QZ2ckGBgoQIcWogAUEMaigCACIAQX9zQQd2IABBBnZyQYGChAhxaiECIAFBEGoiASAJRw0ACwsgBS\
AGayEFIAMgCGohACACQQh2Qf+B/AdxIAJB/4H8B3FqQYGABGxBEHYgBGohBCAHRQ0ACwJ/IAMgBkH\
8AXFBAnRqIgAoAgAiAUF/c0EHdiABQQZ2ckGBgoQIcSIBIAdBAUYNABogASAAKAIEIgFBf3NBB3Yg\
AUEGdnJBgYKECHFqIgEgB0ECRg0AGiAAKAIIIgBBf3NBB3YgAEEGdnJBgYKECHEgAWoLIgFBCHZB/\
4EccSABQf+B/AdxakGBgARsQRB2IARqDwsgAUUEQEEADwsgAUEDcSEDAkAgAUEESQRADAELIAFBfH\
EhBQNAIAQgACACaiIBLAAAQb9/SmogAUEBaiwAAEG/f0pqIAFBAmosAABBv39KaiABQQNqLAAAQb9\
/SmohBCAFIAJBBGoiAkcNAAsLIANFDQAgACACaiEBA0AgBCABLAAAQb9/SmohBCABQQFqIQEgA0EB\
ayIDDQALCyAEC4oGAQZ/IAAoAggiAyABSQRAIAEgAyICayIEIAAoAgAgAmtLBEAgACACIARBBEEEE\
CYgACgCCCECCyAAKAIEIgYgAkECdGohBSAEQQJPBEAgASADQX9zakECdCIHBEAgBUEAIAf8CwALIA\
EgAmpBAnQgA0ECdGsgBmpBBGshBSACIARqQQFrIQILIAVBADYCACAAIAJBAWo2AggLIAAoAhQiAyA\
BSQRAIAEgAyICayIEIAAoAgwgAmtLBEAgAEEMaiACIARBBEEEECYgACgCFCECCyAAKAIQIgYgAkEC\
dGohBSAEQQJPBEAgASADQX9zakECdCIHBEAgBUEAIAf8CwALIAEgAmpBAnQgA0ECdGsgBmpBBGshB\
SACIARqQQFrIQILIAVBADYCACAAIAJBAWo2AhQLIAAoAjgiAyABSQRAIAEgAyICayIEIAAoAjAgAm\
tLBEAgAEEwaiACIARBBEEEECYgACgCOCECCyAAKAI0IgYgAkECdGohBSAEQQJPBEAgASADQX9zakE\
CdCIHBEAgBUEAIAf8CwALIAEgAmpBAnQgA0ECdGsgBmpBBGshBSACIARqQQFrIQILIAVBADYCACAA\
IAJBAWo2AjgLIAAoAiAiA0H//wNNBEAgAyEBQYCABCADayICIAAoAhggA2tLBEAgAEEYaiADIAJBB\
EEEECYgACgCICEBCyAAKAIcIgUgAUECdCIEaiECIANB//8DRwRAQfz/DyADQQJ0IgZrIgcEQCACQQ\
AgB/wLAAsgBCAGayAFakH8/w9qIQIgASADa0H//wNqIQELIAJBADYCACAAIAFBAWo2AiALIAAoAiw\
iA0H//wNNBEAgAyEBQYCABCADayICIAAoAiQgA2tLBEAgAEEkaiADIAJBBEEEECYgACgCLCEBCyAA\
KAIoIgUgAUECdCIEaiECIANB//8DRwRAQfz/DyADQQJ0IgZrIgcEQCACQQAgB/wLAAsgBCAGayAFa\
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\
zYCCCANIAo2AgQgDSAANgIAIA0gDUEEaiIAKAIAEG02AgwgDSANQQhqNgIcIA0gDTYCGCANIAA2Ah\
QgDSANQQxqNgIQIA1BEGohACMAQdAAayIIJAACQAJAAkACQAJAQQBBjIbAACgCABEEACIPBEAgDyg\
CAA0BIAAoAgwhFiAAKAIIIQogACgCACEDIA9BfzYCACAAKAIEIQAgD0EEaiILIAMoAgAQEyAIIABB\
ACAKKAIAEGE2AgggCigCACIAIA8oAgwiCUsNAiAIQQhqIA8oAgggABAzIAhBDGohFSADKAIAIQAgC\
igCACETIwBBMGsiDiQAIAsgABATAkAgCygCCCIAIBNPBEAgCygCBCEKIAsoAhwhAwJAIAsoAiAiDE\
UNACAMQQJ0IgBFDQAgA0EAIAD8CwALIAsoAighFAJAIAsoAiwiEEUNACAQQQJ0IgBFDQAgFEEAIAD\
8CwALIBNBAnQhCSATBEAgCSEEIAohAANAAkAgACgCACIGQYCAgPwHTw0AIAwgBkF/cyIFQf//A3Ei\
BksEQCADIAZBAnRqIgYgBigCAEEBajYCACAQIAVBEHYiBksEQCAUIAZBAnRqIgYgBigCAEEBajYCA\
AwCCyAGIBBB3InAABAxAAsgBiAMQcyJwAAQMQALIABBBGohACAEQQRrIgQNAAsLAkAgDEUEQEEAIQ\
QMAQsgDEEBa0H/////A3EiAEEBaiIEQQdxIQUCQCAAQQdJBEBBACEEIAMhAAwBCyAEQfj///8HcSE\
GQQAhBCADIQADQCAAKAIAIQcgACAENgIAIABBBGoiESgCACESIBEgBCAHaiIENgIAIABBCGoiBygC\
ACERIAcgBCASaiIENgIAIABBDGoiBygCACESIAcgBCARaiIENgIAIABBEGoiBygCACERIAcgBCASa\
iIENgIAIABBFGoiBygCACESIAcgBCARaiIENgIAIABBGGoiBygCACERIAcgBCASaiIENgIAIABBHG\
oiBygCACESIAcgBCARaiIENgIAIAQgEmohBCAAQSBqIQAgBkEIayIGDQALCyAFRQ0AA0AgACgCACE\
GIAAgBDYCACAAQQRqIQAgBCAGaiEEIAVBAWsiBQ0ACwsgDiAENgIEIBMEQCAJIApqIREgCkEEaiEG\
IBNBAWtB/////wNxQQFqIRIgCygCNCEXIAsoAjghB0EAIQUgCiEJA0AgBiEAAkAgCSgCACIJQYCAg\
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\
3I2AgQgByAHKAIEQQFyNgIEIAEgAxAaDAkLQciZwAAoAgAgBGoiBCABSw0HCyADEBEiAUUNASADQX\
xBeCAFKAIAIgJBA3EbIAJBeHFqIgIgAiADSxsiAgRAIAEgACAC/AoAAAsgABAVIAEMCAsgAyABIAE\
gA0sbIgIEQCAIIAAgAvwKAAALIAUoAgAiAkF4cSIDIAFBBEEIIAJBA3EiAhtqSQ0DIAJBACADIAlL\
Gw0EIAAQFQsgCAwGC0HQi8AAQYCMwAAQOgALQZCMwABBwIzAABA6AAtB0IvAAEGAjMAAEDoAC0GQj\
MAAQcCMwAAQOgALIAUgASAGQQFxckECcjYCACABIAJqIgIgBCABayIBQQFyNgIEQciZwAAgATYCAE\
HQmcAAIAI2AgAgAAwBCyAACwsWACAAKAIAIAEgAiAAKAIEKAIMEQIAC4UCAQN/QfCVwAAoAgBFBEA\
CQAJAAn8CQCAARQ0AIAAoAgAgAEEANgIAQQFxRQ0AIAAoAhAhAiAAKAIMIQEgACgCCCEDIAAoAgQM\
AQsCQEGAgMAAEBEiAEUNACAAQQRrLQAAQQNxRQ0AIABBAEGAgMAA/AsACyAAIgFFDQFBgIAQIQJBg\
IAQIQNBAAshAEGAlsAAIAI2AgBB9JXAACAANgIAQfyVwAAoAgAhAkH8lcAAIAE2AgBB+JXAACgCAC\
EAQfiVwAAgAzYCAEHwlcAAKAIAQfCVwABBATYCAEUgAEVyRQRAIAIgAEECdBBgCwwBC0EEQYCAwAB\
B+IXAABBMAAsLQfSVwAALxAQBEX9BrJXAACgCAEUEQAJAIAAEQCAAKAJAIQEgACgCPCECIAAoAjgh\
AyAAKAI0IQQgACgCMCEFIAAoAiwhBiAAKAIoIQcgACgCJCEIIAAoAiAhCSAAKAIcIQogACgCGCELI\
AAoAhQhDCAAKAIQIQ0gACgCDCEOIAAoAgghDyAAKAIEIRAgACgCACAAQQA2AgBBAXENAQtBBCECQQ\
AhAUEAIQNBACEEQQQhBUEAIQZBACEHQQQhCEEAIQlBACEKQQQhC0EAIQxBACENQQQhDkEAIQ9BACE\
QC0HslcAAIAE2AgBB4JXAACAENgIAQdSVwAAgBzYCAEHIlcAAIAo2AgBBvJXAACANNgIAQbCVwAAg\
EDYCAEHolcAAKAIAIQdB6JXAACACNgIAQeSVwAAoAgAhAEHklcAAIAM2AgBB3JXAACgCACEKQdyVw\
AAgBTYCAEHYlcAAKAIAIQFB2JXAACAGNgIAQdCVwAAoAgAhBUHQlcAAIAg2AgBBzJXAACgCACECQc\
yVwAAgCTYCAEHElcAAKAIAIQZBxJXAACALNgIAQcCVwAAoAgAhA0HAlcAAIAw2AgBBuJXAACgCACE\
IQbiVwAAgDjYCAEG0lcAAKAIAIQRBtJXAACAPNgIAQayVwAAoAgAhCUGslcAAQQE2AgACQCAJRQ0A\
IAQEQCAIIARBAnQQYAsgAwRAIAYgA0ECdBBgCyACBEAgBSACQQJ0EGALIAEEQCAKIAFBAnQQYAsgA\
EUNACAHIABBAnQQYAsLQbCVwAAL8gIBCX9BgJXAACgCAEUEQAJ/AkAgAEUNACAAKAIAIABBADYCAE\
EBcUUNACAAKAIoIQEgACgCJCEHIAAoAiAhAiAAKAIcIQMgACgCGCEIIAAoAhQhBCAAKAIQIQUgACg\
CDCEJIAAoAgghBiAAKAIEDAELQQIhCUEEIQdBACEBQQQhCEEACyEAQaiVwAAgATYCAEGclcAAIAM2\
AgBBkJXAACAFNgIAQYSVwAAgADYCAEGklcAAKAIAIQVBpJXAACAHNgIAQaCVwAAoAgAhAEGglcAAI\
AI2AgBBmJXAACgCACEBQZiVwAAgCDYCAEGUlcAAKAIAIQJBlJXAACAENgIAQYyVwAAoAgAhBEGMlc\
AAIAk2AgBBiJXAACgCACEDQYiVwAAgBjYCAEGAlcAAKAIAIQZBgJXAAEEBNgIAAkAgBkUNACADBEA\
gBCADQQF0EGALIAIEQCABIAJBAnQQYAsgAEUNACAFIABBAnQQYAsLQYSVwAALFAAgACgCACABIAAo\
AgQoAgwRAAALFAIBbwF/EA8hABAdIgEgACYBIAELEAAgASAAKAIEIAAoAggQFgsZAAJ/IAFBCU8EQ\
CABIAAQHAwBCyAAEBELCyAAIABC356dmJy3lrgCNwMIIABCoe2sjPn0nLgHNwMACyIAIABC7bqtts\
2F1PXjADcDCCAAQviCmb2V7sbFuX83AwALEwAgAEGAjsAANgIEIAAgATYCAAsQACABIAAoAgAgACg\
CBBBRCxAAIAEgACgCACAAKAIEEBYLEAAgASgCACABKAIEIAAQGAsOACAAJQEgASUBIAIQBgtbAQJ/\
AkACQCAAQQRrKAIAIgJBeHEiA0EEQQggAkEDcSICGyABak8EQCACQQAgAyABQSdqSxsNASAAEBUMA\
gtB0IvAAEGAjMAAEDoAC0GQjMAAQcCMwAAQOgALCx0BAW8gACgCACUBIAEgAhAMIQMQHSIAIAMmAS\
AAC2oBAX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQQI2AgwgA0G0lMAANgIIIANCAjcCFCADIAN\
BBGqtQoCAgIDQAIQ3AyggAyADrUKAgICA0ACENwMgIAMgA0EgajYCECADQQhqIAIQPwALCQAgACAB\
EA4ACw0AIABBuIvAACABEBgLDAAgACABKQIANwMACw0AIABB0I7AACABEBgLDQAgAUHIjsAAQQUQU\
QsZACAAIAFBkJbAACgCACIAQRQgABsRAQAACw0AIAFBpJDAAEEYEBYLoAIBA38gACgCACEAIwBBkA\
FrIgMkAAJ/AkAgASgCCCICQYCAgBBxRQRAIAJBgICAIHENASADQQhqIAAoAgAgA0EQahAfIAFBAUE\
AIAMoAgggAygCDBAUDAILIAAoAgAhAkEAIQADQCAAIANqQY8BaiACQQ9xIgRBMHIgBEHXAGogBEEK\
SRs6AAAgAEEBayEAIAJBD0sgAkEEdiECDQALIAFBt5LAAEECIAAgA2pBkAFqQQAgAGsQFAwBCyAAK\
AIAIQJBACEAA0AgACADakGPAWogAkEPcSIEQTByIARBN2ogBEEKSRs6AAAgAEEBayEAIAJBD0sgAk\
EEdiECDQALIAFBt5LAAEECIAAgA2pBkAFqQQAgAGsQFAsgA0GQAWokAAsJACAAQQA2AgALCAAgACU\
BEAMLCAAgACUBEAcLC/UUAwBBgIDAAAuhD3NwYXJrLWludGVybmFsLXJzL3NyYy9yYXljYXN0LnJz\
AHNwYXJrLWludGVybmFsLXJzL3NyYy9zb3J0LnJzAGxpYnJhcnkvYWxsb2Mvc3JjL2ZtdC5ycwAva\
G9tZS9ydW5uZXIvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2Yj\
ViNTU3Zi93YXNtLWJpbmRnZW4tMC4yLjEwMC9zcmMvY29udmVydC9zbGljZXMucnMAL3J1c3RjLzI\
5NDgzODgzZWVkNjlkNWZiNGRiMDE5NjRjZGYyYWY0ZDg2ZTljYjIvbGlicmFyeS9zdGQvc3JjL3Ro\
cmVhZC9sb2NhbC5ycwBsaWJyYXJ5L2FsbG9jL3NyYy9zdHJpbmcucnMAL3J1c3RjLzI5NDgzODgzZ\
WVkNjlkNWZiNGRiMDE5NjRjZGYyYWY0ZDg2ZTljYjIvbGlicmFyeS9hbGxvYy9zcmMvc2xpY2Uucn\
MAL3J1c3RjLzI5NDgzODgzZWVkNjlkNWZiNGRiMDE5NjRjZGYyYWY0ZDg2ZTljYjIvbGlicmFyeS9\
hbGxvYy9zcmMvcmF3X3ZlYy9tb2QucnMAL3J1c3QvZGVwcy9kbG1hbGxvYy0wLjIuOS9zcmMvZGxt\
YWxsb2MucnMAbGlicmFyeS9zdGQvc3JjL2FsbG9jLnJzAHNwYXJrLWludGVybmFsLXJzL3NyYy9sa\
WIucnMAL2hvbWUvcnVubmVyLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5ND\
ljZjhjNmI1YjU1N2YvanMtc3lzLTAuMy43Ny9zcmMvbGliLnJzAC9ob21lL3J1bm5lci8uY2FyZ28\
vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL29uY2VfY2VsbC0x\
LjIxLjMvc3JjL2xpYi5ycwAAAHwBEABRAAAALgIAABEAAAAQAhAAHQAAABEAAAA9AAAAAQAAAAIAA\
AADAAAAxQAQAFAAAAAZAQAAGQAAAMUAEABQAAAAGAIAACYAAAAxARAASwAAAMEBAAAdAAAAAAAQAC\
EAAAAqAAAAFwAAAAAAEAAhAAAAeAAAABcAAAAAABAAIQAAAH4AAAAcAAAAAAAQACEAAACAAAAAHAA\
AAAAAEAAhAAAAhQAAACAAAAAQAhAAHQAAAB0AAAAzAAAAEAIQAB0AAAAoAAAALQAAAAEAAAAAAAAA\
EAIQAB0AAAA6AAAAMwAAABACEAAdAAAARQAAAC0AAAAQAhAAHQAAAF4AAAAoAAAAIQAQAB4AAAAbA\
AAAHQAAAEV4cGVjdGVkICBhY3RpdmUgc3BsYXRzIGJ1dCBnb3Qg/AMQAAkAAAAFBBAAFwAAACEAEA\
AeAAAAMwAAAB0AAAAhABAAHgAAADMAAAAVAAAAIQAQAB4AAAAkAAAAFAAAACEAEAAeAAAAdAAAABk\
AAAAhABAAHgAAAKcAAAATAAAAIQAQAB4AAACfAAAAEwAAACEAEAAeAAAAogAAAB0AAAAhABAAHgAA\
AKIAAAARAAAAIQAQAB4AAACQAAAAIAAAACEAEAAeAAAAkAAAABQAAAAhABAAHgAAAHwAAAAYAAAAI\
QAQAB4AAAB9AAAAGAAAAC0CEABbAAAA+xgAAAEAAABYABAAbQAAACQBAAAOAAAAY2xvc3VyZSBpbn\
Zva2VkIHJlY3Vyc2l2ZWx5IG9yIGFmdGVyIGJlaW5nIGRyb3BwZWRMYXp5IGluc3RhbmNlIGhhcyB\
wcmV2aW91c2x5IGJlZW4gcG9pc29uZWQ+BRAAKgAAAIgCEABeAAAACAMAABkAAAByZWVudHJhbnQg\
aW5pdAAAgAUQAA4AAACIAhAAXgAAAHoCAAANAAAAfAEQAFEAAAAuAgAAEQAAABUAAAAMAAAABAAAA\
BYAAAAXAAAAGAAAAGFzc2VydGlvbiBmYWlsZWQ6IHBzaXplID49IHNpemUgKyBtaW5fb3ZlcmhlYW\
QAAM0BEAAqAAAAsAQAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA8PSBzaXplICsgbWF4X29\
2ZXJoZWFkAADNARAAKgAAALYEAAANAAAAQWNjZXNzRXJyb3JjYW5ub3QgYWNjZXNzIGEgVGhyZWFk\
IExvY2FsIFN0b3JhZ2UgdmFsdWUgZHVyaW5nIG9yIGFmdGVyIGRlc3RydWN0aW9uOiAAWwYQAEgAA\
ABtZW1vcnkgYWxsb2NhdGlvbiBvZiAgYnl0ZXMgZmFpbGVkAACsBhAAFQAAAMEGEAANAAAA9wEQAB\
kAAABkAQAACQAAABUAAAAMAAAABAAAABkAAAAAAAAACAAAAAQAAAAaAAAAAAAAAAgAAAAEAAAAGwA\
AABwAAAAdAAAAHgAAAB8AAAAQAAAABAAAACAAAAAhAAAAIgAAACMAAABFcnJvcgAAACQAAAAMAAAA\
BAAAACUAAAAmAAAAJwAAAGNhcGFjaXR5IG92ZXJmbG93AAAAaAcQABEAAACsARAAIQAAAC4CAAARA\
AAAFQEQABwAAADoAQAAFwBBrI/AAAu4BQEAAAAoAAAAYSBmb3JtYXR0aW5nIHRyYWl0IGltcGxlbW\
VudGF0aW9uIHJldHVybmVkIGFuIGVycm9yIHdoZW4gdGhlIHVuZGVybHlpbmcgc3RyZWFtIGRpZCB\
ub3QAAD8AEAAZAAAAigIAAA4AAAABAAAAAAAAAFJlZkNlbGwgYWxyZWFkeSBib3Jyb3dlZGluZGV4\
IG91dCBvZiBib3VuZHM6IHRoZSBsZW4gaXMgIGJ1dCB0aGUgaW5kZXggaXMgAAA8CBAAIAAAAFwIE\
AASAAAAAAAAAAQAAAAEAAAALQAAAD09IT1tYXRjaGVzYXNzZXJ0aW9uIGBsZWZ0ICByaWdodGAgZm\
FpbGVkCiAgbGVmdDogCiByaWdodDogAJsIEAAQAAAAqwgQABcAAADCCBAACQAAACByaWdodGAgZmF\
pbGVkOiAKICBsZWZ0OiAAAACbCBAAEAAAAOQIEAAQAAAA9AgQAAkAAADCCBAACQAAADogAAABAAAA\
AAAAACAJEAACAAAAfSB9MHgwMDAxMDIwMzA0MDUwNjA3MDgwOTEwMTExMjEzMTQxNTE2MTcxODE5M\
jAyMTIyMjMyNDI1MjYyNzI4MjkzMDMxMzIzMzM0MzUzNjM3MzgzOTQwNDE0MjQzNDQ0NTQ2NDc0OD\
Q5NTA1MTUyNTM1NDU1NTY1NzU4NTk2MDYxNjI2MzY0NjU2NjY3Njg2OTcwNzE3MjczNzQ3NTc2Nzc\
3ODc5ODA4MTgyODM4NDg1ODY4Nzg4ODk5MDkxOTI5Mzk0OTU5Njk3OTg5OSBvdXQgb2YgcmFuZ2Ug\
Zm9yIHNsaWNlIG9mIGxlbmd0aCByYW5nZSBlbmQgaW5kZXggACMKEAAQAAAAAQoQACIAAACQCBAAk\
ggQAJQIEAACAAAAAgAAAAcAAAAAAAA/AAAAvwBB/JTAAAsBEgB8CXByb2R1Y2VycwIIbGFuZ3VhZ2\
UBBFJ1c3QADHByb2Nlc3NlZC1ieQMFcnVzdGMdMS44OS4wICgyOTQ4Mzg4M2UgMjAyNS0wOC0wNCk\
Gd2FscnVzBjAuMjMuMwx3YXNtLWJpbmRnZW4TMC4yLjEwMCAoMjQwNWVjMmI0KQBrD3RhcmdldF9m\
ZWF0dXJlcwYrD211dGFibGUtZ2xvYmFscysTbm9udHJhcHBpbmctZnB0b2ludCsLYnVsay1tZW1vc\
nkrCHNpZ24tZXh0Kw9yZWZlcmVuY2UtdHlwZXMrCm11bHRpdmFsdWU=\", \
self.location.href);\\n    }\\n    const imports = __wbg_get_imports();\\n    \
if (typeof module_or_path === \"string\" || typeof Request === \"function\" \
&& module_or_path instanceof Request || typeof URL === \"function\" && \
module_or_path instanceof URL) {\\n      module_or_path = \
fetch(module_or_path);\\n    }\\n    const { instance, module } = await \
__wbg_load(await module_or_path, imports);\\n    return \
__wbg_finalize_init(instance, module);\\n  }\\n  var ch2 = {};\\n  var wk = \
function(c, id, msg, transfer, cb) {\\n    var w = new Worker(ch2[id] || \
(ch2[id] = URL.createObjectURL(new Blob([\\n      c + \
\\';addEventListener(\"error\",function(e){e=e.error;postMessage({$e$:[e.mess\
age,e.code,e.stack]})})\\'\\n    ], { type: \"text/javascript\" }))));\\n    \
w.onmessage = function(e) {\\n      var d = e.data, ed = d.$e$;\\n      if \
(ed) {\\n        var err2 = new Error(ed[0]);\\n        err2[\"code\"] = \
ed[1];\\n        err2.stack = ed[2];\\n        cb(err2, null);\\n      } \
else\\n        cb(null, d);\\n    };\\n    w.postMessage(msg, transfer);\\n   \
 return w;\\n  };\\n  var u8 = Uint8Array, u16 = Uint16Array, i32 = \
Int32Array;\\n  var fleb = new u8([\\n    0,\\n    0,\\n    0,\\n    0,\\n    \
0,\\n    0,\\n    0,\\n    0,\\n    1,\\n    1,\\n    1,\\n    1,\\n    2,\\n \
   2,\\n    2,\\n    2,\\n    3,\\n    3,\\n    3,\\n    3,\\n    4,\\n    \
4,\\n    4,\\n    4,\\n    5,\\n    5,\\n    5,\\n    5,\\n    0,\\n    /* \
unused */\\n    0,\\n    0,\\n    /* impossible */\\n    0\\n  ]);\\n  var \
fdeb = new u8([\\n    0,\\n    0,\\n    0,\\n    0,\\n    1,\\n    1,\\n    \
2,\\n    2,\\n    3,\\n    3,\\n    4,\\n    4,\\n    5,\\n    5,\\n    6,\\n \
   6,\\n    7,\\n    7,\\n    8,\\n    8,\\n    9,\\n    9,\\n    10,\\n    \
10,\\n    11,\\n    11,\\n    12,\\n    12,\\n    13,\\n    13,\\n    /* \
unused */\\n    0,\\n    0\\n  ]);\\n  var clim = new u8([16, 17, 18, 0, 8, \
7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\\n  var freb = function(eb, \
start) {\\n    var b = new u16(31);\\n    for (var i2 = 0; i2 < 31; ++i2) \
{\\n      b[i2] = start += 1 << eb[i2 - 1];\\n    }\\n    var r = new \
i32(b[30]);\\n    for (var i2 = 1; i2 < 30; ++i2) {\\n      for (var j = \
b[i2]; j < b[i2 + 1]; ++j) {\\n        r[j] = j - b[i2] << 5 | i2;\\n      \
}\\n    }\\n    return { b, r };\\n  };\\n  var _a = freb(fleb, 2), fl = \
_a.b, revfl = _a.r;\\n  fl[28] = 258, revfl[258] = 28;\\n  var _b = \
freb(fdeb, 0), fd = _b.b;\\n  var rev = new u16(32768);\\n  for (var i = 0; i \
< 32768; ++i) {\\n    var x = (i & 43690) >> 1 | (i & 21845) << 1;\\n    x = \
(x & 52428) >> 2 | (x & 13107) << 2;\\n    x = (x & 61680) >> 4 | (x & 3855) \
<< 4;\\n    rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;\\n  }\\n  var \
hMap = function(cd, mb, r) {\\n    var s = cd.length;\\n    var i2 = 0;\\n    \
var l = new u16(mb);\\n    for (; i2 < s; ++i2) {\\n      if (cd[i2])\\n      \
  ++l[cd[i2] - 1];\\n    }\\n    var le = new u16(mb);\\n    for (i2 = 1; i2 \
< mb; ++i2) {\\n      le[i2] = le[i2 - 1] + l[i2 - 1] << 1;\\n    }\\n    var \
co;\\n    if (r) {\\n      co = new u16(1 << mb);\\n      var rvb = 15 - \
mb;\\n      for (i2 = 0; i2 < s; ++i2) {\\n        if (cd[i2]) {\\n          \
var sv = i2 << 4 | cd[i2];\\n          var r_1 = mb - cd[i2];\\n          var \
v = le[cd[i2] - 1]++ << r_1;\\n          for (var m = v | (1 << r_1) - 1; v \
<= m; ++v) {\\n            co[rev[v] >> rvb] = sv;\\n          }\\n        \
}\\n      }\\n    } else {\\n      co = new u16(s);\\n      for (i2 = 0; i2 < \
s; ++i2) {\\n        if (cd[i2]) {\\n          co[i2] = rev[le[cd[i2] - 1]++] \
>> 15 - cd[i2];\\n        }\\n      }\\n    }\\n    return co;\\n  };\\n  var \
flt = new u8(288);\\n  for (var i = 0; i < 144; ++i)\\n    flt[i] = 8;\\n  \
for (var i = 144; i < 256; ++i)\\n    flt[i] = 9;\\n  for (var i = 256; i < \
280; ++i)\\n    flt[i] = 7;\\n  for (var i = 280; i < 288; ++i)\\n    flt[i] \
= 8;\\n  var fdt = new u8(32);\\n  for (var i = 0; i < 32; ++i)\\n    fdt[i] \
= 5;\\n  var flrm = /* @__PURE__ */ hMap(flt, 9, 1);\\n  var fdrm = /* \
@__PURE__ */ hMap(fdt, 5, 1);\\n  var max = function(a) {\\n    var m = \
a[0];\\n    for (var i2 = 1; i2 < a.length; ++i2) {\\n      if (a[i2] > m)\\n \
       m = a[i2];\\n    }\\n    return m;\\n  };\\n  var bits = function(d, \
p, m) {\\n    var o = p / 8 | 0;\\n    return (d[o] | d[o + 1] << 8) >> (p & \
7) & m;\\n  };\\n  var bits16 = function(d, p) {\\n    var o = p / 8 | 0;\\n  \
  return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);\\n  };\\n  var \
shft = function(p) {\\n    return (p + 7) / 8 | 0;\\n  };\\n  var slc = \
function(v, s, e) {\\n    if (s == null || s < 0)\\n      s = 0;\\n    if (e \
== null || e > v.length)\\n      e = v.length;\\n    return new \
u8(v.subarray(s, e));\\n  };\\n  var ec = [\\n    \"unexpected EOF\",\\n    \
\"invalid block type\",\\n    \"invalid length/literal\",\\n    \"invalid \
distance\",\\n    \"stream finished\",\\n    \"no stream handler\",\\n    \
,\\n    \"no callback\",\\n    \"invalid UTF-8 data\",\\n    \"extra field \
too long\",\\n    \"date not in range 1980-2099\",\\n    \"filename too \
long\",\\n    \"stream finishing\",\\n    \"invalid zip data\"\\n    // \
determined by unknown compression method\\n  ];\\n  var err = function(ind, \
msg, nt) {\\n    var e = new Error(msg || ec[ind]);\\n    e.code = ind;\\n    \
if (Error.captureStackTrace)\\n      Error.captureStackTrace(e, err);\\n    \
if (!nt)\\n      throw e;\\n    return e;\\n  };\\n  var inflt = \
function(dat, st, buf, dict) {\\n    var sl = dat.length, dl = dict ? \
dict.length : 0;\\n    if (!sl || st.f && !st.l)\\n      return buf || new \
u8(0);\\n    var noBuf = !buf;\\n    var resize = noBuf || st.i != 2;\\n    \
var noSt = st.i;\\n    if (noBuf)\\n      buf = new u8(sl * 3);\\n    var \
cbuf = function(l2) {\\n      var bl = buf.length;\\n      if (l2 > bl) {\\n  \
      var nbuf = new u8(Math.max(bl * 2, l2));\\n        nbuf.set(buf);\\n    \
    buf = nbuf;\\n      }\\n    };\\n    var final = st.f || 0, pos = st.p || \
0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\\n    var \
tbts = sl * 8;\\n    do {\\n      if (!lm) {\\n        final = bits(dat, pos, \
1);\\n        var type = bits(dat, pos + 1, 3);\\n        pos += 3;\\n        \
if (!type) {\\n          var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] \
<< 8, t = s + l;\\n          if (t > sl) {\\n            if (noSt)\\n         \
     err(0);\\n            break;\\n          }\\n          if (resize)\\n    \
        cbuf(bt + l);\\n          buf.set(dat.subarray(s, t), bt);\\n         \
 st.b = bt += l, st.p = pos = t * 8, st.f = final;\\n          continue;\\n   \
     } else if (type == 1)\\n          lm = flrm, dm = fdrm, lbt = 9, dbt = \
5;\\n        else if (type == 2) {\\n          var hLit = bits(dat, pos, 31) \
+ 257, hcLen = bits(dat, pos + 10, 15) + 4;\\n          var tl = hLit + \
bits(dat, pos + 5, 31) + 1;\\n          pos += 14;\\n          var ldt = new \
u8(tl);\\n          var clt = new u8(19);\\n          for (var i2 = 0; i2 < \
hcLen; ++i2) {\\n            clt[clim[i2]] = bits(dat, pos + i2 * 3, 7);\\n   \
       }\\n          pos += hcLen * 3;\\n          var clb = max(clt), clbmsk \
= (1 << clb) - 1;\\n          var clm = hMap(clt, clb, 1);\\n          for \
(var i2 = 0; i2 < tl; ) {\\n            var r = clm[bits(dat, pos, \
clbmsk)];\\n            pos += r & 15;\\n            var s = r >> 4;\\n       \
     if (s < 16) {\\n              ldt[i2++] = s;\\n            } else {\\n   \
           var c = 0, n = 0;\\n              if (s == 16)\\n                n \
= 3 + bits(dat, pos, 3), pos += 2, c = ldt[i2 - 1];\\n              else if \
(s == 17)\\n                n = 3 + bits(dat, pos, 7), pos += 3;\\n           \
   else if (s == 18)\\n                n = 11 + bits(dat, pos, 127), pos += \
7;\\n              while (n--)\\n                ldt[i2++] = c;\\n            \
}\\n          }\\n          var lt = ldt.subarray(0, hLit), dt = \
ldt.subarray(hLit);\\n          lbt = max(lt);\\n          dbt = max(dt);\\n  \
        lm = hMap(lt, lbt, 1);\\n          dm = hMap(dt, dbt, 1);\\n        } \
else\\n          err(1);\\n        if (pos > tbts) {\\n          if (noSt)\\n \
           err(0);\\n          break;\\n        }\\n      }\\n      if \
(resize)\\n        cbuf(bt + 131072);\\n      var lms = (1 << lbt) - 1, dms = \
(1 << dbt) - 1;\\n      var lpos = pos;\\n      for (; ; lpos = pos) {\\n     \
   var c = lm[bits16(dat, pos) & lms], sym = c >> 4;\\n        pos += c & \
15;\\n        if (pos > tbts) {\\n          if (noSt)\\n            \
err(0);\\n          break;\\n        }\\n        if (!c)\\n          \
err(2);\\n        if (sym < 256)\\n          buf[bt++] = sym;\\n        else \
if (sym == 256) {\\n          lpos = pos, lm = null;\\n          break;\\n    \
    } else {\\n          var add = sym - 254;\\n          if (sym > 264) {\\n \
           var i2 = sym - 257, b = fleb[i2];\\n            add = bits(dat, \
pos, (1 << b) - 1) + fl[i2];\\n            pos += b;\\n          }\\n         \
 var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;\\n          if (!d)\\n    \
        err(3);\\n          pos += d & 15;\\n          var dt = fd[dsym];\\n  \
        if (dsym > 3) {\\n            var b = fdeb[dsym];\\n            dt += \
bits16(dat, pos) & (1 << b) - 1, pos += b;\\n          }\\n          if (pos \
> tbts) {\\n            if (noSt)\\n              err(0);\\n            \
break;\\n          }\\n          if (resize)\\n            cbuf(bt + \
131072);\\n          var end = bt + add;\\n          if (bt < dt) {\\n        \
    var shift = dl - dt, dend = Math.min(dt, end);\\n            if (shift + \
bt < 0)\\n              err(3);\\n            for (; bt < dend; ++bt)\\n      \
        buf[bt] = dict[shift + bt];\\n          }\\n          for (; bt < \
end; ++bt)\\n            buf[bt] = buf[bt - dt];\\n        }\\n      }\\n     \
 st.l = lm, st.p = lpos, st.b = bt, st.f = final;\\n      if (lm)\\n        \
final = 1, st.m = lbt, st.d = dm, st.n = dbt;\\n    } while (!final);\\n    \
return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);\\n  \
};\\n  var et = /* @__PURE__ */ new u8(0);\\n  var mrg = function(a, b) {\\n  \
  var o = {};\\n    for (var k in a)\\n      o[k] = a[k];\\n    for (var k in \
b)\\n      o[k] = b[k];\\n    return o;\\n  };\\n  var wcln = function(fn, \
fnStr, td2) {\\n    var dt = fn();\\n    var st = fn.toString();\\n    var ks \
= st.slice(st.indexOf(\"[\") + 1, st.lastIndexOf(\"]\")).replace(/\\\\s+/g, \
\"\").split(\",\");\\n    for (var i2 = 0; i2 < dt.length; ++i2) {\\n      \
var v = dt[i2], k = ks[i2];\\n      if (typeof v == \"function\") {\\n        \
fnStr += \";\" + k + \"=\";\\n        var st_1 = v.toString();\\n        if \
(v.prototype) {\\n          if (st_1.indexOf(\"[native code]\") != -1) {\\n   \
         var spInd = st_1.indexOf(\" \", 8) + 1;\\n            fnStr += \
st_1.slice(spInd, st_1.indexOf(\"(\", spInd));\\n          } else {\\n        \
    fnStr += st_1;\\n            for (var t in v.prototype)\\n              \
fnStr += \";\" + k + \".prototype.\" + t + \"=\" + \
v.prototype[t].toString();\\n          }\\n        } else\\n          fnStr \
+= st_1;\\n      } else\\n        td2[k] = v;\\n    }\\n    return fnStr;\\n  \
};\\n  var ch = [];\\n  var cbfs = function(v) {\\n    var tl = [];\\n    for \
(var k in v) {\\n      if (v[k].buffer) {\\n        tl.push((v[k] = new \
v[k].constructor(v[k])).buffer);\\n      }\\n    }\\n    return tl;\\n  };\\n \
 var wrkr = function(fns, init, id, cb) {\\n    if (!ch[id]) {\\n      var \
fnStr = \"\", td_1 = {}, m = fns.length - 1;\\n      for (var i2 = 0; i2 < m; \
++i2)\\n        fnStr = wcln(fns[i2], fnStr, td_1);\\n      ch[id] = { c: \
wcln(fns[m], fnStr, td_1), e: td_1 };\\n    }\\n    var td2 = mrg({}, \
ch[id].e);\\n    return wk(ch[id].c + \";onmessage=function(e){for(var k in \
e.data)self[k]=e.data[k];onmessage=\" + init.toString() + \"}\", id, td2, \
cbfs(td2), cb);\\n  };\\n  var bInflt = function() {\\n    return [u8, u16, \
i32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, \
shft, slc, err, inflt, inflateSync, pbf, gopt];\\n  };\\n  var pbf = \
function(msg) {\\n    return postMessage(msg, [msg.buffer]);\\n  };\\n  var \
gopt = function(o) {\\n    return o && {\\n      out: o.size && new \
u8(o.size),\\n      dictionary: o.dictionary\\n    };\\n  };\\n  var cbify = \
function(dat, opts, fns, init, id, cb) {\\n    var w = wrkr(fns, init, id, \
function(err2, dat2) {\\n      w.terminate();\\n      cb(err2, dat2);\\n    \
});\\n    w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);\\n    \
return function() {\\n      w.terminate();\\n    };\\n  };\\n  var b2 = \
function(d, b) {\\n    return d[b] | d[b + 1] << 8;\\n  };\\n  var b4 = \
function(d, b) {\\n    return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + \
3] << 24) >>> 0;\\n  };\\n  var b8 = function(d, b) {\\n    return b4(d, b) + \
b4(d, b + 4) * 4294967296;\\n  };\\n  var gzs = function(d) {\\n    if (d[0] \
!= 31 || d[1] != 139 || d[2] != 8)\\n      err(6, \"invalid gzip data\");\\n  \
  var flg = d[3];\\n    var st = 10;\\n    if (flg & 4)\\n      st += (d[10] \
| d[11] << 8) + 2;\\n    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > \
0; zs -= !d[st++])\\n      ;\\n    return st + (flg & 2);\\n  };\\n  var \
Inflate = /* @__PURE__ */ function() {\\n    function Inflate2(opts, cb) {\\n \
     if (typeof opts == \"function\")\\n        cb = opts, opts = {};\\n      \
this.ondata = cb;\\n      var dict = opts && opts.dictionary && \
opts.dictionary.subarray(-32768);\\n      this.s = { i: 0, b: dict ? \
dict.length : 0 };\\n      this.o = new u8(32768);\\n      this.p = new \
u8(0);\\n      if (dict)\\n        this.o.set(dict);\\n    }\\n    \
Inflate2.prototype.e = function(c) {\\n      if (!this.ondata)\\n        \
err(5);\\n      if (this.d)\\n        err(4);\\n      if (!this.p.length)\\n  \
      this.p = c;\\n      else if (c.length) {\\n        var n = new \
u8(this.p.length + c.length);\\n        n.set(this.p), n.set(c, \
this.p.length), this.p = n;\\n      }\\n    };\\n    Inflate2.prototype.c = \
function(final) {\\n      this.s.i = +(this.d = final || false);\\n      var \
bts = this.s.b;\\n      var dt = inflt(this.p, this.s, this.o);\\n      \
this.ondata(slc(dt, bts, this.s.b), this.d);\\n      this.o = slc(dt, \
this.s.b - 32768), this.s.b = this.o.length;\\n      this.p = slc(this.p, \
this.s.p / 8 | 0), this.s.p &= 7;\\n    };\\n    Inflate2.prototype.push = \
function(chunk, final) {\\n      this.e(chunk), this.c(final);\\n    };\\n    \
return Inflate2;\\n  }();\\n  function inflate(data, opts, cb) {\\n    if \
(!cb)\\n      cb = opts, opts = {};\\n    if (typeof cb != \"function\")\\n   \
   err(7);\\n    return cbify(data, opts, [\\n      bInflt\\n    ], \
function(ev) {\\n      return pbf(inflateSync(ev.data[0], \
gopt(ev.data[1])));\\n    }, 1, cb);\\n  }\\n  function inflateSync(data, \
opts) {\\n    return inflt(data, { i: 2 }, opts && opts.out, opts && \
opts.dictionary);\\n  }\\n  var Gunzip = /* @__PURE__ */ function() {\\n    \
function Gunzip2(opts, cb) {\\n      this.v = 1;\\n      this.r = 0;\\n      \
Inflate.call(this, opts, cb);\\n    }\\n    Gunzip2.prototype.push = \
function(chunk, final) {\\n      Inflate.prototype.e.call(this, chunk);\\n    \
  this.r += chunk.length;\\n      if (this.v) {\\n        var p = \
this.p.subarray(this.v - 1);\\n        var s = p.length > 3 ? gzs(p) : 4;\\n  \
      if (s > p.length) {\\n          if (!final)\\n            return;\\n    \
    } else if (this.v > 1 && this.onmember) {\\n          \
this.onmember(this.r - p.length);\\n        }\\n        this.p = \
p.subarray(s), this.v = 0;\\n      }\\n      Inflate.prototype.c.call(this, \
final);\\n      if (this.s.f && !this.s.l && !final) {\\n        this.v = \
shft(this.s.p) + 9;\\n        this.s = { i: 0 };\\n        this.o = new \
u8(0);\\n        this.push(new u8(0), final);\\n      }\\n    };\\n    return \
Gunzip2;\\n  }();\\n  var td = typeof TextDecoder != \"undefined\" && /* \
@__PURE__ */ new TextDecoder();\\n  try {\\n    td.decode(et, { stream: true \
});\\n  } catch (e) {\\n  }\\n  var dutf8 = function(d) {\\n    for (var r = \
\"\", i2 = 0; ; ) {\\n      var c = d[i2++];\\n      var eb = (c > 127) + (c \
> 223) + (c > 239);\\n      if (i2 + eb > d.length)\\n        return { s: r, \
r: slc(d, i2 - 1) };\\n      if (!eb)\\n        r += \
String.fromCharCode(c);\\n      else if (eb == 3) {\\n        c = ((c & 15) \
<< 18 | (d[i2++] & 63) << 12 | (d[i2++] & 63) << 6 | d[i2++] & 63) - 65536, r \
+= String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);\\n      } else if \
(eb & 1)\\n        r += String.fromCharCode((c & 31) << 6 | d[i2++] & 63);\\n \
     else\\n        r += String.fromCharCode((c & 15) << 12 | (d[i2++] & 63) \
<< 6 | d[i2++] & 63);\\n    }\\n  };\\n  function strFromU8(dat, latin1) {\\n \
   if (latin1) {\\n      var r = \"\";\\n      for (var i2 = 0; i2 < \
dat.length; i2 += 16384)\\n        r += String.fromCharCode.apply(null, \
dat.subarray(i2, i2 + 16384));\\n      return r;\\n    } else if (td) {\\n    \
  return td.decode(dat);\\n    } else {\\n      var _a2 = dutf8(dat), s = \
_a2.s, r = _a2.r;\\n      if (r.length)\\n        err(8);\\n      return \
s;\\n    }\\n  }\\n  var slzh = function(d, b) {\\n    return b + 30 + b2(d, \
b + 26) + b2(d, b + 28);\\n  };\\n  var zh = function(d, b, z) {\\n    var \
fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, \
b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\\n    var _a2 = z && \
bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = \
_a2[0], su = _a2[1], off = _a2[2];\\n    return [b2(d, b + 10), sc, su, fn, \
es + b2(d, b + 30) + b2(d, b + 32), off];\\n  };\\n  var z64e = function(d, \
b) {\\n    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))\\n      ;\\n    \
return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];\\n  };\\n  var mt = \
typeof queueMicrotask == \"function\" ? queueMicrotask : typeof setTimeout == \
\"function\" ? setTimeout : function(fn) {\\n    fn();\\n  };\\n  function \
unzip(data, opts, cb) {\\n    if (!cb)\\n      cb = opts, opts = {};\\n    if \
(typeof cb != \"function\")\\n      err(7);\\n    var term = [];\\n    var \
tAll = function() {\\n      for (var i3 = 0; i3 < term.length; ++i3)\\n       \
 term[i3]();\\n    };\\n    var files = {};\\n    var cbd = function(a, b) \
{\\n      mt(function() {\\n        cb(a, b);\\n      });\\n    };\\n    \
mt(function() {\\n      cbd = cb;\\n    });\\n    var e = data.length - \
22;\\n    for (; b4(data, e) != 101010256; --e) {\\n      if (!e || \
data.length - e > 65558) {\\n        cbd(err(13, 0, 1), null);\\n        \
return tAll;\\n      }\\n    }\\n    var lft = b2(data, e + 8);\\n    if \
(lft) {\\n      var c = lft;\\n      var o = b4(data, e + 16);\\n      var z \
= o == 4294967295 || c == 65535;\\n      if (z) {\\n        var ze = b4(data, \
e - 12);\\n        z = b4(data, ze) == 101075792;\\n        if (z) {\\n       \
   c = lft = b4(data, ze + 32);\\n          o = b4(data, ze + 48);\\n        \
}\\n      }\\n      var fltr = opts && opts.filter;\\n      var _loop_3 = \
function(i3) {\\n        var _a2 = zh(data, o, z), c_1 = _a2[0], sc = _a2[1], \
su = _a2[2], fn = _a2[3], no = _a2[4], off = _a2[5], b = slzh(data, off);\\n  \
      o = no;\\n        var cbl = function(e2, d) {\\n          if (e2) {\\n  \
          tAll();\\n            cbd(e2, null);\\n          } else {\\n        \
    if (d)\\n              files[fn] = d;\\n            if (!--lft)\\n        \
      cbd(null, files);\\n          }\\n        };\\n        if (!fltr || \
fltr({\\n          name: fn,\\n          size: sc,\\n          originalSize: \
su,\\n          compression: c_1\\n        })) {\\n          if (!c_1)\\n     \
       cbl(null, slc(data, b, b + sc));\\n          else if (c_1 == 8) {\\n   \
         var infl = data.subarray(b, b + sc);\\n            if (su < 524288 \
|| sc > 0.8 * su) {\\n              try {\\n                cbl(null, \
inflateSync(infl, { out: new u8(su) }));\\n              } catch (e2) {\\n    \
            cbl(e2, null);\\n              }\\n            } else\\n          \
    term.push(inflate(infl, { size: su }, cbl));\\n          } else\\n        \
    cbl(err(14, \"unknown compression type \" + c_1, 1), null);\\n        } \
else\\n          cbl(null, null);\\n      };\\n      for (var i2 = 0; i2 < c; \
++i2) {\\n        _loop_3(i2);\\n      }\\n    } else\\n      cbd(null, \
{});\\n    return tAll;\\n  }\\n  function unzipSync(data, opts) {\\n    var \
files = {};\\n    var e = data.length - 22;\\n    for (; b4(data, e) != \
101010256; --e) {\\n      if (!e || data.length - e > 65558)\\n        \
err(13);\\n    }\\n    var c = b2(data, e + 8);\\n    if (!c)\\n      return \
{};\\n    var o = b4(data, e + 16);\\n    var z = o == 4294967295 || c == \
65535;\\n    if (z) {\\n      var ze = b4(data, e - 12);\\n      z = b4(data, \
ze) == 101075792;\\n      if (z) {\\n        c = b4(data, ze + 32);\\n        \
o = b4(data, ze + 48);\\n      }\\n    }\\n    var fltr = opts && \
opts.filter;\\n    for (var i2 = 0; i2 < c; ++i2) {\\n      var _a2 = \
zh(data, o, z), c_2 = _a2[0], sc = _a2[1], su = _a2[2], fn = _a2[3], no = \
_a2[4], off = _a2[5], b = slzh(data, off);\\n      o = no;\\n      if (!fltr \
|| fltr({\\n        name: fn,\\n        size: sc,\\n        originalSize: \
su,\\n        compression: c_2\\n      })) {\\n        if (!c_2)\\n          \
files[fn] = slc(data, b, b + sc);\\n        else if (c_2 == 8)\\n          \
files[fn] = inflateSync(data.subarray(b, b + sc), { out: new u8(su) });\\n    \
    else\\n          err(14, \"unknown compression type \" + c_2);\\n      \
}\\n    }\\n    return files;\\n  }\\n  /**\\n   * @license\\n   * Copyright \
2010-2025 Three.js Authors\\n   * SPDX-License-Identifier: MIT\\n   */\\n  \
const REVISION = \"178\";\\n  const NoColorSpace = \"\";\\n  const \
SRGBColorSpace = \"srgb\";\\n  const LinearSRGBColorSpace = \
\"srgb-linear\";\\n  const LinearTransfer = \"linear\";\\n  const \
SRGBTransfer = \"srgb\";\\n  function clamp(value, min, max2) {\\n    return \
Math.max(min, Math.min(max2, value));\\n  }\\n  function euclideanModulo(n, \
m) {\\n    return (n % m + m) % m;\\n  }\\n  function lerp(x2, y, t) {\\n    \
return (1 - t) * x2 + t * y;\\n  }\\n  class Quaternion {\\n    /**\\n     * \
Constructs a new quaternion.\\n     *\\n     * @param {number} [x=0] - The x \
value of this quaternion.\\n     * @param {number} [y=0] - The y value of \
this quaternion.\\n     * @param {number} [z=0] - The z value of this \
quaternion.\\n     * @param {number} [w=1] - The w value of this \
quaternion.\\n     */\\n    constructor(x2 = 0, y = 0, z = 0, w = 1) {\\n     \
 this.isQuaternion = true;\\n      this._x = x2;\\n      this._y = y;\\n      \
this._z = z;\\n      this._w = w;\\n    }\\n    /**\\n     * Interpolates \
between two quaternions via SLERP. This implementation assumes the\\n     * \
quaternion data are managed  in flat arrays.\\n     *\\n     * @param \
{Array<number>} dst - The destination array.\\n     * @param {number} \
dstOffset - An offset into the destination array.\\n     * @param \
{Array<number>} src0 - The source array of the first quaternion.\\n     * \
@param {number} srcOffset0 - An offset into the first source array.\\n     * \
@param {Array<number>} src1 -  The source array of the second quaternion.\\n  \
   * @param {number} srcOffset1 - An offset into the second source array.\\n  \
   * @param {number} t - The interpolation factor in the range `[0,1]`.\\n    \
 * @see {@link Quaternion#slerp}\\n     */\\n    static slerpFlat(dst, \
dstOffset, src0, srcOffset0, src1, srcOffset1, t) {\\n      let x0 = \
src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], \
w0 = src0[srcOffset0 + 3];\\n      const x1 = src1[srcOffset1 + 0], y1 = \
src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + \
3];\\n      if (t === 0) {\\n        dst[dstOffset + 0] = x0;\\n        \
dst[dstOffset + 1] = y0;\\n        dst[dstOffset + 2] = z0;\\n        \
dst[dstOffset + 3] = w0;\\n        return;\\n      }\\n      if (t === 1) \
{\\n        dst[dstOffset + 0] = x1;\\n        dst[dstOffset + 1] = y1;\\n    \
    dst[dstOffset + 2] = z1;\\n        dst[dstOffset + 3] = w1;\\n        \
return;\\n      }\\n      if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== \
z1) {\\n        let s = 1 - t;\\n        const cos = x0 * x1 + y0 * y1 + z0 * \
z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;\\n        if \
(sqrSin > Number.EPSILON) {\\n          const sin = Math.sqrt(sqrSin), len = \
Math.atan2(sin, cos * dir);\\n          s = Math.sin(s * len) / sin;\\n       \
   t = Math.sin(t * len) / sin;\\n        }\\n        const tDir = t * \
dir;\\n        x0 = x0 * s + x1 * tDir;\\n        y0 = y0 * s + y1 * tDir;\\n \
       z0 = z0 * s + z1 * tDir;\\n        w0 = w0 * s + w1 * tDir;\\n        \
if (s === 1 - t) {\\n          const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 \
* z0 + w0 * w0);\\n          x0 *= f;\\n          y0 *= f;\\n          z0 *= \
f;\\n          w0 *= f;\\n        }\\n      }\\n      dst[dstOffset] = x0;\\n \
     dst[dstOffset + 1] = y0;\\n      dst[dstOffset + 2] = z0;\\n      \
dst[dstOffset + 3] = w0;\\n    }\\n    /**\\n     * Multiplies two \
quaternions. This implementation assumes the quaternion data are managed\\n   \
  * in flat arrays.\\n     *\\n     * @param {Array<number>} dst - The \
destination array.\\n     * @param {number} dstOffset - An offset into the \
destination array.\\n     * @param {Array<number>} src0 - The source array of \
the first quaternion.\\n     * @param {number} srcOffset0 - An offset into \
the first source array.\\n     * @param {Array<number>} src1 -  The source \
array of the second quaternion.\\n     * @param {number} srcOffset1 - An \
offset into the second source array.\\n     * @return {Array<number>} The \
destination array.\\n     * @see {@link Quaternion#multiplyQuaternions}.\\n   \
  */\\n    static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, \
src1, srcOffset1) {\\n      const x0 = src0[srcOffset0];\\n      const y0 = \
src0[srcOffset0 + 1];\\n      const z0 = src0[srcOffset0 + 2];\\n      const \
w0 = src0[srcOffset0 + 3];\\n      const x1 = src1[srcOffset1];\\n      const \
y1 = src1[srcOffset1 + 1];\\n      const z1 = src1[srcOffset1 + 2];\\n      \
const w1 = src1[srcOffset1 + 3];\\n      dst[dstOffset] = x0 * w1 + w0 * x1 + \
y0 * z1 - z0 * y1;\\n      dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - \
x0 * z1;\\n      dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * \
x1;\\n      dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;\\n    \
  return dst;\\n    }\\n    /**\\n     * The x value of this quaternion.\\n   \
  *\\n     * @type {number}\\n     * @default 0\\n     */\\n    get x() {\\n  \
    return this._x;\\n    }\\n    set x(value) {\\n      this._x = value;\\n  \
    this._onChangeCallback();\\n    }\\n    /**\\n     * The y value of this \
quaternion.\\n     *\\n     * @type {number}\\n     * @default 0\\n     */\\n \
   get y() {\\n      return this._y;\\n    }\\n    set y(value) {\\n      \
this._y = value;\\n      this._onChangeCallback();\\n    }\\n    /**\\n     * \
The z value of this quaternion.\\n     *\\n     * @type {number}\\n     * \
@default 0\\n     */\\n    get z() {\\n      return this._z;\\n    }\\n    \
set z(value) {\\n      this._z = value;\\n      this._onChangeCallback();\\n  \
  }\\n    /**\\n     * The w value of this quaternion.\\n     *\\n     * \
@type {number}\\n     * @default 1\\n     */\\n    get w() {\\n      return \
this._w;\\n    }\\n    set w(value) {\\n      this._w = value;\\n      \
this._onChangeCallback();\\n    }\\n    /**\\n     * Sets the quaternion \
components.\\n     *\\n     * @param {number} x - The x value of this \
quaternion.\\n     * @param {number} y - The y value of this quaternion.\\n   \
  * @param {number} z - The z value of this quaternion.\\n     * @param \
{number} w - The w value of this quaternion.\\n     * @return {Quaternion} A \
reference to this quaternion.\\n     */\\n    set(x2, y, z, w) {\\n      \
this._x = x2;\\n      this._y = y;\\n      this._z = z;\\n      this._w = \
w;\\n      this._onChangeCallback();\\n      return this;\\n    }\\n    \
/**\\n     * Returns a new quaternion with copied values from this \
instance.\\n     *\\n     * @return {Quaternion} A clone of this instance.\\n \
    */\\n    clone() {\\n      return new this.constructor(this._x, this._y, \
this._z, this._w);\\n    }\\n    /**\\n     * Copies the values of the given \
quaternion to this instance.\\n     *\\n     * @param {Quaternion} quaternion \
- The quaternion to copy.\\n     * @return {Quaternion} A reference to this \
quaternion.\\n     */\\n    copy(quaternion) {\\n      this._x = \
quaternion.x;\\n      this._y = quaternion.y;\\n      this._z = \
quaternion.z;\\n      this._w = quaternion.w;\\n      \
this._onChangeCallback();\\n      return this;\\n    }\\n    /**\\n     * \
Sets this quaternion from the rotation specified by the given\\n     * Euler \
angles.\\n     *\\n     * @param {Euler} euler - The Euler angles.\\n     * \
@param {boolean} [update=true] - Whether the internal `onChange` callback \
should be executed or not.\\n     * @return {Quaternion} A reference to this \
quaternion.\\n     */\\n    setFromEuler(euler, update = true) {\\n      \
const x2 = euler._x, y = euler._y, z = euler._z, order = euler._order;\\n     \
 const cos = Math.cos;\\n      const sin = Math.sin;\\n      const c1 = \
cos(x2 / 2);\\n      const c2 = cos(y / 2);\\n      const c3 = cos(z / 2);\\n \
     const s1 = sin(x2 / 2);\\n      const s2 = sin(y / 2);\\n      const s3 \
= sin(z / 2);\\n      switch (order) {\\n        case \"XYZ\":\\n          \
this._x = s1 * c2 * c3 + c1 * s2 * s3;\\n          this._y = c1 * s2 * c3 - \
s1 * c2 * s3;\\n          this._z = c1 * c2 * s3 + s1 * s2 * c3;\\n          \
this._w = c1 * c2 * c3 - s1 * s2 * s3;\\n          break;\\n        case \
\"YXZ\":\\n          this._x = s1 * c2 * c3 + c1 * s2 * s3;\\n          \
this._y = c1 * s2 * c3 - s1 * c2 * s3;\\n          this._z = c1 * c2 * s3 - \
s1 * s2 * c3;\\n          this._w = c1 * c2 * c3 + s1 * s2 * s3;\\n          \
break;\\n        case \"ZXY\":\\n          this._x = s1 * c2 * c3 - c1 * s2 * \
s3;\\n          this._y = c1 * s2 * c3 + s1 * c2 * s3;\\n          this._z = \
c1 * c2 * s3 + s1 * s2 * c3;\\n          this._w = c1 * c2 * c3 - s1 * s2 * \
s3;\\n          break;\\n        case \"ZYX\":\\n          this._x = s1 * c2 \
* c3 - c1 * s2 * s3;\\n          this._y = c1 * s2 * c3 + s1 * c2 * s3;\\n    \
      this._z = c1 * c2 * s3 - s1 * s2 * c3;\\n          this._w = c1 * c2 * \
c3 + s1 * s2 * s3;\\n          break;\\n        case \"YZX\":\\n          \
this._x = s1 * c2 * c3 + c1 * s2 * s3;\\n          this._y = c1 * s2 * c3 + \
s1 * c2 * s3;\\n          this._z = c1 * c2 * s3 - s1 * s2 * c3;\\n          \
this._w = c1 * c2 * c3 - s1 * s2 * s3;\\n          break;\\n        case \
\"XZY\":\\n          this._x = s1 * c2 * c3 - c1 * s2 * s3;\\n          \
this._y = c1 * s2 * c3 - s1 * c2 * s3;\\n          this._z = c1 * c2 * s3 + \
s1 * s2 * c3;\\n          this._w = c1 * c2 * c3 + s1 * s2 * s3;\\n          \
break;\\n        default:\\n          console.warn(\"THREE.Quaternion: \
.setFromEuler() encountered an unknown order: \" + order);\\n      }\\n      \
if (update === true) this._onChangeCallback();\\n      return this;\\n    \
}\\n    /**\\n     * Sets this quaternion from the given axis and angle.\\n   \
  *\\n     * @param {Vector3} axis - The normalized axis.\\n     * @param \
{number} angle - The angle in radians.\\n     * @return {Quaternion} A \
reference to this quaternion.\\n     */\\n    setFromAxisAngle(axis, angle) \
{\\n      const halfAngle = angle / 2, s = Math.sin(halfAngle);\\n      \
this._x = axis.x * s;\\n      this._y = axis.y * s;\\n      this._z = axis.z \
* s;\\n      this._w = Math.cos(halfAngle);\\n      \
this._onChangeCallback();\\n      return this;\\n    }\\n    /**\\n     * \
Sets this quaternion from the given rotation matrix.\\n     *\\n     * @param \
{Matrix4} m - A 4x4 matrix of which the upper 3x3 of matrix is a pure \
rotation matrix (i.e. unscaled).\\n     * @return {Quaternion} A reference to \
this quaternion.\\n     */\\n    setFromRotationMatrix(m) {\\n      const te \
= m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = \
te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 \
+ m33;\\n      if (trace > 0) {\\n        const s = 0.5 / Math.sqrt(trace + \
1);\\n        this._w = 0.25 / s;\\n        this._x = (m32 - m23) * s;\\n     \
   this._y = (m13 - m31) * s;\\n        this._z = (m21 - m12) * s;\\n      } \
else if (m11 > m22 && m11 > m33) {\\n        const s = 2 * Math.sqrt(1 + m11 \
- m22 - m33);\\n        this._w = (m32 - m23) / s;\\n        this._x = 0.25 * \
s;\\n        this._y = (m12 + m21) / s;\\n        this._z = (m13 + m31) / \
s;\\n      } else if (m22 > m33) {\\n        const s = 2 * Math.sqrt(1 + m22 \
- m11 - m33);\\n        this._w = (m13 - m31) / s;\\n        this._x = (m12 + \
m21) / s;\\n        this._y = 0.25 * s;\\n        this._z = (m23 + m32) / \
s;\\n      } else {\\n        const s = 2 * Math.sqrt(1 + m33 - m11 - \
m22);\\n        this._w = (m21 - m12) / s;\\n        this._x = (m13 + m31) / \
s;\\n        this._y = (m23 + m32) / s;\\n        this._z = 0.25 * s;\\n      \
}\\n      this._onChangeCallback();\\n      return this;\\n    }\\n    /**\\n \
    * Sets this quaternion to the rotation required to rotate the direction \
vector\\n     * `vFrom` to the direction vector `vTo`.\\n     *\\n     * \
@param {Vector3} vFrom - The first (normalized) direction vector.\\n     * \
@param {Vector3} vTo - The second (normalized) direction vector.\\n     * \
@return {Quaternion} A reference to this quaternion.\\n     */\\n    \
setFromUnitVectors(vFrom, vTo) {\\n      let r = vFrom.dot(vTo) + 1;\\n      \
if (r < 1e-8) {\\n        r = 0;\\n        if (Math.abs(vFrom.x) > \
Math.abs(vFrom.z)) {\\n          this._x = -vFrom.y;\\n          this._y = \
vFrom.x;\\n          this._z = 0;\\n          this._w = r;\\n        } else \
{\\n          this._x = 0;\\n          this._y = -vFrom.z;\\n          \
this._z = vFrom.y;\\n          this._w = r;\\n        }\\n      } else {\\n   \
     this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;\\n        this._y = vFrom.z \
* vTo.x - vFrom.x * vTo.z;\\n        this._z = vFrom.x * vTo.y - vFrom.y * \
vTo.x;\\n        this._w = r;\\n      }\\n      return this.normalize();\\n   \
 }\\n    /**\\n     * Returns the angle between this quaternion and the given \
one in radians.\\n     *\\n     * @param {Quaternion} q - The quaternion to \
compute the angle with.\\n     * @return {number} The angle in radians.\\n    \
 */\\n    angleTo(q) {\\n      return 2 * \
Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));\\n    }\\n    /**\\n     * \
Rotates this quaternion by a given angular step to the given quaternion.\\n   \
  * The method ensures that the final quaternion will not overshoot `q`.\\n   \
  *\\n     * @param {Quaternion} q - The target quaternion.\\n     * @param \
{number} step - The angular step in radians.\\n     * @return {Quaternion} A \
reference to this quaternion.\\n     */\\n    rotateTowards(q, step) {\\n     \
 const angle = this.angleTo(q);\\n      if (angle === 0) return this;\\n      \
const t = Math.min(1, step / angle);\\n      this.slerp(q, t);\\n      return \
this;\\n    }\\n    /**\\n     * Sets this quaternion to the identity \
quaternion; that is, to the\\n     * quaternion that represents \"no \
rotation\".\\n     *\\n     * @return {Quaternion} A reference to this \
quaternion.\\n     */\\n    identity() {\\n      return this.set(0, 0, 0, \
1);\\n    }\\n    /**\\n     * Inverts this quaternion via {@link \
Quaternion#conjugate}. The\\n     * quaternion is assumed to have unit \
length.\\n     *\\n     * @return {Quaternion} A reference to this \
quaternion.\\n     */\\n    invert() {\\n      return this.conjugate();\\n    \
}\\n    /**\\n     * Returns the rotational conjugate of this quaternion. The \
conjugate of a\\n     * quaternion represents the same rotation in the \
opposite direction about\\n     * the rotational axis.\\n     *\\n     * \
@return {Quaternion} A reference to this quaternion.\\n     */\\n    \
conjugate() {\\n      this._x *= -1;\\n      this._y *= -1;\\n      this._z \
*= -1;\\n      this._onChangeCallback();\\n      return this;\\n    }\\n    \
/**\\n     * Calculates the dot product of this quaternion and the given \
one.\\n     *\\n     * @param {Quaternion} v - The quaternion to compute the \
dot product with.\\n     * @return {number} The result of the dot product.\\n \
    */\\n    dot(v) {\\n      return this._x * v._x + this._y * v._y + \
this._z * v._z + this._w * v._w;\\n    }\\n    /**\\n     * Computes the \
squared Euclidean length (straight-line length) of this quaternion,\\n     * \
considered as a 4 dimensional vector. This can be useful if you are comparing \
the\\n     * lengths of two quaternions, as this is a slightly more efficient \
calculation than\\n     * {@link Quaternion#length}.\\n     *\\n     * \
@return {number} The squared Euclidean length.\\n     */\\n    lengthSq() \
{\\n      return this._x * this._x + this._y * this._y + this._z * this._z + \
this._w * this._w;\\n    }\\n    /**\\n     * Computes the Euclidean length \
(straight-line length) of this quaternion,\\n     * considered as a 4 \
dimensional vector.\\n     *\\n     * @return {number} The Euclidean \
length.\\n     */\\n    length() {\\n      return Math.sqrt(this._x * this._x \
+ this._y * this._y + this._z * this._z + this._w * this._w);\\n    }\\n    \
/**\\n     * Normalizes this quaternion - that is, calculated the quaternion \
that performs\\n     * the same rotation as this one, but has a length equal \
to `1`.\\n     *\\n     * @return {Quaternion} A reference to this \
quaternion.\\n     */\\n    normalize() {\\n      let l = this.length();\\n   \
   if (l === 0) {\\n        this._x = 0;\\n        this._y = 0;\\n        \
this._z = 0;\\n        this._w = 1;\\n      } else {\\n        l = 1 / l;\\n  \
      this._x = this._x * l;\\n        this._y = this._y * l;\\n        \
this._z = this._z * l;\\n        this._w = this._w * l;\\n      }\\n      \
this._onChangeCallback();\\n      return this;\\n    }\\n    /**\\n     * \
Multiplies this quaternion by the given one.\\n     *\\n     * @param \
{Quaternion} q - The quaternion.\\n     * @return {Quaternion} A reference to \
this quaternion.\\n     */\\n    multiply(q) {\\n      return \
this.multiplyQuaternions(this, q);\\n    }\\n    /**\\n     * Pre-multiplies \
this quaternion by the given one.\\n     *\\n     * @param {Quaternion} q - \
The quaternion.\\n     * @return {Quaternion} A reference to this \
quaternion.\\n     */\\n    premultiply(q) {\\n      return \
this.multiplyQuaternions(q, this);\\n    }\\n    /**\\n     * Multiplies the \
given quaternions and stores the result in this instance.\\n     *\\n     * \
@param {Quaternion} a - The first quaternion.\\n     * @param {Quaternion} b \
- The second quaternion.\\n     * @return {Quaternion} A reference to this \
quaternion.\\n     */\\n    multiplyQuaternions(a, b) {\\n      const qax = \
a._x, qay = a._y, qaz = a._z, qaw = a._w;\\n      const qbx = b._x, qby = \
b._y, qbz = b._z, qbw = b._w;\\n      this._x = qax * qbw + qaw * qbx + qay * \
qbz - qaz * qby;\\n      this._y = qay * qbw + qaw * qby + qaz * qbx - qax * \
qbz;\\n      this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\\n      \
this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\\n      \
this._onChangeCallback();\\n      return this;\\n    }\\n    /**\\n     * \
Performs a spherical linear interpolation between quaternions.\\n     *\\n    \
 * @param {Quaternion} qb - The target quaternion.\\n     * @param {number} t \
- The interpolation factor in the closed interval `[0, 1]`.\\n     * @return \
{Quaternion} A reference to this quaternion.\\n     */\\n    slerp(qb, t) \
{\\n      if (t === 0) return this;\\n      if (t === 1) return \
this.copy(qb);\\n      const x2 = this._x, y = this._y, z = this._z, w = \
this._w;\\n      let cosHalfTheta = w * qb._w + x2 * qb._x + y * qb._y + z * \
qb._z;\\n      if (cosHalfTheta < 0) {\\n        this._w = -qb._w;\\n        \
this._x = -qb._x;\\n        this._y = -qb._y;\\n        this._z = -qb._z;\\n  \
      cosHalfTheta = -cosHalfTheta;\\n      } else {\\n        \
this.copy(qb);\\n      }\\n      if (cosHalfTheta >= 1) {\\n        this._w = \
w;\\n        this._x = x2;\\n        this._y = y;\\n        this._z = z;\\n   \
     return this;\\n      }\\n      const sqrSinHalfTheta = 1 - cosHalfTheta \
* cosHalfTheta;\\n      if (sqrSinHalfTheta <= Number.EPSILON) {\\n        \
const s = 1 - t;\\n        this._w = s * w + t * this._w;\\n        this._x = \
s * x2 + t * this._x;\\n        this._y = s * y + t * this._y;\\n        \
this._z = s * z + t * this._z;\\n        this.normalize();\\n        return \
this;\\n      }\\n      const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);\\n   \
   const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);\\n      const \
ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * \
halfTheta) / sinHalfTheta;\\n      this._w = w * ratioA + this._w * \
ratioB;\\n      this._x = x2 * ratioA + this._x * ratioB;\\n      this._y = y \
* ratioA + this._y * ratioB;\\n      this._z = z * ratioA + this._z * \
ratioB;\\n      this._onChangeCallback();\\n      return this;\\n    }\\n    \
/**\\n     * Performs a spherical linear interpolation between the given \
quaternions\\n     * and stores the result in this quaternion.\\n     *\\n    \
 * @param {Quaternion} qa - The source quaternion.\\n     * @param \
{Quaternion} qb - The target quaternion.\\n     * @param {number} t - The \
interpolation factor in the closed interval `[0, 1]`.\\n     * @return \
{Quaternion} A reference to this quaternion.\\n     */\\n    \
slerpQuaternions(qa, qb, t) {\\n      return this.copy(qa).slerp(qb, t);\\n   \
 }\\n    /**\\n     * Sets this quaternion to a uniformly random, normalized \
quaternion.\\n     *\\n     * @return {Quaternion} A reference to this \
quaternion.\\n     */\\n    random() {\\n      const theta1 = 2 * Math.PI * \
Math.random();\\n      const theta2 = 2 * Math.PI * Math.random();\\n      \
const x0 = Math.random();\\n      const r1 = Math.sqrt(1 - x0);\\n      const \
r2 = Math.sqrt(x0);\\n      return this.set(\\n        r1 * \
Math.sin(theta1),\\n        r1 * Math.cos(theta1),\\n        r2 * \
Math.sin(theta2),\\n        r2 * Math.cos(theta2)\\n      );\\n    }\\n    \
/**\\n     * Returns `true` if this quaternion is equal with the given \
one.\\n     *\\n     * @param {Quaternion} quaternion - The quaternion to \
test for equality.\\n     * @return {boolean} Whether this quaternion is \
equal with the given one.\\n     */\\n    equals(quaternion) {\\n      return \
quaternion._x === this._x && quaternion._y === this._y && quaternion._z === \
this._z && quaternion._w === this._w;\\n    }\\n    /**\\n     * Sets this \
quaternion\\'s components from the given array.\\n     *\\n     * @param \
{Array<number>} array - An array holding the quaternion component values.\\n  \
   * @param {number} [offset=0] - The offset into the array.\\n     * @return \
{Quaternion} A reference to this quaternion.\\n     */\\n    fromArray(array, \
offset = 0) {\\n      this._x = array[offset];\\n      this._y = array[offset \
+ 1];\\n      this._z = array[offset + 2];\\n      this._w = array[offset + \
3];\\n      this._onChangeCallback();\\n      return this;\\n    }\\n    \
/**\\n     * Writes the components of this quaternion to the given array. If \
no array is provided,\\n     * the method returns a new instance.\\n     *\\n \
    * @param {Array<number>} [array=[]] - The target array holding the \
quaternion components.\\n     * @param {number} [offset=0] - Index of the \
first element in the array.\\n     * @return {Array<number>} The quaternion \
components.\\n     */\\n    toArray(array = [], offset = 0) {\\n      \
array[offset] = this._x;\\n      array[offset + 1] = this._y;\\n      \
array[offset + 2] = this._z;\\n      array[offset + 3] = this._w;\\n      \
return array;\\n    }\\n    /**\\n     * Sets the components of this \
quaternion from the given buffer attribute.\\n     *\\n     * @param \
{BufferAttribute} attribute - The buffer attribute holding quaternion \
data.\\n     * @param {number} index - The index into the attribute.\\n     * \
@return {Quaternion} A reference to this quaternion.\\n     */\\n    \
fromBufferAttribute(attribute, index) {\\n      this._x = \
attribute.getX(index);\\n      this._y = attribute.getY(index);\\n      \
this._z = attribute.getZ(index);\\n      this._w = attribute.getW(index);\\n  \
    this._onChangeCallback();\\n      return this;\\n    }\\n    /**\\n     * \
This methods defines the serialization result of this class. Returns the\\n   \
  * numerical elements of this quaternion in an array of format `[x, y, z, \
w]`.\\n     *\\n     * @return {Array<number>} The serialized quaternion.\\n  \
   */\\n    toJSON() {\\n      return this.toArray();\\n    }\\n    \
_onChange(callback) {\\n      this._onChangeCallback = callback;\\n      \
return this;\\n    }\\n    _onChangeCallback() {\\n    }\\n    \
*[Symbol.iterator]() {\\n      yield this._x;\\n      yield this._y;\\n      \
yield this._z;\\n      yield this._w;\\n    }\\n  }\\n  class Vector3 {\\n    \
/**\\n     * Constructs a new 3D vector.\\n     *\\n     * @param {number} \
[x=0] - The x value of this vector.\\n     * @param {number} [y=0] - The y \
value of this vector.\\n     * @param {number} [z=0] - The z value of this \
vector.\\n     */\\n    constructor(x2 = 0, y = 0, z = 0) {\\n      \
Vector3.prototype.isVector3 = true;\\n      this.x = x2;\\n      this.y = \
y;\\n      this.z = z;\\n    }\\n    /**\\n     * Sets the vector \
components.\\n     *\\n     * @param {number} x - The value of the x \
component.\\n     * @param {number} y - The value of the y component.\\n     \
* @param {number} z - The value of the z component.\\n     * @return \
{Vector3} A reference to this vector.\\n     */\\n    set(x2, y, z) {\\n      \
if (z === void 0) z = this.z;\\n      this.x = x2;\\n      this.y = y;\\n     \
 this.z = z;\\n      return this;\\n    }\\n    /**\\n     * Sets the vector \
components to the same value.\\n     *\\n     * @param {number} scalar - The \
value to set for all vector components.\\n     * @return {Vector3} A \
reference to this vector.\\n     */\\n    setScalar(scalar) {\\n      this.x \
= scalar;\\n      this.y = scalar;\\n      this.z = scalar;\\n      return \
this;\\n    }\\n    /**\\n     * Sets the vector\\'s x component to the given \
value\\n     *\\n     * @param {number} x - The value to set.\\n     * \
@return {Vector3} A reference to this vector.\\n     */\\n    setX(x2) {\\n   \
   this.x = x2;\\n      return this;\\n    }\\n    /**\\n     * Sets the \
vector\\'s y component to the given value\\n     *\\n     * @param {number} y \
- The value to set.\\n     * @return {Vector3} A reference to this vector.\\n \
    */\\n    setY(y) {\\n      this.y = y;\\n      return this;\\n    }\\n    \
/**\\n     * Sets the vector\\'s z component to the given value\\n     *\\n   \
  * @param {number} z - The value to set.\\n     * @return {Vector3} A \
reference to this vector.\\n     */\\n    setZ(z) {\\n      this.z = z;\\n    \
  return this;\\n    }\\n    /**\\n     * Allows to set a vector component \
with an index.\\n     *\\n     * @param {number} index - The component index. \
`0` equals to x, `1` equals to y, `2` equals to z.\\n     * @param {number} \
value - The value to set.\\n     * @return {Vector3} A reference to this \
vector.\\n     */\\n    setComponent(index, value) {\\n      switch (index) \
{\\n        case 0:\\n          this.x = value;\\n          break;\\n        \
case 1:\\n          this.y = value;\\n          break;\\n        case 2:\\n   \
       this.z = value;\\n          break;\\n        default:\\n          \
throw new Error(\"index is out of range: \" + index);\\n      }\\n      \
return this;\\n    }\\n    /**\\n     * Returns the value of the vector \
component which matches the given index.\\n     *\\n     * @param {number} \
index - The component index. `0` equals to x, `1` equals to y, `2` equals to \
z.\\n     * @return {number} A vector component value.\\n     */\\n    \
getComponent(index) {\\n      switch (index) {\\n        case 0:\\n          \
return this.x;\\n        case 1:\\n          return this.y;\\n        case \
2:\\n          return this.z;\\n        default:\\n          throw new \
Error(\"index is out of range: \" + index);\\n      }\\n    }\\n    /**\\n    \
 * Returns a new vector with copied values from this instance.\\n     *\\n    \
 * @return {Vector3} A clone of this instance.\\n     */\\n    clone() {\\n   \
   return new this.constructor(this.x, this.y, this.z);\\n    }\\n    /**\\n  \
   * Copies the values of the given vector to this instance.\\n     *\\n     \
* @param {Vector3} v - The vector to copy.\\n     * @return {Vector3} A \
reference to this vector.\\n     */\\n    copy(v) {\\n      this.x = v.x;\\n  \
    this.y = v.y;\\n      this.z = v.z;\\n      return this;\\n    }\\n    \
/**\\n     * Adds the given vector to this instance.\\n     *\\n     * @param \
{Vector3} v - The vector to add.\\n     * @return {Vector3} A reference to \
this vector.\\n     */\\n    add(v) {\\n      this.x += v.x;\\n      this.y \
+= v.y;\\n      this.z += v.z;\\n      return this;\\n    }\\n    /**\\n     \
* Adds the given scalar value to all components of this instance.\\n     *\\n \
    * @param {number} s - The scalar to add.\\n     * @return {Vector3} A \
reference to this vector.\\n     */\\n    addScalar(s) {\\n      this.x += \
s;\\n      this.y += s;\\n      this.z += s;\\n      return this;\\n    }\\n  \
  /**\\n     * Adds the given vectors and stores the result in this \
instance.\\n     *\\n     * @param {Vector3} a - The first vector.\\n     * \
@param {Vector3} b - The second vector.\\n     * @return {Vector3} A \
reference to this vector.\\n     */\\n    addVectors(a, b) {\\n      this.x = \
a.x + b.x;\\n      this.y = a.y + b.y;\\n      this.z = a.z + b.z;\\n      \
return this;\\n    }\\n    /**\\n     * Adds the given vector scaled by the \
given factor to this instance.\\n     *\\n     * @param {Vector3|Vector4} v - \
The vector.\\n     * @param {number} s - The factor that scales `v`.\\n     * \
@return {Vector3} A reference to this vector.\\n     */\\n    \
addScaledVector(v, s) {\\n      this.x += v.x * s;\\n      this.y += v.y * \
s;\\n      this.z += v.z * s;\\n      return this;\\n    }\\n    /**\\n     * \
Subtracts the given vector from this instance.\\n     *\\n     * @param \
{Vector3} v - The vector to subtract.\\n     * @return {Vector3} A reference \
to this vector.\\n     */\\n    sub(v) {\\n      this.x -= v.x;\\n      \
this.y -= v.y;\\n      this.z -= v.z;\\n      return this;\\n    }\\n    \
/**\\n     * Subtracts the given scalar value from all components of this \
instance.\\n     *\\n     * @param {number} s - The scalar to subtract.\\n    \
 * @return {Vector3} A reference to this vector.\\n     */\\n    subScalar(s) \
{\\n      this.x -= s;\\n      this.y -= s;\\n      this.z -= s;\\n      \
return this;\\n    }\\n    /**\\n     * Subtracts the given vectors and \
stores the result in this instance.\\n     *\\n     * @param {Vector3} a - \
The first vector.\\n     * @param {Vector3} b - The second vector.\\n     * \
@return {Vector3} A reference to this vector.\\n     */\\n    subVectors(a, \
b) {\\n      this.x = a.x - b.x;\\n      this.y = a.y - b.y;\\n      this.z = \
a.z - b.z;\\n      return this;\\n    }\\n    /**\\n     * Multiplies the \
given vector with this instance.\\n     *\\n     * @param {Vector3} v - The \
vector to multiply.\\n     * @return {Vector3} A reference to this vector.\\n \
    */\\n    multiply(v) {\\n      this.x *= v.x;\\n      this.y *= v.y;\\n   \
   this.z *= v.z;\\n      return this;\\n    }\\n    /**\\n     * Multiplies \
the given scalar value with all components of this instance.\\n     *\\n     \
* @param {number} scalar - The scalar to multiply.\\n     * @return {Vector3} \
A reference to this vector.\\n     */\\n    multiplyScalar(scalar) {\\n      \
this.x *= scalar;\\n      this.y *= scalar;\\n      this.z *= scalar;\\n      \
return this;\\n    }\\n    /**\\n     * Multiplies the given vectors and \
stores the result in this instance.\\n     *\\n     * @param {Vector3} a - \
The first vector.\\n     * @param {Vector3} b - The second vector.\\n     * \
@return {Vector3} A reference to this vector.\\n     */\\n    \
multiplyVectors(a, b) {\\n      this.x = a.x * b.x;\\n      this.y = a.y * \
b.y;\\n      this.z = a.z * b.z;\\n      return this;\\n    }\\n    /**\\n    \
 * Applies the given Euler rotation to this vector.\\n     *\\n     * @param \
{Euler} euler - The Euler angles.\\n     * @return {Vector3} A reference to \
this vector.\\n     */\\n    applyEuler(euler) {\\n      return \
this.applyQuaternion(_quaternion$4.setFromEuler(euler));\\n    }\\n    /**\\n \
    * Applies a rotation specified by an axis and an angle to this vector.\\n \
    *\\n     * @param {Vector3} axis - A normalized vector representing the \
rotation axis.\\n     * @param {number} angle - The angle in radians.\\n     \
* @return {Vector3} A reference to this vector.\\n     */\\n    \
applyAxisAngle(axis, angle) {\\n      return \
this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));\\n    }\\n \
   /**\\n     * Multiplies this vector with the given 3x3 matrix.\\n     *\\n \
    * @param {Matrix3} m - The 3x3 matrix.\\n     * @return {Vector3} A \
reference to this vector.\\n     */\\n    applyMatrix3(m) {\\n      const x2 \
= this.x, y = this.y, z = this.z;\\n      const e = m.elements;\\n      \
this.x = e[0] * x2 + e[3] * y + e[6] * z;\\n      this.y = e[1] * x2 + e[4] * \
y + e[7] * z;\\n      this.z = e[2] * x2 + e[5] * y + e[8] * z;\\n      \
return this;\\n    }\\n    /**\\n     * Multiplies this vector by the given \
normal matrix and normalizes\\n     * the result.\\n     *\\n     * @param \
{Matrix3} m - The normal matrix.\\n     * @return {Vector3} A reference to \
this vector.\\n     */\\n    applyNormalMatrix(m) {\\n      return \
this.applyMatrix3(m).normalize();\\n    }\\n    /**\\n     * Multiplies this \
vector (with an implicit 1 in the 4th dimension) by m, and\\n     * divides \
by perspective.\\n     *\\n     * @param {Matrix4} m - The matrix to \
apply.\\n     * @return {Vector3} A reference to this vector.\\n     */\\n    \
applyMatrix4(m) {\\n      const x2 = this.x, y = this.y, z = this.z;\\n      \
const e = m.elements;\\n      const w = 1 / (e[3] * x2 + e[7] * y + e[11] * z \
+ e[15]);\\n      this.x = (e[0] * x2 + e[4] * y + e[8] * z + e[12]) * w;\\n  \
    this.y = (e[1] * x2 + e[5] * y + e[9] * z + e[13]) * w;\\n      this.z = \
(e[2] * x2 + e[6] * y + e[10] * z + e[14]) * w;\\n      return this;\\n    \
}\\n    /**\\n     * Applies the given Quaternion to this vector.\\n     *\\n \
    * @param {Quaternion} q - The Quaternion.\\n     * @return {Vector3} A \
reference to this vector.\\n     */\\n    applyQuaternion(q) {\\n      const \
vx = this.x, vy = this.y, vz = this.z;\\n      const qx = q.x, qy = q.y, qz = \
q.z, qw = q.w;\\n      const tx = 2 * (qy * vz - qz * vy);\\n      const ty = \
2 * (qz * vx - qx * vz);\\n      const tz = 2 * (qx * vy - qy * vx);\\n      \
this.x = vx + qw * tx + qy * tz - qz * ty;\\n      this.y = vy + qw * ty + qz \
* tx - qx * tz;\\n      this.z = vz + qw * tz + qx * ty - qy * tx;\\n      \
return this;\\n    }\\n    /**\\n     * Projects this vector from world space \
into the camera\\'s normalized\\n     * device coordinate (NDC) space.\\n     \
*\\n     * @param {Camera} camera - The camera.\\n     * @return {Vector3} A \
reference to this vector.\\n     */\\n    project(camera) {\\n      return \
this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMa\
trix);\\n    }\\n    /**\\n     * Unprojects this vector from the camera\\'s \
normalized device coordinate (NDC)\\n     * space into world space.\\n     \
*\\n     * @param {Camera} camera - The camera.\\n     * @return {Vector3} A \
reference to this vector.\\n     */\\n    unproject(camera) {\\n      return \
this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixW\
orld);\\n    }\\n    /**\\n     * Transforms the direction of this vector by \
a matrix (the upper left 3 x 3\\n     * subset of the given 4x4 matrix and \
then normalizes the result.\\n     *\\n     * @param {Matrix4} m - The \
matrix.\\n     * @return {Vector3} A reference to this vector.\\n     */\\n   \
 transformDirection(m) {\\n      const x2 = this.x, y = this.y, z = \
this.z;\\n      const e = m.elements;\\n      this.x = e[0] * x2 + e[4] * y + \
e[8] * z;\\n      this.y = e[1] * x2 + e[5] * y + e[9] * z;\\n      this.z = \
e[2] * x2 + e[6] * y + e[10] * z;\\n      return this.normalize();\\n    }\\n \
   /**\\n     * Divides this instance by the given vector.\\n     *\\n     * \
@param {Vector3} v - The vector to divide.\\n     * @return {Vector3} A \
reference to this vector.\\n     */\\n    divide(v) {\\n      this.x /= \
v.x;\\n      this.y /= v.y;\\n      this.z /= v.z;\\n      return this;\\n    \
}\\n    /**\\n     * Divides this vector by the given scalar.\\n     *\\n     \
* @param {number} scalar - The scalar to divide.\\n     * @return {Vector3} A \
reference to this vector.\\n     */\\n    divideScalar(scalar) {\\n      \
return this.multiplyScalar(1 / scalar);\\n    }\\n    /**\\n     * If this \
vector\\'s x, y or z value is greater than the given vector\\'s x, y or z\\n  \
   * value, replace that value with the corresponding min value.\\n     *\\n  \
   * @param {Vector3} v - The vector.\\n     * @return {Vector3} A reference \
to this vector.\\n     */\\n    min(v) {\\n      this.x = Math.min(this.x, \
v.x);\\n      this.y = Math.min(this.y, v.y);\\n      this.z = \
Math.min(this.z, v.z);\\n      return this;\\n    }\\n    /**\\n     * If \
this vector\\'s x, y or z value is less than the given vector\\'s x, y or \
z\\n     * value, replace that value with the corresponding max value.\\n     \
*\\n     * @param {Vector3} v - The vector.\\n     * @return {Vector3} A \
reference to this vector.\\n     */\\n    max(v) {\\n      this.x = \
Math.max(this.x, v.x);\\n      this.y = Math.max(this.y, v.y);\\n      this.z \
= Math.max(this.z, v.z);\\n      return this;\\n    }\\n    /**\\n     * If \
this vector\\'s x, y or z value is greater than the max vector\\'s x, y or \
z\\n     * value, it is replaced by the corresponding value.\\n     * If this \
vector\\'s x, y or z value is less than the min vector\\'s x, y or z \
value,\\n     * it is replaced by the corresponding value.\\n     *\\n     * \
@param {Vector3} min - The minimum x, y and z values.\\n     * @param \
{Vector3} max - The maximum x, y and z values in the desired range.\\n     * \
@return {Vector3} A reference to this vector.\\n     */\\n    clamp(min, \
max2) {\\n      this.x = clamp(this.x, min.x, max2.x);\\n      this.y = \
clamp(this.y, min.y, max2.y);\\n      this.z = clamp(this.z, min.z, \
max2.z);\\n      return this;\\n    }\\n    /**\\n     * If this vector\\'s \
x, y or z values are greater than the max value, they are\\n     * replaced \
by the max value.\\n     * If this vector\\'s x, y or z values are less than \
the min value, they are\\n     * replaced by the min value.\\n     *\\n     * \
@param {number} minVal - The minimum value the components will be clamped \
to.\\n     * @param {number} maxVal - The maximum value the components will \
be clamped to.\\n     * @return {Vector3} A reference to this vector.\\n     \
*/\\n    clampScalar(minVal, maxVal) {\\n      this.x = clamp(this.x, minVal, \
maxVal);\\n      this.y = clamp(this.y, minVal, maxVal);\\n      this.z = \
clamp(this.z, minVal, maxVal);\\n      return this;\\n    }\\n    /**\\n     \
* If this vector\\'s length is greater than the max value, it is replaced \
by\\n     * the max value.\\n     * If this vector\\'s length is less than \
the min value, it is replaced by the\\n     * min value.\\n     *\\n     * \
@param {number} min - The minimum value the vector length will be clamped \
to.\\n     * @param {number} max - The maximum value the vector length will \
be clamped to.\\n     * @return {Vector3} A reference to this vector.\\n     \
*/\\n    clampLength(min, max2) {\\n      const length = this.length();\\n    \
  return this.divideScalar(length || 1).multiplyScalar(clamp(length, min, \
max2));\\n    }\\n    /**\\n     * The components of this vector are rounded \
down to the nearest integer value.\\n     *\\n     * @return {Vector3} A \
reference to this vector.\\n     */\\n    floor() {\\n      this.x = \
Math.floor(this.x);\\n      this.y = Math.floor(this.y);\\n      this.z = \
Math.floor(this.z);\\n      return this;\\n    }\\n    /**\\n     * The \
components of this vector are rounded up to the nearest integer value.\\n     \
*\\n     * @return {Vector3} A reference to this vector.\\n     */\\n    \
ceil() {\\n      this.x = Math.ceil(this.x);\\n      this.y = \
Math.ceil(this.y);\\n      this.z = Math.ceil(this.z);\\n      return \
this;\\n    }\\n    /**\\n     * The components of this vector are rounded to \
the nearest integer value\\n     *\\n     * @return {Vector3} A reference to \
this vector.\\n     */\\n    round() {\\n      this.x = \
Math.round(this.x);\\n      this.y = Math.round(this.y);\\n      this.z = \
Math.round(this.z);\\n      return this;\\n    }\\n    /**\\n     * The \
components of this vector are rounded towards zero (up if negative,\\n     * \
down if positive) to an integer value.\\n     *\\n     * @return {Vector3} A \
reference to this vector.\\n     */\\n    roundToZero() {\\n      this.x = \
Math.trunc(this.x);\\n      this.y = Math.trunc(this.y);\\n      this.z = \
Math.trunc(this.z);\\n      return this;\\n    }\\n    /**\\n     * Inverts \
this vector - i.e. sets x = -x, y = -y and z = -z.\\n     *\\n     * @return \
{Vector3} A reference to this vector.\\n     */\\n    negate() {\\n      \
this.x = -this.x;\\n      this.y = -this.y;\\n      this.z = -this.z;\\n      \
return this;\\n    }\\n    /**\\n     * Calculates the dot product of the \
given vector with this instance.\\n     *\\n     * @param {Vector3} v - The \
vector to compute the dot product with.\\n     * @return {number} The result \
of the dot product.\\n     */\\n    dot(v) {\\n      return this.x * v.x + \
this.y * v.y + this.z * v.z;\\n    }\\n    // TODO lengthSquared?\\n    \
/**\\n     * Computes the square of the Euclidean length (straight-line \
length) from\\n     * (0, 0, 0) to (x, y, z). If you are comparing the \
lengths of vectors, you should\\n     * compare the length squared instead as \
it is slightly more efficient to calculate.\\n     *\\n     * @return \
{number} The square length of this vector.\\n     */\\n    lengthSq() {\\n    \
  return this.x * this.x + this.y * this.y + this.z * this.z;\\n    }\\n    \
/**\\n     * Computes the  Euclidean length (straight-line length) from (0, \
0, 0) to (x, y, z).\\n     *\\n     * @return {number} The length of this \
vector.\\n     */\\n    length() {\\n      return Math.sqrt(this.x * this.x + \
this.y * this.y + this.z * this.z);\\n    }\\n    /**\\n     * Computes the \
Manhattan length of this vector.\\n     *\\n     * @return {number} The \
length of this vector.\\n     */\\n    manhattanLength() {\\n      return \
Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);\\n    }\\n    /**\\n  \
   * Converts this vector to a unit vector - that is, sets it equal to a \
vector\\n     * with the same direction as this one, but with a vector length \
of `1`.\\n     *\\n     * @return {Vector3} A reference to this vector.\\n    \
 */\\n    normalize() {\\n      return this.divideScalar(this.length() || \
1);\\n    }\\n    /**\\n     * Sets this vector to a vector with the same \
direction as this one, but\\n     * with the specified length.\\n     *\\n    \
 * @param {number} length - The new length of this vector.\\n     * @return \
{Vector3} A reference to this vector.\\n     */\\n    setLength(length) {\\n  \
    return this.normalize().multiplyScalar(length);\\n    }\\n    /**\\n     \
* Linearly interpolates between the given vector and this instance, where\\n  \
   * alpha is the percent distance along the line - alpha = 0 will be this\\n \
    * vector, and alpha = 1 will be the given one.\\n     *\\n     * @param \
{Vector3} v - The vector to interpolate towards.\\n     * @param {number} \
alpha - The interpolation factor, typically in the closed interval `[0, \
1]`.\\n     * @return {Vector3} A reference to this vector.\\n     */\\n    \
lerp(v, alpha) {\\n      this.x += (v.x - this.x) * alpha;\\n      this.y += \
(v.y - this.y) * alpha;\\n      this.z += (v.z - this.z) * alpha;\\n      \
return this;\\n    }\\n    /**\\n     * Linearly interpolates between the \
given vectors, where alpha is the percent\\n     * distance along the line - \
alpha = 0 will be first vector, and alpha = 1 will\\n     * be the second \
one. The result is stored in this instance.\\n     *\\n     * @param \
{Vector3} v1 - The first vector.\\n     * @param {Vector3} v2 - The second \
vector.\\n     * @param {number} alpha - The interpolation factor, typically \
in the closed interval `[0, 1]`.\\n     * @return {Vector3} A reference to \
this vector.\\n     */\\n    lerpVectors(v1, v2, alpha) {\\n      this.x = \
v1.x + (v2.x - v1.x) * alpha;\\n      this.y = v1.y + (v2.y - v1.y) * \
alpha;\\n      this.z = v1.z + (v2.z - v1.z) * alpha;\\n      return this;\\n \
   }\\n    /**\\n     * Calculates the cross product of the given vector with \
this instance.\\n     *\\n     * @param {Vector3} v - The vector to compute \
the cross product with.\\n     * @return {Vector3} The result of the cross \
product.\\n     */\\n    cross(v) {\\n      return this.crossVectors(this, \
v);\\n    }\\n    /**\\n     * Calculates the cross product of the given \
vectors and stores the result\\n     * in this instance.\\n     *\\n     * \
@param {Vector3} a - The first vector.\\n     * @param {Vector3} b - The \
second vector.\\n     * @return {Vector3} A reference to this vector.\\n     \
*/\\n    crossVectors(a, b) {\\n      const ax = a.x, ay = a.y, az = a.z;\\n  \
    const bx = b.x, by = b.y, bz = b.z;\\n      this.x = ay * bz - az * \
by;\\n      this.y = az * bx - ax * bz;\\n      this.z = ax * by - ay * \
bx;\\n      return this;\\n    }\\n    /**\\n     * Projects this vector onto \
the given one.\\n     *\\n     * @param {Vector3} v - The vector to project \
to.\\n     * @return {Vector3} A reference to this vector.\\n     */\\n    \
projectOnVector(v) {\\n      const denominator = v.lengthSq();\\n      if \
(denominator === 0) return this.set(0, 0, 0);\\n      const scalar = \
v.dot(this) / denominator;\\n      return \
this.copy(v).multiplyScalar(scalar);\\n    }\\n    /**\\n     * Projects this \
vector onto a plane by subtracting this\\n     * vector projected onto the \
plane\\'s normal from this vector.\\n     *\\n     * @param {Vector3} \
planeNormal - The plane normal.\\n     * @return {Vector3} A reference to \
this vector.\\n     */\\n    projectOnPlane(planeNormal) {\\n      \
_vector$c.copy(this).projectOnVector(planeNormal);\\n      return \
this.sub(_vector$c);\\n    }\\n    /**\\n     * Reflects this vector off a \
plane orthogonal to the given normal vector.\\n     *\\n     * @param \
{Vector3} normal - The (normalized) normal vector.\\n     * @return {Vector3} \
A reference to this vector.\\n     */\\n    reflect(normal) {\\n      return \
this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));\\n    \
}\\n    /**\\n     * Returns the angle between the given vector and this \
instance in radians.\\n     *\\n     * @param {Vector3} v - The vector to \
compute the angle with.\\n     * @return {number} The angle in radians.\\n    \
 */\\n    angleTo(v) {\\n      const denominator = Math.sqrt(this.lengthSq() \
* v.lengthSq());\\n      if (denominator === 0) return Math.PI / 2;\\n      \
const theta = this.dot(v) / denominator;\\n      return \
Math.acos(clamp(theta, -1, 1));\\n    }\\n    /**\\n     * Computes the \
distance from the given vector to this instance.\\n     *\\n     * @param \
{Vector3} v - The vector to compute the distance to.\\n     * @return \
{number} The distance.\\n     */\\n    distanceTo(v) {\\n      return \
Math.sqrt(this.distanceToSquared(v));\\n    }\\n    /**\\n     * Computes the \
squared distance from the given vector to this instance.\\n     * If you are \
just comparing the distance with another distance, you should compare\\n     \
* the distance squared instead as it is slightly more efficient to \
calculate.\\n     *\\n     * @param {Vector3} v - The vector to compute the \
squared distance to.\\n     * @return {number} The squared distance.\\n     \
*/\\n    distanceToSquared(v) {\\n      const dx = this.x - v.x, dy = this.y \
- v.y, dz = this.z - v.z;\\n      return dx * dx + dy * dy + dz * dz;\\n    \
}\\n    /**\\n     * Computes the Manhattan distance from the given vector to \
this instance.\\n     *\\n     * @param {Vector3} v - The vector to compute \
the Manhattan distance to.\\n     * @return {number} The Manhattan \
distance.\\n     */\\n    manhattanDistanceTo(v) {\\n      return \
Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);\\n  \
  }\\n    /**\\n     * Sets the vector components from the given spherical \
coordinates.\\n     *\\n     * @param {Spherical} s - The spherical \
coordinates.\\n     * @return {Vector3} A reference to this vector.\\n     \
*/\\n    setFromSpherical(s) {\\n      return \
this.setFromSphericalCoords(s.radius, s.phi, s.theta);\\n    }\\n    /**\\n   \
  * Sets the vector components from the given spherical coordinates.\\n     \
*\\n     * @param {number} radius - The radius.\\n     * @param {number} phi \
- The phi angle in radians.\\n     * @param {number} theta - The theta angle \
in radians.\\n     * @return {Vector3} A reference to this vector.\\n     \
*/\\n    setFromSphericalCoords(radius, phi, theta) {\\n      const \
sinPhiRadius = Math.sin(phi) * radius;\\n      this.x = sinPhiRadius * \
Math.sin(theta);\\n      this.y = Math.cos(phi) * radius;\\n      this.z = \
sinPhiRadius * Math.cos(theta);\\n      return this;\\n    }\\n    /**\\n     \
* Sets the vector components from the given cylindrical coordinates.\\n     \
*\\n     * @param {Cylindrical} c - The cylindrical coordinates.\\n     * \
@return {Vector3} A reference to this vector.\\n     */\\n    \
setFromCylindrical(c) {\\n      return \
this.setFromCylindricalCoords(c.radius, c.theta, c.y);\\n    }\\n    /**\\n   \
  * Sets the vector components from the given cylindrical coordinates.\\n     \
*\\n     * @param {number} radius - The radius.\\n     * @param {number} \
theta - The theta angle in radians.\\n     * @param {number} y - The y \
value.\\n     * @return {Vector3} A reference to this vector.\\n     */\\n    \
setFromCylindricalCoords(radius, theta, y) {\\n      this.x = radius * \
Math.sin(theta);\\n      this.y = y;\\n      this.z = radius * \
Math.cos(theta);\\n      return this;\\n    }\\n    /**\\n     * Sets the \
vector components to the position elements of the\\n     * given \
transformation matrix.\\n     *\\n     * @param {Matrix4} m - The 4x4 \
matrix.\\n     * @return {Vector3} A reference to this vector.\\n     */\\n   \
 setFromMatrixPosition(m) {\\n      const e = m.elements;\\n      this.x = \
e[12];\\n      this.y = e[13];\\n      this.z = e[14];\\n      return \
this;\\n    }\\n    /**\\n     * Sets the vector components to the scale \
elements of the\\n     * given transformation matrix.\\n     *\\n     * \
@param {Matrix4} m - The 4x4 matrix.\\n     * @return {Vector3} A reference \
to this vector.\\n     */\\n    setFromMatrixScale(m) {\\n      const sx = \
this.setFromMatrixColumn(m, 0).length();\\n      const sy = \
this.setFromMatrixColumn(m, 1).length();\\n      const sz = \
this.setFromMatrixColumn(m, 2).length();\\n      this.x = sx;\\n      this.y \
= sy;\\n      this.z = sz;\\n      return this;\\n    }\\n    /**\\n     * \
Sets the vector components from the specified matrix column.\\n     *\\n     \
* @param {Matrix4} m - The 4x4 matrix.\\n     * @param {number} index - The \
column index.\\n     * @return {Vector3} A reference to this vector.\\n     \
*/\\n    setFromMatrixColumn(m, index) {\\n      return \
this.fromArray(m.elements, index * 4);\\n    }\\n    /**\\n     * Sets the \
vector components from the specified matrix column.\\n     *\\n     * @param \
{Matrix3} m - The 3x3 matrix.\\n     * @param {number} index - The column \
index.\\n     * @return {Vector3} A reference to this vector.\\n     */\\n    \
setFromMatrix3Column(m, index) {\\n      return this.fromArray(m.elements, \
index * 3);\\n    }\\n    /**\\n     * Sets the vector components from the \
given Euler angles.\\n     *\\n     * @param {Euler} e - The Euler angles to \
set.\\n     * @return {Vector3} A reference to this vector.\\n     */\\n    \
setFromEuler(e) {\\n      this.x = e._x;\\n      this.y = e._y;\\n      \
this.z = e._z;\\n      return this;\\n    }\\n    /**\\n     * Sets the \
vector components from the RGB components of the\\n     * given color.\\n     \
*\\n     * @param {Color} c - The color to set.\\n     * @return {Vector3} A \
reference to this vector.\\n     */\\n    setFromColor(c) {\\n      this.x = \
c.r;\\n      this.y = c.g;\\n      this.z = c.b;\\n      return this;\\n    \
}\\n    /**\\n     * Returns `true` if this vector is equal with the given \
one.\\n     *\\n     * @param {Vector3} v - The vector to test for \
equality.\\n     * @return {boolean} Whether this vector is equal with the \
given one.\\n     */\\n    equals(v) {\\n      return v.x === this.x && v.y \
=== this.y && v.z === this.z;\\n    }\\n    /**\\n     * Sets this vector\\'s \
x value to be `array[ offset ]`, y value to be `array[ offset + 1 ]`\\n     * \
and z value to be `array[ offset + 2 ]`.\\n     *\\n     * @param \
{Array<number>} array - An array holding the vector component values.\\n     \
* @param {number} [offset=0] - The offset into the array.\\n     * @return \
{Vector3} A reference to this vector.\\n     */\\n    fromArray(array, offset \
= 0) {\\n      this.x = array[offset];\\n      this.y = array[offset + 1];\\n \
     this.z = array[offset + 2];\\n      return this;\\n    }\\n    /**\\n    \
 * Writes the components of this vector to the given array. If no array is \
provided,\\n     * the method returns a new instance.\\n     *\\n     * \
@param {Array<number>} [array=[]] - The target array holding the vector \
components.\\n     * @param {number} [offset=0] - Index of the first element \
in the array.\\n     * @return {Array<number>} The vector components.\\n     \
*/\\n    toArray(array = [], offset = 0) {\\n      array[offset] = this.x;\\n \
     array[offset + 1] = this.y;\\n      array[offset + 2] = this.z;\\n      \
return array;\\n    }\\n    /**\\n     * Sets the components of this vector \
from the given buffer attribute.\\n     *\\n     * @param {BufferAttribute} \
attribute - The buffer attribute holding vector data.\\n     * @param \
{number} index - The index into the attribute.\\n     * @return {Vector3} A \
reference to this vector.\\n     */\\n    fromBufferAttribute(attribute, \
index) {\\n      this.x = attribute.getX(index);\\n      this.y = \
attribute.getY(index);\\n      this.z = attribute.getZ(index);\\n      return \
this;\\n    }\\n    /**\\n     * Sets each component of this vector to a \
pseudo-random value between `0` and\\n     * `1`, excluding `1`.\\n     *\\n  \
   * @return {Vector3} A reference to this vector.\\n     */\\n    random() \
{\\n      this.x = Math.random();\\n      this.y = Math.random();\\n      \
this.z = Math.random();\\n      return this;\\n    }\\n    /**\\n     * Sets \
this vector to a uniformly random point on a unit sphere.\\n     *\\n     * \
@return {Vector3} A reference to this vector.\\n     */\\n    \
randomDirection() {\\n      const theta = Math.random() * Math.PI * 2;\\n     \
 const u = Math.random() * 2 - 1;\\n      const c = Math.sqrt(1 - u * u);\\n  \
    this.x = c * Math.cos(theta);\\n      this.y = u;\\n      this.z = c * \
Math.sin(theta);\\n      return this;\\n    }\\n    *[Symbol.iterator]() {\\n \
     yield this.x;\\n      yield this.y;\\n      yield this.z;\\n    }\\n  \
}\\n  const _vector$c = /* @__PURE__ */ new Vector3();\\n  const \
_quaternion$4 = /* @__PURE__ */ new Quaternion();\\n  class Matrix3 {\\n    \
/**\\n     * Constructs a new 3x3 matrix. The arguments are supposed to be\\n \
    * in row-major order. If no arguments are provided, the constructor\\n    \
 * initializes the matrix as an identity matrix.\\n     *\\n     * @param \
{number} [n11] - 1-1 matrix element.\\n     * @param {number} [n12] - 1-2 \
matrix element.\\n     * @param {number} [n13] - 1-3 matrix element.\\n     * \
@param {number} [n21] - 2-1 matrix element.\\n     * @param {number} [n22] - \
2-2 matrix element.\\n     * @param {number} [n23] - 2-3 matrix element.\\n   \
  * @param {number} [n31] - 3-1 matrix element.\\n     * @param {number} \
[n32] - 3-2 matrix element.\\n     * @param {number} [n33] - 3-3 matrix \
element.\\n     */\\n    constructor(n11, n12, n13, n21, n22, n23, n31, n32, \
n33) {\\n      Matrix3.prototype.isMatrix3 = true;\\n      this.elements = \
[\\n        1,\\n        0,\\n        0,\\n        0,\\n        1,\\n        \
0,\\n        0,\\n        0,\\n        1\\n      ];\\n      if (n11 !== void \
0) {\\n        this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);\\n      \
}\\n    }\\n    /**\\n     * Sets the elements of the matrix.The arguments \
are supposed to be\\n     * in row-major order.\\n     *\\n     * @param \
{number} [n11] - 1-1 matrix element.\\n     * @param {number} [n12] - 1-2 \
matrix element.\\n     * @param {number} [n13] - 1-3 matrix element.\\n     * \
@param {number} [n21] - 2-1 matrix element.\\n     * @param {number} [n22] - \
2-2 matrix element.\\n     * @param {number} [n23] - 2-3 matrix element.\\n   \
  * @param {number} [n31] - 3-1 matrix element.\\n     * @param {number} \
[n32] - 3-2 matrix element.\\n     * @param {number} [n33] - 3-3 matrix \
element.\\n     * @return {Matrix3} A reference to this matrix.\\n     */\\n  \
  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {\\n      const te = \
this.elements;\\n      te[0] = n11;\\n      te[1] = n21;\\n      te[2] = \
n31;\\n      te[3] = n12;\\n      te[4] = n22;\\n      te[5] = n32;\\n      \
te[6] = n13;\\n      te[7] = n23;\\n      te[8] = n33;\\n      return \
this;\\n    }\\n    /**\\n     * Sets this matrix to the 3x3 identity \
matrix.\\n     *\\n     * @return {Matrix3} A reference to this matrix.\\n    \
 */\\n    identity() {\\n      this.set(\\n        1,\\n        0,\\n        \
0,\\n        0,\\n        1,\\n        0,\\n        0,\\n        0,\\n        \
1\\n      );\\n      return this;\\n    }\\n    /**\\n     * Copies the \
values of the given matrix to this instance.\\n     *\\n     * @param \
{Matrix3} m - The matrix to copy.\\n     * @return {Matrix3} A reference to \
this matrix.\\n     */\\n    copy(m) {\\n      const te = this.elements;\\n   \
   const me = m.elements;\\n      te[0] = me[0];\\n      te[1] = me[1];\\n    \
  te[2] = me[2];\\n      te[3] = me[3];\\n      te[4] = me[4];\\n      te[5] \
= me[5];\\n      te[6] = me[6];\\n      te[7] = me[7];\\n      te[8] = \
me[8];\\n      return this;\\n    }\\n    /**\\n     * Extracts the basis of \
this matrix into the three axis vectors provided.\\n     *\\n     * @param \
{Vector3} xAxis - The basis\\'s x axis.\\n     * @param {Vector3} yAxis - The \
basis\\'s y axis.\\n     * @param {Vector3} zAxis - The basis\\'s z axis.\\n  \
   * @return {Matrix3} A reference to this matrix.\\n     */\\n    \
extractBasis(xAxis, yAxis, zAxis) {\\n      xAxis.setFromMatrix3Column(this, \
0);\\n      yAxis.setFromMatrix3Column(this, 1);\\n      \
zAxis.setFromMatrix3Column(this, 2);\\n      return this;\\n    }\\n    \
/**\\n     * Set this matrix to the upper 3x3 matrix of the given 4x4 \
matrix.\\n     *\\n     * @param {Matrix4} m - The 4x4 matrix.\\n     * \
@return {Matrix3} A reference to this matrix.\\n     */\\n    \
setFromMatrix4(m) {\\n      const me = m.elements;\\n      this.set(\\n       \
 me[0],\\n        me[4],\\n        me[8],\\n        me[1],\\n        \
me[5],\\n        me[9],\\n        me[2],\\n        me[6],\\n        me[10]\\n \
     );\\n      return this;\\n    }\\n    /**\\n     * Post-multiplies this \
matrix by the given 3x3 matrix.\\n     *\\n     * @param {Matrix3} m - The \
matrix to multiply with.\\n     * @return {Matrix3} A reference to this \
matrix.\\n     */\\n    multiply(m) {\\n      return \
this.multiplyMatrices(this, m);\\n    }\\n    /**\\n     * Pre-multiplies \
this matrix by the given 3x3 matrix.\\n     *\\n     * @param {Matrix3} m - \
The matrix to multiply with.\\n     * @return {Matrix3} A reference to this \
matrix.\\n     */\\n    premultiply(m) {\\n      return \
this.multiplyMatrices(m, this);\\n    }\\n    /**\\n     * Multiples the \
given 3x3 matrices and stores the result\\n     * in this matrix.\\n     *\\n \
    * @param {Matrix3} a - The first matrix.\\n     * @param {Matrix3} b - \
The second matrix.\\n     * @return {Matrix3} A reference to this matrix.\\n  \
   */\\n    multiplyMatrices(a, b) {\\n      const ae = a.elements;\\n      \
const be = b.elements;\\n      const te = this.elements;\\n      const a11 = \
ae[0], a12 = ae[3], a13 = ae[6];\\n      const a21 = ae[1], a22 = ae[4], a23 \
= ae[7];\\n      const a31 = ae[2], a32 = ae[5], a33 = ae[8];\\n      const \
b11 = be[0], b12 = be[3], b13 = be[6];\\n      const b21 = be[1], b22 = \
be[4], b23 = be[7];\\n      const b31 = be[2], b32 = be[5], b33 = be[8];\\n   \
   te[0] = a11 * b11 + a12 * b21 + a13 * b31;\\n      te[3] = a11 * b12 + a12 \
* b22 + a13 * b32;\\n      te[6] = a11 * b13 + a12 * b23 + a13 * b33;\\n      \
te[1] = a21 * b11 + a22 * b21 + a23 * b31;\\n      te[4] = a21 * b12 + a22 * \
b22 + a23 * b32;\\n      te[7] = a21 * b13 + a22 * b23 + a23 * b33;\\n      \
te[2] = a31 * b11 + a32 * b21 + a33 * b31;\\n      te[5] = a31 * b12 + a32 * \
b22 + a33 * b32;\\n      te[8] = a31 * b13 + a32 * b23 + a33 * b33;\\n      \
return this;\\n    }\\n    /**\\n     * Multiplies every component of the \
matrix by the given scalar.\\n     *\\n     * @param {number} s - The \
scalar.\\n     * @return {Matrix3} A reference to this matrix.\\n     */\\n   \
 multiplyScalar(s) {\\n      const te = this.elements;\\n      te[0] *= s;\\n \
     te[3] *= s;\\n      te[6] *= s;\\n      te[1] *= s;\\n      te[4] *= \
s;\\n      te[7] *= s;\\n      te[2] *= s;\\n      te[5] *= s;\\n      te[8] \
*= s;\\n      return this;\\n    }\\n    /**\\n     * Computes and returns \
the determinant of this matrix.\\n     *\\n     * @return {number} The \
determinant.\\n     */\\n    determinant() {\\n      const te = \
this.elements;\\n      const a = te[0], b = te[1], c = te[2], d = te[3], e = \
te[4], f = te[5], g = te[6], h = te[7], i2 = te[8];\\n      return a * e * i2 \
- a * f * h - b * d * i2 + b * f * g + c * d * h - c * e * g;\\n    }\\n    \
/**\\n     * Inverts this matrix, using the [analytic method]{@link \
https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution}.\\n     * \
You can not invert with a determinant of zero. If you attempt this, the \
method produces\\n     * a zero matrix instead.\\n     *\\n     * @return \
{Matrix3} A reference to this matrix.\\n     */\\n    invert() {\\n      \
const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], \
n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * \
n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, \
det = n11 * t11 + n21 * t12 + n31 * t13;\\n      if (det === 0) return \
this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);\\n      const detInv = 1 / det;\\n      \
te[0] = t11 * detInv;\\n      te[1] = (n31 * n23 - n33 * n21) * detInv;\\n    \
  te[2] = (n32 * n21 - n31 * n22) * detInv;\\n      te[3] = t12 * detInv;\\n  \
    te[4] = (n33 * n11 - n31 * n13) * detInv;\\n      te[5] = (n31 * n12 - \
n32 * n11) * detInv;\\n      te[6] = t13 * detInv;\\n      te[7] = (n21 * n13 \
- n23 * n11) * detInv;\\n      te[8] = (n22 * n11 - n21 * n12) * detInv;\\n   \
   return this;\\n    }\\n    /**\\n     * Transposes this matrix in \
place.\\n     *\\n     * @return {Matrix3} A reference to this matrix.\\n     \
*/\\n    transpose() {\\n      let tmp;\\n      const m = this.elements;\\n   \
   tmp = m[1];\\n      m[1] = m[3];\\n      m[3] = tmp;\\n      tmp = \
m[2];\\n      m[2] = m[6];\\n      m[6] = tmp;\\n      tmp = m[5];\\n      \
m[5] = m[7];\\n      m[7] = tmp;\\n      return this;\\n    }\\n    /**\\n    \
 * Computes the normal matrix which is the inverse transpose of the upper\\n  \
   * left 3x3 portion of the given 4x4 matrix.\\n     *\\n     * @param \
{Matrix4} matrix4 - The 4x4 matrix.\\n     * @return {Matrix3} A reference to \
this matrix.\\n     */\\n    getNormalMatrix(matrix4) {\\n      return \
this.setFromMatrix4(matrix4).invert().transpose();\\n    }\\n    /**\\n     * \
Transposes this matrix into the supplied array, and returns itself \
unchanged.\\n     *\\n     * @param {Array<number>} r - An array to store the \
transposed matrix elements.\\n     * @return {Matrix3} A reference to this \
matrix.\\n     */\\n    transposeIntoArray(r) {\\n      const m = \
this.elements;\\n      r[0] = m[0];\\n      r[1] = m[3];\\n      r[2] = \
m[6];\\n      r[3] = m[1];\\n      r[4] = m[4];\\n      r[5] = m[7];\\n      \
r[6] = m[2];\\n      r[7] = m[5];\\n      r[8] = m[8];\\n      return \
this;\\n    }\\n    /**\\n     * Sets the UV transform matrix from offset, \
repeat, rotation, and center.\\n     *\\n     * @param {number} tx - Offset \
x.\\n     * @param {number} ty - Offset y.\\n     * @param {number} sx - \
Repeat x.\\n     * @param {number} sy - Repeat y.\\n     * @param {number} \
rotation - Rotation, in radians. Positive values rotate counterclockwise.\\n  \
   * @param {number} cx - Center x of rotation.\\n     * @param {number} cy - \
Center y of rotation\\n     * @return {Matrix3} A reference to this \
matrix.\\n     */\\n    setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {\\n \
     const c = Math.cos(rotation);\\n      const s = Math.sin(rotation);\\n   \
   this.set(\\n        sx * c,\\n        sx * s,\\n        -sx * (c * cx + s \
* cy) + cx + tx,\\n        -sy * s,\\n        sy * c,\\n        -sy * (-s * \
cx + c * cy) + cy + ty,\\n        0,\\n        0,\\n        1\\n      );\\n   \
   return this;\\n    }\\n    /**\\n     * Scales this matrix with the given \
scalar values.\\n     *\\n     * @param {number} sx - The amount to scale in \
the X axis.\\n     * @param {number} sy - The amount to scale in the Y \
axis.\\n     * @return {Matrix3} A reference to this matrix.\\n     */\\n    \
scale(sx, sy) {\\n      this.premultiply(_m3.makeScale(sx, sy));\\n      \
return this;\\n    }\\n    /**\\n     * Rotates this matrix by the given \
angle.\\n     *\\n     * @param {number} theta - The rotation in radians.\\n  \
   * @return {Matrix3} A reference to this matrix.\\n     */\\n    \
rotate(theta) {\\n      this.premultiply(_m3.makeRotation(-theta));\\n      \
return this;\\n    }\\n    /**\\n     * Translates this matrix by the given \
scalar values.\\n     *\\n     * @param {number} tx - The amount to translate \
in the X axis.\\n     * @param {number} ty - The amount to translate in the Y \
axis.\\n     * @return {Matrix3} A reference to this matrix.\\n     */\\n    \
translate(tx, ty) {\\n      this.premultiply(_m3.makeTranslation(tx, ty));\\n \
     return this;\\n    }\\n    // for 2D Transforms\\n    /**\\n     * Sets \
this matrix as a 2D translation transform.\\n     *\\n     * @param \
{number|Vector2} x - The amount to translate in the X axis or alternatively a \
translation vector.\\n     * @param {number} y - The amount to translate in \
the Y axis.\\n     * @return {Matrix3} A reference to this matrix.\\n     \
*/\\n    makeTranslation(x2, y) {\\n      if (x2.isVector2) {\\n        \
this.set(\\n          1,\\n          0,\\n          x2.x,\\n          0,\\n   \
       1,\\n          x2.y,\\n          0,\\n          0,\\n          1\\n    \
    );\\n      } else {\\n        this.set(\\n          1,\\n          0,\\n  \
        x2,\\n          0,\\n          1,\\n          y,\\n          0,\\n    \
      0,\\n          1\\n        );\\n      }\\n      return this;\\n    }\\n \
   /**\\n     * Sets this matrix as a 2D rotational transformation.\\n     \
*\\n     * @param {number} theta - The rotation in radians.\\n     * @return \
{Matrix3} A reference to this matrix.\\n     */\\n    makeRotation(theta) \
{\\n      const c = Math.cos(theta);\\n      const s = Math.sin(theta);\\n    \
  this.set(\\n        c,\\n        -s,\\n        0,\\n        s,\\n        \
c,\\n        0,\\n        0,\\n        0,\\n        1\\n      );\\n      \
return this;\\n    }\\n    /**\\n     * Sets this matrix as a 2D scale \
transform.\\n     *\\n     * @param {number} x - The amount to scale in the X \
axis.\\n     * @param {number} y - The amount to scale in the Y axis.\\n     \
* @return {Matrix3} A reference to this matrix.\\n     */\\n    makeScale(x2, \
y) {\\n      this.set(\\n        x2,\\n        0,\\n        0,\\n        \
0,\\n        y,\\n        0,\\n        0,\\n        0,\\n        1\\n      \
);\\n      return this;\\n    }\\n    /**\\n     * Returns `true` if this \
matrix is equal with the given one.\\n     *\\n     * @param {Matrix3} matrix \
- The matrix to test for equality.\\n     * @return {boolean} Whether this \
matrix is equal with the given one.\\n     */\\n    equals(matrix) {\\n      \
const te = this.elements;\\n      const me = matrix.elements;\\n      for \
(let i2 = 0; i2 < 9; i2++) {\\n        if (te[i2] !== me[i2]) return \
false;\\n      }\\n      return true;\\n    }\\n    /**\\n     * Sets the \
elements of the matrix from the given array.\\n     *\\n     * @param \
{Array<number>} array - The matrix elements in column-major order.\\n     * \
@param {number} [offset=0] - Index of the first element in the array.\\n     \
* @return {Matrix3} A reference to this matrix.\\n     */\\n    \
fromArray(array, offset = 0) {\\n      for (let i2 = 0; i2 < 9; i2++) {\\n    \
    this.elements[i2] = array[i2 + offset];\\n      }\\n      return this;\\n \
   }\\n    /**\\n     * Writes the elements of this matrix to the given \
array. If no array is provided,\\n     * the method returns a new \
instance.\\n     *\\n     * @param {Array<number>} [array=[]] - The target \
array holding the matrix elements in column-major order.\\n     * @param \
{number} [offset=0] - Index of the first element in the array.\\n     * \
@return {Array<number>} The matrix elements in column-major order.\\n     \
*/\\n    toArray(array = [], offset = 0) {\\n      const te = \
this.elements;\\n      array[offset] = te[0];\\n      array[offset + 1] = \
te[1];\\n      array[offset + 2] = te[2];\\n      array[offset + 3] = \
te[3];\\n      array[offset + 4] = te[4];\\n      array[offset + 5] = \
te[5];\\n      array[offset + 6] = te[6];\\n      array[offset + 7] = \
te[7];\\n      array[offset + 8] = te[8];\\n      return array;\\n    }\\n    \
/**\\n     * Returns a matrix with copied values from this instance.\\n     \
*\\n     * @return {Matrix3} A clone of this instance.\\n     */\\n    \
clone() {\\n      return new this.constructor().fromArray(this.elements);\\n  \
  }\\n  }\\n  const _m3 = /* @__PURE__ */ new Matrix3();\\n  const _cache = \
{};\\n  function warnOnce(message) {\\n    if (message in _cache) return;\\n  \
  _cache[message] = true;\\n    console.warn(message);\\n  }\\n  const \
LINEAR_REC709_TO_XYZ = /* @__PURE__ */ new Matrix3().set(\\n    0.4123908,\\n \
   0.3575843,\\n    0.1804808,\\n    0.212639,\\n    0.7151687,\\n    \
0.0721923,\\n    0.0193308,\\n    0.1191948,\\n    0.9505322\\n  );\\n  const \
XYZ_TO_LINEAR_REC709 = /* @__PURE__ */ new Matrix3().set(\\n    3.2409699,\\n \
   -1.5373832,\\n    -0.4986108,\\n    -0.9692436,\\n    1.8759675,\\n    \
0.0415551,\\n    0.0556301,\\n    -0.203977,\\n    1.0569715\\n  );\\n  \
function createColorManagement() {\\n    const ColorManagement2 = {\\n      \
enabled: true,\\n      workingColorSpace: LinearSRGBColorSpace,\\n      \
/**\\n       * Implementations of supported color spaces.\\n       *\\n       \
* Required:\\n       *\t- primaries: chromaticity coordinates [ rx ry gx gy \
bx by ]\\n       *\t- whitePoint: reference white [ x y ]\\n       *\t- \
transfer: transfer function (pre-defined)\\n       *\t- toXYZ: Matrix3 RGB to \
XYZ transform\\n       *\t- fromXYZ: Matrix3 XYZ to RGB transform\\n       \
*\t- luminanceCoefficients: RGB luminance coefficients\\n       *\\n       * \
Optional:\\n       *  - outputColorSpaceConfig: { drawingBufferColorSpace: \
ColorSpace }\\n       *  - workingColorSpaceConfig: { unpackColorSpace: \
ColorSpace }\\n       *\\n       * Reference:\\n       * - \
https://www.russellcottrell.com/photo/matrixCalculator.htm\\n       */\\n     \
 spaces: {},\\n      convert: function(color, sourceColorSpace, \
targetColorSpace) {\\n        if (this.enabled === false || sourceColorSpace \
=== targetColorSpace || !sourceColorSpace || !targetColorSpace) {\\n          \
return color;\\n        }\\n        if \
(this.spaces[sourceColorSpace].transfer === SRGBTransfer) {\\n          \
color.r = SRGBToLinear(color.r);\\n          color.g = \
SRGBToLinear(color.g);\\n          color.b = SRGBToLinear(color.b);\\n        \
}\\n        if (this.spaces[sourceColorSpace].primaries !== \
this.spaces[targetColorSpace].primaries) {\\n          \
color.applyMatrix3(this.spaces[sourceColorSpace].toXYZ);\\n          \
color.applyMatrix3(this.spaces[targetColorSpace].fromXYZ);\\n        }\\n     \
   if (this.spaces[targetColorSpace].transfer === SRGBTransfer) {\\n          \
color.r = LinearToSRGB(color.r);\\n          color.g = \
LinearToSRGB(color.g);\\n          color.b = LinearToSRGB(color.b);\\n        \
}\\n        return color;\\n      },\\n      workingToColorSpace: \
function(color, targetColorSpace) {\\n        return this.convert(color, \
this.workingColorSpace, targetColorSpace);\\n      },\\n      \
colorSpaceToWorking: function(color, sourceColorSpace) {\\n        return \
this.convert(color, sourceColorSpace, this.workingColorSpace);\\n      },\\n  \
    getPrimaries: function(colorSpace) {\\n        return \
this.spaces[colorSpace].primaries;\\n      },\\n      getTransfer: \
function(colorSpace) {\\n        if (colorSpace === NoColorSpace) return \
LinearTransfer;\\n        return this.spaces[colorSpace].transfer;\\n      \
},\\n      getLuminanceCoefficients: function(target, colorSpace = \
this.workingColorSpace) {\\n        return \
target.fromArray(this.spaces[colorSpace].luminanceCoefficients);\\n      \
},\\n      define: function(colorSpaces) {\\n        \
Object.assign(this.spaces, colorSpaces);\\n      },\\n      // Internal \
APIs\\n      _getMatrix: function(targetMatrix, sourceColorSpace, \
targetColorSpace) {\\n        return \
targetMatrix.copy(this.spaces[sourceColorSpace].toXYZ).multiply(this.spaces[t\
argetColorSpace].fromXYZ);\\n      },\\n      _getDrawingBufferColorSpace: \
function(colorSpace) {\\n        return \
this.spaces[colorSpace].outputColorSpaceConfig.drawingBufferColorSpace;\\n    \
  },\\n      _getUnpackColorSpace: function(colorSpace = \
this.workingColorSpace) {\\n        return \
this.spaces[colorSpace].workingColorSpaceConfig.unpackColorSpace;\\n      \
},\\n      // Deprecated\\n      fromWorkingColorSpace: function(color, \
targetColorSpace) {\\n        warnOnce(\"THREE.ColorManagement: \
.fromWorkingColorSpace() has been renamed to .workingToColorSpace().\");\\n   \
     return ColorManagement2.workingToColorSpace(color, targetColorSpace);\\n \
     },\\n      toWorkingColorSpace: function(color, sourceColorSpace) {\\n   \
     warnOnce(\"THREE.ColorManagement: .toWorkingColorSpace() has been \
renamed to .colorSpaceToWorking().\");\\n        return \
ColorManagement2.colorSpaceToWorking(color, sourceColorSpace);\\n      }\\n   \
 };\\n    const REC709_PRIMARIES = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06];\\n    \
const REC709_LUMINANCE_COEFFICIENTS = [0.2126, 0.7152, 0.0722];\\n    const \
D65 = [0.3127, 0.329];\\n    ColorManagement2.define({\\n      \
[LinearSRGBColorSpace]: {\\n        primaries: REC709_PRIMARIES,\\n        \
whitePoint: D65,\\n        transfer: LinearTransfer,\\n        toXYZ: \
LINEAR_REC709_TO_XYZ,\\n        fromXYZ: XYZ_TO_LINEAR_REC709,\\n        \
luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,\\n        \
workingColorSpaceConfig: { unpackColorSpace: SRGBColorSpace },\\n        \
outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }\\n      \
},\\n      [SRGBColorSpace]: {\\n        primaries: REC709_PRIMARIES,\\n      \
  whitePoint: D65,\\n        transfer: SRGBTransfer,\\n        toXYZ: \
LINEAR_REC709_TO_XYZ,\\n        fromXYZ: XYZ_TO_LINEAR_REC709,\\n        \
luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,\\n        \
outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }\\n      \
}\\n    });\\n    return ColorManagement2;\\n  }\\n  const ColorManagement = \
/* @__PURE__ */ createColorManagement();\\n  function SRGBToLinear(c) {\\n    \
return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + \
0.0521327014, 2.4);\\n  }\\n  function LinearToSRGB(c) {\\n    return c < \
31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;\\n  }\\n  class \
Box3 {\\n    /**\\n     * Constructs a new bounding box.\\n     *\\n     * \
@param {Vector3} [min=(Infinity,Infinity,Infinity)] - A vector representing \
the lower boundary of the box.\\n     * @param {Vector3} \
[max=(-Infinity,-Infinity,-Infinity)] - A vector representing the upper \
boundary of the box.\\n     */\\n    constructor(min = new Vector3(Infinity, \
Infinity, Infinity), max2 = new Vector3(-Infinity, -Infinity, -Infinity)) \
{\\n      this.isBox3 = true;\\n      this.min = min;\\n      this.max = \
max2;\\n    }\\n    /**\\n     * Sets the lower and upper boundaries of this \
box.\\n     * Please note that this method only copies the values from the \
given objects.\\n     *\\n     * @param {Vector3} min - The lower boundary of \
the box.\\n     * @param {Vector3} max - The upper boundary of the box.\\n    \
 * @return {Box3} A reference to this bounding box.\\n     */\\n    set(min, \
max2) {\\n      this.min.copy(min);\\n      this.max.copy(max2);\\n      \
return this;\\n    }\\n    /**\\n     * Sets the upper and lower bounds of \
this box so it encloses the position data\\n     * in the given array.\\n     \
*\\n     * @param {Array<number>} array - An array holding 3D position \
data.\\n     * @return {Box3} A reference to this bounding box.\\n     */\\n  \
  setFromArray(array) {\\n      this.makeEmpty();\\n      for (let i2 = 0, il \
= array.length; i2 < il; i2 += 3) {\\n        \
this.expandByPoint(_vector$b.fromArray(array, i2));\\n      }\\n      return \
this;\\n    }\\n    /**\\n     * Sets the upper and lower bounds of this box \
so it encloses the position data\\n     * in the given buffer attribute.\\n   \
  *\\n     * @param {BufferAttribute} attribute - A buffer attribute holding \
3D position data.\\n     * @return {Box3} A reference to this bounding \
box.\\n     */\\n    setFromBufferAttribute(attribute) {\\n      \
this.makeEmpty();\\n      for (let i2 = 0, il = attribute.count; i2 < il; \
i2++) {\\n        this.expandByPoint(_vector$b.fromBufferAttribute(attribute, \
i2));\\n      }\\n      return this;\\n    }\\n    /**\\n     * Sets the \
upper and lower bounds of this box so it encloses the position data\\n     * \
in the given array.\\n     *\\n     * @param {Array<Vector3>} points - An \
array holding 3D position data as instances of {@link Vector3}.\\n     * \
@return {Box3} A reference to this bounding box.\\n     */\\n    \
setFromPoints(points) {\\n      this.makeEmpty();\\n      for (let i2 = 0, il \
= points.length; i2 < il; i2++) {\\n        \
this.expandByPoint(points[i2]);\\n      }\\n      return this;\\n    }\\n    \
/**\\n     * Centers this box on the given center vector and sets this \
box\\'s width, height and\\n     * depth to the given size values.\\n     \
*\\n     * @param {Vector3} center - The center of the box.\\n     * @param \
{Vector3} size - The x, y and z dimensions of the box.\\n     * @return \
{Box3} A reference to this bounding box.\\n     */\\n    \
setFromCenterAndSize(center, size) {\\n      const halfSize = \
_vector$b.copy(size).multiplyScalar(0.5);\\n      \
this.min.copy(center).sub(halfSize);\\n      \
this.max.copy(center).add(halfSize);\\n      return this;\\n    }\\n    \
/**\\n     * Computes the world-axis-aligned bounding box for the given 3D \
object\\n     * (including its children), accounting for the object\\'s, and \
children\\'s,\\n     * world transforms. The function may result in a larger \
box than strictly necessary.\\n     *\\n     * @param {Object3D} object - The \
3D object to compute the bounding box for.\\n     * @param {boolean} \
[precise=false] - If set to `true`, the method computes the smallest\\n     * \
world-axis-aligned bounding box at the expense of more computation.\\n     * \
@return {Box3} A reference to this bounding box.\\n     */\\n    \
setFromObject(object, precise = false) {\\n      this.makeEmpty();\\n      \
return this.expandByObject(object, precise);\\n    }\\n    /**\\n     * \
Returns a new box with copied values from this instance.\\n     *\\n     * \
@return {Box3} A clone of this instance.\\n     */\\n    clone() {\\n      \
return new this.constructor().copy(this);\\n    }\\n    /**\\n     * Copies \
the values of the given box to this instance.\\n     *\\n     * @param {Box3} \
box - The box to copy.\\n     * @return {Box3} A reference to this bounding \
box.\\n     */\\n    copy(box) {\\n      this.min.copy(box.min);\\n      \
this.max.copy(box.max);\\n      return this;\\n    }\\n    /**\\n     * Makes \
this box empty which means in encloses a zero space in 3D.\\n     *\\n     * \
@return {Box3} A reference to this bounding box.\\n     */\\n    makeEmpty() \
{\\n      this.min.x = this.min.y = this.min.z = Infinity;\\n      this.max.x \
= this.max.y = this.max.z = -Infinity;\\n      return this;\\n    }\\n    \
/**\\n     * Returns true if this box includes zero points within its \
bounds.\\n     * Note that a box with equal lower and upper bounds still \
includes one\\n     * point, the one both bounds share.\\n     *\\n     * \
@return {boolean} Whether this box is empty or not.\\n     */\\n    isEmpty() \
{\\n      return this.max.x < this.min.x || this.max.y < this.min.y || \
this.max.z < this.min.z;\\n    }\\n    /**\\n     * Returns the center point \
of this box.\\n     *\\n     * @param {Vector3} target - The target vector \
that is used to store the method\\'s result.\\n     * @return {Vector3} The \
center point.\\n     */\\n    getCenter(target) {\\n      return \
this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, \
this.max).multiplyScalar(0.5);\\n    }\\n    /**\\n     * Returns the \
dimensions of this box.\\n     *\\n     * @param {Vector3} target - The \
target vector that is used to store the method\\'s result.\\n     * @return \
{Vector3} The size.\\n     */\\n    getSize(target) {\\n      return \
this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, \
this.min);\\n    }\\n    /**\\n     * Expands the boundaries of this box to \
include the given point.\\n     *\\n     * @param {Vector3} point - The point \
that should be included by the bounding box.\\n     * @return {Box3} A \
reference to this bounding box.\\n     */\\n    expandByPoint(point) {\\n     \
 this.min.min(point);\\n      this.max.max(point);\\n      return this;\\n    \
}\\n    /**\\n     * Expands this box equilaterally by the given vector. The \
width of this\\n     * box will be expanded by the x component of the vector \
in both\\n     * directions. The height of this box will be expanded by the y \
component of\\n     * the vector in both directions. The depth of this box \
will be\\n     * expanded by the z component of the vector in both \
directions.\\n     *\\n     * @param {Vector3} vector - The vector that \
should expand the bounding box.\\n     * @return {Box3} A reference to this \
bounding box.\\n     */\\n    expandByVector(vector) {\\n      \
this.min.sub(vector);\\n      this.max.add(vector);\\n      return this;\\n   \
 }\\n    /**\\n     * Expands each dimension of the box by the given scalar. \
If negative, the\\n     * dimensions of the box will be contracted.\\n     \
*\\n     * @param {number} scalar - The scalar value that should expand the \
bounding box.\\n     * @return {Box3} A reference to this bounding box.\\n    \
 */\\n    expandByScalar(scalar) {\\n      this.min.addScalar(-scalar);\\n    \
  this.max.addScalar(scalar);\\n      return this;\\n    }\\n    /**\\n     * \
Expands the boundaries of this box to include the given 3D object and\\n     \
* its children, accounting for the object\\'s, and children\\'s, world\\n     \
* transforms. The function may result in a larger box than strictly\\n     * \
necessary (unless the precise parameter is set to true).\\n     *\\n     * \
@param {Object3D} object - The 3D object that should expand the bounding \
box.\\n     * @param {boolean} precise - If set to `true`, the method expands \
the bounding box\\n     * as little as necessary at the expense of more \
computation.\\n     * @return {Box3} A reference to this bounding box.\\n     \
*/\\n    expandByObject(object, precise = false) {\\n      \
object.updateWorldMatrix(false, false);\\n      const geometry = \
object.geometry;\\n      if (geometry !== void 0) {\\n        const \
positionAttribute = geometry.getAttribute(\"position\");\\n        if \
(precise === true && positionAttribute !== void 0 && object.isInstancedMesh \
!== true) {\\n          for (let i2 = 0, l = positionAttribute.count; i2 < l; \
i2++) {\\n            if (object.isMesh === true) {\\n              \
object.getVertexPosition(i2, _vector$b);\\n            } else {\\n            \
  _vector$b.fromBufferAttribute(positionAttribute, i2);\\n            }\\n    \
        _vector$b.applyMatrix4(object.matrixWorld);\\n            \
this.expandByPoint(_vector$b);\\n          }\\n        } else {\\n          \
if (object.boundingBox !== void 0) {\\n            if (object.boundingBox === \
null) {\\n              object.computeBoundingBox();\\n            }\\n       \
     _box$4.copy(object.boundingBox);\\n          } else {\\n            if \
(geometry.boundingBox === null) {\\n              \
geometry.computeBoundingBox();\\n            }\\n            \
_box$4.copy(geometry.boundingBox);\\n          }\\n          \
_box$4.applyMatrix4(object.matrixWorld);\\n          this.union(_box$4);\\n   \
     }\\n      }\\n      const children = object.children;\\n      for (let \
i2 = 0, l = children.length; i2 < l; i2++) {\\n        \
this.expandByObject(children[i2], precise);\\n      }\\n      return this;\\n \
   }\\n    /**\\n     * Returns `true` if the given point lies within or on \
the boundaries of this box.\\n     *\\n     * @param {Vector3} point - The \
point to test.\\n     * @return {boolean} Whether the bounding box contains \
the given point or not.\\n     */\\n    containsPoint(point) {\\n      return \
point.x >= this.min.x && point.x <= this.max.x && point.y >= this.min.y && \
point.y <= this.max.y && point.z >= this.min.z && point.z <= this.max.z;\\n   \
 }\\n    /**\\n     * Returns `true` if this bounding box includes the \
entirety of the given bounding box.\\n     * If this box and the given one \
are identical, this function also returns `true`.\\n     *\\n     * @param \
{Box3} box - The bounding box to test.\\n     * @return {boolean} Whether the \
bounding box contains the given bounding box or not.\\n     */\\n    \
containsBox(box) {\\n      return this.min.x <= box.min.x && box.max.x <= \
this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && \
this.min.z <= box.min.z && box.max.z <= this.max.z;\\n    }\\n    /**\\n     \
* Returns a point as a proportion of this box\\'s width, height and depth.\\n \
    *\\n     * @param {Vector3} point - A point in 3D space.\\n     * @param \
{Vector3} target - The target vector that is used to store the method\\'s \
result.\\n     * @return {Vector3} A point as a proportion of this box\\'s \
width, height and depth.\\n     */\\n    getParameter(point, target) {\\n     \
 return target.set(\\n        (point.x - this.min.x) / (this.max.x - \
this.min.x),\\n        (point.y - this.min.y) / (this.max.y - this.min.y),\\n \
       (point.z - this.min.z) / (this.max.z - this.min.z)\\n      );\\n    \
}\\n    /**\\n     * Returns `true` if the given bounding box intersects with \
this bounding box.\\n     *\\n     * @param {Box3} box - The bounding box to \
test.\\n     * @return {boolean} Whether the given bounding box intersects \
with this bounding box.\\n     */\\n    intersectsBox(box) {\\n      return \
box.max.x >= this.min.x && box.min.x <= this.max.x && box.max.y >= this.min.y \
&& box.min.y <= this.max.y && box.max.z >= this.min.z && box.min.z <= \
this.max.z;\\n    }\\n    /**\\n     * Returns `true` if the given bounding \
sphere intersects with this bounding box.\\n     *\\n     * @param {Sphere} \
sphere - The bounding sphere to test.\\n     * @return {boolean} Whether the \
given bounding sphere intersects with this bounding box.\\n     */\\n    \
intersectsSphere(sphere) {\\n      this.clampPoint(sphere.center, \
_vector$b);\\n      return _vector$b.distanceToSquared(sphere.center) <= \
sphere.radius * sphere.radius;\\n    }\\n    /**\\n     * Returns `true` if \
the given plane intersects with this bounding box.\\n     *\\n     * @param \
{Plane} plane - The plane to test.\\n     * @return {boolean} Whether the \
given plane intersects with this bounding box.\\n     */\\n    \
intersectsPlane(plane) {\\n      let min, max2;\\n      if (plane.normal.x > \
0) {\\n        min = plane.normal.x * this.min.x;\\n        max2 = \
plane.normal.x * this.max.x;\\n      } else {\\n        min = plane.normal.x \
* this.max.x;\\n        max2 = plane.normal.x * this.min.x;\\n      }\\n      \
if (plane.normal.y > 0) {\\n        min += plane.normal.y * this.min.y;\\n    \
    max2 += plane.normal.y * this.max.y;\\n      } else {\\n        min += \
plane.normal.y * this.max.y;\\n        max2 += plane.normal.y * \
this.min.y;\\n      }\\n      if (plane.normal.z > 0) {\\n        min += \
plane.normal.z * this.min.z;\\n        max2 += plane.normal.z * \
this.max.z;\\n      } else {\\n        min += plane.normal.z * this.max.z;\\n \
       max2 += plane.normal.z * this.min.z;\\n      }\\n      return min <= \
-plane.constant && max2 >= -plane.constant;\\n    }\\n    /**\\n     * \
Returns `true` if the given triangle intersects with this bounding box.\\n    \
 *\\n     * @param {Triangle} triangle - The triangle to test.\\n     * \
@return {boolean} Whether the given triangle intersects with this bounding \
box.\\n     */\\n    intersectsTriangle(triangle) {\\n      if \
(this.isEmpty()) {\\n        return false;\\n      }\\n      \
this.getCenter(_center);\\n      _extents.subVectors(this.max, _center);\\n   \
   _v0$2.subVectors(triangle.a, _center);\\n      \
_v1$7.subVectors(triangle.b, _center);\\n      _v2$4.subVectors(triangle.c, \
_center);\\n      _f0.subVectors(_v1$7, _v0$2);\\n      _f1.subVectors(_v2$4, \
_v1$7);\\n      _f2.subVectors(_v0$2, _v2$4);\\n      let axes = [\\n        \
0,\\n        -_f0.z,\\n        _f0.y,\\n        0,\\n        -_f1.z,\\n       \
 _f1.y,\\n        0,\\n        -_f2.z,\\n        _f2.y,\\n        _f0.z,\\n   \
     0,\\n        -_f0.x,\\n        _f1.z,\\n        0,\\n        -_f1.x,\\n  \
      _f2.z,\\n        0,\\n        -_f2.x,\\n        -_f0.y,\\n        \
_f0.x,\\n        0,\\n        -_f1.y,\\n        _f1.x,\\n        0,\\n        \
-_f2.y,\\n        _f2.x,\\n        0\\n      ];\\n      if (!satForAxes(axes, \
_v0$2, _v1$7, _v2$4, _extents)) {\\n        return false;\\n      }\\n      \
axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];\\n      if (!satForAxes(axes, _v0$2, \
_v1$7, _v2$4, _extents)) {\\n        return false;\\n      }\\n      \
_triangleNormal.crossVectors(_f0, _f1);\\n      axes = [_triangleNormal.x, \
_triangleNormal.y, _triangleNormal.z];\\n      return satForAxes(axes, _v0$2, \
_v1$7, _v2$4, _extents);\\n    }\\n    /**\\n     * Clamps the given point \
within the bounds of this box.\\n     *\\n     * @param {Vector3} point - The \
point to clamp.\\n     * @param {Vector3} target - The target vector that is \
used to store the method\\'s result.\\n     * @return {Vector3} The clamped \
point.\\n     */\\n    clampPoint(point, target) {\\n      return \
target.copy(point).clamp(this.min, this.max);\\n    }\\n    /**\\n     * \
Returns the euclidean distance from any edge of this box to the specified \
point. If\\n     * the given point lies inside of this box, the distance will \
be `0`.\\n     *\\n     * @param {Vector3} point - The point to compute the \
distance to.\\n     * @return {number} The euclidean distance.\\n     */\\n   \
 distanceToPoint(point) {\\n      return this.clampPoint(point, \
_vector$b).distanceTo(point);\\n    }\\n    /**\\n     * Returns a bounding \
sphere that encloses this bounding box.\\n     *\\n     * @param {Sphere} \
target - The target sphere that is used to store the method\\'s result.\\n    \
 * @return {Sphere} The bounding sphere that encloses this bounding box.\\n   \
  */\\n    getBoundingSphere(target) {\\n      if (this.isEmpty()) {\\n       \
 target.makeEmpty();\\n      } else {\\n        \
this.getCenter(target.center);\\n        target.radius = \
this.getSize(_vector$b).length() * 0.5;\\n      }\\n      return target;\\n   \
 }\\n    /**\\n     * Computes the intersection of this bounding box and the \
given one, setting the upper\\n     * bound of this box to the lesser of the \
two boxes\\' upper bounds and the\\n     * lower bound of this box to the \
greater of the two boxes\\' lower bounds. If\\n     * there\\'s no overlap, \
makes this box empty.\\n     *\\n     * @param {Box3} box - The bounding box \
to intersect with.\\n     * @return {Box3} A reference to this bounding \
box.\\n     */\\n    intersect(box) {\\n      this.min.max(box.min);\\n      \
this.max.min(box.max);\\n      if (this.isEmpty()) this.makeEmpty();\\n      \
return this;\\n    }\\n    /**\\n     * Computes the union of this box and \
another and the given one, setting the upper\\n     * bound of this box to \
the greater of the two boxes\\' upper bounds and the\\n     * lower bound of \
this box to the lesser of the two boxes\\' lower bounds.\\n     *\\n     * \
@param {Box3} box - The bounding box that will be unioned with this \
instance.\\n     * @return {Box3} A reference to this bounding box.\\n     \
*/\\n    union(box) {\\n      this.min.min(box.min);\\n      \
this.max.max(box.max);\\n      return this;\\n    }\\n    /**\\n     * \
Transforms this bounding box by the given 4x4 transformation matrix.\\n     \
*\\n     * @param {Matrix4} matrix - The transformation matrix.\\n     * \
@return {Box3} A reference to this bounding box.\\n     */\\n    \
applyMatrix4(matrix) {\\n      if (this.isEmpty()) return this;\\n      \
_points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);\\n   \
   _points[1].set(this.min.x, this.min.y, \
this.max.z).applyMatrix4(matrix);\\n      _points[2].set(this.min.x, \
this.max.y, this.min.z).applyMatrix4(matrix);\\n      \
_points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);\\n   \
   _points[4].set(this.max.x, this.min.y, \
this.min.z).applyMatrix4(matrix);\\n      _points[5].set(this.max.x, \
this.min.y, this.max.z).applyMatrix4(matrix);\\n      \
_points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);\\n   \
   _points[7].set(this.max.x, this.max.y, \
this.max.z).applyMatrix4(matrix);\\n      this.setFromPoints(_points);\\n     \
 return this;\\n    }\\n    /**\\n     * Adds the given offset to both the \
upper and lower bounds of this bounding box,\\n     * effectively moving it \
in 3D space.\\n     *\\n     * @param {Vector3} offset - The offset that \
should be used to translate the bounding box.\\n     * @return {Box3} A \
reference to this bounding box.\\n     */\\n    translate(offset) {\\n      \
this.min.add(offset);\\n      this.max.add(offset);\\n      return this;\\n   \
 }\\n    /**\\n     * Returns `true` if this bounding box is equal with the \
given one.\\n     *\\n     * @param {Box3} box - The box to test for \
equality.\\n     * @return {boolean} Whether this bounding box is equal with \
the given one.\\n     */\\n    equals(box) {\\n      return \
box.min.equals(this.min) && box.max.equals(this.max);\\n    }\\n    /**\\n    \
 * Returns a serialized structure of the bounding box.\\n     *\\n     * \
@return {Object} Serialized structure with fields representing the object \
state.\\n     */\\n    toJSON() {\\n      return {\\n        min: \
this.min.toArray(),\\n        max: this.max.toArray()\\n      };\\n    }\\n   \
 /**\\n     * Returns a serialized structure of the bounding box.\\n     *\\n \
    * @param {Object} json - The serialized json to set the box from.\\n     \
* @return {Box3} A reference to this bounding box.\\n     */\\n    \
fromJSON(json) {\\n      this.min.fromArray(json.min);\\n      \
this.max.fromArray(json.max);\\n      return this;\\n    }\\n  }\\n  const \
_points = [\\n    /* @__PURE__ */ new Vector3(),\\n    /* @__PURE__ */ new \
Vector3(),\\n    /* @__PURE__ */ new Vector3(),\\n    /* @__PURE__ */ new \
Vector3(),\\n    /* @__PURE__ */ new Vector3(),\\n    /* @__PURE__ */ new \
Vector3(),\\n    /* @__PURE__ */ new Vector3(),\\n    /* @__PURE__ */ new \
Vector3()\\n  ];\\n  const _vector$b = /* @__PURE__ */ new Vector3();\\n  \
const _box$4 = /* @__PURE__ */ new Box3();\\n  const _v0$2 = /* @__PURE__ */ \
new Vector3();\\n  const _v1$7 = /* @__PURE__ */ new Vector3();\\n  const \
_v2$4 = /* @__PURE__ */ new Vector3();\\n  const _f0 = /* @__PURE__ */ new \
Vector3();\\n  const _f1 = /* @__PURE__ */ new Vector3();\\n  const _f2 = /* \
@__PURE__ */ new Vector3();\\n  const _center = /* @__PURE__ */ new \
Vector3();\\n  const _extents = /* @__PURE__ */ new Vector3();\\n  const \
_triangleNormal = /* @__PURE__ */ new Vector3();\\n  const _testAxis = /* \
@__PURE__ */ new Vector3();\\n  function satForAxes(axes, v0, v1, v2, \
extents) {\\n    for (let i2 = 0, j = axes.length - 3; i2 <= j; i2 += 3) {\\n \
     _testAxis.fromArray(axes, i2);\\n      const r = extents.x * \
Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * \
Math.abs(_testAxis.z);\\n      const p0 = v0.dot(_testAxis);\\n      const p1 \
= v1.dot(_testAxis);\\n      const p2 = v2.dot(_testAxis);\\n      if \
(Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {\\n        \
return false;\\n      }\\n    }\\n    return true;\\n  }\\n  const \
_colorKeywords = {\\n    \"aliceblue\": 15792383,\\n    \"antiquewhite\": \
16444375,\\n    \"aqua\": 65535,\\n    \"aquamarine\": 8388564,\\n    \
\"azure\": 15794175,\\n    \"beige\": 16119260,\\n    \"bisque\": \
16770244,\\n    \"black\": 0,\\n    \"blanchedalmond\": 16772045,\\n    \
\"blue\": 255,\\n    \"blueviolet\": 9055202,\\n    \"brown\": 10824234,\\n   \
 \"burlywood\": 14596231,\\n    \"cadetblue\": 6266528,\\n    \"chartreuse\": \
8388352,\\n    \"chocolate\": 13789470,\\n    \"coral\": 16744272,\\n    \
\"cornflowerblue\": 6591981,\\n    \"cornsilk\": 16775388,\\n    \"crimson\": \
14423100,\\n    \"cyan\": 65535,\\n    \"darkblue\": 139,\\n    \"darkcyan\": \
35723,\\n    \"darkgoldenrod\": 12092939,\\n    \"darkgray\": 11119017,\\n    \
\"darkgreen\": 25600,\\n    \"darkgrey\": 11119017,\\n    \"darkkhaki\": \
12433259,\\n    \"darkmagenta\": 9109643,\\n    \"darkolivegreen\": \
5597999,\\n    \"darkorange\": 16747520,\\n    \"darkorchid\": 10040012,\\n   \
 \"darkred\": 9109504,\\n    \"darksalmon\": 15308410,\\n    \
\"darkseagreen\": 9419919,\\n    \"darkslateblue\": 4734347,\\n    \
\"darkslategray\": 3100495,\\n    \"darkslategrey\": 3100495,\\n    \
\"darkturquoise\": 52945,\\n    \"darkviolet\": 9699539,\\n    \"deeppink\": \
16716947,\\n    \"deepskyblue\": 49151,\\n    \"dimgray\": 6908265,\\n    \
\"dimgrey\": 6908265,\\n    \"dodgerblue\": 2003199,\\n    \"firebrick\": \
11674146,\\n    \"floralwhite\": 16775920,\\n    \"forestgreen\": 2263842,\\n \
   \"fuchsia\": 16711935,\\n    \"gainsboro\": 14474460,\\n    \
\"ghostwhite\": 16316671,\\n    \"gold\": 16766720,\\n    \"goldenrod\": \
14329120,\\n    \"gray\": 8421504,\\n    \"green\": 32768,\\n    \
\"greenyellow\": 11403055,\\n    \"grey\": 8421504,\\n    \"honeydew\": \
15794160,\\n    \"hotpink\": 16738740,\\n    \"indianred\": 13458524,\\n    \
\"indigo\": 4915330,\\n    \"ivory\": 16777200,\\n    \"khaki\": 15787660,\\n \
   \"lavender\": 15132410,\\n    \"lavenderblush\": 16773365,\\n    \
\"lawngreen\": 8190976,\\n    \"lemonchiffon\": 16775885,\\n    \
\"lightblue\": 11393254,\\n    \"lightcoral\": 15761536,\\n    \"lightcyan\": \
14745599,\\n    \"lightgoldenrodyellow\": 16448210,\\n    \"lightgray\": \
13882323,\\n    \"lightgreen\": 9498256,\\n    \"lightgrey\": 13882323,\\n    \
\"lightpink\": 16758465,\\n    \"lightsalmon\": 16752762,\\n    \
\"lightseagreen\": 2142890,\\n    \"lightskyblue\": 8900346,\\n    \
\"lightslategray\": 7833753,\\n    \"lightslategrey\": 7833753,\\n    \
\"lightsteelblue\": 11584734,\\n    \"lightyellow\": 16777184,\\n    \
\"lime\": 65280,\\n    \"limegreen\": 3329330,\\n    \"linen\": 16445670,\\n  \
  \"magenta\": 16711935,\\n    \"maroon\": 8388608,\\n    \
\"mediumaquamarine\": 6737322,\\n    \"mediumblue\": 205,\\n    \
\"mediumorchid\": 12211667,\\n    \"mediumpurple\": 9662683,\\n    \
\"mediumseagreen\": 3978097,\\n    \"mediumslateblue\": 8087790,\\n    \
\"mediumspringgreen\": 64154,\\n    \"mediumturquoise\": 4772300,\\n    \
\"mediumvioletred\": 13047173,\\n    \"midnightblue\": 1644912,\\n    \
\"mintcream\": 16121850,\\n    \"mistyrose\": 16770273,\\n    \"moccasin\": \
16770229,\\n    \"navajowhite\": 16768685,\\n    \"navy\": 128,\\n    \
\"oldlace\": 16643558,\\n    \"olive\": 8421376,\\n    \"olivedrab\": \
7048739,\\n    \"orange\": 16753920,\\n    \"orangered\": 16729344,\\n    \
\"orchid\": 14315734,\\n    \"palegoldenrod\": 15657130,\\n    \"palegreen\": \
10025880,\\n    \"paleturquoise\": 11529966,\\n    \"palevioletred\": \
14381203,\\n    \"papayawhip\": 16773077,\\n    \"peachpuff\": 16767673,\\n   \
 \"peru\": 13468991,\\n    \"pink\": 16761035,\\n    \"plum\": 14524637,\\n   \
 \"powderblue\": 11591910,\\n    \"purple\": 8388736,\\n    \
\"rebeccapurple\": 6697881,\\n    \"red\": 16711680,\\n    \"rosybrown\": \
12357519,\\n    \"royalblue\": 4286945,\\n    \"saddlebrown\": 9127187,\\n    \
\"salmon\": 16416882,\\n    \"sandybrown\": 16032864,\\n    \"seagreen\": \
3050327,\\n    \"seashell\": 16774638,\\n    \"sienna\": 10506797,\\n    \
\"silver\": 12632256,\\n    \"skyblue\": 8900331,\\n    \"slateblue\": \
6970061,\\n    \"slategray\": 7372944,\\n    \"slategrey\": 7372944,\\n    \
\"snow\": 16775930,\\n    \"springgreen\": 65407,\\n    \"steelblue\": \
4620980,\\n    \"tan\": 13808780,\\n    \"teal\": 32896,\\n    \"thistle\": \
14204888,\\n    \"tomato\": 16737095,\\n    \"turquoise\": 4251856,\\n    \
\"violet\": 15631086,\\n    \"wheat\": 16113331,\\n    \"white\": \
16777215,\\n    \"whitesmoke\": 16119285,\\n    \"yellow\": 16776960,\\n    \
\"yellowgreen\": 10145074\\n  };\\n  const _hslA = { h: 0, s: 0, l: 0 };\\n  \
const _hslB = { h: 0, s: 0, l: 0 };\\n  function hue2rgb(p, q, t) {\\n    if \
(t < 0) t += 1;\\n    if (t > 1) t -= 1;\\n    if (t < 1 / 6) return p + (q - \
p) * 6 * t;\\n    if (t < 1 / 2) return q;\\n    if (t < 2 / 3) return p + (q \
- p) * 6 * (2 / 3 - t);\\n    return p;\\n  }\\n  class Color {\\n    /**\\n  \
   * Constructs a new color.\\n     *\\n     * Note that standard method of \
specifying color in three.js is with a hexadecimal triplet,\\n     * and that \
method is used throughout the rest of the documentation.\\n     *\\n     * \
@param {(number|string|Color)} [r] - The red component of the color. If `g` \
and `b` are\\n     * not provided, it can be hexadecimal triplet, a CSS-style \
string or another `Color` instance.\\n     * @param {number} [g] - The green \
component.\\n     * @param {number} [b] - The blue component.\\n     */\\n    \
constructor(r, g, b) {\\n      this.isColor = true;\\n      this.r = 1;\\n    \
  this.g = 1;\\n      this.b = 1;\\n      return this.set(r, g, b);\\n    \
}\\n    /**\\n     * Sets the colors\\'s components from the given values.\\n \
    *\\n     * @param {(number|string|Color)} [r] - The red component of the \
color. If `g` and `b` are\\n     * not provided, it can be hexadecimal \
triplet, a CSS-style string or another `Color` instance.\\n     * @param \
{number} [g] - The green component.\\n     * @param {number} [b] - The blue \
component.\\n     * @return {Color} A reference to this color.\\n     */\\n   \
 set(r, g, b) {\\n      if (g === void 0 && b === void 0) {\\n        const \
value = r;\\n        if (value && value.isColor) {\\n          \
this.copy(value);\\n        } else if (typeof value === \"number\") {\\n      \
    this.setHex(value);\\n        } else if (typeof value === \"string\") \
{\\n          this.setStyle(value);\\n        }\\n      } else {\\n        \
this.setRGB(r, g, b);\\n      }\\n      return this;\\n    }\\n    /**\\n     \
* Sets the colors\\'s components to the given scalar value.\\n     *\\n     * \
@param {number} scalar - The scalar value.\\n     * @return {Color} A \
reference to this color.\\n     */\\n    setScalar(scalar) {\\n      this.r = \
scalar;\\n      this.g = scalar;\\n      this.b = scalar;\\n      return \
this;\\n    }\\n    /**\\n     * Sets this color from a hexadecimal value.\\n \
    *\\n     * @param {number} hex - The hexadecimal value.\\n     * @param \
{string} [colorSpace=SRGBColorSpace] - The color space.\\n     * @return \
{Color} A reference to this color.\\n     */\\n    setHex(hex, colorSpace = \
SRGBColorSpace) {\\n      hex = Math.floor(hex);\\n      this.r = (hex >> 16 \
& 255) / 255;\\n      this.g = (hex >> 8 & 255) / 255;\\n      this.b = (hex \
& 255) / 255;\\n      ColorManagement.colorSpaceToWorking(this, \
colorSpace);\\n      return this;\\n    }\\n    /**\\n     * Sets this color \
from RGB values.\\n     *\\n     * @param {number} r - Red channel value \
between `0.0` and `1.0`.\\n     * @param {number} g - Green channel value \
between `0.0` and `1.0`.\\n     * @param {number} b - Blue channel value \
between `0.0` and `1.0`.\\n     * @param {string} \
[colorSpace=ColorManagement.workingColorSpace] - The color space.\\n     * \
@return {Color} A reference to this color.\\n     */\\n    setRGB(r, g, b, \
colorSpace = ColorManagement.workingColorSpace) {\\n      this.r = r;\\n      \
this.g = g;\\n      this.b = b;\\n      \
ColorManagement.colorSpaceToWorking(this, colorSpace);\\n      return \
this;\\n    }\\n    /**\\n     * Sets this color from RGB values.\\n     *\\n \
    * @param {number} h - Hue value between `0.0` and `1.0`.\\n     * @param \
{number} s - Saturation value between `0.0` and `1.0`.\\n     * @param \
{number} l - Lightness value between `0.0` and `1.0`.\\n     * @param \
{string} [colorSpace=ColorManagement.workingColorSpace] - The color space.\\n \
    * @return {Color} A reference to this color.\\n     */\\n    setHSL(h, s, \
l, colorSpace = ColorManagement.workingColorSpace) {\\n      h = \
euclideanModulo(h, 1);\\n      s = clamp(s, 0, 1);\\n      l = clamp(l, 0, \
1);\\n      if (s === 0) {\\n        this.r = this.g = this.b = l;\\n      } \
else {\\n        const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;\\n        \
const q = 2 * l - p;\\n        this.r = hue2rgb(q, p, h + 1 / 3);\\n        \
this.g = hue2rgb(q, p, h);\\n        this.b = hue2rgb(q, p, h - 1 / 3);\\n    \
  }\\n      ColorManagement.colorSpaceToWorking(this, colorSpace);\\n      \
return this;\\n    }\\n    /**\\n     * Sets this color from a CSS-style \
string. For example, `rgb(250, 0,0)`,\\n     * `rgb(100%, 0%, 0%)`, `hsl(0, \
100%, 50%)`, `#ff0000`, `#f00`, or `red` ( or\\n     * any [X11 color \
name]{@link https://en.wikipedia.org/wiki/X11_color_names#Color_name_chart} \
-\\n     * all 140 color names are supported).\\n     *\\n     * @param \
{string} style - Color as a CSS-style string.\\n     * @param {string} \
[colorSpace=SRGBColorSpace] - The color space.\\n     * @return {Color} A \
reference to this color.\\n     */\\n    setStyle(style, colorSpace = \
SRGBColorSpace) {\\n      function handleAlpha(string) {\\n        if (string \
=== void 0) return;\\n        if (parseFloat(string) < 1) {\\n          \
console.warn(\"THREE.Color: Alpha component of \" + style + \" will be \
ignored.\");\\n        }\\n      }\\n      let m;\\n      if (m = \
/^(\\\\w+)\\\\(([^\\\\)]*)\\\\)/.exec(style)) {\\n        let color;\\n       \
 const name = m[1];\\n        const components = m[2];\\n        switch \
(name) {\\n          case \"rgb\":\\n          case \"rgba\":\\n            \
if (color = \
/^\\\\s*(\\\\d+)\\\\s*,\\\\s*(\\\\d+)\\\\s*,\\\\s*(\\\\d+)\\\\s*(?:,\\\\s*(\\\
\\d*\\\\.?\\\\d+)\\\\s*)?$/.exec(components)) {\\n              \
handleAlpha(color[4]);\\n              return this.setRGB(\\n                \
Math.min(255, parseInt(color[1], 10)) / 255,\\n                Math.min(255, \
parseInt(color[2], 10)) / 255,\\n                Math.min(255, \
parseInt(color[3], 10)) / 255,\\n                colorSpace\\n              \
);\\n            }\\n            if (color = \
/^\\\\s*(\\\\d+)\\\\%\\\\s*,\\\\s*(\\\\d+)\\\\%\\\\s*,\\\\s*(\\\\d+)\\\\%\\\\\
s*(?:,\\\\s*(\\\\d*\\\\.?\\\\d+)\\\\s*)?$/.exec(components)) {\\n             \
 handleAlpha(color[4]);\\n              return this.setRGB(\\n                \
Math.min(100, parseInt(color[1], 10)) / 100,\\n                Math.min(100, \
parseInt(color[2], 10)) / 100,\\n                Math.min(100, \
parseInt(color[3], 10)) / 100,\\n                colorSpace\\n              \
);\\n            }\\n            break;\\n          case \"hsl\":\\n          \
case \"hsla\":\\n            if (color = \
/^\\\\s*(\\\\d*\\\\.?\\\\d+)\\\\s*,\\\\s*(\\\\d*\\\\.?\\\\d+)\\\\%\\\\s*,\\\\\
s*(\\\\d*\\\\.?\\\\d+)\\\\%\\\\s*(?:,\\\\s*(\\\\d*\\\\.?\\\\d+)\\\\s*)?$/.exe\
c(components)) {\\n              handleAlpha(color[4]);\\n              \
return this.setHSL(\\n                parseFloat(color[1]) / 360,\\n          \
      parseFloat(color[2]) / 100,\\n                parseFloat(color[3]) / \
100,\\n                colorSpace\\n              );\\n            }\\n       \
     break;\\n          default:\\n            console.warn(\"THREE.Color: \
Unknown color model \" + style);\\n        }\\n      } else if (m = \
/^\\\\#([A-Fa-f\\\\d]+)$/.exec(style)) {\\n        const hex = m[1];\\n       \
 const size = hex.length;\\n        if (size === 3) {\\n          return \
this.setRGB(\\n            parseInt(hex.charAt(0), 16) / 15,\\n            \
parseInt(hex.charAt(1), 16) / 15,\\n            parseInt(hex.charAt(2), 16) / \
15,\\n            colorSpace\\n          );\\n        } else if (size === 6) \
{\\n          return this.setHex(parseInt(hex, 16), colorSpace);\\n        } \
else {\\n          console.warn(\"THREE.Color: Invalid hex color \" + \
style);\\n        }\\n      } else if (style && style.length > 0) {\\n        \
return this.setColorName(style, colorSpace);\\n      }\\n      return \
this;\\n    }\\n    /**\\n     * Sets this color from a color name. Faster \
than {@link Color#setStyle} if\\n     * you don\\'t need the other CSS-style \
formats.\\n     *\\n     * For convenience, the list of names is exposed in \
`Color.NAMES` as a hash.\\n     * ```js\\n     * Color.NAMES.aliceblue // \
returns 0xF0F8FF\\n     * ```\\n     *\\n     * @param {string} style - The \
color name.\\n     * @param {string} [colorSpace=SRGBColorSpace] - The color \
space.\\n     * @return {Color} A reference to this color.\\n     */\\n    \
setColorName(style, colorSpace = SRGBColorSpace) {\\n      const hex = \
_colorKeywords[style.toLowerCase()];\\n      if (hex !== void 0) {\\n        \
this.setHex(hex, colorSpace);\\n      } else {\\n        \
console.warn(\"THREE.Color: Unknown color \" + style);\\n      }\\n      \
return this;\\n    }\\n    /**\\n     * Returns a new color with copied \
values from this instance.\\n     *\\n     * @return {Color} A clone of this \
instance.\\n     */\\n    clone() {\\n      return new \
this.constructor(this.r, this.g, this.b);\\n    }\\n    /**\\n     * Copies \
the values of the given color to this instance.\\n     *\\n     * @param \
{Color} color - The color to copy.\\n     * @return {Color} A reference to \
this color.\\n     */\\n    copy(color) {\\n      this.r = color.r;\\n      \
this.g = color.g;\\n      this.b = color.b;\\n      return this;\\n    }\\n   \
 /**\\n     * Copies the given color into this color, and then converts this \
color from\\n     * `SRGBColorSpace` to `LinearSRGBColorSpace`.\\n     *\\n   \
  * @param {Color} color - The color to copy/convert.\\n     * @return \
{Color} A reference to this color.\\n     */\\n    copySRGBToLinear(color) \
{\\n      this.r = SRGBToLinear(color.r);\\n      this.g = \
SRGBToLinear(color.g);\\n      this.b = SRGBToLinear(color.b);\\n      return \
this;\\n    }\\n    /**\\n     * Copies the given color into this color, and \
then converts this color from\\n     * `LinearSRGBColorSpace` to \
`SRGBColorSpace`.\\n     *\\n     * @param {Color} color - The color to \
copy/convert.\\n     * @return {Color} A reference to this color.\\n     \
*/\\n    copyLinearToSRGB(color) {\\n      this.r = LinearToSRGB(color.r);\\n \
     this.g = LinearToSRGB(color.g);\\n      this.b = \
LinearToSRGB(color.b);\\n      return this;\\n    }\\n    /**\\n     * \
Converts this color from `SRGBColorSpace` to `LinearSRGBColorSpace`.\\n     \
*\\n     * @return {Color} A reference to this color.\\n     */\\n    \
convertSRGBToLinear() {\\n      this.copySRGBToLinear(this);\\n      return \
this;\\n    }\\n    /**\\n     * Converts this color from \
`LinearSRGBColorSpace` to `SRGBColorSpace`.\\n     *\\n     * @return {Color} \
A reference to this color.\\n     */\\n    convertLinearToSRGB() {\\n      \
this.copyLinearToSRGB(this);\\n      return this;\\n    }\\n    /**\\n     * \
Returns the hexadecimal value of this color.\\n     *\\n     * @param \
{string} [colorSpace=SRGBColorSpace] - The color space.\\n     * @return \
{number} The hexadecimal value.\\n     */\\n    getHex(colorSpace = \
SRGBColorSpace) {\\n      \
ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);\\n      \
return Math.round(clamp(_color.r * 255, 0, 255)) * 65536 + \
Math.round(clamp(_color.g * 255, 0, 255)) * 256 + Math.round(clamp(_color.b * \
255, 0, 255));\\n    }\\n    /**\\n     * Returns the hexadecimal value of \
this color as a string (for example, \\'FFFFFF\\').\\n     *\\n     * @param \
{string} [colorSpace=SRGBColorSpace] - The color space.\\n     * @return \
{string} The hexadecimal value as a string.\\n     */\\n    \
getHexString(colorSpace = SRGBColorSpace) {\\n      return (\"000000\" + \
this.getHex(colorSpace).toString(16)).slice(-6);\\n    }\\n    /**\\n     * \
Converts the colors RGB values into the HSL format and stores them into \
the\\n     * given target object.\\n     *\\n     * @param \
{{h:number,s:number,l:number}} target - The target object that is used to \
store the method\\'s result.\\n     * @param {string} \
[colorSpace=ColorManagement.workingColorSpace] - The color space.\\n     * \
@return {{h:number,s:number,l:number}} The HSL representation of this \
color.\\n     */\\n    getHSL(target, colorSpace = \
ColorManagement.workingColorSpace) {\\n      \
ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);\\n      \
const r = _color.r, g = _color.g, b = _color.b;\\n      const max2 = \
Math.max(r, g, b);\\n      const min = Math.min(r, g, b);\\n      let hue, \
saturation;\\n      const lightness = (min + max2) / 2;\\n      if (min === \
max2) {\\n        hue = 0;\\n        saturation = 0;\\n      } else {\\n      \
  const delta = max2 - min;\\n        saturation = lightness <= 0.5 ? delta / \
(max2 + min) : delta / (2 - max2 - min);\\n        switch (max2) {\\n         \
 case r:\\n            hue = (g - b) / delta + (g < b ? 6 : 0);\\n            \
break;\\n          case g:\\n            hue = (b - r) / delta + 2;\\n        \
    break;\\n          case b:\\n            hue = (r - g) / delta + 4;\\n    \
        break;\\n        }\\n        hue /= 6;\\n      }\\n      target.h = \
hue;\\n      target.s = saturation;\\n      target.l = lightness;\\n      \
return target;\\n    }\\n    /**\\n     * Returns the RGB values of this \
color and stores them into the given target object.\\n     *\\n     * @param \
{Color} target - The target color that is used to store the method\\'s \
result.\\n     * @param {string} \
[colorSpace=ColorManagement.workingColorSpace] - The color space.\\n     * \
@return {Color} The RGB representation of this color.\\n     */\\n    \
getRGB(target, colorSpace = ColorManagement.workingColorSpace) {\\n      \
ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);\\n      \
target.r = _color.r;\\n      target.g = _color.g;\\n      target.b = \
_color.b;\\n      return target;\\n    }\\n    /**\\n     * Returns the value \
of this color as a CSS style string. Example: `rgb(255,0,0)`.\\n     *\\n     \
* @param {string} [colorSpace=SRGBColorSpace] - The color space.\\n     * \
@return {string} The CSS representation of this color.\\n     */\\n    \
getStyle(colorSpace = SRGBColorSpace) {\\n      \
ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);\\n      \
const r = _color.r, g = _color.g, b = _color.b;\\n      if (colorSpace !== \
SRGBColorSpace) {\\n        return `color(${colorSpace} ${r.toFixed(3)} \
${g.toFixed(3)} ${b.toFixed(3)})`;\\n      }\\n      return \
`rgb(${Math.round(r * 255)},${Math.round(g * 255)},${Math.round(b * \
255)})`;\\n    }\\n    /**\\n     * Adds the given HSL values to this \
color\\'s values.\\n     * Internally, this converts the color\\'s RGB values \
to HSL, adds HSL\\n     * and then converts the color back to RGB.\\n     \
*\\n     * @param {number} h - Hue value between `0.0` and `1.0`.\\n     * \
@param {number} s - Saturation value between `0.0` and `1.0`.\\n     * @param \
{number} l - Lightness value between `0.0` and `1.0`.\\n     * @return \
{Color} A reference to this color.\\n     */\\n    offsetHSL(h, s, l) {\\n    \
  this.getHSL(_hslA);\\n      return this.setHSL(_hslA.h + h, _hslA.s + s, \
_hslA.l + l);\\n    }\\n    /**\\n     * Adds the RGB values of the given \
color to the RGB values of this color.\\n     *\\n     * @param {Color} color \
- The color to add.\\n     * @return {Color} A reference to this color.\\n    \
 */\\n    add(color) {\\n      this.r += color.r;\\n      this.g += \
color.g;\\n      this.b += color.b;\\n      return this;\\n    }\\n    /**\\n \
    * Adds the RGB values of the given colors and stores the result in this \
instance.\\n     *\\n     * @param {Color} color1 - The first color.\\n     * \
@param {Color} color2 - The second color.\\n     * @return {Color} A \
reference to this color.\\n     */\\n    addColors(color1, color2) {\\n      \
this.r = color1.r + color2.r;\\n      this.g = color1.g + color2.g;\\n      \
this.b = color1.b + color2.b;\\n      return this;\\n    }\\n    /**\\n     * \
Adds the given scalar value to the RGB values of this color.\\n     *\\n     \
* @param {number} s - The scalar to add.\\n     * @return {Color} A reference \
to this color.\\n     */\\n    addScalar(s) {\\n      this.r += s;\\n      \
this.g += s;\\n      this.b += s;\\n      return this;\\n    }\\n    /**\\n   \
  * Subtracts the RGB values of the given color from the RGB values of this \
color.\\n     *\\n     * @param {Color} color - The color to subtract.\\n     \
* @return {Color} A reference to this color.\\n     */\\n    sub(color) {\\n  \
    this.r = Math.max(0, this.r - color.r);\\n      this.g = Math.max(0, \
this.g - color.g);\\n      this.b = Math.max(0, this.b - color.b);\\n      \
return this;\\n    }\\n    /**\\n     * Multiplies the RGB values of the \
given color with the RGB values of this color.\\n     *\\n     * @param \
{Color} color - The color to multiply.\\n     * @return {Color} A reference \
to this color.\\n     */\\n    multiply(color) {\\n      this.r *= \
color.r;\\n      this.g *= color.g;\\n      this.b *= color.b;\\n      return \
this;\\n    }\\n    /**\\n     * Multiplies the given scalar value with the \
RGB values of this color.\\n     *\\n     * @param {number} s - The scalar to \
multiply.\\n     * @return {Color} A reference to this color.\\n     */\\n    \
multiplyScalar(s) {\\n      this.r *= s;\\n      this.g *= s;\\n      this.b \
*= s;\\n      return this;\\n    }\\n    /**\\n     * Linearly interpolates \
this color\\'s RGB values toward the RGB values of the\\n     * given color. \
The alpha argument can be thought of as the ratio between\\n     * the two \
colors, where `0.0` is this color and `1.0` is the first argument.\\n     \
*\\n     * @param {Color} color - The color to converge on.\\n     * @param \
{number} alpha - The interpolation factor in the closed interval `[0,1]`.\\n  \
   * @return {Color} A reference to this color.\\n     */\\n    lerp(color, \
alpha) {\\n      this.r += (color.r - this.r) * alpha;\\n      this.g += \
(color.g - this.g) * alpha;\\n      this.b += (color.b - this.b) * alpha;\\n  \
    return this;\\n    }\\n    /**\\n     * Linearly interpolates between the \
given colors and stores the result in this instance.\\n     * The alpha \
argument can be thought of as the ratio between the two colors, where \
`0.0`\\n     * is the first and `1.0` is the second color.\\n     *\\n     * \
@param {Color} color1 - The first color.\\n     * @param {Color} color2 - The \
second color.\\n     * @param {number} alpha - The interpolation factor in \
the closed interval `[0,1]`.\\n     * @return {Color} A reference to this \
color.\\n     */\\n    lerpColors(color1, color2, alpha) {\\n      this.r = \
color1.r + (color2.r - color1.r) * alpha;\\n      this.g = color1.g + \
(color2.g - color1.g) * alpha;\\n      this.b = color1.b + (color2.b - \
color1.b) * alpha;\\n      return this;\\n    }\\n    /**\\n     * Linearly \
interpolates this color\\'s HSL values toward the HSL values of the\\n     * \
given color. It differs from {@link Color#lerp} by not interpolating \
straight\\n     * from one color to the other, but instead going through all \
the hues in between\\n     * those two colors. The alpha argument can be \
thought of as the ratio between\\n     * the two colors, where 0.0 is this \
color and 1.0 is the first argument.\\n     *\\n     * @param {Color} color - \
The color to converge on.\\n     * @param {number} alpha - The interpolation \
factor in the closed interval `[0,1]`.\\n     * @return {Color} A reference \
to this color.\\n     */\\n    lerpHSL(color, alpha) {\\n      \
this.getHSL(_hslA);\\n      color.getHSL(_hslB);\\n      const h = \
lerp(_hslA.h, _hslB.h, alpha);\\n      const s = lerp(_hslA.s, _hslB.s, \
alpha);\\n      const l = lerp(_hslA.l, _hslB.l, alpha);\\n      \
this.setHSL(h, s, l);\\n      return this;\\n    }\\n    /**\\n     * Sets \
the color\\'s RGB components from the given 3D vector.\\n     *\\n     * \
@param {Vector3} v - The vector to set.\\n     * @return {Color} A reference \
to this color.\\n     */\\n    setFromVector3(v) {\\n      this.r = v.x;\\n   \
   this.g = v.y;\\n      this.b = v.z;\\n      return this;\\n    }\\n    \
/**\\n     * Transforms this color with the given 3x3 matrix.\\n     *\\n     \
* @param {Matrix3} m - The matrix.\\n     * @return {Color} A reference to \
this color.\\n     */\\n    applyMatrix3(m) {\\n      const r = this.r, g = \
this.g, b = this.b;\\n      const e = m.elements;\\n      this.r = e[0] * r + \
e[3] * g + e[6] * b;\\n      this.g = e[1] * r + e[4] * g + e[7] * b;\\n      \
this.b = e[2] * r + e[5] * g + e[8] * b;\\n      return this;\\n    }\\n    \
/**\\n     * Returns `true` if this color is equal with the given one.\\n     \
*\\n     * @param {Color} c - The color to test for equality.\\n     * \
@return {boolean} Whether this bounding color is equal with the given one.\\n \
    */\\n    equals(c) {\\n      return c.r === this.r && c.g === this.g && \
c.b === this.b;\\n    }\\n    /**\\n     * Sets this color\\'s RGB components \
from the given array.\\n     *\\n     * @param {Array<number>} array - An \
array holding the RGB values.\\n     * @param {number} [offset=0] - The \
offset into the array.\\n     * @return {Color} A reference to this color.\\n \
    */\\n    fromArray(array, offset = 0) {\\n      this.r = \
array[offset];\\n      this.g = array[offset + 1];\\n      this.b = \
array[offset + 2];\\n      return this;\\n    }\\n    /**\\n     * Writes the \
RGB components of this color to the given array. If no array is provided,\\n  \
   * the method returns a new instance.\\n     *\\n     * @param \
{Array<number>} [array=[]] - The target array holding the color \
components.\\n     * @param {number} [offset=0] - Index of the first element \
in the array.\\n     * @return {Array<number>} The color components.\\n     \
*/\\n    toArray(array = [], offset = 0) {\\n      array[offset] = this.r;\\n \
     array[offset + 1] = this.g;\\n      array[offset + 2] = this.b;\\n      \
return array;\\n    }\\n    /**\\n     * Sets the components of this color \
from the given buffer attribute.\\n     *\\n     * @param {BufferAttribute} \
attribute - The buffer attribute holding color data.\\n     * @param {number} \
index - The index into the attribute.\\n     * @return {Color} A reference to \
this color.\\n     */\\n    fromBufferAttribute(attribute, index) {\\n      \
this.r = attribute.getX(index);\\n      this.g = attribute.getY(index);\\n    \
  this.b = attribute.getZ(index);\\n      return this;\\n    }\\n    /**\\n   \
  * This methods defines the serialization result of this class. Returns the \
color\\n     * as a hexadecimal value.\\n     *\\n     * @return {number} The \
hexadecimal value.\\n     */\\n    toJSON() {\\n      return \
this.getHex();\\n    }\\n    *[Symbol.iterator]() {\\n      yield this.r;\\n  \
    yield this.g;\\n      yield this.b;\\n    }\\n  }\\n  const _color = /* \
@__PURE__ */ new Color();\\n  Color.NAMES = _colorKeywords;\\n  if (typeof \
__THREE_DEVTOOLS__ !== \"undefined\") {\\n    \
__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent(\"register\", { detail: {\\n \
     revision: REVISION\\n    } }));\\n  }\\n  if (typeof window !== \
\"undefined\") {\\n    if (window.__THREE__) {\\n      \
console.warn(\"WARNING: Multiple instances of Three.js being imported.\");\\n \
   } else {\\n      window.__THREE__ = REVISION;\\n    }\\n  }\\n  const \
LN_SCALE_MIN = -12;\\n  const LN_SCALE_MAX = 9;\\n  const LN_SCALE_ZERO = \
-30;\\n  const SCALE_ZERO = Math.exp(LN_SCALE_ZERO);\\n  const \
SPLAT_TEX_WIDTH_BITS = 11;\\n  const SPLAT_TEX_HEIGHT_BITS = 11;\\n  const \
SPLAT_TEX_WIDTH = 1 << SPLAT_TEX_WIDTH_BITS;\\n  const SPLAT_TEX_HEIGHT = 1 \
<< SPLAT_TEX_HEIGHT_BITS;\\n  const SPLAT_TEX_MIN_HEIGHT = 1;\\n  function \
unindentLines(s) {\\n    var _a2;\\n    let seenNonEmpty = false;\\n    const \
lines = s.split(\"\\\\n\").map((line) => {\\n      const trimmedLine = \
line.trimEnd();\\n      if (seenNonEmpty) {\\n        return trimmedLine;\\n  \
    }\\n      if (trimmedLine.length > 0) {\\n        seenNonEmpty = true;\\n \
       return trimmedLine;\\n      }\\n      return null;\\n    \
}).filter((line) => line != null);\\n    while (lines.length > 0 && \
lines[lines.length - 1].length === 0) {\\n      lines.pop();\\n    }\\n    if \
(lines.length === 0) {\\n      return [];\\n    }\\n    const indent = (_a2 = \
lines[0].match(/^\\\\s*/)) == null ? void 0 : _a2[0];\\n    if (!indent) {\\n \
     return lines;\\n    }\\n    const regex = new RegExp(`^${indent}`);\\n   \
 return lines.map((line) => line.replace(regex, \"\"));\\n  }\\n  function \
unindent(s) {\\n    return unindentLines(s).join(\"\\\\n\");\\n  }\\n  const \
f32buffer = new Float32Array(1);\\n  const u32buffer = new \
Uint32Array(f32buffer.buffer);\\n  const supportsFloat16Array = \
\"Float16Array\" in globalThis;\\n  const f16buffer = supportsFloat16Array ? \
new globalThis[\"Float16Array\"](1) : null;\\n  const u16buffer = new \
Uint16Array(f16buffer == null ? void 0 : f16buffer.buffer);\\n  function \
normalize(vec) {\\n    const norm = Math.sqrt(vec.reduce((acc, v) => acc + v \
* v, 0));\\n    return vec.map((v) => v / norm);\\n  }\\n  const toHalf = \
supportsFloat16Array ? toHalfNative : toHalfJS;\\n  const fromHalf = \
supportsFloat16Array ? fromHalfNative : fromHalfJS;\\n  function \
toHalfNative(f) {\\n    f16buffer[0] = f;\\n    return u16buffer[0];\\n  }\\n \
 function toHalfJS(f) {\\n    f32buffer[0] = f;\\n    const bits2 = \
u32buffer[0];\\n    const sign = bits2 >> 31 & 1;\\n    const exp = bits2 >> \
23 & 255;\\n    const frac = bits2 & 8388607;\\n    const halfSign = sign << \
15;\\n    if (exp === 255) {\\n      if (frac !== 0) {\\n        return \
halfSign | 32767;\\n      }\\n      return halfSign | 31744;\\n    }\\n    \
const newExp = exp - 127 + 15;\\n    if (newExp >= 31) {\\n      return \
halfSign | 31744;\\n    }\\n    if (newExp <= 0) {\\n      if (newExp < -10) \
{\\n        return halfSign;\\n      }\\n      const subFrac = (frac | \
8388608) >> 1 - newExp + 13;\\n      return halfSign | subFrac;\\n    }\\n    \
const halfFrac = frac >> 13;\\n    return halfSign | newExp << 10 | \
halfFrac;\\n  }\\n  function fromHalfNative(u) {\\n    u16buffer[0] = u;\\n   \
 return f16buffer[0];\\n  }\\n  function fromHalfJS(h) {\\n    const sign = h \
>> 15 & 1;\\n    const exp = h >> 10 & 31;\\n    const frac = h & 1023;\\n    \
let f32bits;\\n    if (exp === 0) {\\n      if (frac === 0) {\\n        \
f32bits = sign << 31;\\n      } else {\\n        let mant = frac;\\n        \
let e = -14;\\n        while ((mant & 1024) === 0) {\\n          mant <<= \
1;\\n          e--;\\n        }\\n        mant &= 1023;\\n        const \
newExp = e + 127;\\n        const newFrac = mant << 13;\\n        f32bits = \
sign << 31 | newExp << 23 | newFrac;\\n      }\\n    } else if (exp === 31) \
{\\n      if (frac === 0) {\\n        f32bits = sign << 31 | 2139095040;\\n   \
   } else {\\n        f32bits = sign << 31 | 2143289344;\\n      }\\n    } \
else {\\n      const newExp = exp - 15 + 127;\\n      const newFrac = frac << \
13;\\n      f32bits = sign << 31 | newExp << 23 | newFrac;\\n    }\\n    \
u32buffer[0] = f32bits;\\n    return f32buffer[0];\\n  }\\n  function \
floatToUint8(v) {\\n    return Math.max(0, Math.min(255, Math.round(v * \
255)));\\n  }\\n  function getArrayBuffers(ctx) {\\n    const buffers = \
[];\\n    const seen = /* @__PURE__ */ new Set();\\n    function \
traverse(obj) {\\n      if (obj && typeof obj === \"object\" && \
!seen.has(obj)) {\\n        seen.add(obj);\\n        if (obj instanceof \
ArrayBuffer) {\\n          buffers.push(obj);\\n        } else if \
(ArrayBuffer.isView(obj)) {\\n          buffers.push(obj.buffer);\\n        } \
else if (Array.isArray(obj)) {\\n          obj.forEach(traverse);\\n        } \
else {\\n          Object.values(obj).forEach(traverse);\\n        }\\n      \
}\\n    }\\n    traverse(ctx);\\n    return buffers;\\n  }\\n  function \
setPackedSplat(packedSplats, index, x2, y, z, scaleX, scaleY, scaleZ, quatX, \
quatY, quatZ, quatW, opacity, r, g, b, encoding) {\\n    const rgbMin = \
(encoding == null ? void 0 : encoding.rgbMin) ?? 0;\\n    const rgbMax = \
(encoding == null ? void 0 : encoding.rgbMax) ?? 1;\\n    const rgbRange = \
rgbMax - rgbMin;\\n    const uR = floatToUint8((r - rgbMin) / rgbRange);\\n   \
 const uG = floatToUint8((g - rgbMin) / rgbRange);\\n    const uB = \
floatToUint8((b - rgbMin) / rgbRange);\\n    const uA = \
floatToUint8(opacity);\\n    const uQuat = encodeQuatOctXy88R8(\\n      \
tempQuaternion.set(quatX, quatY, quatZ, quatW)\\n    );\\n    const uQuatX = \
uQuat & 255;\\n    const uQuatY = uQuat >>> 8 & 255;\\n    const uQuatZ = \
uQuat >>> 16 & 255;\\n    const lnScaleMin = (encoding == null ? void 0 : \
encoding.lnScaleMin) ?? LN_SCALE_MIN;\\n    const lnScaleMax = (encoding == \
null ? void 0 : encoding.lnScaleMax) ?? LN_SCALE_MAX;\\n    const \
lnScaleScale = 254 / (lnScaleMax - lnScaleMin);\\n    const uScaleX = scaleX \
< SCALE_ZERO ? 0 : Math.min(\\n      255,\\n      Math.max(\\n        1,\\n   \
     Math.round((Math.log(scaleX) - lnScaleMin) * lnScaleScale) + 1\\n      \
)\\n    );\\n    const uScaleY = scaleY < SCALE_ZERO ? 0 : Math.min(\\n      \
255,\\n      Math.max(\\n        1,\\n        Math.round((Math.log(scaleY) - \
lnScaleMin) * lnScaleScale) + 1\\n      )\\n    );\\n    const uScaleZ = \
scaleZ < SCALE_ZERO ? 0 : Math.min(\\n      255,\\n      Math.max(\\n        \
1,\\n        Math.round((Math.log(scaleZ) - lnScaleMin) * lnScaleScale) + \
1\\n      )\\n    );\\n    const uCenterX = toHalf(x2);\\n    const uCenterY \
= toHalf(y);\\n    const uCenterZ = toHalf(z);\\n    const i4 = index * 4;\\n \
   packedSplats[i4] = uR | uG << 8 | uB << 16 | uA << 24;\\n    \
packedSplats[i4 + 1] = uCenterX | uCenterY << 16;\\n    packedSplats[i4 + 2] \
= uCenterZ | uQuatX << 16 | uQuatY << 24;\\n    packedSplats[i4 + 3] = \
uScaleX | uScaleY << 8 | uScaleZ << 16 | uQuatZ << 24;\\n  }\\n  function \
setPackedSplatCenter(packedSplats, index, x2, y, z) {\\n    const uCenterX = \
toHalf(x2);\\n    const uCenterY = toHalf(y);\\n    const uCenterZ = \
toHalf(z);\\n    const i4 = index * 4;\\n    packedSplats[i4 + 1] = uCenterX \
| uCenterY << 16;\\n    packedSplats[i4 + 2] = uCenterZ | packedSplats[i4 + \
2] & 4294901760;\\n  }\\n  function setPackedSplatScales(packedSplats, index, \
scaleX, scaleY, scaleZ, encoding) {\\n    const lnScaleMin = (encoding == \
null ? void 0 : encoding.lnScaleMin) ?? LN_SCALE_MIN;\\n    const lnScaleMax \
= (encoding == null ? void 0 : encoding.lnScaleMax) ?? LN_SCALE_MAX;\\n    \
const lnScaleScale = 254 / (lnScaleMax - lnScaleMin);\\n    const uScaleX = \
scaleX < SCALE_ZERO ? 0 : Math.min(\\n      255,\\n      Math.max(\\n        \
1,\\n        Math.round((Math.log(scaleX) - lnScaleMin) * lnScaleScale) + \
1\\n      )\\n    );\\n    const uScaleY = scaleY < SCALE_ZERO ? 0 : \
Math.min(\\n      255,\\n      Math.max(\\n        1,\\n        \
Math.round((Math.log(scaleY) - lnScaleMin) * lnScaleScale) + 1\\n      )\\n   \
 );\\n    const uScaleZ = scaleZ < SCALE_ZERO ? 0 : Math.min(\\n      255,\\n \
     Math.max(\\n        1,\\n        Math.round((Math.log(scaleZ) - \
lnScaleMin) * lnScaleScale) + 1\\n      )\\n    );\\n    const i4 = index * \
4;\\n    packedSplats[i4 + 3] = uScaleX | uScaleY << 8 | uScaleZ << 16 | \
packedSplats[i4 + 3] & 4278190080;\\n  }\\n  const tempQuaternion = new \
Quaternion();\\n  function setPackedSplatQuat(packedSplats, index, quatX, \
quatY, quatZ, quatW) {\\n    const uQuat = encodeQuatOctXy88R8(\\n      \
tempQuaternion.set(quatX, quatY, quatZ, quatW)\\n    );\\n    const uQuatX = \
uQuat & 255;\\n    const uQuatY = uQuat >>> 8 & 255;\\n    const uQuatZ = \
uQuat >>> 16 & 255;\\n    const i4 = index * 4;\\n    packedSplats[i4 + 2] = \
packedSplats[i4 + 2] & 65535 | uQuatX << 16 | uQuatY << 24;\\n    \
packedSplats[i4 + 3] = packedSplats[i4 + 3] & 16777215 | uQuatZ << 24;\\n  \
}\\n  function setPackedSplatRgba(packedSplats, index, r, g, b, a, encoding) \
{\\n    const rgbMin = (encoding == null ? void 0 : encoding.rgbMin) ?? 0;\\n \
   const rgbMax = (encoding == null ? void 0 : encoding.rgbMax) ?? 1;\\n    \
const rgbRange = rgbMax - rgbMin;\\n    const uR = floatToUint8((r - rgbMin) \
/ rgbRange);\\n    const uG = floatToUint8((g - rgbMin) / rgbRange);\\n    \
const uB = floatToUint8((b - rgbMin) / rgbRange);\\n    const uA = \
floatToUint8(a);\\n    const i4 = index * 4;\\n    packedSplats[i4] = uR | uG \
<< 8 | uB << 16 | uA << 24;\\n  }\\n  function \
setPackedSplatRgb(packedSplats, index, r, g, b, encoding) {\\n    const \
rgbMin = (encoding == null ? void 0 : encoding.rgbMin) ?? 0;\\n    const \
rgbMax = (encoding == null ? void 0 : encoding.rgbMax) ?? 1;\\n    const \
rgbRange = rgbMax - rgbMin;\\n    const uR = floatToUint8((r - rgbMin) / \
rgbRange);\\n    const uG = floatToUint8((g - rgbMin) / rgbRange);\\n    \
const uB = floatToUint8((b - rgbMin) / rgbRange);\\n    const i4 = index * \
4;\\n    packedSplats[i4] = uR | uG << 8 | uB << 16 | packedSplats[i4] & \
4278190080;\\n  }\\n  function setPackedSplatOpacity(packedSplats, index, \
opacity) {\\n    const uA = floatToUint8(opacity);\\n    const i4 = index * \
4;\\n    packedSplats[i4] = packedSplats[i4] & 16777215 | uA << 24;\\n  }\\n  \
new Vector3();\\n  new Vector3();\\n  new Color();\\n  function \
getTextureSize(numSplats) {\\n    const width = SPLAT_TEX_WIDTH;\\n    const \
height = Math.max(\\n      SPLAT_TEX_MIN_HEIGHT,\\n      \
Math.min(SPLAT_TEX_HEIGHT, Math.ceil(numSplats / width))\\n    );\\n    const \
depth = Math.ceil(numSplats / (width * height));\\n    const maxSplats = \
width * height * depth;\\n    return { width, height, depth, maxSplats };\\n  \
}\\n  function computeMaxSplats(numSplats) {\\n    const width = \
SPLAT_TEX_WIDTH;\\n    const height = Math.max(\\n      \
SPLAT_TEX_MIN_HEIGHT,\\n      Math.min(SPLAT_TEX_HEIGHT, Math.ceil(numSplats \
/ width))\\n    );\\n    const depth = Math.ceil(numSplats / (width * \
height));\\n    return width * height * depth;\\n  }\\n  unindent(`\\n  \
precision highp float;\\n\\n  in vec3 position;\\n\\n  void main() {\\n    \
gl_Position = vec4(position.xy, 0.0, 1.0);\\n  }\\n`);\\n  const \
tempNormalizedQuaternion = new Quaternion();\\n  const tempAxis = new \
Vector3();\\n  function encodeQuatOctXy88R8(q) {\\n    const qnorm = \
tempNormalizedQuaternion.copy(q).normalize();\\n    if (qnorm.w < 0) {\\n     \
 qnorm.set(-qnorm.x, -qnorm.y, -qnorm.z, -qnorm.w);\\n    }\\n    const theta \
= 2 * Math.acos(qnorm.w);\\n    const xyz_norm = Math.sqrt(\\n      qnorm.x * \
qnorm.x + qnorm.y * qnorm.y + qnorm.z * qnorm.z\\n    );\\n    const axis = \
xyz_norm < 1e-6 ? tempAxis.set(1, 0, 0) : tempAxis.set(qnorm.x, qnorm.y, \
qnorm.z).divideScalar(xyz_norm);\\n    const sum = Math.abs(axis.x) + \
Math.abs(axis.y) + Math.abs(axis.z);\\n    let p_x = axis.x / sum;\\n    let \
p_y = axis.y / sum;\\n    if (axis.z < 0) {\\n      const tmp = p_x;\\n      \
p_x = (1 - Math.abs(p_y)) * (p_x >= 0 ? 1 : -1);\\n      p_y = (1 - \
Math.abs(tmp)) * (p_y >= 0 ? 1 : -1);\\n    }\\n    const u_f = p_x * 0.5 + \
0.5;\\n    const v_f = p_y * 0.5 + 0.5;\\n    const quantU = Math.round(u_f * \
255);\\n    const quantV = Math.round(v_f * 255);\\n    const angleInt = \
Math.round(theta * (255 / Math.PI));\\n    return angleInt << 16 | quantV << \
8 | quantU;\\n  }\\n  function packSint8Bytes(b0, b1, b22, b3) {\\n    const \
clampedB0 = Math.max(-127, Math.min(127, b0 * 127));\\n    const clampedB1 = \
Math.max(-127, Math.min(127, b1 * 127));\\n    const clampedB2 = \
Math.max(-127, Math.min(127, b22 * 127));\\n    const clampedB3 = \
Math.max(-127, Math.min(127, b3 * 127));\\n    return clampedB0 & 255 | \
(clampedB1 & 255) << 8 | (clampedB2 & 255) << 16 | (clampedB3 & 255) << \
24;\\n  }\\n  function encodeSh1Rgb(sh1Array, index, sh1Rgb, encoding) {\\n   \
 const sh1Min = (encoding == null ? void 0 : encoding.sh1Min) ?? -1;\\n    \
const sh1Max = (encoding == null ? void 0 : encoding.sh1Max) ?? 1;\\n    \
const sh1Mid = 0.5 * (sh1Min + sh1Max);\\n    const sh1Scale = 126 / (sh1Max \
- sh1Min);\\n    const base = index * 2;\\n    for (let i2 = 0; i2 < 9; ++i2) \
{\\n      const s = (sh1Rgb[i2] - sh1Mid) * sh1Scale;\\n      const value = \
Math.round(Math.max(-63, Math.min(63, s))) & 127;\\n      const bitStart = i2 \
* 7;\\n      const bitEnd = bitStart + 7;\\n      const wordStart = \
Math.floor(bitStart / 32);\\n      const bitOffset = bitStart - wordStart * \
32;\\n      const firstWord = value << bitOffset & 4294967295;\\n      \
sh1Array[base + wordStart] |= firstWord;\\n      if (bitEnd > wordStart * 32 \
+ 32) {\\n        const secondWord = value >>> 32 - bitOffset & \
4294967295;\\n        sh1Array[base + wordStart + 1] |= secondWord;\\n      \
}\\n    }\\n  }\\n  function encodeSh2Rgb(sh2Array, index, sh2Rgb, encoding) \
{\\n    const sh2Min = (encoding == null ? void 0 : encoding.sh2Min) ?? \
-1;\\n    const sh2Max = (encoding == null ? void 0 : encoding.sh2Max) ?? \
1;\\n    const sh2Mid = 0.5 * (sh2Min + sh2Max);\\n    const sh2Scale = 2 / \
(sh2Max - sh2Min);\\n    sh2Array[index * 4 + 0] = packSint8Bytes(\\n      \
(sh2Rgb[0] - sh2Mid) * sh2Scale,\\n      (sh2Rgb[1] - sh2Mid) * sh2Scale,\\n  \
    (sh2Rgb[2] - sh2Mid) * sh2Scale,\\n      (sh2Rgb[3] - sh2Mid) * \
sh2Scale\\n    );\\n    sh2Array[index * 4 + 1] = packSint8Bytes(\\n      \
(sh2Rgb[4] - sh2Mid) * sh2Scale,\\n      (sh2Rgb[5] - sh2Mid) * sh2Scale,\\n  \
    (sh2Rgb[6] - sh2Mid) * sh2Scale,\\n      (sh2Rgb[7] - sh2Mid) * \
sh2Scale\\n    );\\n    sh2Array[index * 4 + 2] = packSint8Bytes(\\n      \
(sh2Rgb[8] - sh2Mid) * sh2Scale,\\n      (sh2Rgb[9] - sh2Mid) * sh2Scale,\\n  \
    (sh2Rgb[10] - sh2Mid) * sh2Scale,\\n      (sh2Rgb[11] - sh2Mid) * \
sh2Scale\\n    );\\n    sh2Array[index * 4 + 3] = packSint8Bytes(\\n      \
(sh2Rgb[12] - sh2Mid) * sh2Scale,\\n      (sh2Rgb[13] - sh2Mid) * \
sh2Scale,\\n      (sh2Rgb[14] - sh2Mid) * sh2Scale,\\n      0\\n    );\\n  \
}\\n  function encodeSh3Rgb(sh3Array, index, sh3Rgb, encoding) {\\n    const \
sh3Min = (encoding == null ? void 0 : encoding.sh3Min) ?? -1;\\n    const \
sh3Max = (encoding == null ? void 0 : encoding.sh3Max) ?? 1;\\n    const \
sh3Mid = 0.5 * (sh3Min + sh3Max);\\n    const sh3Scale = 62 / (sh3Max - \
sh3Min);\\n    const base = index * 4;\\n    for (let i2 = 0; i2 < 21; ++i2) \
{\\n      const s = (sh3Rgb[i2] - sh3Mid) * sh3Scale;\\n      const value = \
Math.round(Math.max(-31, Math.min(31, s))) & 63;\\n      const bitStart = i2 \
* 6;\\n      const bitEnd = bitStart + 6;\\n      const wordStart = \
Math.floor(bitStart / 32);\\n      const bitOffset = bitStart - wordStart * \
32;\\n      const firstWord = value << bitOffset & 4294967295;\\n      \
sh3Array[base + wordStart] |= firstWord;\\n      if (bitEnd > wordStart * 32 \
+ 32) {\\n        const secondWord = value >>> 32 - bitOffset & \
4294967295;\\n        sh3Array[base + wordStart + 1] |= secondWord;\\n      \
}\\n    }\\n  }\\n  function decompressPartialGzip(fileBytes, numBytes) {\\n  \
  const chunks = [];\\n    let totalBytes = 0;\\n    let result = null;\\n    \
const gunzip = new Gunzip((data, final) => {\\n      chunks.push(data);\\n    \
  totalBytes += data.length;\\n      if (final || totalBytes >= numBytes) \
{\\n        const allBytes = new Uint8Array(totalBytes);\\n        let \
offset2 = 0;\\n        for (const chunk of chunks) {\\n          \
allBytes.set(chunk, offset2);\\n          offset2 += chunk.length;\\n        \
}\\n        result = allBytes.slice(0, numBytes);\\n      }\\n    });\\n    \
const CHUNK_SIZE = 1024;\\n    let offset = 0;\\n    while (result == null && \
offset < fileBytes.length) {\\n      const chunk = fileBytes.slice(offset, \
offset + CHUNK_SIZE);\\n      gunzip.push(chunk, false);\\n      offset += \
CHUNK_SIZE;\\n    }\\n    if (result == null) {\\n      gunzip.push(new \
Uint8Array(), true);\\n      if (result == null) {\\n        throw new \
Error(\"Failed to decompress partial gzip\");\\n      }\\n    }\\n    return \
result;\\n  }\\n  class GunzipReader {\\n    constructor({\\n      \
fileBytes,\\n      chunkBytes = 64 * 1024\\n    }) {\\n      this.fileBytes = \
fileBytes;\\n      this.chunkBytes = chunkBytes;\\n      this.chunks = [];\\n \
     this.totalBytes = 0;\\n      const ds = new \
DecompressionStream(\"gzip\");\\n      const decompressionStream = new \
Blob([fileBytes]).stream().pipeThrough(ds);\\n      this.reader = \
decompressionStream.getReader();\\n    }\\n    async read(numBytes) {\\n      \
while (this.totalBytes < numBytes) {\\n        const { value: chunk, done: \
readerDone } = await this.reader.read();\\n        if (readerDone) {\\n       \
   break;\\n        }\\n        this.chunks.push(chunk);\\n        \
this.totalBytes += chunk.length;\\n      }\\n      if (this.totalBytes < \
numBytes) {\\n        throw new Error(\\n          `Unexpected EOF: needed \
${numBytes}, got ${this.totalBytes}`\\n        );\\n      }\\n      const \
allBytes = new Uint8Array(this.totalBytes);\\n      let outOffset = 0;\\n     \
 for (const chunk of this.chunks) {\\n        allBytes.set(chunk, \
outOffset);\\n        outOffset += chunk.length;\\n      }\\n      const \
result = allBytes.subarray(0, numBytes);\\n      this.chunks = \
[allBytes.subarray(numBytes)];\\n      this.totalBytes -= numBytes;\\n      \
return result;\\n    }\\n  }\\n  function decodeAntiSplat(fileBytes, \
initNumSplats, splatCallback) {\\n    const numSplats = \
Math.floor(fileBytes.length / 32);\\n    if (numSplats * 32 !== \
fileBytes.length) {\\n      throw new Error(\"Invalid .splat file size\");\\n \
   }\\n    initNumSplats(numSplats);\\n    const f32 = new \
Float32Array(fileBytes.buffer);\\n    for (let i2 = 0; i2 < numSplats; ++i2) \
{\\n      const i322 = i2 * 32;\\n      const i8 = i2 * 8;\\n      const x2 = \
f32[i8 + 0];\\n      const y = f32[i8 + 1];\\n      const z = f32[i8 + 2];\\n \
     const scaleX = f32[i8 + 3];\\n      const scaleY = f32[i8 + 4];\\n      \
const scaleZ = f32[i8 + 5];\\n      const r = fileBytes[i322 + 24] / 255;\\n  \
    const g = fileBytes[i322 + 25] / 255;\\n      const b = fileBytes[i322 + \
26] / 255;\\n      const opacity = fileBytes[i322 + 27] / 255;\\n      const \
quatW = (fileBytes[i322 + 28] - 128) / 128;\\n      const quatX = \
(fileBytes[i322 + 29] - 128) / 128;\\n      const quatY = (fileBytes[i322 + \
30] - 128) / 128;\\n      const quatZ = (fileBytes[i322 + 31] - 128) / \
128;\\n      splatCallback(\\n        i2,\\n        x2,\\n        y,\\n       \
 z,\\n        scaleX,\\n        scaleY,\\n        scaleZ,\\n        quatX,\\n \
       quatY,\\n        quatZ,\\n        quatW,\\n        opacity,\\n        \
r,\\n        g,\\n        b\\n      );\\n    }\\n  }\\n  function \
unpackAntiSplat(fileBytes, splatEncoding) {\\n    let numSplats = 0;\\n    \
let maxSplats = 0;\\n    let packedArray = new Uint32Array(0);\\n    \
decodeAntiSplat(\\n      fileBytes,\\n      (cbNumSplats) => {\\n        \
numSplats = cbNumSplats;\\n        maxSplats = \
computeMaxSplats(numSplats);\\n        packedArray = new \
Uint32Array(maxSplats * 4);\\n      },\\n      (index, x2, y, z, scaleX, \
scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\\n        \
setPackedSplat(\\n          packedArray,\\n          index,\\n          \
x2,\\n          y,\\n          z,\\n          scaleX,\\n          scaleY,\\n  \
        scaleZ,\\n          quatX,\\n          quatY,\\n          quatZ,\\n   \
       quatW,\\n          opacity,\\n          r,\\n          g,\\n          \
b,\\n          splatEncoding\\n        );\\n      }\\n    );\\n    return { \
packedArray, numSplats };\\n  }\\n  const KSPLAT_COMPRESSION = {\\n    0: \
{\\n      bytesPerCenter: 12,\\n      bytesPerScale: 12,\\n      \
bytesPerRotation: 16,\\n      bytesPerColor: 4,\\n      \
bytesPerSphericalHarmonicsComponent: 4,\\n      scaleOffsetBytes: 12,\\n      \
rotationOffsetBytes: 24,\\n      colorOffsetBytes: 40,\\n      \
sphericalHarmonicsOffsetBytes: 44,\\n      scaleRange: 1\\n    },\\n    1: \
{\\n      bytesPerCenter: 6,\\n      bytesPerScale: 6,\\n      \
bytesPerRotation: 8,\\n      bytesPerColor: 4,\\n      \
bytesPerSphericalHarmonicsComponent: 2,\\n      scaleOffsetBytes: 6,\\n      \
rotationOffsetBytes: 12,\\n      colorOffsetBytes: 20,\\n      \
sphericalHarmonicsOffsetBytes: 24,\\n      scaleRange: 32767\\n    },\\n    \
2: {\\n      bytesPerCenter: 6,\\n      bytesPerScale: 6,\\n      \
bytesPerRotation: 8,\\n      bytesPerColor: 4,\\n      \
bytesPerSphericalHarmonicsComponent: 1,\\n      scaleOffsetBytes: 6,\\n      \
rotationOffsetBytes: 12,\\n      colorOffsetBytes: 20,\\n      \
sphericalHarmonicsOffsetBytes: 24,\\n      scaleRange: 32767\\n    }\\n  \
};\\n  const KSPLAT_SH_DEGREE_TO_COMPONENTS = {\\n    0: 0,\\n    1: 9,\\n    \
2: 24,\\n    3: 45\\n  };\\n  function decodeKsplat(fileBytes, initNumSplats, \
splatCallback, shCallback) {\\n    var _a2;\\n    const HEADER_BYTES = \
4096;\\n    const SECTION_BYTES = 1024;\\n    let headerOffset = 0;\\n    \
const header = new DataView(fileBytes.buffer, headerOffset, HEADER_BYTES);\\n \
   headerOffset += HEADER_BYTES;\\n    const versionMajor = \
header.getUint8(0);\\n    const versionMinor = header.getUint8(1);\\n    if \
(versionMajor !== 0 || versionMinor < 1) {\\n      throw new Error(\\n        \
`Unsupported .ksplat version: ${versionMajor}.${versionMinor}`\\n      );\\n  \
  }\\n    const maxSectionCount = header.getUint32(4, true);\\n    \
header.getUint32(16, true);\\n    const compressionLevel = \
header.getUint16(20, true);\\n    if (compressionLevel < 0 || \
compressionLevel > 2) {\\n      throw new Error(`Invalid .ksplat compression \
level: ${compressionLevel}`);\\n    }\\n    const minSphericalHarmonicsCoeff \
= header.getFloat32(36, true) || -1.5;\\n    const maxSphericalHarmonicsCoeff \
= header.getFloat32(40, true) || 1.5;\\n    let sectionBase = HEADER_BYTES + \
maxSectionCount * SECTION_BYTES;\\n    for (let section = 0; section < \
maxSectionCount; ++section) {\\n      let getSh = function(splatOffset, \
component) {\\n        if (compressionLevel === 0) {\\n          return \
data.getFloat32(\\n            splatOffset + sphericalHarmonicsOffsetBytes + \
component * 4,\\n            true\\n          );\\n        }\\n        if \
(compressionLevel === 1) {\\n          return fromHalf(\\n            \
data.getUint16(\\n              splatOffset + sphericalHarmonicsOffsetBytes + \
component * 2,\\n              true\\n            )\\n          );\\n        \
}\\n        const t = data.getUint8(splatOffset + \
sphericalHarmonicsOffsetBytes + component) / 255;\\n        return \
minSphericalHarmonicsCoeff + t * (maxSphericalHarmonicsCoeff - \
minSphericalHarmonicsCoeff);\\n      };\\n      const section2 = new \
DataView(fileBytes.buffer, headerOffset, SECTION_BYTES);\\n      headerOffset \
+= SECTION_BYTES;\\n      const sectionSplatCount = section2.getUint32(0, \
true);\\n      const sectionMaxSplatCount = section2.getUint32(4, true);\\n   \
   const bucketSize = section2.getUint32(8, true);\\n      const bucketCount \
= section2.getUint32(12, true);\\n      const bucketBlockSize = \
section2.getFloat32(16, true);\\n      const bucketStorageSizeBytes = \
section2.getUint16(20, true);\\n      const compressionScaleRange = \
(section2.getUint32(24, true) || ((_a2 = \
KSPLAT_COMPRESSION[compressionLevel]) == null ? void 0 : _a2.scaleRange)) ?? \
1;\\n      const fullBucketCount = section2.getUint32(32, true);\\n      \
const fullBucketSplats = fullBucketCount * bucketSize;\\n      const \
partiallyFilledBucketCount = section2.getUint32(36, true);\\n      const \
bucketsMetaDataSizeBytes = partiallyFilledBucketCount * 4;\\n      const \
bucketsStorageSizeBytes = bucketStorageSizeBytes * bucketCount + \
bucketsMetaDataSizeBytes;\\n      const sphericalHarmonicsDegree = \
section2.getUint16(40, true);\\n      const shComponents = \
KSPLAT_SH_DEGREE_TO_COMPONENTS[sphericalHarmonicsDegree];\\n      const {\\n  \
      bytesPerCenter,\\n        bytesPerScale,\\n        bytesPerRotation,\\n \
       bytesPerColor,\\n        bytesPerSphericalHarmonicsComponent,\\n       \
 scaleOffsetBytes,\\n        rotationOffsetBytes,\\n        \
colorOffsetBytes,\\n        sphericalHarmonicsOffsetBytes\\n      } = \
KSPLAT_COMPRESSION[compressionLevel];\\n      const bytesPerSplat = \
bytesPerCenter + bytesPerScale + bytesPerRotation + bytesPerColor + \
shComponents * bytesPerSphericalHarmonicsComponent;\\n      const \
splatDataStorageSizeBytes = bytesPerSplat * sectionMaxSplatCount;\\n      \
const storageSizeBytes = splatDataStorageSizeBytes + \
bucketsStorageSizeBytes;\\n      const sh1Index = [0, 3, 6, 1, 4, 7, 2, 5, \
8];\\n      const sh2Index = [\\n        9,\\n        14,\\n        19,\\n    \
    10,\\n        15,\\n        20,\\n        11,\\n        16,\\n        \
21,\\n        12,\\n        17,\\n        22,\\n        13,\\n        18,\\n  \
      23\\n      ];\\n      const sh3Index = [\\n        24,\\n        31,\\n \
       38,\\n        25,\\n        32,\\n        39,\\n        26,\\n        \
33,\\n        40,\\n        27,\\n        34,\\n        41,\\n        28,\\n  \
      35,\\n        42,\\n        29,\\n        36,\\n        43,\\n        \
30,\\n        37,\\n        44\\n      ];\\n      const sh1 = \
sphericalHarmonicsDegree >= 1 ? new Float32Array(3 * 3) : void 0;\\n      \
const sh2 = sphericalHarmonicsDegree >= 2 ? new Float32Array(5 * 3) : void \
0;\\n      const sh3 = sphericalHarmonicsDegree >= 3 ? new Float32Array(7 * \
3) : void 0;\\n      const compressionScaleFactor = bucketBlockSize / 2 / \
compressionScaleRange;\\n      const bucketsBase = sectionBase + \
bucketsMetaDataSizeBytes;\\n      const dataBase = sectionBase + \
bucketsStorageSizeBytes;\\n      const data = new DataView(\\n        \
fileBytes.buffer,\\n        dataBase,\\n        splatDataStorageSizeBytes\\n  \
    );\\n      const bucketArray = new Float32Array(\\n        \
fileBytes.buffer,\\n        bucketsBase,\\n        bucketCount * 3\\n      \
);\\n      const partiallyFilledBucketLengths = new Uint32Array(\\n        \
fileBytes.buffer,\\n        sectionBase,\\n        \
partiallyFilledBucketCount\\n      );\\n      let partialBucketIndex = \
fullBucketCount;\\n      let partialBucketBase = fullBucketSplats;\\n      \
for (let i2 = 0; i2 < sectionSplatCount; ++i2) {\\n        const splatOffset \
= i2 * bytesPerSplat;\\n        let bucketIndex;\\n        if (i2 < \
fullBucketSplats) {\\n          bucketIndex = Math.floor(i2 / bucketSize);\\n \
       } else {\\n          const bucketLength = \
partiallyFilledBucketLengths[partialBucketIndex - fullBucketCount];\\n        \
  if (i2 >= partialBucketBase + bucketLength) {\\n            \
partialBucketIndex += 1;\\n            partialBucketBase += bucketLength;\\n  \
        }\\n          bucketIndex = partialBucketIndex;\\n        }\\n        \
const x2 = compressionLevel === 0 ? data.getFloat32(splatOffset + 0, true) : \
(data.getUint16(splatOffset + 0, true) - compressionScaleRange) * \
compressionScaleFactor + bucketArray[3 * bucketIndex + 0];\\n        const y \
= compressionLevel === 0 ? data.getFloat32(splatOffset + 4, true) : \
(data.getUint16(splatOffset + 2, true) - compressionScaleRange) * \
compressionScaleFactor + bucketArray[3 * bucketIndex + 1];\\n        const z \
= compressionLevel === 0 ? data.getFloat32(splatOffset + 8, true) : \
(data.getUint16(splatOffset + 4, true) - compressionScaleRange) * \
compressionScaleFactor + bucketArray[3 * bucketIndex + 2];\\n        const \
scaleX = compressionLevel === 0 ? data.getFloat32(splatOffset + \
scaleOffsetBytes + 0, true) : fromHalf(data.getUint16(splatOffset + \
scaleOffsetBytes + 0, true));\\n        const scaleY = compressionLevel === 0 \
? data.getFloat32(splatOffset + scaleOffsetBytes + 4, true) : \
fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 2, true));\\n        \
const scaleZ = compressionLevel === 0 ? data.getFloat32(splatOffset + \
scaleOffsetBytes + 8, true) : fromHalf(data.getUint16(splatOffset + \
scaleOffsetBytes + 4, true));\\n        const quatW = compressionLevel === 0 \
? data.getFloat32(splatOffset + rotationOffsetBytes + 0, true) : fromHalf(\\n \
         data.getUint16(splatOffset + rotationOffsetBytes + 0, true)\\n       \
 );\\n        const quatX = compressionLevel === 0 ? \
data.getFloat32(splatOffset + rotationOffsetBytes + 4, true) : fromHalf(\\n   \
       data.getUint16(splatOffset + rotationOffsetBytes + 2, true)\\n        \
);\\n        const quatY = compressionLevel === 0 ? \
data.getFloat32(splatOffset + rotationOffsetBytes + 8, true) : fromHalf(\\n   \
       data.getUint16(splatOffset + rotationOffsetBytes + 4, true)\\n        \
);\\n        const quatZ = compressionLevel === 0 ? \
data.getFloat32(splatOffset + rotationOffsetBytes + 12, true) : fromHalf(\\n  \
        data.getUint16(splatOffset + rotationOffsetBytes + 6, true)\\n        \
);\\n        const r = data.getUint8(splatOffset + colorOffsetBytes + 0) / \
255;\\n        const g = data.getUint8(splatOffset + colorOffsetBytes + 1) / \
255;\\n        const b = data.getUint8(splatOffset + colorOffsetBytes + 2) / \
255;\\n        const opacity = data.getUint8(splatOffset + colorOffsetBytes + \
3) / 255;\\n        splatCallback(\\n          i2,\\n          x2,\\n         \
 y,\\n          z,\\n          scaleX,\\n          scaleY,\\n          \
scaleZ,\\n          quatX,\\n          quatY,\\n          quatZ,\\n          \
quatW,\\n          opacity,\\n          r,\\n          g,\\n          b\\n    \
    );\\n        if (sphericalHarmonicsDegree >= 1 && sh1) {\\n          for \
(const [i22, key] of sh1Index.entries()) {\\n            sh1[i22] = \
getSh(splatOffset, key);\\n          }\\n          if (sh2) {\\n            \
for (const [i22, key] of sh2Index.entries()) {\\n              sh2[i22] = \
getSh(splatOffset, key);\\n            }\\n          }\\n          if (sh3) \
{\\n            for (const [i22, key] of sh3Index.entries()) {\\n             \
 sh3[i22] = getSh(splatOffset, key);\\n            }\\n          }\\n         \
 shCallback == null ? void 0 : shCallback(i2, sh1, sh2, sh3);\\n        }\\n  \
    }\\n      sectionBase += storageSizeBytes;\\n    }\\n  }\\n  function \
unpackKsplat(fileBytes, splatEncoding) {\\n    var _a2;\\n    const \
HEADER_BYTES = 4096;\\n    const SECTION_BYTES = 1024;\\n    let headerOffset \
= 0;\\n    const header = new DataView(fileBytes.buffer, headerOffset, \
HEADER_BYTES);\\n    headerOffset += HEADER_BYTES;\\n    const versionMajor = \
header.getUint8(0);\\n    const versionMinor = header.getUint8(1);\\n    if \
(versionMajor !== 0 || versionMinor < 1) {\\n      throw new Error(\\n        \
`Unsupported .ksplat version: ${versionMajor}.${versionMinor}`\\n      );\\n  \
  }\\n    const maxSectionCount = header.getUint32(4, true);\\n    const \
splatCount = header.getUint32(16, true);\\n    const compressionLevel = \
header.getUint16(20, true);\\n    if (compressionLevel < 0 || \
compressionLevel > 2) {\\n      throw new Error(`Invalid .ksplat compression \
level: ${compressionLevel}`);\\n    }\\n    const minSphericalHarmonicsCoeff \
= header.getFloat32(36, true) || -1.5;\\n    const maxSphericalHarmonicsCoeff \
= header.getFloat32(40, true) || 1.5;\\n    const numSplats = splatCount;\\n  \
  const maxSplats = computeMaxSplats(numSplats);\\n    const packedArray = \
new Uint32Array(maxSplats * 4);\\n    const extra = {};\\n    let sectionBase \
= HEADER_BYTES + maxSectionCount * SECTION_BYTES;\\n    for (let section = 0; \
section < maxSectionCount; ++section) {\\n      let getSh = \
function(splatOffset, component) {\\n        if (compressionLevel === 0) {\\n \
         return data.getFloat32(\\n            splatOffset + \
sphericalHarmonicsOffsetBytes + component * 4,\\n            true\\n          \
);\\n        }\\n        if (compressionLevel === 1) {\\n          return \
fromHalf(\\n            data.getUint16(\\n              splatOffset + \
sphericalHarmonicsOffsetBytes + component * 2,\\n              true\\n        \
    )\\n          );\\n        }\\n        const t = \
data.getUint8(splatOffset + sphericalHarmonicsOffsetBytes + component) / \
255;\\n        return minSphericalHarmonicsCoeff + t * \
(maxSphericalHarmonicsCoeff - minSphericalHarmonicsCoeff);\\n      };\\n      \
const section2 = new DataView(fileBytes.buffer, headerOffset, \
SECTION_BYTES);\\n      headerOffset += SECTION_BYTES;\\n      const \
sectionSplatCount = section2.getUint32(0, true);\\n      const \
sectionMaxSplatCount = section2.getUint32(4, true);\\n      const bucketSize \
= section2.getUint32(8, true);\\n      const bucketCount = \
section2.getUint32(12, true);\\n      const bucketBlockSize = \
section2.getFloat32(16, true);\\n      const bucketStorageSizeBytes = \
section2.getUint16(20, true);\\n      const compressionScaleRange = \
(section2.getUint32(24, true) || ((_a2 = \
KSPLAT_COMPRESSION[compressionLevel]) == null ? void 0 : _a2.scaleRange)) ?? \
1;\\n      const fullBucketCount = section2.getUint32(32, true);\\n      \
const fullBucketSplats = fullBucketCount * bucketSize;\\n      const \
partiallyFilledBucketCount = section2.getUint32(36, true);\\n      const \
bucketsMetaDataSizeBytes = partiallyFilledBucketCount * 4;\\n      const \
bucketsStorageSizeBytes = bucketStorageSizeBytes * bucketCount + \
bucketsMetaDataSizeBytes;\\n      const sphericalHarmonicsDegree = \
section2.getUint16(40, true);\\n      const shComponents = \
KSPLAT_SH_DEGREE_TO_COMPONENTS[sphericalHarmonicsDegree];\\n      const {\\n  \
      bytesPerCenter,\\n        bytesPerScale,\\n        bytesPerRotation,\\n \
       bytesPerColor,\\n        bytesPerSphericalHarmonicsComponent,\\n       \
 scaleOffsetBytes,\\n        rotationOffsetBytes,\\n        \
colorOffsetBytes,\\n        sphericalHarmonicsOffsetBytes\\n      } = \
KSPLAT_COMPRESSION[compressionLevel];\\n      const bytesPerSplat = \
bytesPerCenter + bytesPerScale + bytesPerRotation + bytesPerColor + \
shComponents * bytesPerSphericalHarmonicsComponent;\\n      const \
splatDataStorageSizeBytes = bytesPerSplat * sectionMaxSplatCount;\\n      \
const storageSizeBytes = splatDataStorageSizeBytes + \
bucketsStorageSizeBytes;\\n      const sh1Index = [0, 3, 6, 1, 4, 7, 2, 5, \
8];\\n      const sh2Index = [\\n        9,\\n        14,\\n        19,\\n    \
    10,\\n        15,\\n        20,\\n        11,\\n        16,\\n        \
21,\\n        12,\\n        17,\\n        22,\\n        13,\\n        18,\\n  \
      23\\n      ];\\n      const sh3Index = [\\n        24,\\n        31,\\n \
       38,\\n        25,\\n        32,\\n        39,\\n        26,\\n        \
33,\\n        40,\\n        27,\\n        34,\\n        41,\\n        28,\\n  \
      35,\\n        42,\\n        29,\\n        36,\\n        43,\\n        \
30,\\n        37,\\n        44\\n      ];\\n      const sh1 = \
sphericalHarmonicsDegree >= 1 ? new Float32Array(3 * 3) : void 0;\\n      \
const sh2 = sphericalHarmonicsDegree >= 2 ? new Float32Array(5 * 3) : void \
0;\\n      const sh3 = sphericalHarmonicsDegree >= 3 ? new Float32Array(7 * \
3) : void 0;\\n      const compressionScaleFactor = bucketBlockSize / 2 / \
compressionScaleRange;\\n      const bucketsBase = sectionBase + \
bucketsMetaDataSizeBytes;\\n      const dataBase = sectionBase + \
bucketsStorageSizeBytes;\\n      const data = new DataView(\\n        \
fileBytes.buffer,\\n        dataBase,\\n        splatDataStorageSizeBytes\\n  \
    );\\n      const bucketArray = new Float32Array(\\n        \
fileBytes.buffer,\\n        bucketsBase,\\n        bucketCount * 3\\n      \
);\\n      const partiallyFilledBucketLengths = new Uint32Array(\\n        \
fileBytes.buffer,\\n        sectionBase,\\n        \
partiallyFilledBucketCount\\n      );\\n      let partialBucketIndex = \
fullBucketCount;\\n      let partialBucketBase = fullBucketSplats;\\n      \
for (let i2 = 0; i2 < sectionSplatCount; ++i2) {\\n        const splatOffset \
= i2 * bytesPerSplat;\\n        let bucketIndex;\\n        if (i2 < \
fullBucketSplats) {\\n          bucketIndex = Math.floor(i2 / bucketSize);\\n \
       } else {\\n          const bucketLength = \
partiallyFilledBucketLengths[partialBucketIndex - fullBucketCount];\\n        \
  if (i2 >= partialBucketBase + bucketLength) {\\n            \
partialBucketIndex += 1;\\n            partialBucketBase += bucketLength;\\n  \
        }\\n          bucketIndex = partialBucketIndex;\\n        }\\n        \
const x2 = compressionLevel === 0 ? data.getFloat32(splatOffset + 0, true) : \
(data.getUint16(splatOffset + 0, true) - compressionScaleRange) * \
compressionScaleFactor + bucketArray[3 * bucketIndex + 0];\\n        const y \
= compressionLevel === 0 ? data.getFloat32(splatOffset + 4, true) : \
(data.getUint16(splatOffset + 2, true) - compressionScaleRange) * \
compressionScaleFactor + bucketArray[3 * bucketIndex + 1];\\n        const z \
= compressionLevel === 0 ? data.getFloat32(splatOffset + 8, true) : \
(data.getUint16(splatOffset + 4, true) - compressionScaleRange) * \
compressionScaleFactor + bucketArray[3 * bucketIndex + 2];\\n        const \
scaleX = compressionLevel === 0 ? data.getFloat32(splatOffset + \
scaleOffsetBytes + 0, true) : fromHalf(data.getUint16(splatOffset + \
scaleOffsetBytes + 0, true));\\n        const scaleY = compressionLevel === 0 \
? data.getFloat32(splatOffset + scaleOffsetBytes + 4, true) : \
fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 2, true));\\n        \
const scaleZ = compressionLevel === 0 ? data.getFloat32(splatOffset + \
scaleOffsetBytes + 8, true) : fromHalf(data.getUint16(splatOffset + \
scaleOffsetBytes + 4, true));\\n        const quatW = compressionLevel === 0 \
? data.getFloat32(splatOffset + rotationOffsetBytes + 0, true) : fromHalf(\\n \
         data.getUint16(splatOffset + rotationOffsetBytes + 0, true)\\n       \
 );\\n        const quatX = compressionLevel === 0 ? \
data.getFloat32(splatOffset + rotationOffsetBytes + 4, true) : fromHalf(\\n   \
       data.getUint16(splatOffset + rotationOffsetBytes + 2, true)\\n        \
);\\n        const quatY = compressionLevel === 0 ? \
data.getFloat32(splatOffset + rotationOffsetBytes + 8, true) : fromHalf(\\n   \
       data.getUint16(splatOffset + rotationOffsetBytes + 4, true)\\n        \
);\\n        const quatZ = compressionLevel === 0 ? \
data.getFloat32(splatOffset + rotationOffsetBytes + 12, true) : fromHalf(\\n  \
        data.getUint16(splatOffset + rotationOffsetBytes + 6, true)\\n        \
);\\n        const r = data.getUint8(splatOffset + colorOffsetBytes + 0) / \
255;\\n        const g = data.getUint8(splatOffset + colorOffsetBytes + 1) / \
255;\\n        const b = data.getUint8(splatOffset + colorOffsetBytes + 2) / \
255;\\n        const opacity = data.getUint8(splatOffset + colorOffsetBytes + \
3) / 255;\\n        setPackedSplat(\\n          packedArray,\\n          \
i2,\\n          x2,\\n          y,\\n          z,\\n          scaleX,\\n      \
    scaleY,\\n          scaleZ,\\n          quatX,\\n          quatY,\\n      \
    quatZ,\\n          quatW,\\n          opacity,\\n          r,\\n          \
g,\\n          b,\\n          splatEncoding\\n        );\\n        if \
(sphericalHarmonicsDegree >= 1) {\\n          if (sh1) {\\n            if \
(!extra.sh1) {\\n              extra.sh1 = new Uint32Array(numSplats * 2);\\n \
           }\\n            for (const [i22, key] of sh1Index.entries()) {\\n  \
            sh1[i22] = getSh(splatOffset, key);\\n            }\\n            \
encodeSh1Rgb(extra.sh1, i2, sh1, splatEncoding);\\n          }\\n          if \
(sh2) {\\n            if (!extra.sh2) {\\n              extra.sh2 = new \
Uint32Array(numSplats * 4);\\n            }\\n            for (const [i22, \
key] of sh2Index.entries()) {\\n              sh2[i22] = getSh(splatOffset, \
key);\\n            }\\n            encodeSh2Rgb(extra.sh2, i2, sh2, \
splatEncoding);\\n          }\\n          if (sh3) {\\n            if \
(!extra.sh3) {\\n              extra.sh3 = new Uint32Array(numSplats * 4);\\n \
           }\\n            for (const [i22, key] of sh3Index.entries()) {\\n  \
            sh3[i22] = getSh(splatOffset, key);\\n            }\\n            \
encodeSh3Rgb(extra.sh3, i2, sh3, splatEncoding);\\n          }\\n        }\\n \
     }\\n      sectionBase += storageSizeBytes;\\n    }\\n    return { \
packedArray, numSplats, extra };\\n  }\\n  const PLY_PROPERTY_TYPES = [\\n    \
\"char\",\\n    \"uchar\",\\n    \"short\",\\n    \"ushort\",\\n    \
\"int\",\\n    \"uint\",\\n    \"float\",\\n    \"double\"\\n  ];\\n  const \
_PlyReader = class _PlyReader {\\n    // Create a PlyReader from a \
Uint8Array/ArrayBuffer, no parsing done yet\\n    constructor({ fileBytes }) \
{\\n      this.header = \"\";\\n      this.littleEndian = true;\\n      \
this.elements = {};\\n      this.comments = [];\\n      this.data = null;\\n  \
    this.numSplats = 0;\\n      this.fileBytes = fileBytes instanceof \
ArrayBuffer ? new Uint8Array(fileBytes) : fileBytes;\\n    }\\n    // \
Identify and parse the PLY text header (assumed to be <64KB in size).\\n    \
// this.elements will contain all the elements in the file, typically\\n    \
// \"vertex\" contains the Gsplat data.\\n    async parseHeader() {\\n      \
const bufferStream = new ReadableStream({\\n        start: (controller) => \
{\\n          controller.enqueue(this.fileBytes.slice(0, 65536));\\n          \
controller.close();\\n        }\\n      });\\n      const decoder = \
bufferStream.pipeThrough(new TextDecoderStream()).getReader();\\n      \
this.header = \"\";\\n      const headerTerminator = \"end_header\\\\n\";\\n  \
    while (true) {\\n        const { value, done } = await decoder.read();\\n \
       if (done) {\\n          throw new Error(\"Failed to read header\");\\n \
       }\\n        this.header += value;\\n        const endHeader = \
this.header.indexOf(headerTerminator);\\n        if (endHeader >= 0) {\\n     \
     this.header = this.header.slice(0, endHeader + \
headerTerminator.length);\\n          break;\\n        }\\n      }\\n      \
const headerLen = new TextEncoder().encode(this.header).length;\\n      \
this.data = new DataView(this.fileBytes.buffer, headerLen);\\n      \
this.elements = {};\\n      let curElement = null;\\n      this.comments = \
[];\\n      this.header.trim().split(\"\\\\n\").forEach((line, lineIndex) => \
{\\n        const trimmedLine = line.trim();\\n        if (lineIndex === 0) \
{\\n          if (trimmedLine !== \"ply\") {\\n            throw new \
Error(\"Invalid PLY header\");\\n          }\\n          return;\\n        \
}\\n        if (trimmedLine.length === 0) {\\n          return;\\n        \
}\\n        const fields = trimmedLine.split(\" \");\\n        switch \
(fields[0]) {\\n          case \"format\":\\n            if (fields[1] === \
\"binary_little_endian\") {\\n              this.littleEndian = true;\\n      \
      } else if (fields[1] === \"binary_big_endian\") {\\n              \
this.littleEndian = false;\\n            } else {\\n              throw new \
Error(`Unsupported PLY format: ${fields[1]}`);\\n            }\\n            \
if (fields[2] !== \"1.0\") {\\n              throw new Error(`Unsupported PLY \
version: ${fields[2]}`);\\n            }\\n            break;\\n          \
case \"end_header\":\\n            break;\\n          case \"comment\":\\n    \
        this.comments.push(trimmedLine.slice(\"comment \".length));\\n        \
    break;\\n          case \"element\": {\\n            const name = \
fields[1];\\n            curElement = {\\n              name,\\n              \
count: Number.parseInt(fields[2]),\\n              properties: {}\\n          \
  };\\n            this.elements[name] = curElement;\\n            break;\\n  \
        }\\n          case \"property\":\\n            if (curElement == \
null) {\\n              throw new Error(\"Property must be inside an \
element\");\\n            }\\n            if (fields[1] === \"list\") {\\n    \
          curElement.properties[fields[4]] = {\\n                isList: \
true,\\n                type: fields[3],\\n                countType: \
fields[2]\\n              };\\n            } else {\\n              \
curElement.properties[fields[2]] = {\\n                isList: false,\\n      \
          type: fields[1]\\n              };\\n            }\\n            \
break;\\n        }\\n      });\\n      if (this.elements.vertex) {\\n        \
this.numSplats = this.elements.vertex.count;\\n      }\\n    }\\n    \
parseData(elementCallback) {\\n      let offset = 0;\\n      const data = \
this.data;\\n      if (data == null) {\\n        throw new Error(\"No data to \
parse\");\\n      }\\n      for (const elementName in this.elements) {\\n     \
   const element = this.elements[elementName];\\n        const { count, \
properties } = element;\\n        const item = \
createEmptyItem(properties);\\n        const parseFn = \
createParseFn(properties, this.littleEndian);\\n        const callback = \
elementCallback(element) ?? (() => {\\n        });\\n        for (let index = \
0; index < count; index++) {\\n          offset = parseFn(data, offset, \
item);\\n          callback(index, item);\\n        }\\n      }\\n    }\\n    \
// Parse all the Gsplat data in the PLY file in go, invoking the given\\n    \
// callbacks for each Gsplat.\\n    parseSplats(splatCallback, shCallback) \
{\\n      if (this.elements.vertex == null) {\\n        throw new Error(\"No \
vertex element found\");\\n      }\\n      let isSuperSplat = false;\\n      \
const ssChunks = [];\\n      let numSh = 0;\\n      let sh1Props = [];\\n     \
 let sh2Props = [];\\n      let sh3Props = [];\\n      let sh1 = void 0;\\n   \
   let sh2 = void 0;\\n      let sh3 = void 0;\\n      function prepareSh() \
{\\n        const num_f_rest = NUM_SH_TO_NUM_F_REST[numSh];\\n        \
sh1Props = new Array(3).fill(null).flatMap((_, k) => [0, 1, 2].map((_2, d) => \
k + d * num_f_rest / 3));\\n        sh2Props = new \
Array(5).fill(null).flatMap(\\n          (_, k) => [0, 1, 2].map((_2, d) => 3 \
+ k + d * num_f_rest / 3)\\n        );\\n        sh3Props = new \
Array(7).fill(null).flatMap(\\n          (_, k) => [0, 1, 2].map((_2, d) => 8 \
+ k + d * num_f_rest / 3)\\n        );\\n        sh1 = numSh >= 1 ? new \
Float32Array(3 * 3) : void 0;\\n        sh2 = numSh >= 2 ? new Float32Array(5 \
* 3) : void 0;\\n        sh3 = numSh >= 3 ? new Float32Array(7 * 3) : void \
0;\\n      }\\n      function ssShCallback(index, item) {\\n        if (!sh1) \
{\\n          throw new Error(\"Missing sh1\");\\n        }\\n        const \
sh = item.f_rest;\\n        for (let i2 = 0; i2 < sh1Props.length; i2++) {\\n \
         sh1[i2] = sh[sh1Props[i2]] * 8 / 255 - 4;\\n        }\\n        if \
(sh2) {\\n          for (let i2 = 0; i2 < sh2Props.length; i2++) {\\n         \
   sh2[i2] = sh[sh2Props[i2]] * 8 / 255 - 4;\\n          }\\n        }\\n     \
   if (sh3) {\\n          for (let i2 = 0; i2 < sh3Props.length; i2++) {\\n   \
         sh3[i2] = sh[sh3Props[i2]] * 8 / 255 - 4;\\n          }\\n        \
}\\n        shCallback == null ? void 0 : shCallback(index, sh1, sh2, \
sh3);\\n      }\\n      function initSuperSplat(element) {\\n        const \
{\\n          min_x,\\n          min_y,\\n          min_z,\\n          \
max_x,\\n          max_y,\\n          max_z,\\n          min_scale_x,\\n      \
    min_scale_y,\\n          min_scale_z,\\n          max_scale_x,\\n         \
 max_scale_y,\\n          max_scale_z\\n        } = element.properties;\\n    \
    if (!min_x || !min_y || !min_z || !max_x || !max_y || !max_z || \
!min_scale_x || !min_scale_y || !min_scale_z || !max_scale_x || !max_scale_y \
|| !max_scale_z) {\\n          throw new Error(\"Missing PLY chunk \
properties\");\\n        }\\n        isSuperSplat = true;\\n        return \
(index, item) => {\\n          const {\\n            min_x: min_x2,\\n        \
    min_y: min_y2,\\n            min_z: min_z2,\\n            max_x: \
max_x2,\\n            max_y: max_y2,\\n            max_z: max_z2,\\n          \
  min_scale_x: min_scale_x2,\\n            min_scale_y: min_scale_y2,\\n      \
      min_scale_z: min_scale_z2,\\n            max_scale_x: max_scale_x2,\\n  \
          max_scale_y: max_scale_y2,\\n            max_scale_z: \
max_scale_z2,\\n            min_r,\\n            min_g,\\n            \
min_b,\\n            max_r,\\n            max_g,\\n            max_b\\n       \
   } = item;\\n          ssChunks.push({\\n            min_x: min_x2,\\n      \
      min_y: min_y2,\\n            min_z: min_z2,\\n            max_x: \
max_x2,\\n            max_y: max_y2,\\n            max_z: max_z2,\\n          \
  min_scale_x: min_scale_x2,\\n            min_scale_y: min_scale_y2,\\n      \
      min_scale_z: min_scale_z2,\\n            max_scale_x: max_scale_x2,\\n  \
          max_scale_y: max_scale_y2,\\n            max_scale_z: \
max_scale_z2,\\n            min_r,\\n            min_g,\\n            \
min_b,\\n            max_r,\\n            max_g,\\n            max_b\\n       \
   });\\n        };\\n      }\\n      function decodeSuperSplat(element) {\\n \
       if (shCallback && element.name === \"sh\") {\\n          numSh = \
getNumSh(element.properties);\\n          prepareSh();\\n          return \
ssShCallback;\\n        }\\n        if (element.name !== \"vertex\") {\\n     \
     return null;\\n        }\\n        const { packed_position, \
packed_rotation, packed_scale, packed_color } = element.properties;\\n        \
if (!packed_position || !packed_rotation || !packed_scale || !packed_color) \
{\\n          throw new Error(\\n            \"Missing PLY properties: \
packed_position, packed_rotation, packed_scale, packed_color\"\\n          \
);\\n        }\\n        const SQRT2 = Math.sqrt(2);\\n        return (index, \
item) => {\\n          const chunk = ssChunks[index >>> 8];\\n          if \
(chunk == null) {\\n            throw new Error(\"Missing PLY chunk\");\\n    \
      }\\n          const {\\n            min_x,\\n            min_y,\\n      \
      min_z,\\n            max_x,\\n            max_y,\\n            \
max_z,\\n            min_scale_x,\\n            min_scale_y,\\n            \
min_scale_z,\\n            max_scale_x,\\n            max_scale_y,\\n         \
   max_scale_z,\\n            min_r,\\n            min_g,\\n            \
min_b,\\n            max_r,\\n            max_g,\\n            max_b\\n       \
   } = chunk;\\n          const { packed_position: packed_position2, \
packed_rotation: packed_rotation2, packed_scale: packed_scale2, packed_color: \
packed_color2 } = item;\\n          const x2 = (packed_position2 >>> 21 & \
2047) / 2047 * (max_x - min_x) + min_x;\\n          const y = \
(packed_position2 >>> 11 & 1023) / 1023 * (max_y - min_y) + min_y;\\n         \
 const z = (packed_position2 & 2047) / 2047 * (max_z - min_z) + min_z;\\n     \
     const r0 = ((packed_rotation2 >>> 20 & 1023) / 1023 - 0.5) * SQRT2;\\n   \
       const r1 = ((packed_rotation2 >>> 10 & 1023) / 1023 - 0.5) * SQRT2;\\n \
         const r2 = ((packed_rotation2 & 1023) / 1023 - 0.5) * SQRT2;\\n      \
    const rr = Math.sqrt(Math.max(0, 1 - r0 * r0 - r1 * r1 - r2 * r2));\\n    \
      const rOrder = packed_rotation2 >>> 30;\\n          const quatX = \
rOrder === 0 ? r0 : rOrder === 1 ? rr : r1;\\n          const quatY = rOrder \
<= 1 ? r1 : rOrder === 2 ? rr : r2;\\n          const quatZ = rOrder <= 2 ? \
r2 : rr;\\n          const quatW = rOrder === 0 ? rr : r0;\\n          const \
scaleX = Math.exp(\\n            (packed_scale2 >>> 21 & 2047) / 2047 * \
(max_scale_x - min_scale_x) + min_scale_x\\n          );\\n          const \
scaleY = Math.exp(\\n            (packed_scale2 >>> 11 & 1023) / 1023 * \
(max_scale_y - min_scale_y) + min_scale_y\\n          );\\n          const \
scaleZ = Math.exp(\\n            (packed_scale2 & 2047) / 2047 * (max_scale_z \
- min_scale_z) + min_scale_z\\n          );\\n          const r = \
(packed_color2 >>> 24 & 255) / 255 * ((max_r ?? 1) - (min_r ?? 0)) + (min_r \
?? 0);\\n          const g = (packed_color2 >>> 16 & 255) / 255 * ((max_g ?? \
1) - (min_g ?? 0)) + (min_g ?? 0);\\n          const b = (packed_color2 >>> 8 \
& 255) / 255 * ((max_b ?? 1) - (min_b ?? 0)) + (min_b ?? 0);\\n          \
const opacity = (packed_color2 & 255) / 255;\\n          splatCallback(\\n    \
        index,\\n            x2,\\n            y,\\n            z,\\n         \
   scaleX,\\n            scaleY,\\n            scaleZ,\\n            \
quatX,\\n            quatY,\\n            quatZ,\\n            quatW,\\n      \
      opacity,\\n            r,\\n            g,\\n            b\\n          \
);\\n        };\\n      }\\n      const elementCallback = (element) => {\\n   \
     if (element.name === \"chunk\") {\\n          return \
initSuperSplat(element);\\n        }\\n        if (isSuperSplat) {\\n         \
 return decodeSuperSplat(element);\\n        }\\n        if (element.name !== \
\"vertex\") {\\n          return null;\\n        }\\n        const {\\n       \
   x: x2,\\n          y,\\n          z,\\n          scale_0,\\n          \
scale_1,\\n          scale_2,\\n          rot_0,\\n          rot_1,\\n        \
  rot_2,\\n          rot_3,\\n          opacity,\\n          f_dc_0,\\n       \
   f_dc_1,\\n          f_dc_2,\\n          red,\\n          green,\\n         \
 blue,\\n          alpha\\n        } = element.properties;\\n        if (!x2 \
|| !y || !z) {\\n          throw new Error(\"Missing PLY properties: x, y, \
z\");\\n        }\\n        const hasScales = scale_0 && scale_1 && \
scale_2;\\n        const hasRots = rot_0 && rot_1 && rot_2 && rot_3;\\n       \
 const alphaDiv = alpha != null ? FIELD_SCALE[alpha.type] : 1;\\n        \
const redDiv = red != null ? FIELD_SCALE[red.type] : 1;\\n        const \
greenDiv = green != null ? FIELD_SCALE[green.type] : 1;\\n        const \
blueDiv = blue != null ? FIELD_SCALE[blue.type] : 1;\\n        numSh = \
getNumSh(element.properties);\\n        prepareSh();\\n        return (index, \
item) => {\\n          const scaleX = hasScales ? Math.exp(item.scale_0) : \
_PlyReader.defaultPointScale;\\n          const scaleY = hasScales ? \
Math.exp(item.scale_1) : _PlyReader.defaultPointScale;\\n          const \
scaleZ = hasScales ? Math.exp(item.scale_2) : \
_PlyReader.defaultPointScale;\\n          const quatX = hasRots ? item.rot_1 \
: 0;\\n          const quatY = hasRots ? item.rot_2 : 0;\\n          const \
quatZ = hasRots ? item.rot_3 : 0;\\n          const quatW = hasRots ? \
item.rot_0 : 1;\\n          const op = opacity != null ? 1 / (1 + \
Math.exp(-item.opacity)) : alpha != null ? item.alpha / alphaDiv : 1;\\n      \
    const r = f_dc_0 != null ? item.f_dc_0 * SH_C0$1 + 0.5 : red != null ? \
item.red / redDiv : 1;\\n          const g = f_dc_1 != null ? item.f_dc_1 * \
SH_C0$1 + 0.5 : green != null ? item.green / greenDiv : 1;\\n          const \
b = f_dc_2 != null ? item.f_dc_2 * SH_C0$1 + 0.5 : blue != null ? item.blue / \
blueDiv : 1;\\n          splatCallback(\\n            index,\\n            \
item.x,\\n            item.y,\\n            item.z,\\n            scaleX,\\n  \
          scaleY,\\n            scaleZ,\\n            quatX,\\n            \
quatY,\\n            quatZ,\\n            quatW,\\n            op,\\n         \
   r,\\n            g,\\n            b\\n          );\\n          if \
(shCallback && sh1) {\\n            const sh = item.f_rest;\\n            if \
(sh1) {\\n              for (let i2 = 0; i2 < sh1Props.length; i2++) {\\n     \
           sh1[i2] = sh[sh1Props[i2]];\\n              }\\n            }\\n   \
         if (sh2) {\\n              for (let i2 = 0; i2 < sh2Props.length; \
i2++) {\\n                sh2[i2] = sh[sh2Props[i2]];\\n              }\\n    \
        }\\n            if (sh3) {\\n              for (let i2 = 0; i2 < \
sh3Props.length; i2++) {\\n                sh3[i2] = sh[sh3Props[i2]];\\n     \
         }\\n            }\\n            shCallback(index, sh1, sh2, sh3);\\n \
         }\\n        };\\n      };\\n      \
this.parseData(elementCallback);\\n    }\\n    // Inject RGBA values into \
original PLY file, which can be used to modify\\n    // the color/opacity of \
the Gsplats and write out the modified PLY file.\\n    injectRgba(rgba) {\\n  \
    let offset = 0;\\n      const data = this.data;\\n      if (data == null) \
{\\n        throw new Error(\"No parsed data\");\\n      }\\n      if \
(rgba.length !== this.numSplats * 4) {\\n        throw new Error(\"Invalid \
RGBA array length\");\\n      }\\n      for (const elementName in \
this.elements) {\\n        const element = this.elements[elementName];\\n     \
   const { count, properties } = element;\\n        const parsers = [];\\n    \
    let rgbaOffset = 0;\\n        const isVertex = elementName === \
\"vertex\";\\n        if (isVertex) {\\n          for (const name of \
[\"opacity\", \"f_dc_0\", \"f_dc_1\", \"f_dc_2\"]) {\\n            if \
(!properties[name] || properties[name].type !== \"float\") {\\n              \
throw new Error(`Can\\'t injectRgba due to property: ${name}`);\\n            \
}\\n          }\\n        }\\n        for (const [propertyName, property] of \
Object.entries(properties)) {\\n          if (!property.isList) {\\n          \
  if (isVertex) {\\n              if (propertyName === \"f_dc_0\" || \
propertyName === \"f_dc_1\" || propertyName === \"f_dc_2\") {\\n              \
  const component = Number.parseInt(\\n                  \
propertyName.slice(\"f_dc_\".length)\\n                );\\n                \
parsers.push(() => {\\n                  const value = (rgba[rgbaOffset + \
component] / 255 - 0.5) / SH_C0$1;\\n                  \
SET_FIELD[property.type](\\n                    data,\\n                    \
offset,\\n                    this.littleEndian,\\n                    \
value\\n                  );\\n                });\\n              } else if \
(propertyName === \"opacity\") {\\n                parsers.push(() => {\\n    \
              const value = Math.max(\\n                    -100,\\n          \
          Math.min(\\n                      100,\\n                      \
-Math.log(1 / (rgba[rgbaOffset + 3] / 255) - 1)\\n                    )\\n    \
              );\\n                  SET_FIELD[property.type](\\n             \
       data,\\n                    offset,\\n                    \
this.littleEndian,\\n                    value\\n                  );\\n      \
          });\\n              }\\n            }\\n            parsers.push(() \
=> {\\n              offset += FIELD_BYTES[property.type];\\n            \
});\\n          } else {\\n            parsers.push(() => {\\n              \
const length = PARSE_FIELD[property.countType](\\n                data,\\n    \
            offset,\\n                this.littleEndian\\n              );\\n \
             offset += FIELD_BYTES[property.countType];\\n              \
offset += length * FIELD_BYTES[property.type];\\n            });\\n          \
}\\n        }\\n        for (let index = 0; index < count; index++) {\\n      \
    for (const parser of parsers) {\\n            parser();\\n          }\\n  \
        if (isVertex) {\\n            rgbaOffset += 4;\\n          }\\n       \
 }\\n      }\\n    }\\n  };\\n  _PlyReader.defaultPointScale = 1e-3;\\n  let \
PlyReader = _PlyReader;\\n  const SH_C0$1 = 0.28209479177387814;\\n  const \
PARSE_FIELD = {\\n    char: (data, offset, littleEndian) => {\\n      return \
data.getInt8(offset);\\n    },\\n    uchar: (data, offset, littleEndian) => \
{\\n      return data.getUint8(offset);\\n    },\\n    short: (data, offset, \
littleEndian) => {\\n      return data.getInt16(offset, littleEndian);\\n    \
},\\n    ushort: (data, offset, littleEndian) => {\\n      return \
data.getUint16(offset, littleEndian);\\n    },\\n    int: (data, offset, \
littleEndian) => {\\n      return data.getInt32(offset, littleEndian);\\n    \
},\\n    uint: (data, offset, littleEndian) => {\\n      return \
data.getUint32(offset, littleEndian);\\n    },\\n    float: (data, offset, \
littleEndian) => {\\n      return data.getFloat32(offset, littleEndian);\\n   \
 },\\n    double: (data, offset, littleEndian) => {\\n      return \
data.getFloat64(offset, littleEndian);\\n    }\\n  };\\n  const SET_FIELD = \
{\\n    char: (data, offset, littleEndian, value) => {\\n      \
data.setInt8(offset, value);\\n    },\\n    uchar: (data, offset, \
littleEndian, value) => {\\n      data.setUint8(offset, value);\\n    },\\n   \
 short: (data, offset, littleEndian, value) => {\\n      \
data.setInt16(offset, value, littleEndian);\\n    },\\n    ushort: (data, \
offset, littleEndian, value) => {\\n      data.setUint16(offset, value, \
littleEndian);\\n    },\\n    int: (data, offset, littleEndian, value) => \
{\\n      data.setInt32(offset, value, littleEndian);\\n    },\\n    uint: \
(data, offset, littleEndian, value) => {\\n      data.setUint32(offset, \
value, littleEndian);\\n    },\\n    float: (data, offset, littleEndian, \
value) => {\\n      data.setFloat32(offset, value, littleEndian);\\n    },\\n \
   double: (data, offset, littleEndian, value) => {\\n      \
data.setFloat64(offset, value, littleEndian);\\n    }\\n  };\\n  const \
FIELD_BYTES = {\\n    char: 1,\\n    uchar: 1,\\n    short: 2,\\n    ushort: \
2,\\n    int: 4,\\n    uint: 4,\\n    float: 4,\\n    double: 8\\n  };\\n  \
const FIELD_SCALE = {\\n    char: 127,\\n    uchar: 255,\\n    short: \
32767,\\n    ushort: 65535,\\n    int: 2147483647,\\n    uint: 4294967295,\\n \
   float: 1,\\n    double: 1\\n  };\\n  const NUM_F_REST_TO_NUM_SH = {\\n    \
0: 0,\\n    9: 1,\\n    24: 2,\\n    45: 3\\n  };\\n  const \
NUM_SH_TO_NUM_F_REST = {\\n    0: 0,\\n    1: 9,\\n    2: 24,\\n    3: 45\\n  \
};\\n  const F_REST_REGEX = /^f_rest_([0-9]{1,2})$/;\\n  function \
createEmptyItem(properties) {\\n    const item = {};\\n    for (const \
[propertyName, property] of Object.entries(properties)) {\\n      if \
(F_REST_REGEX.test(propertyName)) {\\n        item.f_rest = new \
Array(getNumSh(properties));\\n      } else {\\n        item[propertyName] = \
property.isList ? [] : 0;\\n      }\\n    }\\n    return item;\\n  }\\n  \
function createParseFn(properties, littleEndian) {\\n    if \
(safeToCompile(properties)) {\\n      return \
createCompiledParserFn(properties, littleEndian);\\n    }\\n    return \
createDynamicParserFn(properties, littleEndian);\\n  }\\n  const \
UNSAFE_EVAL_ALLOWED = (() => {\\n    try {\\n      new Function(\"return \
42;\");\\n    } catch (e) {\\n      return false;\\n    }\\n    return \
true;\\n  })();\\n  const PROPERTY_NAME_REGEX = /^[a-zA-Z0-9_]+$/;\\n  \
function safeToCompile(properties) {\\n    if (!UNSAFE_EVAL_ALLOWED) {\\n     \
 return false;\\n    }\\n    for (const [propertyName, property] of \
Object.entries(properties)) {\\n      if \
(!PROPERTY_NAME_REGEX.test(propertyName)) {\\n        return false;\\n      \
}\\n      if (property.isList && \
!PLY_PROPERTY_TYPES.includes(property.countType)) {\\n        return \
false;\\n      }\\n      if (!PLY_PROPERTY_TYPES.includes(property.type)) \
{\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n  \
function createCompiledParserFn(properties, littleEndian) {\\n    const \
parserSrc = [\"let list;\"];\\n    for (const [propertyName, property] of \
Object.entries(properties)) {\\n      const fRestMatch = \
propertyName.match(F_REST_REGEX);\\n      if (fRestMatch) {\\n        const \
fRestIndex = +fRestMatch[1];\\n        parserSrc.push(\\n          /*js*/\\n  \
        `\\n        item.f_rest[${fRestIndex}] = \
PARSE_FIELD[\\'${property.type}\\'](data, offset, ${littleEndian});\\n        \
offset += ${FIELD_BYTES[property.type]};\\n      `\\n        );\\n      } \
else if (!property.isList) {\\n        parserSrc.push(\\n          /*js*/\\n  \
        `\\n        item[\\'${propertyName}\\'] = \
PARSE_FIELD[\\'${property.type}\\'](data, offset, ${littleEndian});\\n        \
offset += ${FIELD_BYTES[property.type]};\\n      `\\n        );\\n      } \
else {\\n        parserSrc.push(\\n          /*js*/\\n          `\\n        \
list = item[\\'${propertyName}\\'];\\n        list.length = \
PARSE_FIELD[\\'${property.countType}\\'](data, offset, ${littleEndian});\\n   \
     offset += ${FIELD_BYTES[property.countType]};\\n        for (let i = 0; \
i < list.length; i++) {\\n          list[i] = \
PARSE_FIELD[\\'${property.type}\\'](data, offset, ${littleEndian});\\n        \
  offset += ${FIELD_BYTES[property.type]};\\n        }\\n      `\\n        \
);\\n      }\\n    }\\n    parserSrc.push(\"return offset;\");\\n    const fn \
= new Function(\\n      \"data\",\\n      \"offset\",\\n      \"item\",\\n    \
  \"PARSE_FIELD\",\\n      parserSrc.join(\"\\\\n\")\\n    );\\n    return \
(data, offset, item) => fn(data, offset, item, PARSE_FIELD);\\n  }\\n  \
function createDynamicParserFn(properties, littleEndian) {\\n    const \
parsers = [];\\n    for (const [propertyName, property] of \
Object.entries(properties)) {\\n      const fRestMatch = \
propertyName.match(F_REST_REGEX);\\n      if (fRestMatch) {\\n        const \
fRestIndex = +fRestMatch[1];\\n        parsers.push(\\n          (data, \
offset, item) => {\\n            item.f_rest[fRestIndex] = \
PARSE_FIELD[property.type](\\n              data,\\n              offset,\\n  \
            littleEndian\\n            );\\n            return offset + \
FIELD_BYTES[property.type];\\n          }\\n        );\\n      } else if \
(!property.isList) {\\n        parsers.push(\\n          (data, offset, item) \
=> {\\n            item[propertyName] = PARSE_FIELD[property.type](\\n        \
      data,\\n              offset,\\n              littleEndian\\n           \
 );\\n            return offset + FIELD_BYTES[property.type];\\n          \
}\\n        );\\n      } else {\\n        parsers.push(\\n          (data, \
offset, item) => {\\n            const list = item[propertyName];\\n          \
  list.length = PARSE_FIELD[property.countType](\\n              data,\\n     \
         offset,\\n              littleEndian\\n            );\\n            \
let currentOffset = offset + FIELD_BYTES[property.countType];\\n            \
for (let i2 = 0; i2 < list.length; i2++) {\\n              list[i2] = \
PARSE_FIELD[property.type](\\n                data,\\n                \
currentOffset,\\n                littleEndian\\n              );\\n           \
   currentOffset += FIELD_BYTES[property.type];\\n            }\\n            \
return currentOffset;\\n          }\\n        );\\n      }\\n    }\\n    \
return (data, offset, item) => {\\n      let currentOffset = offset;\\n      \
for (let parserIndex = 0; parserIndex < parsers.length; parserIndex++) {\\n   \
     currentOffset = parsers[parserIndex](data, currentOffset, item);\\n      \
}\\n      return currentOffset;\\n    };\\n  }\\n  function \
getNumSh(properties) {\\n    let num_f_rest = 0;\\n    while \
(properties[`f_rest_${num_f_rest}`]) {\\n      num_f_rest += 1;\\n    }\\n    \
const numSh = NUM_F_REST_TO_NUM_SH[num_f_rest];\\n    if (numSh == null) {\\n \
     throw new Error(`Unsupported number of SH coefficients: \
${num_f_rest}`);\\n    }\\n    return numSh;\\n  }\\n  var SplatFileType = /* \
@__PURE__ */ ((SplatFileType2) => {\\n    SplatFileType2[\"PLY\"] = \
\"ply\";\\n    SplatFileType2[\"SPZ\"] = \"spz\";\\n    \
SplatFileType2[\"SPLAT\"] = \"splat\";\\n    SplatFileType2[\"KSPLAT\"] = \
\"ksplat\";\\n    SplatFileType2[\"PCSOGS\"] = \"pcsogs\";\\n    \
SplatFileType2[\"PCSOGSZIP\"] = \"pcsogszip\";\\n    return \
SplatFileType2;\\n  })(SplatFileType || {});\\n  function \
getSplatFileType(fileBytes) {\\n    const view = new \
DataView(fileBytes.buffer);\\n    if ((view.getUint32(0, true) & 16777215) \
=== 7957616) {\\n      return \"ply\";\\n    }\\n    if ((view.getUint32(0, \
true) & 16777215) === 559903) {\\n      const header = \
decompressPartialGzip(fileBytes, 4);\\n      const gView = new \
DataView(header.buffer);\\n      if (gView.getUint32(0, true) === 1347635022) \
{\\n        return \"spz\";\\n      }\\n      return void 0;\\n    }\\n    if \
(view.getUint32(0, true) === 67324752) {\\n      if (tryPcSogsZip(fileBytes)) \
{\\n        return \"pcsogszip\";\\n      }\\n      return void 0;\\n    }\\n \
   return void 0;\\n  }\\n  function getFileExtension(pathOrUrl) {\\n    \
const noTrailing = pathOrUrl.split(/[?#]/, 1)[0];\\n    const lastSlash = \
Math.max(\\n      noTrailing.lastIndexOf(\"/\"),\\n      \
noTrailing.lastIndexOf(\"\\\\\\\\\")\\n    );\\n    const filename = \
noTrailing.slice(lastSlash + 1);\\n    const lastDot = \
filename.lastIndexOf(\".\");\\n    if (lastDot <= 0 || lastDot === \
filename.length - 1) {\\n      return \"\";\\n    }\\n    return \
filename.slice(lastDot + 1).toLowerCase();\\n  }\\n  function \
getSplatFileTypeFromPath(pathOrUrl) {\\n    const extension = \
getFileExtension(pathOrUrl);\\n    if (extension === \"ply\") {\\n      \
return \"ply\";\\n    }\\n    if (extension === \"spz\") {\\n      return \
\"spz\";\\n    }\\n    if (extension === \"splat\") {\\n      return \
\"splat\";\\n    }\\n    if (extension === \"ksplat\") {\\n      return \
\"ksplat\";\\n    }\\n    if (extension === \"sog\") {\\n      return \
\"pcsogszip\";\\n    }\\n    return void 0;\\n  }\\n  function \
tryPcSogs(input) {\\n    try {\\n      let text;\\n      if (typeof input === \
\"string\") {\\n        text = input;\\n      } else {\\n        const \
fileBytes = input instanceof ArrayBuffer ? new Uint8Array(input) : input;\\n  \
      if (fileBytes.length > 65536) {\\n          return void 0;\\n        \
}\\n        text = new TextDecoder().decode(fileBytes);\\n      }\\n      \
const json = JSON.parse(text);\\n      if (!json || typeof json !== \
\"object\" || Array.isArray(json)) {\\n        return void 0;\\n      }\\n    \
  const isVersion2 = json.version === 2;\\n      for (const key of \
[\"means\", \"scales\", \"quats\", \"sh0\"]) {\\n        if (!json[key] || \
typeof json[key] !== \"object\" || Array.isArray(json[key])) {\\n          \
return void 0;\\n        }\\n        if (isVersion2) {\\n          if \
(!json[key].files) {\\n            return void 0;\\n          }\\n          \
if ((key === \"scales\" || key === \"sh0\") && !json[key].codebook) {\\n      \
      return void 0;\\n          }\\n          if (key === \"means\" && \
(!json[key].mins || !json[key].maxs)) {\\n            return void 0;\\n       \
   }\\n        } else {\\n          if (!json[key].shape || !json[key].files) \
{\\n            return void 0;\\n          }\\n          if (key !== \
\"quats\" && (!json[key].mins || !json[key].maxs)) {\\n            return \
void 0;\\n          }\\n        }\\n      }\\n      return json;\\n    } \
catch {\\n      return void 0;\\n    }\\n  }\\n  function tryPcSogsZip(input) \
{\\n    try {\\n      const fileBytes = input instanceof ArrayBuffer ? new \
Uint8Array(input) : input;\\n      let metaFilename = null;\\n      const \
unzipped = unzipSync(fileBytes, {\\n        filter: ({ name }) => {\\n        \
  const filename = name.split(/[\\\\\\\\/]/).pop();\\n          if (filename \
=== \"meta.json\") {\\n            metaFilename = name;\\n            return \
true;\\n          }\\n          return false;\\n        }\\n      });\\n      \
if (!metaFilename) {\\n        return void 0;\\n      }\\n      const json = \
tryPcSogs(unzipped[metaFilename]);\\n      if (!json) {\\n        return void \
0;\\n      }\\n      return { name: metaFilename, json };\\n    } catch {\\n  \
    return void 0;\\n    }\\n  }\\n  class SplatData {\\n    constructor({ \
maxSplats = 1 } = {}) {\\n      this.numSplats = 0;\\n      this.maxSplats = \
getTextureSize(maxSplats).maxSplats;\\n      this.centers = new \
Float32Array(this.maxSplats * 3);\\n      this.scales = new \
Float32Array(this.maxSplats * 3);\\n      this.quaternions = new \
Float32Array(this.maxSplats * 4);\\n      this.opacities = new \
Float32Array(this.maxSplats);\\n      this.colors = new \
Float32Array(this.maxSplats * 3);\\n    }\\n    pushSplat() {\\n      const \
index = this.numSplats;\\n      this.ensureIndex(index);\\n      \
this.numSplats += 1;\\n      return index;\\n    }\\n    unpushSplat(index) \
{\\n      if (index === this.numSplats - 1) {\\n        this.numSplats -= \
1;\\n      } else {\\n        throw new Error(\"Cannot unpush splat from \
non-last position\");\\n      }\\n    }\\n    ensureCapacity(numSplats) {\\n  \
    if (numSplats > this.maxSplats) {\\n        const targetSplats = \
Math.max(numSplats, this.maxSplats * 2);\\n        const newCenters = new \
Float32Array(targetSplats * 3);\\n        const newScales = new \
Float32Array(targetSplats * 3);\\n        const newQuaternions = new \
Float32Array(targetSplats * 4);\\n        const newOpacities = new \
Float32Array(targetSplats);\\n        const newColors = new \
Float32Array(targetSplats * 3);\\n        newCenters.set(this.centers);\\n    \
    newScales.set(this.scales);\\n        \
newQuaternions.set(this.quaternions);\\n        \
newOpacities.set(this.opacities);\\n        newColors.set(this.colors);\\n    \
    this.centers = newCenters;\\n        this.scales = newScales;\\n        \
this.quaternions = newQuaternions;\\n        this.opacities = \
newOpacities;\\n        this.colors = newColors;\\n        if (this.sh1) {\\n \
         const newSh1 = new Float32Array(targetSplats * 9);\\n          \
newSh1.set(this.sh1);\\n          this.sh1 = newSh1;\\n        }\\n        if \
(this.sh2) {\\n          const newSh2 = new Float32Array(targetSplats * \
15);\\n          newSh2.set(this.sh2);\\n          this.sh2 = newSh2;\\n      \
  }\\n        if (this.sh3) {\\n          const newSh3 = new \
Float32Array(targetSplats * 21);\\n          newSh3.set(this.sh3);\\n         \
 this.sh3 = newSh3;\\n        }\\n        this.maxSplats = targetSplats;\\n   \
   }\\n    }\\n    ensureIndex(index) {\\n      this.ensureCapacity(index + \
1);\\n    }\\n    setCenter(index, x2, y, z) {\\n      this.centers[index * \
3] = x2;\\n      this.centers[index * 3 + 1] = y;\\n      this.centers[index \
* 3 + 2] = z;\\n    }\\n    setScale(index, scaleX, scaleY, scaleZ) {\\n      \
this.scales[index * 3] = scaleX;\\n      this.scales[index * 3 + 1] = \
scaleY;\\n      this.scales[index * 3 + 2] = scaleZ;\\n    }\\n    \
setQuaternion(index, x2, y, z, w) {\\n      this.quaternions[index * 4] = \
x2;\\n      this.quaternions[index * 4 + 1] = y;\\n      \
this.quaternions[index * 4 + 2] = z;\\n      this.quaternions[index * 4 + 3] \
= w;\\n    }\\n    setOpacity(index, opacity) {\\n      this.opacities[index] \
= opacity;\\n    }\\n    setColor(index, r, g, b) {\\n      this.colors[index \
* 3] = r;\\n      this.colors[index * 3 + 1] = g;\\n      this.colors[index * \
3 + 2] = b;\\n    }\\n    setSh1(index, sh1) {\\n      if (!this.sh1) {\\n    \
    this.sh1 = new Float32Array(this.maxSplats * 9);\\n      }\\n      for \
(let j = 0; j < 9; ++j) {\\n        this.sh1[index * 9 + j] = sh1[j];\\n      \
}\\n    }\\n    setSh2(index, sh2) {\\n      if (!this.sh2) {\\n        \
this.sh2 = new Float32Array(this.maxSplats * 15);\\n      }\\n      for (let \
j = 0; j < 15; ++j) {\\n        this.sh2[index * 15 + j] = sh2[j];\\n      \
}\\n    }\\n    setSh3(index, sh3) {\\n      if (!this.sh3) {\\n        \
this.sh3 = new Float32Array(this.maxSplats * 21);\\n      }\\n      for (let \
j = 0; j < 21; ++j) {\\n        this.sh3[index * 21 + j] = sh3[j];\\n      \
}\\n    }\\n  }\\n  async function unpackPcSogs(json, extraFiles, \
splatEncoding) {\\n    const isVersion2 = \"version\" in json;\\n    if \
(!isVersion2 && json.quats.encoding !== \"quaternion_packed\") {\\n      \
throw new Error(\"Unsupported quaternion encoding\");\\n    }\\n    const \
numSplats = isVersion2 ? json.count : json.means.shape[0];\\n    const \
maxSplats = computeMaxSplats(numSplats);\\n    const packedArray = new \
Uint32Array(maxSplats * 4);\\n    const extra = {};\\n    const meansPromise \
= Promise.all([\\n      decodeImageRgba(extraFiles[json.means.files[0]]),\\n  \
    decodeImageRgba(extraFiles[json.means.files[1]])\\n    ]).then((means) => \
{\\n      for (let i2 = 0; i2 < numSplats; ++i2) {\\n        const i4 = i2 * \
4;\\n        const fx = (means[0][i4 + 0] + (means[1][i4 + 0] << 8)) / \
65535;\\n        const fy = (means[0][i4 + 1] + (means[1][i4 + 1] << 8)) / \
65535;\\n        const fz = (means[0][i4 + 2] + (means[1][i4 + 2] << 8)) / \
65535;\\n        let x2 = json.means.mins[0] + (json.means.maxs[0] - \
json.means.mins[0]) * fx;\\n        let y = json.means.mins[1] + \
(json.means.maxs[1] - json.means.mins[1]) * fy;\\n        let z = \
json.means.mins[2] + (json.means.maxs[2] - json.means.mins[2]) * fz;\\n       \
 x2 = Math.sign(x2) * (Math.exp(Math.abs(x2)) - 1);\\n        y = \
Math.sign(y) * (Math.exp(Math.abs(y)) - 1);\\n        z = Math.sign(z) * \
(Math.exp(Math.abs(z)) - 1);\\n        setPackedSplatCenter(packedArray, i2, \
x2, y, z);\\n      }\\n    });\\n    const scalesPromise = \
decodeImageRgba(extraFiles[json.scales.files[0]]).then(\\n      (scales) => \
{\\n        let xLookup;\\n        let yLookup;\\n        let zLookup;\\n     \
   if (isVersion2) {\\n          xLookup = yLookup = zLookup = \
json.scales.codebook.map((x2) => Math.exp(x2));\\n        } else {\\n         \
 xLookup = new Array(256).fill(0).map(\\n            (_, i2) => \
json.scales.mins[0] + (json.scales.maxs[0] - json.scales.mins[0]) * (i2 / \
255)\\n          ).map((x2) => Math.exp(x2));\\n          yLookup = new \
Array(256).fill(0).map(\\n            (_, i2) => json.scales.mins[1] + \
(json.scales.maxs[1] - json.scales.mins[1]) * (i2 / 255)\\n          \
).map((x2) => Math.exp(x2));\\n          zLookup = new \
Array(256).fill(0).map(\\n            (_, i2) => json.scales.mins[2] + \
(json.scales.maxs[2] - json.scales.mins[2]) * (i2 / 255)\\n          \
).map((x2) => Math.exp(x2));\\n        }\\n        for (let i2 = 0; i2 < \
numSplats; ++i2) {\\n          const i4 = i2 * 4;\\n          \
setPackedSplatScales(\\n            packedArray,\\n            i2,\\n         \
   xLookup[scales[i4 + 0]],\\n            yLookup[scales[i4 + 1]],\\n         \
   zLookup[scales[i4 + 2]],\\n            splatEncoding\\n          );\\n     \
   }\\n      }\\n    );\\n    const quatsPromise = \
decodeImageRgba(extraFiles[json.quats.files[0]]).then(\\n      (quats) => \
{\\n        const SQRT2 = Math.sqrt(2);\\n        const lookup = new \
Array(256).fill(0).map((_, i2) => (i2 / 255 - 0.5) * SQRT2);\\n        for \
(let i2 = 0; i2 < numSplats; ++i2) {\\n          const i4 = i2 * 4;\\n        \
  const r0 = lookup[quats[i4 + 0]];\\n          const r1 = lookup[quats[i4 + \
1]];\\n          const r2 = lookup[quats[i4 + 2]];\\n          const rr = \
Math.sqrt(Math.max(0, 1 - r0 * r0 - r1 * r1 - r2 * r2));\\n          const \
rOrder = quats[i4 + 3] - 252;\\n          const quatX = rOrder === 0 ? r0 : \
rOrder === 1 ? rr : r1;\\n          const quatY = rOrder <= 1 ? r1 : rOrder \
=== 2 ? rr : r2;\\n          const quatZ = rOrder <= 2 ? r2 : rr;\\n          \
const quatW = rOrder === 0 ? rr : r0;\\n          \
setPackedSplatQuat(packedArray, i2, quatX, quatY, quatZ, quatW);\\n        \
}\\n      }\\n    );\\n    const sh0Promise = \
decodeImageRgba(extraFiles[json.sh0.files[0]]).then(\\n      (sh0) => {\\n    \
    const SH_C02 = 0.28209479177387814;\\n        let rLookup;\\n        let \
gLookup;\\n        let bLookup;\\n        let aLookup;\\n        if \
(isVersion2) {\\n          rLookup = gLookup = bLookup = \
json.sh0.codebook.map((x2) => SH_C02 * x2 + 0.5);\\n          aLookup = new \
Array(256).fill(0).map((_, i2) => i2 / 255);\\n        } else {\\n          \
rLookup = new Array(256).fill(0).map(\\n            (_, i2) => \
json.sh0.mins[0] + (json.sh0.maxs[0] - json.sh0.mins[0]) * (i2 / 255)\\n      \
    ).map((x2) => SH_C02 * x2 + 0.5);\\n          gLookup = new \
Array(256).fill(0).map(\\n            (_, i2) => json.sh0.mins[1] + \
(json.sh0.maxs[1] - json.sh0.mins[1]) * (i2 / 255)\\n          ).map((x2) => \
SH_C02 * x2 + 0.5);\\n          bLookup = new Array(256).fill(0).map(\\n      \
      (_, i2) => json.sh0.mins[2] + (json.sh0.maxs[2] - json.sh0.mins[2]) * \
(i2 / 255)\\n          ).map((x2) => SH_C02 * x2 + 0.5);\\n          aLookup \
= new Array(256).fill(0).map(\\n            (_, i2) => json.sh0.mins[3] + \
(json.sh0.maxs[3] - json.sh0.mins[3]) * (i2 / 255)\\n          ).map((x2) => \
1 / (1 + Math.exp(-x2)));\\n        }\\n        for (let i2 = 0; i2 < \
numSplats; ++i2) {\\n          const i4 = i2 * 4;\\n          \
setPackedSplatRgba(\\n            packedArray,\\n            i2,\\n           \
 rLookup[sh0[i4 + 0]],\\n            gLookup[sh0[i4 + 1]],\\n            \
bLookup[sh0[i4 + 2]],\\n            aLookup[sh0[i4 + 3]],\\n            \
splatEncoding\\n          );\\n        }\\n      }\\n    );\\n    const \
promises = [meansPromise, scalesPromise, quatsPromise, sh0Promise];\\n    if \
(json.shN) {\\n      const useSH3 = isVersion2 ? json.shN.bands >= 3 : \
json.shN.shape[1] >= 48 - 3;\\n      const useSH2 = isVersion2 ? \
json.shN.bands >= 2 : json.shN.shape[1] >= 27 - 3;\\n      const useSH1 = \
isVersion2 ? json.shN.bands >= 1 : json.shN.shape[1] >= 12 - 3;\\n      if \
(useSH1) extra.sh1 = new Uint32Array(numSplats * 2);\\n      if (useSH2) \
extra.sh2 = new Uint32Array(numSplats * 4);\\n      if (useSH3) extra.sh3 = \
new Uint32Array(numSplats * 4);\\n      const sh1 = new Float32Array(9);\\n   \
   const sh2 = new Float32Array(15);\\n      const sh3 = new \
Float32Array(21);\\n      const shN = json.shN;\\n      const shNPromise = \
Promise.all([\\n        decodeImage(extraFiles[json.shN.files[0]]),\\n        \
decodeImage(extraFiles[json.shN.files[1]])\\n      ]).then(([centroids, \
labels]) => {\\n        const lookup = \"codebook\" in shN ? shN.codebook : \
new Array(256).fill(0).map((_, i2) => shN.mins + (shN.maxs - shN.mins) * (i2 \
/ 255));\\n        for (let i2 = 0; i2 < numSplats; ++i2) {\\n          const \
i4 = i2 * 4;\\n          const label = labels.rgba[i4 + 0] + (labels.rgba[i4 \
+ 1] << 8);\\n          const col = (label & 63) * 15;\\n          const row \
= label >>> 6;\\n          const offset = row * centroids.width + col;\\n     \
     for (let d = 0; d < 3; ++d) {\\n            if (useSH1) {\\n             \
 for (let k = 0; k < 3; ++k) {\\n                sh1[k * 3 + d] = \
lookup[centroids.rgba[(offset + k) * 4 + d]];\\n              }\\n            \
}\\n            if (useSH2) {\\n              for (let k = 0; k < 5; ++k) \
{\\n                sh2[k * 3 + d] = lookup[centroids.rgba[(offset + 3 + k) * \
4 + d]];\\n              }\\n            }\\n            if (useSH3) {\\n     \
         for (let k = 0; k < 7; ++k) {\\n                sh3[k * 3 + d] = \
lookup[centroids.rgba[(offset + 8 + k) * 4 + d]];\\n              }\\n        \
    }\\n          }\\n          if (useSH1)\\n            \
encodeSh1Rgb(extra.sh1, i2, sh1, splatEncoding);\\n          if (useSH2)\\n   \
         encodeSh2Rgb(extra.sh2, i2, sh2, splatEncoding);\\n          if \
(useSH3)\\n            encodeSh3Rgb(extra.sh3, i2, sh3, splatEncoding);\\n    \
    }\\n      });\\n      promises.push(shNPromise);\\n    }\\n    await \
Promise.all(promises);\\n    return { packedArray, numSplats, extra };\\n  \
}\\n  let offscreenGlContext = null;\\n  async function \
decodeImage(fileBytes) {\\n    if (!offscreenGlContext) {\\n      const \
canvas = new OffscreenCanvas(1, 1);\\n      offscreenGlContext = \
canvas.getContext(\"webgl2\");\\n      if (!offscreenGlContext) {\\n        \
throw new Error(\"Failed to create WebGL2 context\");\\n      }\\n    }\\n    \
const imageBlob = new Blob([fileBytes]);\\n    const bitmap = await \
createImageBitmap(imageBlob, {\\n      premultiplyAlpha: \"none\"\\n    \
});\\n    const gl = offscreenGlContext;\\n    const texture = \
gl.createTexture();\\n    gl.bindTexture(gl.TEXTURE_2D, texture);\\n    \
gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\\n    \
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, \
bitmap);\\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, \
gl.NEAREST);\\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, \
gl.NEAREST);\\n    const framebuffer = gl.createFramebuffer();\\n    \
gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\\n    \
gl.framebufferTexture2D(\\n      gl.FRAMEBUFFER,\\n      \
gl.COLOR_ATTACHMENT0,\\n      gl.TEXTURE_2D,\\n      texture,\\n      0\\n    \
);\\n    const data = new Uint8Array(bitmap.width * bitmap.height * 4);\\n    \
gl.readPixels(\\n      0,\\n      0,\\n      bitmap.width,\\n      \
bitmap.height,\\n      gl.RGBA,\\n      gl.UNSIGNED_BYTE,\\n      data\\n    \
);\\n    gl.deleteTexture(texture);\\n    \
gl.deleteFramebuffer(framebuffer);\\n    return { rgba: data, width: \
bitmap.width, height: bitmap.height };\\n  }\\n  async function \
decodeImageRgba(fileBytes) {\\n    const { rgba } = await \
decodeImage(fileBytes);\\n    return rgba;\\n  }\\n  async function \
unpackPcSogsZip(fileBytes, splatEncoding) {\\n    var _a2;\\n    const \
nameJson = tryPcSogsZip(fileBytes);\\n    if (!nameJson) {\\n      throw new \
Error(\"Invalid PC SOGS zip file\");\\n    }\\n    const { name, json } = \
nameJson;\\n    const lastSlash = name.lastIndexOf(\"/\");\\n    const \
lastBackslash = name.lastIndexOf(\"\\\\\\\\\");\\n    const prefix = \
name.slice(0, Math.max(lastSlash, lastBackslash) + 1);\\n    const fileMap = \
/* @__PURE__ */ new Map();\\n    const refFiles = [\\n      \
...json.means.files,\\n      ...json.scales.files,\\n      \
...json.quats.files,\\n      ...json.sh0.files,\\n      ...((_a2 = json.shN) \
== null ? void 0 : _a2.files) ?? []\\n    ];\\n    for (const file of \
refFiles) {\\n      fileMap.set(prefix + file, file);\\n    }\\n    const \
unzipped = await new Promise(\\n      (resolve, reject) => {\\n        \
unzip(\\n          fileBytes,\\n          {\\n            filter: ({ name: \
name2 }) => {\\n              return fileMap.has(name2);\\n            }\\n   \
       },\\n          (err2, files) => {\\n            if (err2) {\\n         \
     reject(err2);\\n            } else {\\n              resolve(files);\\n  \
          }\\n          }\\n        );\\n      }\\n    );\\n    const \
extraFiles = {};\\n    for (const [full, name2] of fileMap.entries()) {\\n    \
  extraFiles[name2] = unzipped[full];\\n    }\\n    return await \
unpackPcSogs(json, extraFiles, splatEncoding);\\n  }\\n  class SpzReader {\\n \
   constructor({ fileBytes }) {\\n      this.version = -1;\\n      \
this.numSplats = 0;\\n      this.shDegree = 0;\\n      this.fractionalBits = \
0;\\n      this.flags = 0;\\n      this.flagAntiAlias = false;\\n      \
this.reserved = 0;\\n      this.headerParsed = false;\\n      this.parsed = \
false;\\n      this.fileBytes = fileBytes instanceof ArrayBuffer ? new \
Uint8Array(fileBytes) : fileBytes;\\n      this.reader = new GunzipReader({ \
fileBytes: this.fileBytes });\\n    }\\n    async parseHeader() {\\n      if \
(this.headerParsed) {\\n        throw new Error(\"SPZ file header already \
parsed\");\\n      }\\n      const header = new DataView((await \
this.reader.read(16)).buffer);\\n      if (header.getUint32(0, true) !== \
1347635022) {\\n        throw new Error(\"Invalid SPZ file\");\\n      }\\n   \
   this.version = header.getUint32(4, true);\\n      if (this.version < 1 || \
this.version > 3) {\\n        throw new Error(`Unsupported SPZ version: \
${this.version}`);\\n      }\\n      this.numSplats = header.getUint32(8, \
true);\\n      this.shDegree = header.getUint8(12);\\n      \
this.fractionalBits = header.getUint8(13);\\n      this.flags = \
header.getUint8(14);\\n      this.flagAntiAlias = (this.flags & 1) !== 0;\\n  \
    this.reserved = header.getUint8(15);\\n      this.headerParsed = true;\\n \
     this.parsed = false;\\n    }\\n    async parseSplats(centerCallback, \
alphaCallback, rgbCallback, scalesCallback, quatCallback, shCallback) {\\n    \
  if (!this.headerParsed) {\\n        throw new Error(\"SPZ file header must \
be parsed first\");\\n      }\\n      if (this.parsed) {\\n        throw new \
Error(\"SPZ file already parsed\");\\n      }\\n      this.parsed = true;\\n  \
    if (this.version === 1) {\\n        const centerBytes = await \
this.reader.read(this.numSplats * 3 * 2);\\n        const centerUint16 = new \
Uint16Array(centerBytes.buffer);\\n        for (let i2 = 0; i2 < \
this.numSplats; i2++) {\\n          const i3 = i2 * 3;\\n          const x2 = \
fromHalf(centerUint16[i3]);\\n          const y = fromHalf(centerUint16[i3 + \
1]);\\n          const z = fromHalf(centerUint16[i3 + 2]);\\n          \
centerCallback == null ? void 0 : centerCallback(i2, x2, y, z);\\n        \
}\\n      } else if (this.version === 2 || this.version === 3) {\\n        \
const fixed = 1 << this.fractionalBits;\\n        const centerBytes = await \
this.reader.read(this.numSplats * 3 * 3);\\n        for (let i2 = 0; i2 < \
this.numSplats; i2++) {\\n          const i9 = i2 * 9;\\n          const x2 = \
((centerBytes[i9 + 2] << 24 | centerBytes[i9 + 1] << 16 | centerBytes[i9] << \
8) >> 8) / fixed;\\n          const y = ((centerBytes[i9 + 5] << 24 | \
centerBytes[i9 + 4] << 16 | centerBytes[i9 + 3] << 8) >> 8) / fixed;\\n       \
   const z = ((centerBytes[i9 + 8] << 24 | centerBytes[i9 + 7] << 16 | \
centerBytes[i9 + 6] << 8) >> 8) / fixed;\\n          centerCallback == null ? \
void 0 : centerCallback(i2, x2, y, z);\\n        }\\n      } else {\\n        \
throw new Error(\"Unreachable\");\\n      }\\n      {\\n        const bytes = \
await this.reader.read(this.numSplats);\\n        for (let i2 = 0; i2 < \
this.numSplats; i2++) {\\n          alphaCallback == null ? void 0 : \
alphaCallback(i2, bytes[i2] / 255);\\n        }\\n      }\\n      {\\n        \
const rgbBytes = await this.reader.read(this.numSplats * 3);\\n        const \
scale = SH_C0 / 0.15;\\n        for (let i2 = 0; i2 < this.numSplats; i2++) \
{\\n          const i3 = i2 * 3;\\n          const r = (rgbBytes[i3] / 255 - \
0.5) * scale + 0.5;\\n          const g = (rgbBytes[i3 + 1] / 255 - 0.5) * \
scale + 0.5;\\n          const b = (rgbBytes[i3 + 2] / 255 - 0.5) * scale + \
0.5;\\n          rgbCallback == null ? void 0 : rgbCallback(i2, r, g, b);\\n  \
      }\\n      }\\n      {\\n        const scalesBytes = await \
this.reader.read(this.numSplats * 3);\\n        for (let i2 = 0; i2 < \
this.numSplats; i2++) {\\n          const i3 = i2 * 3;\\n          const \
scaleX = Math.exp(scalesBytes[i3] / 16 - 10);\\n          const scaleY = \
Math.exp(scalesBytes[i3 + 1] / 16 - 10);\\n          const scaleZ = \
Math.exp(scalesBytes[i3 + 2] / 16 - 10);\\n          scalesCallback == null ? \
void 0 : scalesCallback(i2, scaleX, scaleY, scaleZ);\\n        }\\n      }\\n \
     if (this.version === 3) {\\n        const maxValue = 1 / \
Math.sqrt(2);\\n        const quatBytes = await \
this.reader.read(this.numSplats * 4);\\n        for (let i2 = 0; i2 < \
this.numSplats; i2++) {\\n          const i3 = i2 * 4;\\n          const \
quaternion = [0, 0, 0, 0];\\n          const values = [\\n            \
quatBytes[i3],\\n            quatBytes[i3 + 1],\\n            quatBytes[i3 + \
2],\\n            quatBytes[i3 + 3]\\n          ];\\n          const \
combinedValues = values[0] + (values[1] << 8) + (values[2] << 16) + \
(values[3] << 24);\\n          const valueMask = (1 << 9) - 1;\\n          \
const largestIndex = combinedValues >>> 30;\\n          let remainingValues = \
combinedValues;\\n          let sumSquares = 0;\\n          for (let i22 = 3; \
i22 >= 0; --i22) {\\n            if (i22 !== largestIndex) {\\n              \
const value = remainingValues & valueMask;\\n              const sign = \
remainingValues >>> 9 & 1;\\n              remainingValues = remainingValues \
>>> 10;\\n              quaternion[i22] = maxValue * (value / valueMask);\\n  \
            quaternion[i22] = sign === 0 ? quaternion[i22] : \
-quaternion[i22];\\n              sumSquares += quaternion[i22] * \
quaternion[i22];\\n            }\\n          }\\n          const square = 1 - \
sumSquares;\\n          quaternion[largestIndex] = Math.sqrt(Math.max(square, \
0));\\n          quatCallback == null ? void 0 : quatCallback(\\n            \
i2,\\n            quaternion[0],\\n            quaternion[1],\\n            \
quaternion[2],\\n            quaternion[3]\\n          );\\n        }\\n      \
} else {\\n        const quatBytes = await this.reader.read(this.numSplats * \
3);\\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\\n          const \
i3 = i2 * 3;\\n          const quatX = quatBytes[i3] / 127.5 - 1;\\n          \
const quatY = quatBytes[i3 + 1] / 127.5 - 1;\\n          const quatZ = \
quatBytes[i3 + 2] / 127.5 - 1;\\n          const quatW = Math.sqrt(\\n        \
    Math.max(0, 1 - quatX * quatX - quatY * quatY - quatZ * quatZ)\\n         \
 );\\n          quatCallback == null ? void 0 : quatCallback(i2, quatX, \
quatY, quatZ, quatW);\\n        }\\n      }\\n      if (shCallback && \
this.shDegree >= 1) {\\n        const sh1 = new Float32Array(3 * 3);\\n       \
 const sh2 = this.shDegree >= 2 ? new Float32Array(5 * 3) : void 0;\\n        \
const sh3 = this.shDegree >= 3 ? new Float32Array(7 * 3) : void 0;\\n        \
const shBytes = await this.reader.read(\\n          this.numSplats * \
SH_DEGREE_TO_VECS[this.shDegree] * 3\\n        );\\n        let offset = \
0;\\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\\n          for \
(let j = 0; j < 9; ++j) {\\n            sh1[j] = (shBytes[offset + j] - 128) \
/ 128;\\n          }\\n          offset += 9;\\n          if (sh2) {\\n       \
     for (let j = 0; j < 15; ++j) {\\n              sh2[j] = (shBytes[offset \
+ j] - 128) / 128;\\n            }\\n            offset += 15;\\n          \
}\\n          if (sh3) {\\n            for (let j = 0; j < 21; ++j) {\\n      \
        sh3[j] = (shBytes[offset + j] - 128) / 128;\\n            }\\n        \
    offset += 21;\\n          }\\n          shCallback == null ? void 0 : \
shCallback(i2, sh1, sh2, sh3);\\n        }\\n      }\\n    }\\n  }\\n  const \
SH_DEGREE_TO_VECS = { 1: 3, 2: 8, 3: 15 };\\n  const SH_C0 = \
0.28209479177387814;\\n  const SPZ_MAGIC = 1347635022;\\n  const SPZ_VERSION \
= 3;\\n  const FLAG_ANTIALIASED = 1;\\n  class SpzWriter {\\n    \
constructor({\\n      numSplats,\\n      shDegree,\\n      fractionalBits = \
12,\\n      flagAntiAlias = true\\n    }) {\\n      this.clippedCount = 0;\\n \
     const splatSize = 9 + // Position\\n      1 + // Opacity\\n      3 + // \
Scale\\n      3 + // DC-rgb\\n      4 + // Rotation\\n      (shDegree >= 1 ? \
9 : 0) + (shDegree >= 2 ? 15 : 0) + (shDegree >= 3 ? 21 : 0);\\n      const \
bufferSize = 16 + numSplats * splatSize;\\n      this.buffer = new \
ArrayBuffer(bufferSize);\\n      this.view = new DataView(this.buffer);\\n    \
  this.view.setUint32(0, SPZ_MAGIC, true);\\n      this.view.setUint32(4, \
SPZ_VERSION, true);\\n      this.view.setUint32(8, numSplats, true);\\n      \
this.view.setUint8(12, shDegree);\\n      this.view.setUint8(13, \
fractionalBits);\\n      this.view.setUint8(14, flagAntiAlias ? \
FLAG_ANTIALIASED : 0);\\n      this.view.setUint8(15, 0);\\n      \
this.numSplats = numSplats;\\n      this.shDegree = shDegree;\\n      \
this.fractionalBits = fractionalBits;\\n      this.fraction = 1 << \
fractionalBits;\\n      this.flagAntiAlias = flagAntiAlias;\\n    }\\n    \
setCenter(index, x2, y, z) {\\n      const xRounded = Math.round(x2 * \
this.fraction);\\n      const xInt = Math.max(-8388607, Math.min(8388607, \
xRounded));\\n      const yRounded = Math.round(y * this.fraction);\\n      \
const yInt = Math.max(-8388607, Math.min(8388607, yRounded));\\n      const \
zRounded = Math.round(z * this.fraction);\\n      const zInt = \
Math.max(-8388607, Math.min(8388607, zRounded));\\n      const clipped = \
xRounded !== xInt || yRounded !== yInt || zRounded !== zInt;\\n      if \
(clipped) {\\n        this.clippedCount += 1;\\n      }\\n      const i9 = \
index * 9;\\n      const base = 16 + i9;\\n      this.view.setUint8(base, \
xInt & 255);\\n      this.view.setUint8(base + 1, xInt >> 8 & 255);\\n      \
this.view.setUint8(base + 2, xInt >> 16 & 255);\\n      \
this.view.setUint8(base + 3, yInt & 255);\\n      this.view.setUint8(base + \
4, yInt >> 8 & 255);\\n      this.view.setUint8(base + 5, yInt >> 16 & \
255);\\n      this.view.setUint8(base + 6, zInt & 255);\\n      \
this.view.setUint8(base + 7, zInt >> 8 & 255);\\n      \
this.view.setUint8(base + 8, zInt >> 16 & 255);\\n    }\\n    setAlpha(index, \
alpha) {\\n      const base = 16 + this.numSplats * 9 + index;\\n      \
this.view.setUint8(\\n        base,\\n        Math.max(0, Math.min(255, \
Math.round(alpha * 255)))\\n      );\\n    }\\n    static scaleRgb(r) {\\n    \
  const v = ((r - 0.5) / (SH_C0 / 0.15) + 0.5) * 255;\\n      return \
Math.max(0, Math.min(255, Math.round(v)));\\n    }\\n    setRgb(index, r, g, \
b) {\\n      const base = 16 + this.numSplats * 10 + index * 3;\\n      \
this.view.setUint8(base, SpzWriter.scaleRgb(r));\\n      \
this.view.setUint8(base + 1, SpzWriter.scaleRgb(g));\\n      \
this.view.setUint8(base + 2, SpzWriter.scaleRgb(b));\\n    }\\n    \
setScale(index, scaleX, scaleY, scaleZ) {\\n      const base = 16 + \
this.numSplats * 13 + index * 3;\\n      this.view.setUint8(\\n        \
base,\\n        Math.max(0, Math.min(255, Math.round((Math.log(scaleX) + 10) \
* 16)))\\n      );\\n      this.view.setUint8(\\n        base + 1,\\n        \
Math.max(0, Math.min(255, Math.round((Math.log(scaleY) + 10) * 16)))\\n      \
);\\n      this.view.setUint8(\\n        base + 2,\\n        Math.max(0, \
Math.min(255, Math.round((Math.log(scaleZ) + 10) * 16)))\\n      );\\n    \
}\\n    setQuat(index, ...q) {\\n      const base = 16 + this.numSplats * 16 \
+ index * 4;\\n      const quat = normalize(q);\\n      let iLargest = 0;\\n  \
    for (let i2 = 1; i2 < 4; ++i2) {\\n        if (Math.abs(quat[i2]) > \
Math.abs(quat[iLargest])) {\\n          iLargest = i2;\\n        }\\n      \
}\\n      const negate = quat[iLargest] < 0 ? 1 : 0;\\n      let comp = \
iLargest;\\n      for (let i2 = 0; i2 < 4; ++i2) {\\n        if (i2 !== \
iLargest) {\\n          const negbit = (quat[i2] < 0 ? 1 : 0) ^ negate;\\n    \
      const mag = Math.floor(\\n            ((1 << 9) - 1) * \
(Math.abs(quat[i2]) / Math.SQRT1_2) + 0.5\\n          );\\n          comp = \
comp << 10 | negbit << 9 | mag;\\n        }\\n      }\\n      \
this.view.setUint8(base, comp & 255);\\n      this.view.setUint8(base + 1, \
comp >> 8 & 255);\\n      this.view.setUint8(base + 2, comp >> 16 & 255);\\n  \
    this.view.setUint8(base + 3, comp >>> 24 & 255);\\n    }\\n    static \
quantizeSh(sh, bits2) {\\n      const value = Math.round(sh * 128) + 128;\\n  \
    const bucketSize = 1 << 8 - bits2;\\n      const quantized = \
Math.floor((value + bucketSize / 2) / bucketSize) * bucketSize;\\n      \
return Math.max(0, Math.min(255, quantized));\\n    }\\n    setSh(index, sh1, \
sh2, sh3) {\\n      const shVecs = SH_DEGREE_TO_VECS[this.shDegree] || 0;\\n  \
    const base1 = 16 + this.numSplats * 20 + index * shVecs * 3;\\n      for \
(let j = 0; j < 9; ++j) {\\n        this.view.setUint8(base1 + j, \
SpzWriter.quantizeSh(sh1[j], 5));\\n      }\\n      if (sh2) {\\n        \
const base2 = base1 + 9;\\n        for (let j = 0; j < 15; ++j) {\\n          \
this.view.setUint8(base2 + j, SpzWriter.quantizeSh(sh2[j], 4));\\n        \
}\\n        if (sh3) {\\n          const base3 = base2 + 15;\\n          for \
(let j = 0; j < 21; ++j) {\\n            this.view.setUint8(base3 + j, \
SpzWriter.quantizeSh(sh3[j], 4));\\n          }\\n        }\\n      }\\n    \
}\\n    async finalize() {\\n      const input = new \
Uint8Array(this.buffer);\\n      const stream = new ReadableStream({\\n       \
 async start(controller) {\\n          controller.enqueue(input);\\n          \
controller.close();\\n        }\\n      });\\n      const compressed = \
stream.pipeThrough(new CompressionStream(\"gzip\"));\\n      const response = \
new Response(compressed);\\n      const buffer = await \
response.arrayBuffer();\\n      console.log(\\n        \"Compressed\",\\n     \
   input.length,\\n        \"bytes to\",\\n        buffer.byteLength,\\n      \
  \"bytes\"\\n      );\\n      return new Uint8Array(buffer);\\n    }\\n  \
}\\n  async function transcodeSpz(input) {\\n    var _a2, _b2, _c;\\n    \
const splats = new SplatData();\\n    const {\\n      inputs,\\n      \
clipXyz,\\n      maxSh,\\n      fractionalBits = 12,\\n      \
opacityThreshold\\n    } = input;\\n    for (const input2 of inputs) {\\n     \
 let transformPos = function(pos) {\\n        pos.multiplyScalar(scale);\\n   \
     pos.applyQuaternion(quaternion);\\n        pos.add(translate);\\n        \
return pos;\\n      }, transformScales = function(scales) {\\n        \
scales.multiplyScalar(scale);\\n        return scales;\\n      }, \
transformQuaternion = function(quat) {\\n        \
quat.premultiply(quaternion);\\n        return quat;\\n      }, withinClip = \
function(p) {\\n        return !clip || clip.containsPoint(p);\\n      }, \
withinOpacity = function(opacity) {\\n        return opacityThreshold !== \
void 0 ? opacity >= opacityThreshold : true;\\n      };\\n      const scale = \
((_a2 = input2.transform) == null ? void 0 : _a2.scale) ?? 1;\\n      const \
quaternion = new Quaternion().fromArray(\\n        ((_b2 = input2.transform) \
== null ? void 0 : _b2.quaternion) ?? [0, 0, 0, 1]\\n      );\\n      const \
translate = new Vector3().fromArray(\\n        ((_c = input2.transform) == \
null ? void 0 : _c.translate) ?? [0, 0, 0]\\n      );\\n      const clip = \
clipXyz ? new Box3(\\n        new Vector3().fromArray(clipXyz.min),\\n        \
new Vector3().fromArray(clipXyz.max)\\n      ) : void 0;\\n      let fileType \
= input2.fileType;\\n      if (!fileType) {\\n        fileType = \
getSplatFileType(input2.fileBytes);\\n        if (!fileType && \
input2.pathOrUrl) {\\n          fileType = \
getSplatFileTypeFromPath(input2.pathOrUrl);\\n        }\\n      }\\n      \
switch (fileType) {\\n        case SplatFileType.PLY: {\\n          const ply \
= new PlyReader({ fileBytes: input2.fileBytes });\\n          await \
ply.parseHeader();\\n          let lastIndex = null;\\n          \
ply.parseSplats(\\n            (index, x2, y, z, scaleX, scaleY, scaleZ, \
quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\\n              const \
center = transformPos(new Vector3(x2, y, z));\\n              if \
(withinClip(center) && withinOpacity(opacity)) {\\n                lastIndex \
= splats.pushSplat();\\n                splats.setCenter(lastIndex, center.x, \
center.y, center.z);\\n                const scales = transformScales(\\n     \
             new Vector3(scaleX, scaleY, scaleZ)\\n                );\\n      \
          splats.setScale(lastIndex, scales.x, scales.y, scales.z);\\n        \
        const quaternion2 = transformQuaternion(\\n                  new \
Quaternion(quatX, quatY, quatZ, quatW)\\n                );\\n                \
splats.setQuaternion(\\n                  lastIndex,\\n                  \
quaternion2.x,\\n                  quaternion2.y,\\n                  \
quaternion2.z,\\n                  quaternion2.w\\n                );\\n      \
          splats.setOpacity(lastIndex, opacity);\\n                \
splats.setColor(lastIndex, r, g, b);\\n              } else {\\n              \
  lastIndex = null;\\n              }\\n            },\\n            (index, \
sh1, sh2, sh3) => {\\n              if (sh1 && lastIndex !== null) {\\n       \
         splats.setSh1(lastIndex, sh1);\\n              }\\n              if \
(sh2 && lastIndex !== null) {\\n                splats.setSh2(lastIndex, \
sh2);\\n              }\\n              if (sh3 && lastIndex !== null) {\\n   \
             splats.setSh3(lastIndex, sh3);\\n              }\\n            \
}\\n          );\\n          break;\\n        }\\n        case \
SplatFileType.SPZ: {\\n          const spz2 = new SpzReader({ fileBytes: \
input2.fileBytes });\\n          await spz2.parseHeader();\\n          const \
mapping = new Int32Array(spz2.numSplats);\\n          mapping.fill(-1);\\n    \
      const centers = new Float32Array(spz2.numSplats * 3);\\n          const \
center = new Vector3();\\n          spz2.parseSplats(\\n            (index, \
x2, y, z) => {\\n              const center2 = transformPos(new Vector3(x2, \
y, z));\\n              centers[index * 3] = center2.x;\\n              \
centers[index * 3 + 1] = center2.y;\\n              centers[index * 3 + 2] = \
center2.z;\\n            },\\n            (index, alpha) => {\\n              \
center.fromArray(centers, index * 3);\\n              if (withinClip(center) \
&& withinOpacity(alpha)) {\\n                mapping[index] = \
splats.pushSplat();\\n                splats.setCenter(mapping[index], \
center.x, center.y, center.z);\\n                \
splats.setOpacity(mapping[index], alpha);\\n              }\\n            \
},\\n            (index, r, g, b) => {\\n              if (mapping[index] >= \
0) {\\n                splats.setColor(mapping[index], r, g, b);\\n           \
   }\\n            },\\n            (index, scaleX, scaleY, scaleZ) => {\\n   \
           if (mapping[index] >= 0) {\\n                const scales = \
transformScales(\\n                  new Vector3(scaleX, scaleY, scaleZ)\\n   \
             );\\n                splats.setScale(mapping[index], scales.x, \
scales.y, scales.z);\\n              }\\n            },\\n            (index, \
quatX, quatY, quatZ, quatW) => {\\n              if (mapping[index] >= 0) \
{\\n                const quaternion2 = transformQuaternion(\\n               \
   new Quaternion(quatX, quatY, quatZ, quatW)\\n                );\\n         \
       splats.setQuaternion(\\n                  mapping[index],\\n           \
       quaternion2.x,\\n                  quaternion2.y,\\n                  \
quaternion2.z,\\n                  quaternion2.w\\n                );\\n      \
        }\\n            },\\n            (index, sh1, sh2, sh3) => {\\n       \
       if (mapping[index] >= 0) {\\n                \
splats.setSh1(mapping[index], sh1);\\n                if (sh2) {\\n           \
       splats.setSh2(mapping[index], sh2);\\n                }\\n             \
   if (sh3) {\\n                  splats.setSh3(mapping[index], sh3);\\n      \
          }\\n              }\\n            }\\n          );\\n          \
break;\\n        }\\n        case SplatFileType.SPLAT:\\n          \
decodeAntiSplat(\\n            input2.fileBytes,\\n            (numSplats) => \
{\\n            },\\n            (index, x2, y, z, scaleX, scaleY, scaleZ, \
quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\\n              const \
center = transformPos(new Vector3(x2, y, z));\\n              if \
(withinClip(center) && withinOpacity(opacity)) {\\n                const \
index2 = splats.pushSplat();\\n                splats.setCenter(index2, \
center.x, center.y, center.z);\\n                const scales = \
transformScales(\\n                  new Vector3(scaleX, scaleY, scaleZ)\\n   \
             );\\n                splats.setScale(index2, scales.x, scales.y, \
scales.z);\\n                const quaternion2 = transformQuaternion(\\n      \
            new Quaternion(quatX, quatY, quatZ, quatW)\\n                \
);\\n                splats.setQuaternion(\\n                  index2,\\n     \
             quaternion2.x,\\n                  quaternion2.y,\\n             \
     quaternion2.z,\\n                  quaternion2.w\\n                );\\n \
               splats.setOpacity(index2, opacity);\\n                \
splats.setColor(index2, r, g, b);\\n              }\\n            }\\n        \
  );\\n          break;\\n        case SplatFileType.KSPLAT: {\\n          \
let lastIndex = null;\\n          decodeKsplat(\\n            \
input2.fileBytes,\\n            (numSplats) => {\\n            },\\n          \
  (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, \
opacity, r, g, b) => {\\n              const center = transformPos(new \
Vector3(x2, y, z));\\n              if (withinClip(center) && \
withinOpacity(opacity)) {\\n                lastIndex = \
splats.pushSplat();\\n                splats.setCenter(lastIndex, center.x, \
center.y, center.z);\\n                const scales = transformScales(\\n     \
             new Vector3(scaleX, scaleY, scaleZ)\\n                );\\n      \
          splats.setScale(lastIndex, scales.x, scales.y, scales.z);\\n        \
        const quaternion2 = transformQuaternion(\\n                  new \
Quaternion(quatX, quatY, quatZ, quatW)\\n                );\\n                \
splats.setQuaternion(\\n                  lastIndex,\\n                  \
quaternion2.x,\\n                  quaternion2.y,\\n                  \
quaternion2.z,\\n                  quaternion2.w\\n                );\\n      \
          splats.setOpacity(lastIndex, opacity);\\n                \
splats.setColor(lastIndex, r, g, b);\\n              } else {\\n              \
  lastIndex = null;\\n              }\\n            },\\n            (index, \
sh1, sh2, sh3) => {\\n              if (lastIndex !== null) {\\n              \
  splats.setSh1(lastIndex, sh1);\\n                if (sh2) {\\n              \
    splats.setSh2(lastIndex, sh2);\\n                }\\n                if \
(sh3) {\\n                  splats.setSh3(lastIndex, sh3);\\n                \
}\\n              }\\n            }\\n          );\\n          break;\\n      \
  }\\n        default:\\n          throw new Error(`transcodeSpz not \
implemented for ${fileType}`);\\n      }\\n    }\\n    const shDegree = \
Math.min(\\n      maxSh ?? 3,\\n      splats.sh3 ? 3 : splats.sh2 ? 2 : \
splats.sh1 ? 1 : 0\\n    );\\n    const spz = new SpzWriter({\\n      \
numSplats: splats.numSplats,\\n      shDegree,\\n      fractionalBits,\\n     \
 flagAntiAlias: true\\n    });\\n    for (let i2 = 0; i2 < splats.numSplats; \
++i2) {\\n      const i3 = i2 * 3;\\n      const i4 = i2 * 4;\\n      \
spz.setCenter(\\n        i2,\\n        splats.centers[i3],\\n        \
splats.centers[i3 + 1],\\n        splats.centers[i3 + 2]\\n      );\\n      \
spz.setScale(\\n        i2,\\n        splats.scales[i3],\\n        \
splats.scales[i3 + 1],\\n        splats.scales[i3 + 2]\\n      );\\n      \
spz.setQuat(\\n        i2,\\n        splats.quaternions[i4],\\n        \
splats.quaternions[i4 + 1],\\n        splats.quaternions[i4 + 2],\\n        \
splats.quaternions[i4 + 3]\\n      );\\n      spz.setAlpha(i2, \
splats.opacities[i2]);\\n      spz.setRgb(\\n        i2,\\n        \
splats.colors[i3],\\n        splats.colors[i3 + 1],\\n        \
splats.colors[i3 + 2]\\n      );\\n      if (splats.sh1 && shDegree >= 1) \
{\\n        spz.setSh(\\n          i2,\\n          splats.sh1.slice(i2 * 9, \
(i2 + 1) * 9),\\n          shDegree >= 2 && splats.sh2 ? splats.sh2.slice(i2 \
* 15, (i2 + 1) * 15) : void 0,\\n          shDegree >= 3 && splats.sh3 ? \
splats.sh3.slice(i2 * 21, (i2 + 1) * 21) : void 0\\n        );\\n      }\\n   \
 }\\n    const spzBytes = await spz.finalize();\\n    return { fileBytes: \
spzBytes, clippedCount: spz.clippedCount };\\n  }\\n  async function \
onMessage(event) {\\n    const { name, args, id } = event.data;\\n    let \
result = void 0;\\n    let error = void 0;\\n    try {\\n      switch (name) \
{\\n        case \"unpackPly\": {\\n          const { packedArray, fileBytes, \
splatEncoding } = args;\\n          const decoded = await unpackPly({\\n      \
      packedArray,\\n            fileBytes,\\n            splatEncoding\\n    \
      });\\n          result = {\\n            id,\\n            numSplats: \
decoded.numSplats,\\n            packedArray: decoded.packedArray,\\n         \
   extra: decoded.extra\\n          };\\n          break;\\n        }\\n      \
  case \"decodeSpz\": {\\n          const { fileBytes, splatEncoding } = \
args;\\n          const decoded = await unpackSpz(fileBytes, \
splatEncoding);\\n          result = {\\n            id,\\n            \
numSplats: decoded.numSplats,\\n            packedArray: \
decoded.packedArray,\\n            extra: decoded.extra\\n          };\\n     \
     break;\\n        }\\n        case \"decodeAntiSplat\": {\\n          \
const { fileBytes, splatEncoding } = args;\\n          const decoded = \
unpackAntiSplat(fileBytes, splatEncoding);\\n          result = {\\n          \
  id,\\n            numSplats: decoded.numSplats,\\n            packedArray: \
decoded.packedArray\\n          };\\n          break;\\n        }\\n        \
case \"decodeKsplat\": {\\n          const { fileBytes, splatEncoding } = \
args;\\n          const decoded = unpackKsplat(fileBytes, splatEncoding);\\n  \
        result = {\\n            id,\\n            numSplats: \
decoded.numSplats,\\n            packedArray: decoded.packedArray,\\n         \
   extra: decoded.extra\\n          };\\n          break;\\n        }\\n      \
  case \"decodePcSogs\": {\\n          const { fileBytes, extraFiles, \
splatEncoding } = args;\\n          const json = JSON.parse(\\n            \
new TextDecoder().decode(fileBytes)\\n          );\\n          const decoded \
= await unpackPcSogs(json, extraFiles, splatEncoding);\\n          result = \
{\\n            id,\\n            numSplats: decoded.numSplats,\\n            \
packedArray: decoded.packedArray,\\n            extra: decoded.extra\\n       \
   };\\n          break;\\n        }\\n        case \"decodePcSogsZip\": {\\n \
         const { fileBytes, splatEncoding } = args;\\n          const decoded \
= await unpackPcSogsZip(fileBytes, splatEncoding);\\n          result = {\\n  \
          id,\\n            numSplats: decoded.numSplats,\\n            \
packedArray: decoded.packedArray,\\n            extra: decoded.extra\\n       \
   };\\n          break;\\n        }\\n        case \"sortSplats\": {\\n      \
    const { totalSplats, readback, ordering } = args;\\n          result = \
{\\n            id,\\n            readback,\\n            ...sortSplats({ \
totalSplats, readback, ordering })\\n          };\\n          break;\\n       \
 }\\n        case \"sortDoubleSplats\": {\\n          const { numSplats, \
readback, ordering } = args;\\n          {\\n            result = {\\n        \
      id,\\n              readback,\\n              ordering,\\n              \
activeSplats: sort_splats(numSplats, readback, ordering)\\n            };\\n  \
        }\\n          break;\\n        }\\n        case \"sort32Splats\": \
{\\n          const { numSplats, readback, ordering } = args;\\n          \
{\\n            result = {\\n              id,\\n              readback,\\n   \
           ordering,\\n              activeSplats: sort32_splats(numSplats, \
readback, ordering)\\n            };\\n          }\\n          break;\\n      \
  }\\n        case \"transcodeSpz\": {\\n          const input = args;\\n     \
     const spzBytes = await transcodeSpz(input);\\n          result = {\\n    \
        id,\\n            fileBytes: spzBytes,\\n            input\\n         \
 };\\n          break;\\n        }\\n        default: {\\n          throw new \
Error(`Unknown name: ${name}`);\\n        }\\n      }\\n    } catch (e) {\\n  \
    error = e;\\n      console.error(error);\\n    }\\n    \
self.postMessage(\\n      { id, result, error },\\n      { transfer: \
getArrayBuffers(result) }\\n    );\\n  }\\n  async function unpackPly({\\n    \
packedArray,\\n    fileBytes,\\n    splatEncoding\\n  }) {\\n    const ply = \
new PlyReader({ fileBytes });\\n    await ply.parseHeader();\\n    const \
numSplats = ply.numSplats;\\n    const extra = {};\\n    ply.parseSplats(\\n  \
    (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, \
opacity, r, g, b) => {\\n        setPackedSplat(\\n          packedArray,\\n  \
        index,\\n          x2,\\n          y,\\n          z,\\n          \
scaleX,\\n          scaleY,\\n          scaleZ,\\n          quatX,\\n         \
 quatY,\\n          quatZ,\\n          quatW,\\n          opacity,\\n         \
 r,\\n          g,\\n          b,\\n          splatEncoding\\n        );\\n   \
   },\\n      (index, sh1, sh2, sh3) => {\\n        if (sh1) {\\n          if \
(!extra.sh1) {\\n            extra.sh1 = new Uint32Array(numSplats * 2);\\n   \
       }\\n          encodeSh1Rgb(extra.sh1, index, sh1, splatEncoding);\\n   \
     }\\n        if (sh2) {\\n          if (!extra.sh2) {\\n            \
extra.sh2 = new Uint32Array(numSplats * 4);\\n          }\\n          \
encodeSh2Rgb(extra.sh2, index, sh2, splatEncoding);\\n        }\\n        if \
(sh3) {\\n          if (!extra.sh3) {\\n            extra.sh3 = new \
Uint32Array(numSplats * 4);\\n          }\\n          encodeSh3Rgb(extra.sh3, \
index, sh3, splatEncoding);\\n        }\\n      }\\n    );\\n    return { \
packedArray, numSplats, extra };\\n  }\\n  async function \
unpackSpz(fileBytes, splatEncoding) {\\n    const spz = new SpzReader({ \
fileBytes });\\n    await spz.parseHeader();\\n    const numSplats = \
spz.numSplats;\\n    const maxSplats = computeMaxSplats(numSplats);\\n    \
const packedArray = new Uint32Array(maxSplats * 4);\\n    const extra = \
{};\\n    await spz.parseSplats(\\n      (index, x2, y, z) => {\\n        \
setPackedSplatCenter(packedArray, index, x2, y, z);\\n      },\\n      \
(index, alpha) => {\\n        setPackedSplatOpacity(packedArray, index, \
alpha);\\n      },\\n      (index, r, g, b) => {\\n        \
setPackedSplatRgb(packedArray, index, r, g, b, splatEncoding);\\n      },\\n  \
    (index, scaleX, scaleY, scaleZ) => {\\n        setPackedSplatScales(\\n   \
       packedArray,\\n          index,\\n          scaleX,\\n          \
scaleY,\\n          scaleZ,\\n          splatEncoding\\n        );\\n      \
},\\n      (index, quatX, quatY, quatZ, quatW) => {\\n        \
setPackedSplatQuat(packedArray, index, quatX, quatY, quatZ, quatW);\\n      \
},\\n      (index, sh1, sh2, sh3) => {\\n        if (sh1) {\\n          if \
(!extra.sh1) {\\n            extra.sh1 = new Uint32Array(numSplats * 2);\\n   \
       }\\n          encodeSh1Rgb(extra.sh1, index, sh1, splatEncoding);\\n   \
     }\\n        if (sh2) {\\n          if (!extra.sh2) {\\n            \
extra.sh2 = new Uint32Array(numSplats * 4);\\n          }\\n          \
encodeSh2Rgb(extra.sh2, index, sh2, splatEncoding);\\n        }\\n        if \
(sh3) {\\n          if (!extra.sh3) {\\n            extra.sh3 = new \
Uint32Array(numSplats * 4);\\n          }\\n          encodeSh3Rgb(extra.sh3, \
index, sh3, splatEncoding);\\n        }\\n      }\\n    );\\n    return { \
packedArray, numSplats, extra };\\n  }\\n  const DEPTH_INFINITY_F16 = \
31744;\\n  const DEPTH_SIZE_16 = DEPTH_INFINITY_F16 + 1;\\n  let depthArray16 \
= null;\\n  function sortSplats({\\n    totalSplats,\\n    readback,\\n    \
ordering\\n  }) {\\n    if (!depthArray16) {\\n      depthArray16 = new \
Uint32Array(DEPTH_SIZE_16);\\n    }\\n    depthArray16.fill(0);\\n    const \
readbackUint32 = readback.map((layer) => new Uint32Array(layer.buffer));\\n   \
 const layerSize = readbackUint32[0].length;\\n    const numLayers = \
Math.ceil(totalSplats / layerSize);\\n    let layerBase = 0;\\n    for (let \
layer = 0; layer < numLayers; ++layer) {\\n      const readbackLayer = \
readbackUint32[layer];\\n      const layerSplats = \
Math.min(readbackLayer.length, totalSplats - layerBase);\\n      for (let i2 \
= 0; i2 < layerSplats; ++i2) {\\n        const pri = readbackLayer[i2] & \
32767;\\n        if (pri < DEPTH_INFINITY_F16) {\\n          \
depthArray16[pri] += 1;\\n        }\\n      }\\n      layerBase += \
layerSplats;\\n    }\\n    let activeSplats = 0;\\n    for (let j = 0; j < \
DEPTH_SIZE_16; ++j) {\\n      const nextIndex = activeSplats + \
depthArray16[j];\\n      depthArray16[j] = activeSplats;\\n      activeSplats \
= nextIndex;\\n    }\\n    layerBase = 0;\\n    for (let layer = 0; layer < \
numLayers; ++layer) {\\n      const readbackLayer = readbackUint32[layer];\\n \
     const layerSplats = Math.min(readbackLayer.length, totalSplats - \
layerBase);\\n      for (let i2 = 0; i2 < layerSplats; ++i2) {\\n        \
const pri = readbackLayer[i2] & 32767;\\n        if (pri < \
DEPTH_INFINITY_F16) {\\n          ordering[depthArray16[pri]] = layerBase + \
i2;\\n          depthArray16[pri] += 1;\\n        }\\n      }\\n      \
layerBase += layerSplats;\\n    }\\n    if (depthArray16[DEPTH_SIZE_16 - 1] \
!== activeSplats) {\\n      throw new Error(\\n        `Expected \
${activeSplats} active splats but got ${depthArray16[DEPTH_SIZE_16 - 1]}`\\n  \
    );\\n    }\\n    return { activeSplats, ordering };\\n  }\\n  const \
messageBuffer = [];\\n  function bufferMessage(event) {\\n    \
messageBuffer.push(event);\\n  }\\n  async function initialize() {\\n    \
self.addEventListener(\"message\", bufferMessage);\\n    await \
__wbg_init();\\n    self.removeEventListener(\"message\", bufferMessage);\\n  \
  self.addEventListener(\"message\", onMessage);\\n    for (const event of \
messageBuffer) {\\n      onMessage(event);\\n    }\\n    messageBuffer.length \
= 0;\\n  }\\n  initialize().catch(console.error);\\n})();\\n//# \
sourceMappingURL=worker-CVv1zjxY.js.map\\n';\nconst blob = typeof self !== \
\"undefined\" && self.Blob && new Blob([jsContent], { type: \
\"text/javascript;charset=utf-8\" });\nfunction WorkerWrapper(options) {\n  \
let objURL;\n  try {\n    objURL = blob && (self.URL || \
self.webkitURL).createObjectURL(blob);\n    if (!objURL) throw \"\";\n    \
const worker = new Worker(objURL, {\n      name: options == null ? void 0 : \
options.name\n    });\n    worker.addEventListener(\"error\", () => {\n      \
(self.URL || self.webkitURL).revokeObjectURL(objURL);\n    });\n    return \
worker;\n  } catch (e) {\n    return new Worker(\n      \
\"data:text/javascript;charset=utf-8,\" + encodeURIComponent(jsContent),\n    \
  {\n        name: options == null ? void 0 : options.name\n      }\n    );\n \
 } finally {\n    objURL && (self.URL || \
self.webkitURL).revokeObjectURL(objURL);\n  }\n}\nclass SplatWorker {\n  \
constructor() {\n    this.messages = {};\n    this.messageIdNext = 0;\n    \
this.worker = new WorkerWrapper();\n    this.worker.onmessage = (event) => \
this.onMessage(event);\n  }\n  makeMessageId() {\n    return \
++this.messageIdNext;\n  }\n  makeMessagePromiseId() {\n    const id = \
this.makeMessageId();\n    const promise = new Promise((resolve, reject) => \
{\n      this.messages[id] = { resolve, reject };\n    });\n    return { id, \
promise };\n  }\n  onMessage(event) {\n    const { id, result, error } = \
event.data;\n    const handler = this.messages[id];\n    if (handler) {\n     \
 delete this.messages[id];\n      if (error) {\n        \
handler.reject(error);\n      } else {\n        handler.resolve(result);\n    \
  }\n    }\n  }\n  // Invoke an RPC on the worker with the given name and \
arguments.\n  // The normal usage of a worker is to run one activity at a \
time,\n  // but this function allows for concurrent calls, tagging each \
request\n  // with a unique message Id and awaiting a response to that same \
Id.\n  // The method will automatically transfer any ArrayBuffers in the\n  \
// arguments to the worker. If you'd like to transfer a copy of a\n  // \
buffer then you must clone it before passing to this function.\n  async \
call(name, args) {\n    const { id, promise } = \
this.makeMessagePromiseId();\n    this.worker.postMessage(\n      { name, \
args, id },\n      { transfer: getArrayBuffers(args) }\n    );\n    return \
promise;\n  }\n}\nlet maxWorkers = 4;\nlet numWorkers = 0;\nconst freeWorkers \
= [];\nconst workerQueue = [];\nasync function allocWorker() {\n  const \
worker = freeWorkers.shift();\n  if (worker) {\n    return worker;\n  }\n  if \
(numWorkers < maxWorkers) {\n    const worker2 = new SplatWorker();\n    \
numWorkers += 1;\n    return worker2;\n  }\n  return new Promise((resolve) => \
{\n    workerQueue.push(resolve);\n  });\n}\nfunction freeWorker(worker) {\n  \
if (numWorkers > maxWorkers) {\n    numWorkers -= 1;\n    return;\n  }\n  \
const waiter = workerQueue.shift();\n  if (waiter) {\n    waiter(worker);\n   \
 return;\n  }\n  freeWorkers.push(worker);\n}\nasync function \
withWorker(callback) {\n  const worker = await allocWorker();\n  try {\n    \
return await callback(worker);\n  } finally {\n    freeWorker(worker);\n  \
}\n}\nclass SplatLoader extends Loader {\n  constructor(manager) {\n    \
super(manager);\n    this.fileLoader = new FileLoader(manager);\n  }\n  \
load(url, onLoad, onProgress, onError) {\n    const resolvedURL = \
this.manager.resolveURL(\n      (this.path ?? \"\") + (url ?? \"\")\n    );\n \
   const headers = new Headers(this.requestHeader);\n    const credentials = \
this.withCredentials ? \"include\" : \"same-origin\";\n    const request = \
new Request(resolvedURL, { headers, credentials });\n    let fileType = \
this.fileType;\n    this.manager.itemStart(resolvedURL);\n    \
fetchWithProgress(request, onProgress).then(async (input) => {\n      var \
_a2;\n      const progresses = [\n        new ProgressEvent(\"progress\", {\n \
         lengthComputable: true,\n          loaded: input.byteLength,\n       \
   total: input.byteLength\n        })\n      ];\n      function \
updateProgresses() {\n        if (onProgress) {\n          const \
lengthComputable = progresses.every((p) => {\n            return \
p.lengthComputable || p.loaded === 0 && p.total === 0;\n          });\n       \
   const loaded = progresses.reduce((sum, p) => sum + p.loaded, 0);\n         \
 const total = progresses.reduce((sum, p) => sum + p.total, 0);\n          \
onProgress(\n            new ProgressEvent(\"progress\", {\n              \
lengthComputable,\n              loaded,\n              total\n            \
})\n          );\n        }\n      }\n      const extraFiles = {};\n      \
const promises = [];\n      const pcSogsJson = tryPcSogs(input);\n      if \
(fileType === \"pcsogs\") {\n        if (pcSogsJson === void 0) {\n          \
throw new Error(\"Invalid PC SOGS file\");\n        }\n      }\n      if \
(pcSogsJson !== void 0) {\n        fileType = \"pcsogs\";\n        for (const \
key of [\"means\", \"scales\", \"quats\", \"sh0\", \"shN\"]) {\n          \
const prop = pcSogsJson[key];\n          if (prop) {\n            for (const \
file of prop.files) {\n              const fileUrl = new URL(file, \
resolvedURL).toString();\n              const progressIndex = \
progresses.length;\n              progresses.push(new \
ProgressEvent(\"progress\"));\n              \
this.manager.itemStart(fileUrl);\n              const request2 = new \
Request(fileUrl, { headers, credentials });\n              const promise = \
fetchWithProgress(request2, (progress) => {\n                \
progresses[progressIndex] = progress;\n                updateProgresses();\n  \
            }).then((data) => {\n                extraFiles[file] = data;\n   \
           }).catch((error) => {\n                \
this.manager.itemError(fileUrl);\n                throw error;\n              \
}).finally(() => {\n                this.manager.itemEnd(fileUrl);\n          \
    });\n              promises.push(promise);\n            }\n          }\n  \
      }\n      }\n      await Promise.all(promises);\n      if (onLoad) {\n   \
     const splatEncoding = ((_a2 = this.packedSplats) == null ? void 0 : \
_a2.splatEncoding) ?? DEFAULT_SPLAT_ENCODING;\n        const decoded = await \
unpackSplats({\n          input,\n          extraFiles,\n          \
fileType,\n          pathOrUrl: resolvedURL,\n          splatEncoding\n       \
 });\n        if (this.packedSplats) {\n          \
this.packedSplats.initialize(decoded);\n          \
onLoad(this.packedSplats);\n        } else {\n          onLoad(new \
PackedSplats(decoded));\n        }\n      }\n    }).catch((error) => {\n      \
this.manager.itemError(resolvedURL);\n      onError == null ? void 0 : \
onError(error);\n    }).finally(() => {\n      \
this.manager.itemEnd(resolvedURL);\n    });\n  }\n  async loadAsync(url, \
onProgress) {\n    return new Promise((resolve, reject) => {\n      \
this.load(\n        url,\n        (decoded) => {\n          \
resolve(decoded);\n        },\n        onProgress,\n        reject\n      \
);\n    });\n  }\n  parse(packedSplats) {\n    return new SplatMesh({ \
packedSplats });\n  }\n}\nasync function fetchWithProgress(request, \
onProgress) {\n  const response = await fetch(request);\n  if (!response.ok) \
{\n    throw new Error(\n      `${response.status} \"${response.statusText}\" \
fetching URL: ${request.url}`\n    );\n  }\n  if (!response.body) {\n    \
throw new Error(`Response body is null for URL: ${request.url}`);\n  }\n  \
const reader = response.body.getReader();\n  const contentLength = \
Number.parseInt(\n    response.headers.get(\"Content-Length\") || \"0\"\n  \
);\n  const total = Number.isNaN(contentLength) ? 0 : contentLength;\n  let \
loaded = 0;\n  const chunks = [];\n  while (true) {\n    const { done, value \
} = await reader.read();\n    if (done) {\n      break;\n    }\n    \
chunks.push(value);\n    loaded += value.length;\n    if (onProgress) {\n     \
 onProgress(\n        new ProgressEvent(\"progress\", {\n          \
lengthComputable: total !== 0,\n          loaded,\n          total\n        \
})\n      );\n    }\n  }\n  const bytes = new Uint8Array(loaded);\n  let \
offset = 0;\n  for (const chunk of chunks) {\n    bytes.set(chunk, offset);\n \
   offset += chunk.length;\n  }\n  return bytes.buffer;\n}\nvar SplatFileType \
= /* @__PURE__ */ ((SplatFileType2) => {\n  SplatFileType2[\"PLY\"] = \
\"ply\";\n  SplatFileType2[\"SPZ\"] = \"spz\";\n  SplatFileType2[\"SPLAT\"] = \
\"splat\";\n  SplatFileType2[\"KSPLAT\"] = \"ksplat\";\n  \
SplatFileType2[\"PCSOGS\"] = \"pcsogs\";\n  SplatFileType2[\"PCSOGSZIP\"] = \
\"pcsogszip\";\n  return SplatFileType2;\n})(SplatFileType || {});\nfunction \
getSplatFileType(fileBytes) {\n  const view = new \
DataView(fileBytes.buffer);\n  if ((view.getUint32(0, true) & 16777215) === \
7957616) {\n    return \"ply\";\n  }\n  if ((view.getUint32(0, true) & \
16777215) === 559903) {\n    const header = decompressPartialGzip(fileBytes, \
4);\n    const gView = new DataView(header.buffer);\n    if \
(gView.getUint32(0, true) === 1347635022) {\n      return \"spz\";\n    }\n   \
 return void 0;\n  }\n  if (view.getUint32(0, true) === 67324752) {\n    if \
(tryPcSogsZip(fileBytes)) {\n      return \"pcsogszip\";\n    }\n    return \
void 0;\n  }\n  return void 0;\n}\nfunction getFileExtension(pathOrUrl) {\n  \
const noTrailing = pathOrUrl.split(/[?#]/, 1)[0];\n  const lastSlash = \
Math.max(\n    noTrailing.lastIndexOf(\"/\"),\n    \
noTrailing.lastIndexOf(\"\\\\\")\n  );\n  const filename = \
noTrailing.slice(lastSlash + 1);\n  const lastDot = \
filename.lastIndexOf(\".\");\n  if (lastDot <= 0 || lastDot === \
filename.length - 1) {\n    return \"\";\n  }\n  return \
filename.slice(lastDot + 1).toLowerCase();\n}\nfunction \
getSplatFileTypeFromPath(pathOrUrl) {\n  const extension = \
getFileExtension(pathOrUrl);\n  if (extension === \"ply\") {\n    return \
\"ply\";\n  }\n  if (extension === \"spz\") {\n    return \"spz\";\n  }\n  if \
(extension === \"splat\") {\n    return \"splat\";\n  }\n  if (extension === \
\"ksplat\") {\n    return \"ksplat\";\n  }\n  if (extension === \"sog\") {\n  \
  return \"pcsogszip\";\n  }\n  return void 0;\n}\nfunction isPcSogs(input) \
{\n  return tryPcSogs(input) !== void 0;\n}\nfunction tryPcSogs(input) {\n  \
try {\n    let text;\n    if (typeof input === \"string\") {\n      text = \
input;\n    } else {\n      const fileBytes = input instanceof ArrayBuffer ? \
new Uint8Array(input) : input;\n      if (fileBytes.length > 65536) {\n       \
 return void 0;\n      }\n      text = new TextDecoder().decode(fileBytes);\n \
   }\n    const json = JSON.parse(text);\n    if (!json || typeof json !== \
\"object\" || Array.isArray(json)) {\n      return void 0;\n    }\n    const \
isVersion2 = json.version === 2;\n    for (const key of [\"means\", \
\"scales\", \"quats\", \"sh0\"]) {\n      if (!json[key] || typeof json[key] \
!== \"object\" || Array.isArray(json[key])) {\n        return void 0;\n      \
}\n      if (isVersion2) {\n        if (!json[key].files) {\n          return \
void 0;\n        }\n        if ((key === \"scales\" || key === \"sh0\") && \
!json[key].codebook) {\n          return void 0;\n        }\n        if (key \
=== \"means\" && (!json[key].mins || !json[key].maxs)) {\n          return \
void 0;\n        }\n      } else {\n        if (!json[key].shape || \
!json[key].files) {\n          return void 0;\n        }\n        if (key !== \
\"quats\" && (!json[key].mins || !json[key].maxs)) {\n          return void \
0;\n        }\n      }\n    }\n    return json;\n  } catch {\n    return void \
0;\n  }\n}\nfunction tryPcSogsZip(input) {\n  try {\n    const fileBytes = \
input instanceof ArrayBuffer ? new Uint8Array(input) : input;\n    let \
metaFilename = null;\n    const unzipped = unzipSync(fileBytes, {\n      \
filter: ({ name }) => {\n        const filename = \
name.split(/[\\\\/]/).pop();\n        if (filename === \"meta.json\") {\n     \
     metaFilename = name;\n          return true;\n        }\n        return \
false;\n      }\n    });\n    if (!metaFilename) {\n      return void 0;\n    \
}\n    const json = tryPcSogs(unzipped[metaFilename]);\n    if (!json) {\n    \
  return void 0;\n    }\n    return { name: metaFilename, json };\n  } catch \
{\n    return void 0;\n  }\n}\nasync function unpackSplats({\n  input,\n  \
extraFiles,\n  fileType,\n  pathOrUrl,\n  splatEncoding\n}) {\n  const \
fileBytes = input instanceof ArrayBuffer ? new Uint8Array(input) : input;\n  \
let splatFileType = fileType;\n  if (!fileType) {\n    splatFileType = \
getSplatFileType(fileBytes);\n    if (!splatFileType && pathOrUrl) {\n      \
splatFileType = getSplatFileTypeFromPath(pathOrUrl);\n    }\n  }\n  switch \
(splatFileType) {\n    case \"ply\": {\n      const ply = new PlyReader({ \
fileBytes });\n      await ply.parseHeader();\n      const numSplats = \
ply.numSplats;\n      const maxSplats = \
getTextureSize(numSplats).maxSplats;\n      const args = {\n        \
fileBytes,\n        packedArray: new Uint32Array(maxSplats * 4),\n        \
splatEncoding\n      };\n      return await withWorker(async (worker) => {\n  \
      const { packedArray, numSplats: numSplats2, extra } = await \
worker.call(\n          \"unpackPly\",\n          args\n        );\n        \
return { packedArray, numSplats: numSplats2, extra };\n      });\n    }\n    \
case \"spz\": {\n      return await withWorker(async (worker) => {\n        \
const { packedArray, numSplats, extra } = await worker.call(\n          \
\"decodeSpz\",\n          {\n            fileBytes,\n            \
splatEncoding\n          }\n        );\n        return { packedArray, \
numSplats, extra };\n      });\n    }\n    case \"splat\": {\n      return \
await withWorker(async (worker) => {\n        const { packedArray, numSplats \
} = await worker.call(\n          \"decodeAntiSplat\",\n          {\n         \
   fileBytes,\n            splatEncoding\n          }\n        );\n        \
return { packedArray, numSplats };\n      });\n    }\n    case \"ksplat\": \
{\n      return await withWorker(async (worker) => {\n        const { \
packedArray, numSplats, extra } = await worker.call(\n          \
\"decodeKsplat\",\n          { fileBytes, splatEncoding }\n        );\n       \
 return { packedArray, numSplats, extra };\n      });\n    }\n    case \
\"pcsogs\": {\n      return await withWorker(async (worker) => {\n        \
const { packedArray, numSplats, extra } = await worker.call(\n          \
\"decodePcSogs\",\n          { fileBytes, extraFiles, splatEncoding }\n       \
 );\n        return { packedArray, numSplats, extra };\n      });\n    }\n    \
case \"pcsogszip\": {\n      return await withWorker(async (worker) => {\n    \
    const { packedArray, numSplats, extra } = await worker.call(\n          \
\"decodePcSogsZip\",\n          { fileBytes, splatEncoding }\n        );\n    \
    return { packedArray, numSplats, extra };\n      });\n    }\n    default: \
{\n      throw new Error(`Unknown splat file type: ${splatFileType}`);\n    \
}\n  }\n}\nclass SplatData {\n  constructor({ maxSplats = 1 } = {}) {\n    \
this.numSplats = 0;\n    this.maxSplats = \
getTextureSize(maxSplats).maxSplats;\n    this.centers = new \
Float32Array(this.maxSplats * 3);\n    this.scales = new \
Float32Array(this.maxSplats * 3);\n    this.quaternions = new \
Float32Array(this.maxSplats * 4);\n    this.opacities = new \
Float32Array(this.maxSplats);\n    this.colors = new \
Float32Array(this.maxSplats * 3);\n  }\n  pushSplat() {\n    const index = \
this.numSplats;\n    this.ensureIndex(index);\n    this.numSplats += 1;\n    \
return index;\n  }\n  unpushSplat(index) {\n    if (index === this.numSplats \
- 1) {\n      this.numSplats -= 1;\n    } else {\n      throw new \
Error(\"Cannot unpush splat from non-last position\");\n    }\n  }\n  \
ensureCapacity(numSplats) {\n    if (numSplats > this.maxSplats) {\n      \
const targetSplats = Math.max(numSplats, this.maxSplats * 2);\n      const \
newCenters = new Float32Array(targetSplats * 3);\n      const newScales = new \
Float32Array(targetSplats * 3);\n      const newQuaternions = new \
Float32Array(targetSplats * 4);\n      const newOpacities = new \
Float32Array(targetSplats);\n      const newColors = new \
Float32Array(targetSplats * 3);\n      newCenters.set(this.centers);\n      \
newScales.set(this.scales);\n      newQuaternions.set(this.quaternions);\n    \
  newOpacities.set(this.opacities);\n      newColors.set(this.colors);\n      \
this.centers = newCenters;\n      this.scales = newScales;\n      \
this.quaternions = newQuaternions;\n      this.opacities = newOpacities;\n    \
  this.colors = newColors;\n      if (this.sh1) {\n        const newSh1 = new \
Float32Array(targetSplats * 9);\n        newSh1.set(this.sh1);\n        \
this.sh1 = newSh1;\n      }\n      if (this.sh2) {\n        const newSh2 = \
new Float32Array(targetSplats * 15);\n        newSh2.set(this.sh2);\n        \
this.sh2 = newSh2;\n      }\n      if (this.sh3) {\n        const newSh3 = \
new Float32Array(targetSplats * 21);\n        newSh3.set(this.sh3);\n        \
this.sh3 = newSh3;\n      }\n      this.maxSplats = targetSplats;\n    }\n  \
}\n  ensureIndex(index) {\n    this.ensureCapacity(index + 1);\n  }\n  \
setCenter(index, x, y, z) {\n    this.centers[index * 3] = x;\n    \
this.centers[index * 3 + 1] = y;\n    this.centers[index * 3 + 2] = z;\n  }\n \
 setScale(index, scaleX, scaleY, scaleZ) {\n    this.scales[index * 3] = \
scaleX;\n    this.scales[index * 3 + 1] = scaleY;\n    this.scales[index * 3 \
+ 2] = scaleZ;\n  }\n  setQuaternion(index, x, y, z, w) {\n    \
this.quaternions[index * 4] = x;\n    this.quaternions[index * 4 + 1] = y;\n  \
  this.quaternions[index * 4 + 2] = z;\n    this.quaternions[index * 4 + 3] = \
w;\n  }\n  setOpacity(index, opacity) {\n    this.opacities[index] = \
opacity;\n  }\n  setColor(index, r, g, b) {\n    this.colors[index * 3] = \
r;\n    this.colors[index * 3 + 1] = g;\n    this.colors[index * 3 + 2] = \
b;\n  }\n  setSh1(index, sh1) {\n    if (!this.sh1) {\n      this.sh1 = new \
Float32Array(this.maxSplats * 9);\n    }\n    for (let j = 0; j < 9; ++j) {\n \
     this.sh1[index * 9 + j] = sh1[j];\n    }\n  }\n  setSh2(index, sh2) {\n  \
  if (!this.sh2) {\n      this.sh2 = new Float32Array(this.maxSplats * 15);\n \
   }\n    for (let j = 0; j < 15; ++j) {\n      this.sh2[index * 15 + j] = \
sh2[j];\n    }\n  }\n  setSh3(index, sh3) {\n    if (!this.sh3) {\n      \
this.sh3 = new Float32Array(this.maxSplats * 21);\n    }\n    for (let j = 0; \
j < 21; ++j) {\n      this.sh3[index * 21 + j] = sh3[j];\n    }\n  }\n}\nvar \
computeUvec4_default = \"precision highp float;\\nprecision highp \
int;\\nprecision highp sampler2D;\\nprecision highp usampler2D;\\nprecision \
highp isampler2D;\\nprecision highp sampler2DArray;\\nprecision highp \
usampler2DArray;\\nprecision highp isampler2DArray;\\nprecision highp \
sampler3D;\\nprecision highp usampler3D;\\nprecision highp \
isampler3D;\\n\\n#include <splatDefines>\\n\\nuniform uint \
targetLayer;\\nuniform int targetBase;\\nuniform int targetCount;\\n\\nout \
uvec4 target;\\n\\n{{ GLOBALS }}\\n\\nvoid produceSplat(int index) {\\n    {{ \
STATEMENTS }}\\n}\\n\\nvoid main() {\\n    int targetIndex = int(targetLayer \
<< SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) \
+ int(gl_FragCoord.x);\\n    int index = targetIndex - targetBase;\\n\\n    \
if ((index >= 0) && (index < targetCount)) {\\n        \
produceSplat(index);\\n    } else {\\n        target = uvec4(0u, 0u, 0u, \
0u);\\n    }\\n}\";\nconst DEFAULT_SPLAT_ENCODING = {\n  rgbMin: 0,\n  \
rgbMax: 1,\n  lnScaleMin: LN_SCALE_MIN,\n  lnScaleMax: LN_SCALE_MAX,\n  \
sh1Min: -1,\n  sh1Max: 1,\n  sh2Min: -1,\n  sh2Max: 1,\n  sh3Min: -1,\n  \
sh3Max: 1\n};\nconst _PackedSplats = class _PackedSplats {\n  \
constructor(options = {}) {\n    this.maxSplats = 0;\n    this.numSplats = \
0;\n    this.packedArray = null;\n    this.isInitialized = false;\n    \
this.target = null;\n    this.source = null;\n    this.needsUpdate = true;\n  \
  this.extra = {};\n    this.dyno = new DynoPackedSplats({ packedSplats: this \
});\n    this.dynoRgbMinMaxLnScaleMinMax = new DynoVec4({\n      key: \
\"rgbMinMaxLnScaleMinMax\",\n      value: new THREE.Vector4(0, 1, \
LN_SCALE_MIN, LN_SCALE_MAX),\n      update: (value) => {\n        var _a2, \
_b2, _c, _d;\n        value.set(\n          ((_a2 = this.splatEncoding) == \
null ? void 0 : _a2.rgbMin) ?? 0,\n          ((_b2 = this.splatEncoding) == \
null ? void 0 : _b2.rgbMax) ?? 1,\n          ((_c = this.splatEncoding) == \
null ? void 0 : _c.lnScaleMin) ?? LN_SCALE_MIN,\n          ((_d = \
this.splatEncoding) == null ? void 0 : _d.lnScaleMax) ?? LN_SCALE_MAX\n       \
 );\n        return value;\n      }\n    });\n    this.dynoSh1MinMax = new \
DynoVec2({\n      key: \"sh1MinMax\",\n      value: new THREE.Vector2(-1, \
1),\n      update: (value) => {\n        var _a2, _b2;\n        value.set(\n  \
        ((_a2 = this.splatEncoding) == null ? void 0 : _a2.sh1Min) ?? -1,\n   \
       ((_b2 = this.splatEncoding) == null ? void 0 : _b2.sh1Max) ?? 1\n      \
  );\n        return value;\n      }\n    });\n    this.dynoSh2MinMax = new \
DynoVec2({\n      key: \"sh2MinMax\",\n      value: new THREE.Vector2(-1, \
1),\n      update: (value) => {\n        var _a2, _b2;\n        value.set(\n  \
        ((_a2 = this.splatEncoding) == null ? void 0 : _a2.sh2Min) ?? -1,\n   \
       ((_b2 = this.splatEncoding) == null ? void 0 : _b2.sh2Max) ?? 1\n      \
  );\n        return value;\n      }\n    });\n    this.dynoSh3MinMax = new \
DynoVec2({\n      key: \"sh3MinMax\",\n      value: new THREE.Vector2(-1, \
1),\n      update: (value) => {\n        var _a2, _b2;\n        value.set(\n  \
        ((_a2 = this.splatEncoding) == null ? void 0 : _a2.sh3Min) ?? -1,\n   \
       ((_b2 = this.splatEncoding) == null ? void 0 : _b2.sh3Max) ?? 1\n      \
  );\n        return value;\n      }\n    });\n    this.initialized = \
Promise.resolve(this);\n    this.reinitialize(options);\n  }\n  \
reinitialize(options) {\n    this.isInitialized = false;\n    this.extra = \
{};\n    this.splatEncoding = options.splatEncoding;\n    if (options.url || \
options.fileBytes || options.construct) {\n      this.initialized = \
this.asyncInitialize(options).then(() => {\n        this.isInitialized = \
true;\n        return this;\n      });\n    } else {\n      \
this.initialize(options);\n      this.isInitialized = true;\n      \
this.initialized = Promise.resolve(this);\n    }\n  }\n  initialize(options) \
{\n    if (options.packedArray) {\n      this.packedArray = \
options.packedArray;\n      this.maxSplats = \
Math.floor(this.packedArray.length / 4);\n      this.maxSplats = \
Math.floor(this.maxSplats / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n      \
this.numSplats = Math.min(\n        this.maxSplats,\n        \
options.numSplats ?? Number.POSITIVE_INFINITY\n      );\n    } else {\n      \
this.maxSplats = options.maxSplats ?? 0;\n      this.numSplats = 0;\n    }\n  \
  this.extra = options.extra ?? {};\n  }\n  async asyncInitialize(options) \
{\n    const { url, fileBytes, construct } = options;\n    if (url) {\n      \
const loader = new SplatLoader();\n      loader.packedSplats = this;\n      \
await loader.loadAsync(url);\n    } else if (fileBytes) {\n      const \
unpacked = await unpackSplats({\n        input: fileBytes,\n        fileType: \
options.fileType,\n        pathOrUrl: options.fileName ?? url,\n        \
splatEncoding: options.splatEncoding ?? DEFAULT_SPLAT_ENCODING\n      });\n   \
   this.initialize(unpacked);\n    }\n    if (construct) {\n      const \
maybePromise = construct(this);\n      if (maybePromise instanceof Promise) \
{\n        await maybePromise;\n      }\n    }\n  }\n  // Call this when you \
are finished with the PackedSplats and want to free\n  // any buffers it \
holds.\n  dispose() {\n    if (this.target) {\n      this.target.dispose();\n \
     this.target = null;\n    }\n    if (this.source) {\n      \
this.source.dispose();\n      this.source = null;\n    }\n  }\n  // Ensures \
that this.packedArray can fit numSplats Gsplats. If it's too small,\n  // \
resize exponentially and copy over the original data.\n  //\n  // Typically \
you don't need to call this, because calling this.setSplat(index, ...)\n  // \
and this.pushSplat(...) will automatically call ensureSplats() so we have\n  \
// enough splats.\n  ensureSplats(numSplats) {\n    const targetSize = \
numSplats <= this.maxSplats ? this.maxSplats : (\n      // Grow exponentially \
to avoid frequent reallocations\n      Math.max(numSplats, 2 * \
this.maxSplats)\n    );\n    const currentSize = !this.packedArray ? 0 : \
this.packedArray.length / 4;\n    if (!this.packedArray || targetSize > \
currentSize) {\n      this.maxSplats = \
getTextureSize(targetSize).maxSplats;\n      const newArray2 = new \
Uint32Array(this.maxSplats * 4);\n      if (this.packedArray) {\n        \
newArray2.set(this.packedArray);\n      }\n      this.packedArray = \
newArray2;\n    }\n    return this.packedArray;\n  }\n  // Ensure the extra \
array for the given level is large enough to hold numSplats\n  \
ensureSplatsSh(level, numSplats) {\n    let wordsPerSplat;\n    let key;\n    \
if (level === 0) {\n      return this.ensureSplats(numSplats);\n    }\n    if \
(level === 1) {\n      wordsPerSplat = 2;\n      key = \"sh1\";\n    } else \
if (level === 2) {\n      wordsPerSplat = 4;\n      key = \"sh2\";\n    } \
else if (level === 3) {\n      wordsPerSplat = 4;\n      key = \"sh3\";\n    \
} else {\n      throw new Error(`Invalid level: ${level}`);\n    }\n    let \
maxSplats = !this.extra[key] ? 0 : this.extra[key].length / wordsPerSplat;\n  \
  const targetSize = numSplats <= maxSplats ? maxSplats : Math.max(numSplats, \
2 * maxSplats);\n    if (!this.extra[key] || targetSize > maxSplats) {\n      \
maxSplats = getTextureSize(targetSize).maxSplats;\n      const newArray2 = \
new Uint32Array(maxSplats * wordsPerSplat);\n      if (this.extra[key]) {\n   \
     newArray2.set(this.extra[key]);\n      }\n      this.extra[key] = \
newArray2;\n    }\n    return this.extra[key];\n  }\n  // Unpack the 16-byte \
Gsplat data at index into the Three.js components\n  // center: \
THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion,\n  // \
opacity: number 0..1, color: THREE.Color 0..1.\n  getSplat(index) {\n    if \
(!this.packedArray || index >= this.numSplats) {\n      throw new \
Error(\"Invalid index\");\n    }\n    return unpackSplat(this.packedArray, \
index, this.splatEncoding);\n  }\n  // Set all PackedSplat components at \
index with the provided Gsplat attributes\n  // (can be the same objects \
returned by getSplat). Ensures there is capacity\n  // for at least index+1 \
Gsplats.\n  setSplat(index, center, scales, quaternion, opacity, color) {\n   \
 const packedSplats = this.ensureSplats(index + 1);\n    setPackedSplat(\n    \
  packedSplats,\n      index,\n      center.x,\n      center.y,\n      \
center.z,\n      scales.x,\n      scales.y,\n      scales.z,\n      \
quaternion.x,\n      quaternion.y,\n      quaternion.z,\n      \
quaternion.w,\n      opacity,\n      color.r,\n      color.g,\n      \
color.b\n    );\n    this.numSplats = Math.max(this.numSplats, index + 1);\n  \
}\n  // Effectively calls this.setSplat(this.numSplats++, center, ...), \
useful on\n  // construction where you just want to iterate and create a \
collection of Gsplats.\n  pushSplat(center, scales, quaternion, opacity, \
color) {\n    const packedSplats = this.ensureSplats(this.numSplats + 1);\n   \
 setPackedSplat(\n      packedSplats,\n      this.numSplats,\n      \
center.x,\n      center.y,\n      center.z,\n      scales.x,\n      \
scales.y,\n      scales.z,\n      quaternion.x,\n      quaternion.y,\n      \
quaternion.z,\n      quaternion.w,\n      opacity,\n      color.r,\n      \
color.g,\n      color.b\n    );\n    ++this.numSplats;\n  }\n  // Iterate \
over Gsplats index 0..=(this.numSplats-1), unpack each Gsplat\n  // and \
invoke the callback function with the Gsplat attributes.\n  \
forEachSplat(callback) {\n    if (!this.packedArray || !this.numSplats) {\n   \
   return;\n    }\n    for (let i = 0; i < this.numSplats; ++i) {\n      \
const unpacked = unpackSplat(this.packedArray, i, this.splatEncoding);\n      \
callback(\n        i,\n        unpacked.center,\n        unpacked.scales,\n   \
     unpacked.quaternion,\n        unpacked.opacity,\n        \
unpacked.color\n      );\n    }\n  }\n  // Ensures our PackedSplats.target \
render target has enough space to generate\n  // maxSplats total Gsplats, and \
reallocate if not large enough.\n  ensureGenerate(maxSplats) {\n    if \
(this.target && (maxSplats ?? 1) <= this.maxSplats) {\n      return false;\n  \
  }\n    this.dispose();\n    const textureSize2 = getTextureSize(maxSplats \
?? 1);\n    const { width, height, depth } = textureSize2;\n    \
this.maxSplats = textureSize2.maxSplats;\n    this.target = new \
THREE.WebGLArrayRenderTarget(width, height, depth, {\n      depthBuffer: \
false,\n      stencilBuffer: false,\n      generateMipmaps: false,\n      \
magFilter: THREE.NearestFilter,\n      minFilter: THREE.NearestFilter\n    \
});\n    this.target.texture.format = THREE.RGBAIntegerFormat;\n    \
this.target.texture.type = THREE.UnsignedIntType;\n    \
this.target.texture.internalFormat = \"RGBA32UI\";\n    \
this.target.scissorTest = true;\n    return true;\n  }\n  // Given an array \
of splatCounts (.numSplats for each\n  // SplatGenerator/SplatMesh in the \
scene), compute a\n  // \"mapping layout\" in the composite array of \
generated outputs.\n  generateMapping(splatCounts) {\n    let maxSplats = \
0;\n    const mapping = splatCounts.map((numSplats) => {\n      const base = \
maxSplats;\n      const rounded = Math.ceil(numSplats / SPLAT_TEX_WIDTH) * \
SPLAT_TEX_WIDTH;\n      maxSplats += rounded;\n      return { base, count: \
numSplats };\n    });\n    return { maxSplats, mapping };\n  }\n  // Returns \
a THREE.DataArrayTexture representing the PackedSplats content as\n  // a \
Uint32x4 data array texture (2048 x 2048 x depth in size)\n  getTexture() {\n \
   if (this.target) {\n      return this.target.texture;\n    }\n    if \
(this.source || this.packedArray) {\n      const source = \
this.maybeUpdateSource();\n      return source;\n    }\n    return \
_PackedSplats.getEmpty();\n  }\n  // Check if source texture needs to be \
created/updated\n  maybeUpdateSource() {\n    if (!this.packedArray) {\n      \
throw new Error(\"No packed splats\");\n    }\n    if (this.needsUpdate || \
!this.source) {\n      this.needsUpdate = false;\n      if (this.source) {\n  \
      const { width, height, depth } = this.source.image;\n        if \
(this.maxSplats !== width * height * depth) {\n          \
this.source.dispose();\n          this.source = null;\n        }\n      }\n   \
   if (!this.source) {\n        const { width, height, depth } = \
getTextureSize(this.maxSplats);\n        this.source = new \
THREE.DataArrayTexture(\n          this.packedArray,\n          width,\n      \
    height,\n          depth\n        );\n        this.source.format = \
THREE.RGBAIntegerFormat;\n        this.source.type = THREE.UnsignedIntType;\n \
       this.source.internalFormat = \"RGBA32UI\";\n        \
this.source.needsUpdate = true;\n      } else if (this.packedArray.buffer !== \
this.source.image.data.buffer) {\n        this.source.image.data = new \
Uint8Array(this.packedArray.buffer);\n      }\n      this.source.needsUpdate \
= true;\n    }\n    return this.source;\n  }\n  // Can be used where you need \
an uninitialized THREE.DataArrayTexture like\n  // a uniform you will update \
with the result of this.getTexture() later.\n  static getEmpty() {\n    if \
(!_PackedSplats.emptySource) {\n      const { width, height, depth, maxSplats \
} = getTextureSize(1);\n      const emptyArray = new Uint32Array(maxSplats * \
4);\n      _PackedSplats.emptySource = new THREE.DataArrayTexture(\n        \
emptyArray,\n        width,\n        height,\n        depth\n      );\n      \
_PackedSplats.emptySource.format = THREE.RGBAIntegerFormat;\n      \
_PackedSplats.emptySource.type = THREE.UnsignedIntType;\n      \
_PackedSplats.emptySource.internalFormat = \"RGBA32UI\";\n      \
_PackedSplats.emptySource.needsUpdate = true;\n    }\n    return \
_PackedSplats.emptySource;\n  }\n  // Get a program and \
THREE.RawShaderMaterial for a given GsplatGenerator,\n  // generating it if \
necessary and caching the result.\n  prepareProgramMaterial(generator) {\n    \
let program = _PackedSplats.generatorProgram.get(generator);\n    if \
(!program) {\n      const graph = dynoBlock(\n        { index: \"int\" },\n   \
     { output: \"uvec4\" },\n        ({ index }) => {\n          \
generator.inputs.index = index;\n          const gsplat = \
generator.outputs.gsplat;\n          const output = outputPackedSplat(\n      \
      gsplat,\n            this.dynoRgbMinMaxLnScaleMinMax\n          );\n    \
      return { output };\n        }\n      );\n      if \
(!_PackedSplats.programTemplate) {\n        _PackedSplats.programTemplate = \
new DynoProgramTemplate(\n          computeUvec4_default\n        );\n      \
}\n      program = new DynoProgram({\n        graph,\n        inputs: { \
index: \"index\" },\n        outputs: { output: \"target\" },\n        \
template: _PackedSplats.programTemplate\n      });\n      \
Object.assign(program.uniforms, {\n        targetLayer: { value: 0 },\n       \
 targetBase: { value: 0 },\n        targetCount: { value: 0 }\n      });\n    \
  _PackedSplats.generatorProgram.set(generator, program);\n    }\n    const \
material = program.prepareMaterial();\n    \
_PackedSplats.fullScreenQuad.material = material;\n    return { program, \
material };\n  }\n  saveRenderState(renderer) {\n    return {\n      \
xrEnabled: renderer.xr.enabled,\n      autoClear: renderer.autoClear\n    \
};\n  }\n  resetRenderState(renderer, state) {\n    \
renderer.setRenderTarget(null);\n    renderer.xr.enabled = state.xrEnabled;\n \
   renderer.autoClear = state.autoClear;\n  }\n  // Executes a dyno program \
specified by generator which is any DynoBlock that\n  // maps { index: \
\"int\" } to { gsplat: Gsplat }. This is called in\n  // \
SparkRenderer.updateInternal() to re-generate Gsplats in the scene for\n  // \
SplatGenerator instances whose version is newer than what was generated\n  // \
for it last time.\n  generate({\n    generator,\n    base,\n    count,\n    \
renderer\n  }) {\n    if (!this.target) {\n      throw new Error(\"Target \
must be initialized with ensureSplats\");\n    }\n    if (base + count > \
this.maxSplats) {\n      throw new Error(\"Base + count exceeds \
maxSplats\");\n    }\n    const { program, material } = \
this.prepareProgramMaterial(generator);\n    program.update();\n    const \
renderState = this.saveRenderState(renderer);\n    const nextBase = \
Math.ceil((base + count) / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n    const \
layerSize = SPLAT_TEX_WIDTH * SPLAT_TEX_HEIGHT;\n    \
material.uniforms.targetBase.value = base;\n    \
material.uniforms.targetCount.value = count;\n    while (base < nextBase) {\n \
     const layer = Math.floor(base / layerSize);\n      \
material.uniforms.targetLayer.value = layer;\n      const layerBase = layer * \
layerSize;\n      const layerYStart = Math.floor((base - layerBase) / \
SPLAT_TEX_WIDTH);\n      const layerYEnd = Math.min(\n        \
SPLAT_TEX_HEIGHT,\n        Math.ceil((nextBase - layerBase) / \
SPLAT_TEX_WIDTH)\n      );\n      this.target.scissor.set(\n        0,\n      \
  layerYStart,\n        SPLAT_TEX_WIDTH,\n        layerYEnd - layerYStart\n   \
   );\n      renderer.setRenderTarget(this.target, layer);\n      \
renderer.xr.enabled = false;\n      renderer.autoClear = false;\n      \
_PackedSplats.fullScreenQuad.render(renderer);\n      base += SPLAT_TEX_WIDTH \
* (layerYEnd - layerYStart);\n    }\n    this.resetRenderState(renderer, \
renderState);\n    return { nextBase };\n  }\n};\n_PackedSplats.emptySource = \
null;\n_PackedSplats.programTemplate = null;\n_PackedSplats.generatorProgram \
= /* @__PURE__ */ new Map();\n_PackedSplats.fullScreenQuad = new \
FullScreenQuad(\n  new THREE.RawShaderMaterial({ visible: false })\n);\nlet \
PackedSplats = _PackedSplats;\nclass DynoPackedSplats extends DynoUniform {\n \
 constructor({ packedSplats } = {}) {\n    super({\n      key: \
\"packedSplats\",\n      type: TPackedSplats,\n      globals: () => \
[definePackedSplats],\n      value: {\n        texture: \
PackedSplats.getEmpty(),\n        numSplats: 0,\n        \
rgbMinMaxLnScaleMinMax: new THREE.Vector4(\n          0,\n          1,\n      \
    LN_SCALE_MIN,\n          LN_SCALE_MAX\n        )\n      },\n      update: \
(value) => {\n        var _a2, _b2, _c, _d, _e, _f, _g, _h, _i, _j;\n        \
value.texture = ((_a2 = this.packedSplats) == null ? void 0 : \
_a2.getTexture()) ?? PackedSplats.getEmpty();\n        value.numSplats = \
((_b2 = this.packedSplats) == null ? void 0 : _b2.numSplats) ?? 0;\n        \
value.rgbMinMaxLnScaleMinMax.set(\n          ((_d = (_c = this.packedSplats) \
== null ? void 0 : _c.splatEncoding) == null ? void 0 : _d.rgbMin) ?? 0,\n    \
      ((_f = (_e = this.packedSplats) == null ? void 0 : _e.splatEncoding) == \
null ? void 0 : _f.rgbMax) ?? 1,\n          ((_h = (_g = this.packedSplats) \
== null ? void 0 : _g.splatEncoding) == null ? void 0 : _h.lnScaleMin) ?? \
LN_SCALE_MIN,\n          ((_j = (_i = this.packedSplats) == null ? void 0 : \
_i.splatEncoding) == null ? void 0 : _j.lnScaleMax) ?? LN_SCALE_MAX\n        \
);\n        return value;\n      }\n    });\n    this.packedSplats = \
packedSplats;\n  }\n}\nclass SplatGeometry extends \
THREE.InstancedBufferGeometry {\n  constructor(ordering, activeSplats) {\n    \
super();\n    this.ordering = ordering;\n    this.setAttribute(\"position\", \
new THREE.BufferAttribute(QUAD_VERTICES, 3));\n    this.setIndex(new \
THREE.BufferAttribute(QUAD_INDICES, 1));\n    this._maxInstanceCount = \
ordering.length;\n    this.instanceCount = activeSplats;\n    this.attribute \
= new THREE.InstancedBufferAttribute(ordering, 1, false, 1);\n    \
this.attribute.setUsage(THREE.DynamicDrawUsage);\n    \
this.setAttribute(\"splatIndex\", this.attribute);\n  }\n  update(ordering, \
activeSplats) {\n    this.ordering = ordering;\n    this.attribute.array = \
ordering;\n    this.instanceCount = activeSplats;\n    \
this.attribute.addUpdateRange(0, activeSplats);\n    \
this.attribute.needsUpdate = true;\n  }\n}\nconst QUAD_VERTICES = new \
Float32Array([\n  -1,\n  -1,\n  0,\n  1,\n  -1,\n  0,\n  1,\n  1,\n  0,\n  \
-1,\n  1,\n  0\n]);\nconst QUAD_INDICES = new Uint16Array([0, 1, 2, 0, 2, \
3]);\nconst _SparkViewpoint = class _SparkViewpoint {\n  constructor(options) \
{\n    this.lastTime = null;\n    this.encodeLinear = false;\n    \
this.superXY = 1;\n    this.display = null;\n    this.sorting = null;\n    \
this.pending = null;\n    this.sortingCheck = false;\n    this.readback16 = \
new Uint16Array(0);\n    this.readback32 = new Uint32Array(0);\n    \
this.spark = options.spark;\n    this.camera = options.camera;\n    \
this.viewToWorld = options.viewToWorld ?? new THREE.Matrix4();\n    if \
(options.target) {\n      const { width, height, doubleBuffer } = \
options.target;\n      const superXY = Math.max(1, Math.min(4, \
options.target.superXY ?? 1));\n      this.superXY = superXY;\n      if \
(width * superXY > 8192 || height * superXY > 8192) {\n        throw new \
Error(\"Target size too large\");\n      }\n      this.target = new \
THREE.WebGLRenderTarget(\n        width * superXY,\n        height * \
superXY,\n        {\n          format: THREE.RGBAFormat,\n          type: \
THREE.UnsignedByteType,\n          colorSpace: THREE.SRGBColorSpace\n        \
}\n      );\n      if (doubleBuffer) {\n        this.back = new \
THREE.WebGLRenderTarget(\n          width * superXY,\n          height * \
superXY,\n          {\n            format: THREE.RGBAFormat,\n            \
type: THREE.UnsignedByteType,\n            colorSpace: THREE.SRGBColorSpace\n \
         }\n        );\n      }\n      this.encodeLinear = true;\n    }\n    \
this.onTextureUpdated = options.onTextureUpdated;\n    this.sortRadial = \
options.sortRadial ?? true;\n    this.sortDistance = options.sortDistance;\n  \
  this.sortCoorient = options.sortCoorient;\n    this.depthBias = \
options.depthBias;\n    this.sort360 = options.sort360;\n    this.sort32 = \
options.sort32;\n    this.stochastic = options.stochastic ?? false;\n    \
this.orderingFreelist = new FreeList({\n      allocate: (maxSplats) => new \
Uint32Array(maxSplats),\n      valid: (ordering, maxSplats) => \
ordering.length === maxSplats\n    });\n    this.autoUpdate = false;\n    \
this.setAutoUpdate(options.autoUpdate ?? false);\n  }\n  // Call this when \
you are done with the SparkViewpoint and want to\n  // free up its resources \
(GPU targets, pixel buffers, etc.)\n  dispose() {\n    var _a2;\n    \
this.setAutoUpdate(false);\n    if (this.target) {\n      \
this.target.dispose();\n      this.target = void 0;\n    }\n    if \
(this.back) {\n      this.back.dispose();\n      this.back = void 0;\n    }\n \
   if (this.display) {\n      \
this.spark.releaseAccumulator(this.display.accumulator);\n      \
this.display.geometry.dispose();\n      this.display = null;\n    }\n    if \
((_a2 = this.pending) == null ? void 0 : _a2.accumulator) {\n      \
this.spark.releaseAccumulator(this.pending.accumulator);\n      this.pending \
= null;\n    }\n  }\n  // Use this function to change whether this viewpoint \
will auto-update\n  // its sort order whenever the attached SparkRenderer \
updates the Gsplats.\n  // Turn this on or off depending on whether you \
expect to do renders from\n  // this viewpoint most frames.\n  \
setAutoUpdate(autoUpdate) {\n    if (!this.autoUpdate && autoUpdate) {\n      \
this.spark.autoViewpoints.push(this);\n    } else if (this.autoUpdate && \
!autoUpdate) {\n      this.spark.autoViewpoints = \
this.spark.autoViewpoints.filter(\n        (v) => v !== this\n      );\n    \
}\n    this.autoUpdate = autoUpdate;\n  }\n  // See below async \
prepareRenderPixels() for explanation of parameters.\n  // Awaiting this \
method updates the Gsplats in the scene and performs a sort of the\n  // \
Gsplats from this viewpoint, preparing it for a subsequent \
this.renderTarget()\n  // call in the same tick.\n  async prepare({\n    \
scene,\n    camera,\n    viewToWorld,\n    update,\n    forceOrigin\n  }) {\n \
   var _a2;\n    if (viewToWorld) {\n      this.viewToWorld = viewToWorld;\n  \
  } else {\n      this.camera = camera ?? this.camera;\n      if \
(this.camera) {\n        this.camera.updateMatrixWorld();\n        \
this.viewToWorld = this.camera.matrixWorld.clone();\n      }\n    }\n    \
while (update ?? true) {\n      const originToWorld = forceOrigin ? \
this.viewToWorld : void 0;\n      const updated = this.spark.updateInternal({ \
scene, originToWorld });\n      if (updated) {\n        break;\n      }\n     \
 await new Promise((resolve) => setTimeout(resolve, 10));\n    }\n    const \
accumulator = this.spark.active;\n    if (accumulator !== ((_a2 = \
this.display) == null ? void 0 : _a2.accumulator)) {\n      \
this.spark.active.refCount += 1;\n    }\n    await this.sortUpdate({ \
accumulator, viewToWorld: this.viewToWorld });\n  }\n  // Render out the \
viewpoint to the view target RGBA buffer.\n  // Swaps buffers if \
doubleBuffer: true was set.\n  // Calls onTextureUpdated(texture) with the \
resulting texture.\n  renderTarget({\n    scene,\n    camera\n  }) {\n    var \
_a2;\n    const target = this.back ?? this.target;\n    if (!target) {\n      \
throw new Error(\"Must initialize SparkViewpoint with target\");\n    }\n    \
camera = camera ?? this.camera;\n    if (!camera) {\n      throw new \
Error(\"Must provide camera\");\n    }\n    if (camera instanceof \
THREE.PerspectiveCamera) {\n      const newCam = new \
THREE.PerspectiveCamera().copy(camera, false);\n      newCam.aspect = \
target.width / target.height;\n      newCam.updateProjectionMatrix();\n      \
camera = newCam;\n    }\n    this.viewToWorld = camera.matrixWorld.clone();\n \
   try {\n      this.spark.renderer.setRenderTarget(target);\n      \
this.spark.prepareViewpoint(this);\n      this.spark.renderer.render(scene, \
camera);\n    } finally {\n      \
this.spark.prepareViewpoint(this.spark.defaultView);\n      \
this.spark.renderer.setRenderTarget(null);\n    }\n    if (target !== \
this.target) {\n      [this.target, this.back] = [this.back, this.target];\n  \
  }\n    (_a2 = this.onTextureUpdated) == null ? void 0 : _a2.call(this, \
target.texture);\n  }\n  // Read back the previously rendered target image as \
a Uint8Array of packed\n  // RGBA values (in that order). If superXY was set \
greater than 1 then\n  // downsampling is performed in the target pixel array \
with simple averaging\n  // to derive the returned pixel values. Subsequent \
calls to this.readTarget()\n  // will reuse the same buffers to minimize \
memory allocations.\n  async readTarget() {\n    if (!this.target) {\n      \
throw new Error(\"Must initialize SparkViewpoint with target\");\n    }\n    \
const { width, height } = this.target;\n    const byteSize = width * height * \
4;\n    if (!this.superPixels || this.superPixels.length < byteSize) {\n      \
this.superPixels = new Uint8Array(byteSize);\n    }\n    await \
this.spark.renderer.readRenderTargetPixelsAsync(\n      this.target,\n      \
0,\n      0,\n      width,\n      height,\n      this.superPixels\n    );\n   \
 const { superXY } = this;\n    if (superXY === 1) {\n      return \
this.superPixels;\n    }\n    const subWidth = width / superXY;\n    const \
subHeight = height / superXY;\n    const subSize = subWidth * subHeight * \
4;\n    if (!this.pixels || this.pixels.length < subSize) {\n      \
this.pixels = new Uint8Array(subSize);\n    }\n    const { superPixels, \
pixels } = this;\n    const super2 = superXY * superXY;\n    for (let y = 0; \
y < subHeight; y++) {\n      const row = y * subWidth;\n      for (let x = 0; \
x < subWidth; x++) {\n        const superCol = x * superXY;\n        let r = \
0;\n        let g = 0;\n        let b = 0;\n        let a = 0;\n        for \
(let sy = 0; sy < superXY; sy++) {\n          const superRow = (y * superXY + \
sy) * this.target.width;\n          for (let sx = 0; sx < superXY; sx++) {\n  \
          const superIndex = (superRow + superCol + sx) * 4;\n            r \
+= superPixels[superIndex];\n            g += superPixels[superIndex + 1];\n  \
          b += superPixels[superIndex + 2];\n            a += \
superPixels[superIndex + 3];\n          }\n        }\n        const \
pixelIndex = (row + x) * 4;\n        pixels[pixelIndex] = r / super2;\n       \
 pixels[pixelIndex + 1] = g / super2;\n        pixels[pixelIndex + 2] = b / \
super2;\n        pixels[pixelIndex + 3] = a / super2;\n      }\n    }\n    \
return pixels;\n  }\n  // Render out a viewpoint as a Uint8Array of RGBA \
values for the provided scene\n  // and any camera/viewToWorld viewpoint \
overrides. By default update is true,\n  // which triggers its SparkRenderer \
to check and potentially update the Gsplats.\n  // Setting update to false \
disables this and sorts the Gsplats as they are.\n  // Setting forceOrigin \
(default: false) to true forces the view update to\n  // recalculate the \
splats with this view origin, potentially altering any\n  // view-dependent \
effects. If you expect view-dependent effects to play a role\n  // in the \
rendering quality, enable this.\n  //\n  // Underneath, prepareRenderPixels() \
simply calls await this.prepare(...),\n  // this.renderTarget(...), and \
finally returns the result this.readTarget(),\n  // a Promise to a Uint8Array \
with RGBA values for all the pixels (potentially\n  // downsampled if the \
superXY parameter was used). These steps can also be called\n  // manually, \
for example if you need to alter the scene before and after\n  // \
this.renderTarget(...) to hide UI elements from being rendered.\n  async \
prepareRenderPixels({\n    scene,\n    camera,\n    viewToWorld,\n    \
update,\n    forceOrigin\n  }) {\n    await this.prepare({ scene, camera, \
viewToWorld, update, forceOrigin });\n    this.renderTarget({ scene, camera \
});\n    return this.readTarget();\n  }\n  // This is called automatically by \
SparkRenderer, there is no need to call it!\n  // The method cannot be \
private because then SparkRenderer would\n  // not be able to call it.\n  \
autoPoll({ accumulator }) {\n    var _a2, _b2, _c, _d;\n    if (this.camera) \
{\n      this.camera.updateMatrixWorld();\n      this.viewToWorld = \
this.camera.matrixWorld.clone();\n    }\n    let needsSort = false;\n    let \
displayed = false;\n    if (!this.display) {\n      needsSort = true;\n    } \
else if (accumulator) {\n      needsSort = true;\n      const { \
mappingVersion } = this.display.accumulator;\n      if \
(accumulator.mappingVersion === mappingVersion) {\n        \
this.spark.releaseAccumulator(this.display.accumulator);\n        \
this.display.accumulator = accumulator;\n        displayed = true;\n      }\n \
   }\n    const latestView = ((_a2 = this.sorting) == null ? void 0 : \
_a2.viewToWorld) ?? ((_b2 = this.display) == null ? void 0 : \
_b2.viewToWorld);\n    if (latestView && !withinCoorientDist({\n      \
matrix1: this.viewToWorld,\n      matrix2: latestView,\n      // By default \
update sort each 1 cm\n      maxDistance: this.sortDistance ?? 0.01,\n      \
// By default for radial sort, update for intermittent movement so that\n     \
 // we bring back splats culled by being behind the camera.\n      // For \
depth sort, small rotations can change sort order a lot, so\n      // update \
sort for even small rotations.\n      minCoorient: this.sortCoorient ?? \
this.sortRadial ? 0.99 : 0.999\n    })) {\n      needsSort = true;\n    }\n   \
 if (!needsSort) {\n      return;\n    }\n    if (accumulator) {\n      \
accumulator.refCount += 1;\n    }\n    if (accumulator && ((_c = \
this.pending) == null ? void 0 : _c.accumulator) && this.pending.accumulator \
!== ((_d = this.display) == null ? void 0 : _d.accumulator)) {\n      \
this.spark.releaseAccumulator(this.pending.accumulator);\n    }\n    \
this.pending = { accumulator, viewToWorld: this.viewToWorld, displayed };\n   \
 this.driveSort();\n  }\n  async driveSort() {\n    var _a2;\n    while \
(true) {\n      if (this.sorting || !this.pending) {\n        return;\n      \
}\n      const { viewToWorld, displayed } = this.pending;\n      let \
accumulator = this.pending.accumulator ?? ((_a2 = this.display) == null ? \
void 0 : _a2.accumulator);\n      if (!accumulator) {\n        accumulator = \
this.spark.active;\n        accumulator.refCount += 1;\n      }\n      \
this.pending = null;\n      if (!accumulator) {\n        throw new Error(\"No \
accumulator to sort\");\n      }\n      this.sorting = { viewToWorld };\n     \
 await this.sortUpdate({ accumulator, viewToWorld, displayed });\n      \
this.sorting = null;\n    }\n  }\n  async sortUpdate({\n    accumulator,\n    \
viewToWorld,\n    displayed = false\n  }) {\n    if (this.sortingCheck) {\n   \
   throw new Error(\"Only one sort at a time\");\n    }\n    \
this.sortingCheck = true;\n    accumulator = accumulator ?? \
this.spark.active;\n    const { numSplats, maxSplats } = \
accumulator.splats;\n    let activeSplats = 0;\n    let ordering = \
this.orderingFreelist.alloc(maxSplats);\n    if (this.stochastic) {\n      \
activeSplats = numSplats;\n      for (let i = 0; i < numSplats; ++i) {\n      \
  ordering[i] = i;\n      }\n    } else if (numSplats > 0) {\n      const {\n \
       reader,\n        doubleSortReader,\n        sort32Reader,\n        \
dynoSortRadial,\n        dynoOrigin,\n        dynoDirection,\n        \
dynoDepthBias,\n        dynoSort360,\n        dynoSplats\n      } = \
_SparkViewpoint.makeSorter();\n      const sort32 = this.sort32 ?? false;\n   \
   let readback;\n      if (sort32) {\n        this.readback32 = \
reader.ensureBuffer(maxSplats, this.readback32);\n        readback = \
this.readback32;\n      } else {\n        const halfMaxSplats = \
Math.ceil(maxSplats / 2);\n        this.readback16 = \
reader.ensureBuffer(halfMaxSplats, this.readback16);\n        readback = \
this.readback16;\n      }\n      const worldToOrigin = \
accumulator.toWorld.clone().invert();\n      const viewToOrigin = \
viewToWorld.clone().premultiply(worldToOrigin);\n      dynoSortRadial.value = \
this.sort360 ? true : this.sortRadial;\n      dynoOrigin.value.set(0, 0, \
0).applyMatrix4(viewToOrigin);\n      dynoDirection.value.set(0, 0, \
-1).applyMatrix4(viewToOrigin).sub(dynoOrigin.value).normalize();\n      \
dynoDepthBias.value = this.depthBias ?? 1;\n      dynoSort360.value = \
this.sort360 ?? false;\n      dynoSplats.packedSplats = accumulator.splats;\n \
     const sortReader = sort32 ? sort32Reader : doubleSortReader;\n      \
const count = sort32 ? numSplats : Math.ceil(numSplats / 2);\n      await \
reader.renderReadback({\n        renderer: this.spark.renderer,\n        \
reader: sortReader,\n        count,\n        readback\n      });\n      const \
result = await withWorker(async (worker) => {\n        const rpcName = sort32 \
? \"sort32Splats\" : \"sortDoubleSplats\";\n        return \
worker.call(rpcName, {\n          maxSplats,\n          numSplats,\n          \
readback,\n          ordering\n        });\n      });\n      if (sort32) {\n  \
      this.readback32 = result.readback;\n      } else {\n        \
this.readback16 = result.readback;\n      }\n      ordering = \
result.ordering;\n      activeSplats = result.activeSplats;\n    }\n    \
this.updateDisplay({\n      accumulator,\n      viewToWorld,\n      \
ordering,\n      activeSplats,\n      displayed\n    });\n    \
this.sortingCheck = false;\n  }\n  updateDisplay({\n    accumulator,\n    \
viewToWorld,\n    ordering,\n    activeSplats,\n    displayed = false\n  }) \
{\n    if (!this.display) {\n      this.display = {\n        accumulator,\n   \
     viewToWorld,\n        geometry: new SplatGeometry(ordering, \
activeSplats)\n      };\n    } else {\n      if (!displayed && accumulator \
!== this.display.accumulator) {\n        \
this.spark.releaseAccumulator(this.display.accumulator);\n        \
this.display.accumulator = accumulator;\n      }\n      \
this.display.viewToWorld = viewToWorld;\n      const oldOrdering = \
this.display.geometry.ordering;\n      if (oldOrdering.length === \
ordering.length) {\n        this.display.geometry.update(ordering, \
activeSplats);\n      } else {\n        this.display.geometry.dispose();\n    \
    this.display.geometry = new SplatGeometry(ordering, activeSplats);\n      \
}\n      this.orderingFreelist.free(oldOrdering);\n    }\n    if \
(this.spark.viewpoint === this) {\n      this.spark.prepareViewpoint(this);\n \
   }\n  }\n  static makeSorter() {\n    if (!_SparkViewpoint.dynos) {\n      \
const dynoSortRadial = new DynoBool({ value: true });\n      const dynoOrigin \
= new DynoVec3({ value: new THREE.Vector3() });\n      const dynoDirection = \
new DynoVec3({ value: new THREE.Vector3() });\n      const dynoDepthBias = \
new DynoFloat({ value: 1 });\n      const dynoSort360 = new DynoBool({ value: \
false });\n      const dynoSplats = new DynoPackedSplats();\n      const \
reader = new Readback();\n      const doubleSortReader = dynoBlock(\n        \
{ index: \"int\" },\n        { rgba8: \"vec4\" },\n        ({ index }) => {\n \
         if (!index) {\n            throw new Error(\"No index\");\n          \
}\n          const sortParams = {\n            sortRadial: dynoSortRadial,\n  \
          sortOrigin: dynoOrigin,\n            sortDirection: \
dynoDirection,\n            sortDepthBias: dynoDepthBias,\n            \
sort360: dynoSort360\n          };\n          const index2 = mul(index, \
dynoConst(\"int\", 2));\n          const gsplat0 = \
readPackedSplat(dynoSplats, index2);\n          const metric0 = \
computeSortMetric({ gsplat: gsplat0, ...sortParams });\n          const \
gsplat1 = readPackedSplat(\n            dynoSplats,\n            add(index2, \
dynoConst(\"int\", 1))\n          );\n          const metric1 = \
computeSortMetric({ gsplat: gsplat1, ...sortParams });\n          const \
combined = combine({\n            vectorType: \"vec2\",\n            x: \
metric0,\n            y: metric1\n          });\n          const rgba8 = \
uintToRgba8(packHalf2x16(combined));\n          return { rgba8 };\n        \
}\n      );\n      const sort32Reader = dynoBlock(\n        { index: \"int\" \
},\n        { rgba8: \"vec4\" },\n        ({ index }) => {\n          if \
(!index) {\n            throw new Error(\"No index\");\n          }\n         \
 const sortParams = {\n            sortRadial: dynoSortRadial,\n            \
sortOrigin: dynoOrigin,\n            sortDirection: dynoDirection,\n          \
  sortDepthBias: dynoDepthBias,\n            sort360: dynoSort360\n          \
};\n          const gsplat = readPackedSplat(dynoSplats, index);\n          \
const metric = computeSortMetric({ gsplat, ...sortParams });\n          const \
rgba8 = uintToRgba8(floatBitsToUint(metric));\n          return { rgba8 };\n  \
      }\n      );\n      _SparkViewpoint.dynos = {\n        dynoSortRadial,\n \
       dynoOrigin,\n        dynoDirection,\n        dynoDepthBias,\n        \
dynoSort360,\n        dynoSplats,\n        reader,\n        \
doubleSortReader,\n        sort32Reader\n      };\n    }\n    return \
_SparkViewpoint.dynos;\n  }\n};\n_SparkViewpoint.EMPTY_TEXTURE = new \
THREE.Texture();\n_SparkViewpoint.dynos = null;\nlet SparkViewpoint = \
_SparkViewpoint;\nconst defineComputeSortMetric = unindent(`\n  float \
computeSort(Gsplat gsplat, bool sortRadial, vec3 sortOrigin, vec3 \
sortDirection, float sortDepthBias, bool sort360) {\n    if \
(!isGsplatActive(gsplat.flags)) {\n      return INFINITY;\n    }\n\n    vec3 \
center = gsplat.center - sortOrigin;\n    float biasedDepth = dot(center, \
sortDirection) + sortDepthBias;\n    if (!sort360 && (biasedDepth <= 0.0)) \
{\n      return INFINITY;\n    }\n\n    return sortRadial ? length(center) : \
biasedDepth;\n  }\n`);\nfunction computeSortMetric({\n  gsplat,\n  \
sortRadial,\n  sortOrigin,\n  sortDirection,\n  sortDepthBias,\n  sort360\n}) \
{\n  return dyno$1({\n    inTypes: {\n      gsplat: Gsplat,\n      \
sortRadial: \"bool\",\n      sortOrigin: \"vec3\",\n      sortDirection: \
\"vec3\",\n      sortDepthBias: \"float\",\n      sort360: \"bool\"\n    },\n \
   outTypes: { metric: \"float\" },\n    globals: () => [defineGsplat, \
defineComputeSortMetric],\n    inputs: {\n      gsplat,\n      sortRadial,\n  \
    sortOrigin,\n      sortDirection,\n      sortDepthBias,\n      sort360\n  \
  },\n    statements: ({ inputs, outputs }) => {\n      const {\n        \
gsplat: gsplat2,\n        sortRadial: sortRadial2,\n        sortOrigin: \
sortOrigin2,\n        sortDirection: sortDirection2,\n        sortDepthBias: \
sortDepthBias2,\n        sort360: sort3602\n      } = inputs;\n      return \
unindentLines(`\n        ${outputs.metric} = computeSort(${gsplat2}, \
${sortRadial2}, ${sortOrigin2}, ${sortDirection2}, ${sortDepthBias2}, \
${sort3602});\n      `);\n    }\n  }).outputs.metric;\n}\nclass \
SplatAccumulator {\n  constructor() {\n    this.splats = new \
PackedSplats();\n    this.toWorld = new THREE.Matrix4();\n    this.mapping = \
[];\n    this.refCount = 0;\n    this.splatsVersion = -1;\n    \
this.mappingVersion = -1;\n  }\n  ensureGenerate(maxSplats) {\n    if \
(this.splats.ensureGenerate(maxSplats)) {\n      this.mapping = [];\n    }\n  \
}\n  // Generate all Gsplats from an array of generators\n  \
generateSplats({\n    renderer,\n    modifier,\n    generators: \
generators2,\n    forceUpdate,\n    originToWorld\n  }) {\n    const mapping \
= this.mapping.reduce((map, record) => {\n      map.set(record.node, \
record);\n      return map;\n    }, /* @__PURE__ */ new Map());\n    let \
updated = 0;\n    let numSplats = 0;\n    for (const { node, generator, \
version, base, count } of generators2) {\n      const current = \
mapping.get(node);\n      if (forceUpdate || generator !== (current == null ? \
void 0 : current.generator) || version !== (current == null ? void 0 : \
current.version) || base !== (current == null ? void 0 : current.base) || \
count !== (current == null ? void 0 : current.count)) {\n        if \
(generator && count > 0) {\n          const modGenerator = \
modifier.apply(generator);\n          try {\n            \
this.splats.generate({\n              generator: modGenerator,\n              \
base,\n              count,\n              renderer\n            });\n        \
  } catch (error) {\n            node.generator = void 0;\n            \
node.generatorError = error;\n          }\n          updated += 1;\n        \
}\n      }\n      numSplats = Math.max(numSplats, base + count);\n    }\n    \
this.splats.numSplats = numSplats;\n    this.toWorld = originToWorld;\n    \
this.mapping = generators2;\n    return updated !== 0;\n  }\n  // Check if \
this accumulator has exactly the same generator mapping as\n  // the previous \
one. If so, we can reuse the Gsplat sort order.\n  hasCorrespondence(other) \
{\n    if (this.mapping.length !== other.mapping.length) {\n      return \
false;\n    }\n    return this.mapping.every(({ node, base, count }, i) => \
{\n      const {\n        node: otherNode,\n        base: otherBase,\n        \
count: otherCount\n      } = other.mapping[i];\n      return node === \
otherNode && base === otherBase && count === otherCount;\n    });\n  \
}\n}\nvar splatDefines_default = \"const float LN_SCALE_MIN = -12.0;\\nconst \
float LN_SCALE_MAX = 9.0;\\n\\nconst uint SPLAT_TEX_WIDTH_BITS = 11u;\\nconst \
uint SPLAT_TEX_HEIGHT_BITS = 11u;\\nconst uint SPLAT_TEX_DEPTH_BITS = \
11u;\\nconst uint SPLAT_TEX_LAYER_BITS = SPLAT_TEX_WIDTH_BITS + \
SPLAT_TEX_HEIGHT_BITS;\\n\\nconst uint SPLAT_TEX_WIDTH = 1u << \
SPLAT_TEX_WIDTH_BITS;\\nconst uint SPLAT_TEX_HEIGHT = 1u << \
SPLAT_TEX_HEIGHT_BITS;\\nconst uint SPLAT_TEX_DEPTH = 1u << \
SPLAT_TEX_DEPTH_BITS;\\n\\nconst uint SPLAT_TEX_WIDTH_MASK = SPLAT_TEX_WIDTH \
- 1u;\\nconst uint SPLAT_TEX_HEIGHT_MASK = SPLAT_TEX_HEIGHT - 1u;\\nconst \
uint SPLAT_TEX_DEPTH_MASK = SPLAT_TEX_DEPTH - 1u;\\n\\nconst uint F16_INF = \
0x7c00u;\\nconst float PI = 3.1415926535897932384626433832795;\\n\\nconst \
float INFINITY = 1.0 / 0.0;\\nconst float NEG_INFINITY = \
-INFINITY;\\n\\nfloat sqr(float x) {\\n    return x * x;\\n}\\n\\nfloat \
pow4(float x) {\\n    float x2 = x * x;\\n    return x2 * x2;\\n}\\n\\nfloat \
pow8(float x) {\\n    float x4 = pow4(x);\\n    return x4 * x4;\\n}\\n\\nvec3 \
srgbToLinear(vec3 rgb) {\\n    return pow(rgb, vec3(2.2));\\n}\\n\\nvec3 \
linearToSrgb(vec3 rgb) {\\n    return pow(rgb, vec3(1.0 / \
2.2));\\n}\\n\\nuint encodeQuatOctXy88R8(vec4 q) {\\n    \\n    if (q.w < \
0.0) {\\n        q = -q;\\n    }\\n    \\n    float theta = 2.0 * \
acos(q.w);\\n    float halfTheta = theta * 0.5;\\n    float s = \
sin(halfTheta);\\n    \\n    vec3 axis = (abs(s) < 1e-6) ? vec3(1.0, 0.0, \
0.0) : q.xyz / s;\\n    \\n    \\n    \\n    float sum = abs(axis.x) + \
abs(axis.y) + abs(axis.z);\\n    vec2 p = vec2(axis.x, axis.y) / sum;\\n    \
\\n    if (axis.z < 0.0) {\\n        float oldPx = p.x;\\n        p.x = (1.0 \
- abs(p.y)) * (p.x >= 0.0 ? 1.0 : -1.0);\\n        p.y = (1.0 - abs(oldPx)) * \
(p.y >= 0.0 ? 1.0 : -1.0);\\n    }\\n    \\n    float u_f = p.x * 0.5 + \
0.5;\\n    float v_f = p.y * 0.5 + 0.5;\\n    \\n    uint quantU = \
uint(clamp(round(u_f * 255.0), 0.0, 255.0));\\n    uint quantV = \
uint(clamp(round(v_f * 255.0), 0.0, 255.0));\\n    \\n    \\n    \\n    uint \
angleInt = uint(clamp(round((theta / 3.14159265359) * 255.0), 0.0, \
255.0));\\n    \\n    \\n    return (angleInt << 16u) | (quantV << 8u) | \
quantU;\\n}\\n\\nvec4 decodeQuatOctXy88R8(uint encoded) {\\n    \\n    uint \
quantU = encoded & uint(0xFFu);               \\n    uint quantV = (encoded \
>> 8u) & uint(0xFFu);         \\n    uint angleInt = encoded >> 16u;          \
            \\n\\n    \\n    float u_f = float(quantU) / 255.0;\\n    float \
v_f = float(quantV) / 255.0;\\n    vec2 f = vec2(u_f * 2.0 - 1.0, v_f * 2.0 - \
1.0);\\n\\n    vec3 axis = vec3(f.xy, 1.0 - abs(f.x) - abs(f.y));\\n    float \
t = max(-axis.z, 0.0);\\n    axis.x += (axis.x >= 0.0) ? -t : t;\\n    axis.y \
+= (axis.y >= 0.0) ? -t : t;\\n    axis = normalize(axis);\\n    \\n    \\n   \
 float theta = (float(angleInt) / 255.0) * 3.14159265359;\\n    float \
halfTheta = theta * 0.5;\\n    float s = sin(halfTheta);\\n    float w = \
cos(halfTheta);\\n    \\n    return vec4(axis * s, w);\\n}\\n\\n    \\n\\n    \
\\n\\n    \\n\\n    \\n\\n    \\n\\n    \\n\\n    \\n\\n    \\n\\n    \\n\\n  \
  \\n\\nuvec4 packSplatEncoding(\\n    vec3 center, vec3 scales, vec4 \
quaternion, vec4 rgba, vec4 rgbMinMaxLnScaleMinMax\\n) {\\n    float rgbMin = \
rgbMinMaxLnScaleMinMax.x;\\n    float rgbMax = rgbMinMaxLnScaleMinMax.y;\\n   \
 vec3 encRgb = (rgba.rgb - vec3(rgbMin)) / (rgbMax - rgbMin);\\n    uvec4 \
uRgba = uvec4(round(clamp(vec4(encRgb, rgba.a) * 255.0, 0.0, 255.0)));\\n\\n  \
  uint uQuat = encodeQuatOctXy88R8(quaternion);\\n    \\n    \\n    uvec3 \
uQuat3 = uvec3(uQuat & 0xffu, (uQuat >> 8u) & 0xffu, (uQuat >> 16u) & \
0xffu);\\n\\n    \\n    float lnScaleMin = rgbMinMaxLnScaleMinMax.z;\\n    \
float lnScaleMax = rgbMinMaxLnScaleMinMax.w;\\n    float lnScaleScale = 254.0 \
/ (lnScaleMax - lnScaleMin);\\n    uvec3 uScales = uvec3(\\n        (scales.x \
== 0.0) ? 0u : uint(round(clamp((log(scales.x) - lnScaleMin) * lnScaleScale, \
0.0, 254.0))) + 1u,\\n        (scales.y == 0.0) ? 0u : \
uint(round(clamp((log(scales.y) - lnScaleMin) * lnScaleScale, 0.0, 254.0))) + \
1u,\\n        (scales.z == 0.0) ? 0u : uint(round(clamp((log(scales.z) - \
lnScaleMin) * lnScaleScale, 0.0, 254.0))) + 1u\\n    );\\n\\n    \\n    uint \
word0 = uRgba.r | (uRgba.g << 8u) | (uRgba.b << 16u) | (uRgba.a << 24u);\\n   \
 uint word1 = packHalf2x16(center.xy);\\n    uint word2 = \
packHalf2x16(vec2(center.z, 0.0)) | (uQuat3.x << 16u) | (uQuat3.y << 24u);\\n \
   uint word3 = uScales.x | (uScales.y << 8u) | (uScales.z << 16u) | \
(uQuat3.z << 24u);\\n    return uvec4(word0, word1, word2, \
word3);\\n}\\n\\nuvec4 packSplat(vec3 center, vec3 scales, vec4 quaternion, \
vec4 rgba) {\\n    return packSplatEncoding(center, scales, quaternion, rgba, \
vec4(0.0, 1.0, LN_SCALE_MIN, LN_SCALE_MAX));\\n}\\n\\nvoid \
unpackSplatEncoding(uvec4 packed, out vec3 center, out vec3 scales, out vec4 \
quaternion, out vec4 rgba, vec4 rgbMinMaxLnScaleMinMax) {\\n    uint word0 = \
packed.x, word1 = packed.y, word2 = packed.z, word3 = packed.w;\\n\\n    \
uvec4 uRgba = uvec4(word0 & 0xffu, (word0 >> 8u) & 0xffu, (word0 >> 16u) & \
0xffu, (word0 >> 24u) & 0xffu);\\n    float rgbMin = \
rgbMinMaxLnScaleMinMax.x;\\n    float rgbMax = rgbMinMaxLnScaleMinMax.y;\\n   \
 rgba = (vec4(uRgba) / 255.0);\\n    rgba.rgb = rgba.rgb * (rgbMax - rgbMin) \
+ rgbMin;\\n\\n    center = vec4(\\n        unpackHalf2x16(word1),\\n        \
unpackHalf2x16(word2 & 0xffffu)\\n    ).xyz;\\n\\n    uvec3 uScales = \
uvec3(word3 & 0xffu, (word3 >> 8u) & 0xffu, (word3 >> 16u) & 0xffu);\\n    \
float lnScaleMin = rgbMinMaxLnScaleMinMax.z;\\n    float lnScaleMax = \
rgbMinMaxLnScaleMinMax.w;\\n    float lnScaleScale = (lnScaleMax - \
lnScaleMin) / 254.0;\\n    scales = vec3(\\n        (uScales.x == 0u) ? 0.0 : \
exp(lnScaleMin + float(uScales.x - 1u) * lnScaleScale),\\n        (uScales.y \
== 0u) ? 0.0 : exp(lnScaleMin + float(uScales.y - 1u) * lnScaleScale),\\n     \
   (uScales.z == 0u) ? 0.0 : exp(lnScaleMin + float(uScales.z - 1u) * \
lnScaleScale)\\n    );\\n\\n    uint uQuat = ((word2 >> 16u) & 0xFFFFu) | \
((word3 >> 8u) & 0xFF0000u);\\n    quaternion = \
decodeQuatOctXy88R8(uQuat);\\n    \\n    \\n}\\n\\nvoid unpackSplat(uvec4 \
packed, out vec3 center, out vec3 scales, out vec4 quaternion, out vec4 rgba) \
{\\n    unpackSplatEncoding(packed, center, scales, quaternion, rgba, \
vec4(0.0, 1.0, LN_SCALE_MIN, LN_SCALE_MAX));\\n}\\n\\nvec3 quatVec(vec4 q, \
vec3 v) {\\n    \\n    vec3 t = 2.0 * cross(q.xyz, v);\\n    return v + q.w * \
t + cross(q.xyz, t);\\n}\\n\\nvec4 quatQuat(vec4 q1, vec4 q2) {\\n    return \
vec4(\\n        q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,\\n     \
   q1.w * q2.y - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x,\\n        q1.w * \
q2.z + q1.x * q2.y - q1.y * q2.x + q1.z * q2.w,\\n        q1.w * q2.w - q1.x \
* q2.x - q1.y * q2.y - q1.z * q2.z\\n    );\\n}\\n\\nmat3 \
scaleQuaternionToMatrix(vec3 s, vec4 q) {\\n    \\n    return mat3(\\n        \
s.x * (1.0 - 2.0 * (q.y * q.y + q.z * q.z)),\\n        s.x * (2.0 * (q.x * \
q.y + q.w * q.z)),\\n        s.x * (2.0 * (q.x * q.z - q.w * q.y)),\\n        \
s.y * (2.0 * (q.x * q.y - q.w * q.z)),\\n        s.y * (1.0 - 2.0 * (q.x * \
q.x + q.z * q.z)),\\n        s.y * (2.0 * (q.y * q.z + q.w * q.x)),\\n        \
s.z * (2.0 * (q.x * q.z + q.w * q.y)),\\n        s.z * (2.0 * (q.y * q.z - \
q.w * q.x)),\\n        s.z * (1.0 - 2.0 * (q.x * q.x + q.y * q.y))\\n    \
);\\n}\\n\\nvec4 slerp(vec4 q1, vec4 q2, float t) {\\n    \\n    float \
cosHalfTheta = dot(q1, q2);\\n\\n    \\n    if (abs(cosHalfTheta) >= 0.999) \
{\\n        return q1;\\n    }\\n    \\n    \\n    \\n    if (cosHalfTheta < \
0.0) {\\n        q2 = -q2;\\n        cosHalfTheta = -cosHalfTheta;\\n    \
}\\n\\n    \\n    float halfTheta = acos(cosHalfTheta);\\n    float \
sinHalfTheta = sqrt(1.0 - cosHalfTheta * cosHalfTheta);\\n\\n    \\n    float \
ratioA = sin((1.0 - t) * halfTheta) / sinHalfTheta;\\n    float ratioB = \
sin(t * halfTheta) / sinHalfTheta;\\n\\n    \\n    return q1 * ratioA + q2 * \
ratioB;\\n}\\n\\nivec3 splatTexCoord(int index) {\\n    uint x = uint(index) \
& SPLAT_TEX_WIDTH_MASK;\\n    uint y = (uint(index) >> SPLAT_TEX_WIDTH_BITS) \
& SPLAT_TEX_HEIGHT_MASK;\\n    uint z = uint(index) >> \
SPLAT_TEX_LAYER_BITS;\\n    return ivec3(x, y, z);\\n}\";\nvar \
splatFragment_default = \"precision highp float;\\nprecision highp \
int;\\n\\n#include <splatDefines>\\n\\nuniform float near;\\nuniform float \
far;\\nuniform bool encodeLinear;\\nuniform float time;\\nuniform bool \
debugFlag;\\nuniform float maxStdDev;\\nuniform float minAlpha;\\nuniform \
bool stochastic;\\nuniform bool disableFalloff;\\nuniform float \
falloff;\\n\\nuniform bool splatTexEnable;\\nuniform sampler3D \
splatTexture;\\nuniform mat2 splatTexMul;\\nuniform vec2 \
splatTexAdd;\\nuniform float splatTexNear;\\nuniform float \
splatTexFar;\\nuniform float splatTexMid;\\n\\nout vec4 fragColor;\\n\\nin \
vec4 vRgba;\\nin vec2 vSplatUv;\\nin vec3 vNdc;\\nflat in uint \
vSplatIndex;\\n\\nvoid main() {\\n    vec4 rgba = vRgba;\\n\\n    float z = \
dot(vSplatUv, vSplatUv);\\n    if (!splatTexEnable) {\\n        if (z > \
(maxStdDev * maxStdDev)) {\\n            discard;\\n        }\\n    } else \
{\\n        vec2 uv = splatTexMul * vSplatUv + splatTexAdd;\\n        float \
ndcZ = vNdc.z;\\n        float depth = (2.0 * near * far) / (far + near - \
ndcZ * (far - near));\\n        float clampedFar = max(splatTexFar, \
splatTexNear);\\n        float clampedDepth = clamp(depth, splatTexNear, \
clampedFar);\\n        float logDepth = log2(clampedDepth + 1.0);\\n        \
float logNear = log2(splatTexNear + 1.0);\\n        float logFar = \
log2(clampedFar + 1.0);\\n\\n        float texZ;\\n        if (splatTexMid > \
0.0) {\\n            float clampedMid = clamp(splatTexMid, splatTexNear, \
clampedFar);\\n            float logMid = log2(clampedMid + 1.0);\\n          \
  texZ = (clampedDepth <= clampedMid) ?\\n                (0.5 * ((logDepth - \
logNear) / (logMid - logNear))) :\\n                (0.5 * ((logDepth - \
logMid) / (logFar - logMid)) + 0.5);\\n        } else {\\n            texZ = \
(logDepth - logNear) / (logFar - logNear);\\n        }\\n\\n        vec4 \
modulate = texture(splatTexture, vec3(uv, 1.0 - texZ));\\n        rgba *= \
modulate;\\n    }\\n\\n    rgba.a *= mix(1.0, exp(-0.5 * z), falloff);\\n\\n  \
  if (rgba.a < minAlpha) {\\n        discard;\\n    }\\n    if (encodeLinear) \
{\\n        rgba.rgb = srgbToLinear(rgba.rgb);\\n    }\\n\\n    if \
(stochastic) {\\n        const bool STEADY = false;\\n        uint uTime = \
STEADY ? 0u : floatBitsToUint(time);\\n        uvec2 coord = \
uvec2(gl_FragCoord.xy);\\n        uint state = uTime + 0x9e3779b9u * coord.x \
+ 0x85ebca6bu * coord.y + 0xc2b2ae35u * uint(vSplatIndex);\\n        state = \
state * 747796405u + 2891336453u;\\n        uint hash = ((state >> ((state >> \
28u) + 4u)) ^ state) * 277803737u;\\n        hash = (hash >> 22u) ^ hash;\\n  \
      float rand = float(hash) / 4294967296.0;\\n        if (rand < rgba.a) \
{\\n            fragColor = vec4(rgba.rgb, 1.0);\\n        } else {\\n        \
    discard;\\n        }\\n    } else {\\n        #ifdef \
PREMULTIPLIED_ALPHA\\n            fragColor = vec4(rgba.rgb * rgba.a, \
rgba.a);\\n        #else\\n            fragColor = rgba;\\n        #endif\\n  \
  }\\n}\";\nvar splatVertex_default = \"precision highp float;\\nprecision \
highp int;\\nprecision highp usampler2DArray;\\n\\n#include \
<splatDefines>\\n\\nattribute uint splatIndex;\\n\\nout vec4 vRgba;\\nout \
vec2 vSplatUv;\\nout vec3 vNdc;\\nflat out uint vSplatIndex;\\n\\nuniform \
vec2 renderSize;\\nuniform uint numSplats;\\nuniform vec4 \
renderToViewQuat;\\nuniform vec3 renderToViewPos;\\nuniform float \
maxStdDev;\\nuniform float minPixelRadius;\\nuniform float \
maxPixelRadius;\\nuniform float time;\\nuniform float deltaTime;\\nuniform \
bool debugFlag;\\nuniform float minAlpha;\\nuniform bool \
stochastic;\\nuniform bool enable2DGS;\\nuniform float blurAmount;\\nuniform \
float preBlurAmount;\\nuniform float focalDistance;\\nuniform float \
apertureAngle;\\nuniform float clipXY;\\nuniform float \
focalAdjustment;\\n\\nuniform usampler2DArray packedSplats;\\nuniform vec4 \
rgbMinMaxLnScaleMinMax;\\n\\nvoid main() {\\n    \\n    gl_Position = \
vec4(0.0, 0.0, 2.0, 1.0);\\n\\n    if (uint(gl_InstanceID) >= numSplats) {\\n \
       return;\\n    }\\n\\n    ivec3 texCoord;\\n    if (stochastic) {\\n    \
    texCoord = ivec3(\\n            uint(gl_InstanceID) & \
SPLAT_TEX_WIDTH_MASK,\\n            (uint(gl_InstanceID) >> \
SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK,\\n            \
(uint(gl_InstanceID) >> SPLAT_TEX_LAYER_BITS)\\n        );\\n    } else {\\n  \
      if (splatIndex == 0xffffffffu) {\\n            \\n            \
return;\\n        }\\n        texCoord = ivec3(\\n            splatIndex & \
SPLAT_TEX_WIDTH_MASK,\\n            (splatIndex >> SPLAT_TEX_WIDTH_BITS) & \
SPLAT_TEX_HEIGHT_MASK,\\n            splatIndex >> SPLAT_TEX_LAYER_BITS\\n    \
    );\\n    }\\n    uvec4 packed = texelFetch(packedSplats, texCoord, \
0);\\n\\n    vec3 center, scales;\\n    vec4 quaternion, rgba;\\n    \
unpackSplatEncoding(packed, center, scales, quaternion, rgba, \
rgbMinMaxLnScaleMinMax);\\n\\n    if (rgba.a < minAlpha) {\\n        \
return;\\n    }\\n    bvec3 zeroScales = equal(scales, vec3(0.0));\\n    if \
(all(zeroScales)) {\\n        return;\\n    }\\n\\n    \\n    vec3 viewCenter \
= quatVec(renderToViewQuat, center) + renderToViewPos;\\n\\n    \\n    if \
(viewCenter.z >= 0.0) {\\n        return;\\n    }\\n\\n    \\n    vec4 \
clipCenter = projectionMatrix * vec4(viewCenter, 1.0);\\n\\n    \\n    if \
(abs(clipCenter.z) >= clipCenter.w) {\\n        return;\\n    }\\n\\n    \\n  \
  float clip = clipXY * clipCenter.w;\\n    if (abs(clipCenter.x) > clip || \
abs(clipCenter.y) > clip) {\\n        return;\\n    }\\n\\n    \\n    \
vSplatIndex = splatIndex;\\n\\n    \\n    vec4 viewQuaternion = \
quatQuat(renderToViewQuat, quaternion);\\n\\n    if (enable2DGS && \
any(zeroScales)) {\\n        vRgba = rgba;\\n        vSplatUv = position.xy * \
maxStdDev;\\n\\n        vec3 offset;\\n        if (zeroScales.z) {\\n         \
   offset = vec3(vSplatUv.xy * scales.xy, 0.0);\\n        } else if \
(zeroScales.y) {\\n            offset = vec3(vSplatUv.x * scales.x, 0.0, \
vSplatUv.y * scales.z);\\n        } else {\\n            offset = vec3(0.0, \
vSplatUv.xy * scales.yz);\\n        }\\n\\n        vec3 viewPos = viewCenter \
+ quatVec(viewQuaternion, offset);\\n        gl_Position = projectionMatrix * \
vec4(viewPos, 1.0);\\n        vNdc = gl_Position.xyz / gl_Position.w;\\n      \
  return;\\n    }\\n\\n    \\n    vec3 ndcCenter = clipCenter.xyz / \
clipCenter.w;\\n\\n    \\n    mat3 RS = scaleQuaternionToMatrix(scales, \
viewQuaternion);\\n    mat3 cov3D = RS * transpose(RS);\\n\\n    \\n    vec2 \
scaledRenderSize = renderSize * focalAdjustment;\\n    vec2 focal = 0.5 * \
scaledRenderSize * vec2(projectionMatrix[0][0], \
projectionMatrix[1][1]);\\n\\n    mat3 J;\\n    if(isOrthographic) {\\n       \
 J = mat3(\\n            focal.x, 0.0, 0.0,\\n            0.0, focal.y, \
0.0,\\n            0.0, 0.0, 0.0\\n        );\\n    } else {\\n        float \
invZ = 1.0 / viewCenter.z;\\n        vec2 J1 = focal * invZ;\\n        vec2 \
J2 = -(J1 * viewCenter.xy) * invZ;\\n        J = mat3(\\n            J1.x, \
0.0, J2.x,\\n            0.0, J1.y, J2.y,\\n            0.0, 0.0, 0.0\\n      \
  );\\n    }\\n\\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    mat3 \
cov2D = transpose(J) * cov3D * J;\\n    float a = cov2D[0][0];\\n    float d \
= cov2D[1][1];\\n    float b = cov2D[0][1];\\n\\n    \\n    a += \
preBlurAmount;\\n    d += preBlurAmount;\\n\\n    float fullBlurAmount = \
blurAmount;\\n    if ((focalDistance > 0.0) && (apertureAngle > 0.0)) {\\n    \
    float focusRadius = maxPixelRadius;\\n        if (viewCenter.z < 0.0) \
{\\n            float focusBlur = abs((-viewCenter.z - focalDistance) / \
viewCenter.z);\\n            float apertureRadius = focal.x * tan(0.5 * \
apertureAngle);\\n            focusRadius = focusBlur * apertureRadius;\\n    \
    }\\n        fullBlurAmount = clamp(sqr(focusRadius), blurAmount, \
sqr(maxPixelRadius));\\n    }\\n\\n    \\n    float detOrig = a * d - b * \
b;\\n    a += fullBlurAmount;\\n    d += fullBlurAmount;\\n    float det = a \
* d - b * b;\\n\\n    \\n    float blurAdjust = sqrt(max(0.0, detOrig / \
det));\\n    rgba.a *= blurAdjust;\\n    if (rgba.a < minAlpha) {\\n        \
return;\\n    }\\n\\n    \\n    float eigenAvg = 0.5 * (a + d);\\n    float \
eigenDelta = sqrt(max(0.0, eigenAvg * eigenAvg - det));\\n    float eigen1 = \
eigenAvg + eigenDelta;\\n    float eigen2 = eigenAvg - eigenDelta;\\n\\n    \
vec2 eigenVec1 = normalize(vec2((abs(b) < 0.001) ? 1.0 : b, eigen1 - a));\\n  \
  vec2 eigenVec2 = vec2(eigenVec1.y, -eigenVec1.x);\\n\\n    float scale1 = \
min(maxPixelRadius, maxStdDev * sqrt(eigen1));\\n    float scale2 = \
min(maxPixelRadius, maxStdDev * sqrt(eigen2));\\n    if (scale1 < \
minPixelRadius && scale2 < minPixelRadius) {\\n        return;\\n    }\\n\\n  \
  \\n    vec2 pixelOffset = position.x * eigenVec1 * scale1 + position.y * \
eigenVec2 * scale2;\\n    vec2 ndcOffset = (2.0 / scaledRenderSize) * \
pixelOffset;\\n    vec3 ndc = vec3(ndcCenter.xy + ndcOffset, \
ndcCenter.z);\\n\\n    vRgba = rgba;\\n    vSplatUv = position.xy * \
maxStdDev;\\n    vNdc = ndc;\\n    gl_Position = vec4(ndc.xy * clipCenter.w, \
clipCenter.zw);\\n}\";\nlet shaders = null;\nfunction getShaders() {\n  if \
(!shaders) {\n    THREE.ShaderChunk.splatDefines = splatDefines_default;\n    \
shaders = {\n      splatVertex: splatVertex_default,\n      splatFragment: \
splatFragment_default\n    };\n  }\n  return shaders;\n}\nconst \
MAX_ACCUMULATORS = 5;\nconst _SparkRenderer = class _SparkRenderer extends \
THREE.Mesh {\n  constructor(options) {\n    const uniforms = \
_SparkRenderer.makeUniforms();\n    const shaders2 = getShaders();\n    const \
premultipliedAlpha = options.premultipliedAlpha ?? true;\n    const material \
= new THREE.ShaderMaterial({\n      glslVersion: THREE.GLSL3,\n      \
vertexShader: shaders2.splatVertex,\n      fragmentShader: \
shaders2.splatFragment,\n      uniforms,\n      premultipliedAlpha,\n      \
transparent: true,\n      depthTest: true,\n      depthWrite: false,\n      \
side: THREE.DoubleSide\n    });\n    super(EMPTY_GEOMETRY, material);\n    \
this.splatTexture = null;\n    this.autoViewpoints = [];\n    \
this.rotateToAccumulator = new DynoVec4({ value: new THREE.Quaternion() });\n \
   this.translateToAccumulator = new DynoVec3({ value: new THREE.Vector3() \
});\n    this.lastFrame = -1;\n    this.lastUpdateTime = null;\n    \
this.defaultCameras = [];\n    this.lastStochastic = null;\n    \
this.pendingUpdate = {\n      scene: null,\n      originToWorld: new \
THREE.Matrix4(),\n      timeoutId: -1\n    };\n    this.envViewpoint = \
null;\n    this.frustumCulled = false;\n    this.renderer = \
options.renderer;\n    this.material = material;\n    this.uniforms = \
uniforms;\n    const modifier = dynoBlock(\n      { gsplat: Gsplat },\n      \
{ gsplat: Gsplat },\n      ({ gsplat }) => {\n        if (!gsplat) {\n        \
  throw new Error(\"gsplat not defined\");\n        }\n        gsplat = \
transformGsplat(gsplat, {\n          rotate: this.rotateToAccumulator,\n      \
    translate: this.translateToAccumulator\n        });\n        return { \
gsplat };\n      }\n    );\n    this.modifier = new \
SplatModifier(modifier);\n    this.premultipliedAlpha = premultipliedAlpha;\n \
   this.autoUpdate = options.autoUpdate ?? true;\n    this.preUpdate = \
options.preUpdate ?? false;\n    this.needsUpdate = false;\n    \
this.originDistance = options.originDistance ?? 1;\n    this.maxStdDev = \
options.maxStdDev ?? Math.sqrt(8);\n    this.minPixelRadius = \
options.minPixelRadius ?? 0;\n    this.maxPixelRadius = \
options.maxPixelRadius ?? 512;\n    this.minAlpha = options.minAlpha ?? 0.5 * \
(1 / 255);\n    this.enable2DGS = options.enable2DGS ?? false;\n    \
this.preBlurAmount = options.preBlurAmount ?? 0;\n    this.blurAmount = \
options.blurAmount ?? 0.3;\n    this.focalDistance = options.focalDistance ?? \
0;\n    this.apertureAngle = options.apertureAngle ?? 0;\n    this.falloff = \
options.falloff ?? 1;\n    this.clipXY = options.clipXY ?? 1.4;\n    \
this.focalAdjustment = options.focalAdjustment ?? 1;\n    this.splatEncoding \
= options.splatEncoding ?? { ...DEFAULT_SPLAT_ENCODING };\n    this.active = \
new SplatAccumulator();\n    this.accumulatorCount = 1;\n    \
this.freeAccumulators = [];\n    for (let count = 0; count < 1; ++count) {\n  \
    this.freeAccumulators.push(new SplatAccumulator());\n      \
this.accumulatorCount += 1;\n    }\n    this.defaultView = new \
SparkViewpoint({\n      ...options.view,\n      autoUpdate: true,\n      \
spark: this\n    });\n    this.viewpoint = this.defaultView;\n    \
this.prepareViewpoint(this.viewpoint);\n    this.clock = options.clock ? \
cloneClock(options.clock) : new THREE.Clock();\n  }\n  static makeUniforms() \
{\n    const uniforms = {\n      // Size of render viewport in pixels\n      \
renderSize: { value: new THREE.Vector2() },\n      // Near and far plane \
distances\n      near: { value: 0.1 },\n      far: { value: 1e3 },\n      // \
Total number of Gsplats in packedSplats to render\n      numSplats: { value: \
0 },\n      // SplatAccumulator to view transformation quaternion\n      \
renderToViewQuat: { value: new THREE.Quaternion() },\n      // \
SplatAccumulator to view transformation translation\n      renderToViewPos: { \
value: new THREE.Vector3() },\n      // Maximum distance (in stddevs) from \
Gsplat center to render\n      maxStdDev: { value: 1 },\n      // Minimum \
pixel radius for splat rendering\n      minPixelRadius: { value: 0 },\n      \
// Maximum pixel radius for splat rendering\n      maxPixelRadius: { value: \
512 },\n      // Minimum alpha value for splat rendering\n      minAlpha: { \
value: 0.5 * (1 / 255) },\n      // Enable stochastic splat rendering\n      \
stochastic: { value: false },\n      // Enable interpreting 0-thickness \
Gsplats as 2DGS\n      enable2DGS: { value: false },\n      // Add to \
projected 2D splat covariance diagonal (thickens and brightens)\n      \
preBlurAmount: { value: 0 },\n      // Add to 2D splat covariance diagonal \
and adjust opacity (anti-aliasing)\n      blurAmount: { value: 0.3 },\n      \
// Depth-of-field distance to focal plane\n      focalDistance: { value: 0 \
},\n      // Full-width angle of aperture opening (in radians)\n      \
apertureAngle: { value: 0 },\n      // Modulate Gaussian kernal falloff. 0 \
means \"no falloff, flat shading\",\n      // 1 is normal e^-x^2 falloff.\n   \
   falloff: { value: 1 },\n      // Clip Gsplats that are clipXY times beyond \
the +-1 frustum bounds\n      clipXY: { value: 1.4 },\n      // Debug \
renderSize scale factor\n      focalAdjustment: { value: 1 },\n      // \
Enable splat texture rendering\n      splatTexEnable: { value: false },\n     \
 // Splat texture to render\n      splatTexture: { type: \"t\", value: \
_SparkRenderer.EMPTY_SPLAT_TEXTURE },\n      // Splat texture UV transform \
(multiply)\n      splatTexMul: { value: new THREE.Matrix2() },\n      // \
Splat texture UV transform (add)\n      splatTexAdd: { value: new \
THREE.Vector2() },\n      // Splat texture near plane distance\n      \
splatTexNear: { value: 0.1 },\n      // Splat texture far plane distance\n    \
  splatTexFar: { value: 1e3 },\n      // Splat texture mid plane distance, or \
0.0 to disable\n      splatTexMid: { value: 0 },\n      // Gsplat collection \
to render\n      packedSplats: { type: \"t\", value: PackedSplats.getEmpty() \
},\n      // Splat encoding ranges\n      rgbMinMaxLnScaleMinMax: { value: \
new THREE.Vector4() },\n      // Time in seconds for time-based effects\n     \
 time: { value: 0 },\n      // Delta time in seconds since last frame\n      \
deltaTime: { value: 0 },\n      // Whether to encode Gsplat with linear RGB \
(for environment mapping)\n      encodeLinear: { value: false },\n      // \
Debug flag that alternates each frame\n      debugFlag: { value: false }\n    \
};\n    return uniforms;\n  }\n  canAllocAccumulator() {\n    return \
this.freeAccumulators.length > 0 || this.accumulatorCount < \
MAX_ACCUMULATORS;\n  }\n  maybeAllocAccumulator() {\n    let accumulator = \
this.freeAccumulators.pop();\n    if (accumulator === void 0) {\n      if \
(this.accumulatorCount >= MAX_ACCUMULATORS) {\n        return null;\n      \
}\n      accumulator = new SplatAccumulator();\n      this.accumulatorCount \
+= 1;\n    }\n    accumulator.refCount = 1;\n    return accumulator;\n  }\n  \
releaseAccumulator(accumulator) {\n    accumulator.refCount -= 1;\n    if \
(accumulator.refCount === 0) {\n      \
this.freeAccumulators.push(accumulator);\n    }\n  }\n  newViewpoint(options) \
{\n    return new SparkViewpoint({ ...options, spark: this });\n  }\n  \
onBeforeRender(renderer, scene, camera) {\n    var _a2, _b2;\n    const time \
= this.time ?? this.clock.getElapsedTime();\n    const deltaTime = time - \
(this.viewpoint.lastTime ?? time);\n    this.viewpoint.lastTime = time;\n    \
const frame = renderer.info.render.frame;\n    const isNewFrame = frame !== \
this.lastFrame;\n    this.lastFrame = frame;\n    const viewpoint = \
this.viewpoint;\n    if (viewpoint === this.defaultView) {\n      if \
(isNewFrame) {\n        if (!renderer.xr.isPresenting) {\n          \
this.defaultView.viewToWorld = camera.matrixWorld.clone();\n          \
this.defaultCameras = [this.defaultView.viewToWorld];\n        } else {\n     \
     const cameras = renderer.xr.getCamera().cameras;\n          \
this.defaultCameras = cameras.map((camera2) => camera2.matrixWorld);\n        \
  this.defaultView.viewToWorld = averageOriginToWorlds(this.defaultCameras) \
?? new THREE.Matrix4();\n        }\n      }\n      if (this.autoUpdate) {\n   \
     this.update({ scene, viewToWorld: this.defaultView.viewToWorld });\n     \
 }\n    }\n    if (isNewFrame) {\n      if (this.material.premultipliedAlpha \
!== this.premultipliedAlpha) {\n        this.material.premultipliedAlpha = \
this.premultipliedAlpha;\n        this.material.needsUpdate = true;\n      \
}\n      this.uniforms.time.value = time;\n      \
this.uniforms.deltaTime.value = deltaTime;\n      \
this.uniforms.debugFlag.value = performance.now() / 1e3 % 2 < 1;\n      if \
(viewpoint.display && viewpoint.stochastic) {\n        \
this.geometry.instanceCount = this.uniforms.numSplats.value;\n      }\n    \
}\n    if (viewpoint.target) {\n      this.uniforms.renderSize.value.set(\n   \
     viewpoint.target.width,\n        viewpoint.target.height\n      );\n    \
} else {\n      const renderSize = renderer.getDrawingBufferSize(\n        \
this.uniforms.renderSize.value\n      );\n      if (renderSize.x === 1 && \
renderSize.y === 1) {\n        const baseLayer = (_a2 = \
renderer.xr.getSession()) == null ? void 0 : _a2.renderState.baseLayer;\n     \
   if (baseLayer) {\n          renderSize.x = baseLayer.framebufferWidth;\n   \
       renderSize.y = baseLayer.framebufferHeight;\n        }\n      }\n    \
}\n    const typedCamera = camera;\n    this.uniforms.near.value = \
typedCamera.near;\n    this.uniforms.far.value = typedCamera.far;\n    \
this.uniforms.encodeLinear.value = viewpoint.encodeLinear;\n    \
this.uniforms.maxStdDev.value = this.maxStdDev;\n    \
this.uniforms.minPixelRadius.value = this.minPixelRadius;\n    \
this.uniforms.maxPixelRadius.value = this.maxPixelRadius;\n    \
this.uniforms.minAlpha.value = this.minAlpha;\n    \
this.uniforms.stochastic.value = viewpoint.stochastic;\n    \
this.uniforms.enable2DGS.value = this.enable2DGS;\n    \
this.uniforms.preBlurAmount.value = this.preBlurAmount;\n    \
this.uniforms.blurAmount.value = this.blurAmount;\n    \
this.uniforms.focalDistance.value = this.focalDistance;\n    \
this.uniforms.apertureAngle.value = this.apertureAngle;\n    \
this.uniforms.falloff.value = this.falloff;\n    this.uniforms.clipXY.value = \
this.clipXY;\n    this.uniforms.focalAdjustment.value = \
this.focalAdjustment;\n    if (this.lastStochastic !== !viewpoint.stochastic) \
{\n      this.lastStochastic = !viewpoint.stochastic;\n      \
this.material.transparent = !viewpoint.stochastic;\n      \
this.material.depthWrite = viewpoint.stochastic;\n      \
this.material.needsUpdate = true;\n    }\n    if (this.splatTexture) {\n      \
const { enable, texture: texture2, multiply, add: add2, near, far, mid } = \
this.splatTexture;\n      if (enable && texture2) {\n        \
this.uniforms.splatTexEnable.value = true;\n        \
this.uniforms.splatTexture.value = texture2;\n        if (multiply) {\n       \
   this.uniforms.splatTexMul.value.fromArray(multiply.elements);\n        } \
else {\n          this.uniforms.splatTexMul.value.set(\n            0.5 / \
this.maxStdDev,\n            0,\n            0,\n            0.5 / \
this.maxStdDev\n          );\n        }\n        \
this.uniforms.splatTexAdd.value.set((add2 == null ? void 0 : add2.x) ?? 0.5, \
(add2 == null ? void 0 : add2.y) ?? 0.5);\n        \
this.uniforms.splatTexNear.value = near ?? this.uniforms.near.value;\n        \
this.uniforms.splatTexFar.value = far ?? this.uniforms.far.value;\n        \
this.uniforms.splatTexMid.value = mid ?? 0;\n      } else {\n        \
this.uniforms.splatTexEnable.value = false;\n        \
this.uniforms.splatTexture.value = _SparkRenderer.EMPTY_SPLAT_TEXTURE;\n      \
}\n    } else {\n      this.uniforms.splatTexEnable.value = false;\n      \
this.uniforms.splatTexture.value = _SparkRenderer.EMPTY_SPLAT_TEXTURE;\n    \
}\n    const accumToWorld = ((_b2 = viewpoint.display) == null ? void 0 : \
_b2.accumulator.toWorld) ?? new THREE.Matrix4();\n    const worldToCamera = \
camera.matrixWorld.clone().invert();\n    const originToCamera = \
accumToWorld.clone().premultiply(worldToCamera);\n    \
originToCamera.decompose(\n      this.uniforms.renderToViewPos.value,\n      \
this.uniforms.renderToViewQuat.value,\n      new THREE.Vector3()\n    );\n  \
}\n  // Update the uniforms for the given viewpoint.\n  // Note that the \
client expects to be able to call render() at any point\n  // to update the \
canvas, so we must switch the viewpoint back to\n  // defaultView when we're \
finished.\n  prepareViewpoint(viewpoint) {\n    var _a2, _b2, _c, _d;\n    \
this.viewpoint = viewpoint ?? this.viewpoint;\n    if \
(this.viewpoint.display) {\n      const { accumulator, geometry } = \
this.viewpoint.display;\n      this.uniforms.numSplats.value = \
accumulator.splats.numSplats;\n      this.uniforms.packedSplats.value = \
accumulator.splats.getTexture();\n      \
this.uniforms.rgbMinMaxLnScaleMinMax.value.set(\n        ((_a2 = \
accumulator.splats.splatEncoding) == null ? void 0 : _a2.rgbMin) ?? 0,\n      \
  ((_b2 = accumulator.splats.splatEncoding) == null ? void 0 : _b2.rgbMax) ?? \
1,\n        ((_c = accumulator.splats.splatEncoding) == null ? void 0 : \
_c.lnScaleMin) ?? LN_SCALE_MIN,\n        ((_d = \
accumulator.splats.splatEncoding) == null ? void 0 : _d.lnScaleMax) ?? \
LN_SCALE_MAX\n      );\n      this.geometry = geometry;\n      \
this.material.transparent = !this.viewpoint.stochastic;\n      \
this.material.depthWrite = this.viewpoint.stochastic;\n      \
this.material.needsUpdate = true;\n    } else {\n      \
this.uniforms.numSplats.value = 0;\n      this.uniforms.packedSplats.value = \
PackedSplats.getEmpty();\n      this.geometry = EMPTY_GEOMETRY;\n    }\n  }\n \
 // If spark.autoUpdate is false then you must manually call\n  // \
spark.update({ scene }) to have the scene Gsplats be re-generated.\n  \
update({\n    scene,\n    viewToWorld\n  }) {\n    const originToWorld = \
this.matrixWorld;\n    if (this.preUpdate) {\n      this.updateInternal({\n   \
     scene,\n        originToWorld: originToWorld.clone(),\n        \
viewToWorld\n      });\n    } else {\n      this.pendingUpdate.scene = \
scene;\n      this.pendingUpdate.originToWorld.copy(originToWorld);\n      if \
(this.pendingUpdate.timeoutId === -1) {\n        this.pendingUpdate.timeoutId \
= setTimeout(() => {\n          const { scene: scene2, originToWorld: \
originToWorld2 } = this.pendingUpdate;\n          this.pendingUpdate.scene = \
null;\n          this.pendingUpdate.timeoutId = -1;\n          const updated \
= this.updateInternal({\n            scene: scene2,\n            \
originToWorld: originToWorld2,\n            viewToWorld\n          });\n      \
    if (updated) {\n            const gl = this.renderer.getContext();\n      \
      gl.flush();\n          }\n        }, 1);\n      }\n    }\n  }\n  \
updateInternal({\n    scene,\n    originToWorld,\n    viewToWorld\n  }) {\n   \
 var _a2;\n    if (!this.canAllocAccumulator()) {\n      return false;\n    \
}\n    if (!originToWorld) {\n      originToWorld = this.active.toWorld;\n    \
}\n    viewToWorld = viewToWorld ?? originToWorld.clone();\n    const time = \
this.time ?? this.clock.getElapsedTime();\n    const deltaTime = time - \
(this.lastUpdateTime ?? time);\n    this.lastUpdateTime = time;\n    const \
activeMapping = this.active.mapping.reduce((map, record) => {\n      \
map.set(record.node, record);\n      return map;\n    }, /* @__PURE__ */ new \
Map());\n    const { generators: generators2, visibleGenerators, globalEdits \
} = this.compileScene(scene);\n    for (const object of generators2) {\n      \
(_a2 = object.frameUpdate) == null ? void 0 : _a2.call(object, {\n        \
object,\n        time,\n        deltaTime,\n        viewToWorld,\n        \
globalEdits\n      });\n    }\n    const visibleGenHash = new \
Set(visibleGenerators.map((g) => g.uuid));\n    for (const object of \
generators2) {\n      const current = activeMapping.get(object);\n      const \
isVisible = object.generator && visibleGenHash.has(object.uuid);\n      const \
numSplats = isVisible ? object.numSplats : 0;\n      if (this.needsUpdate || \
object.generator !== (current == null ? void 0 : current.generator) || \
numSplats !== (current == null ? void 0 : current.count)) {\n        \
object.updateVersion();\n      }\n    }\n    const originUpdate = \
!withinCoorientDist({\n      matrix1: originToWorld,\n      matrix2: \
this.active.toWorld,\n      maxDistance: this.originDistance\n    });\n    \
const needsUpdate = this.needsUpdate || originUpdate || generators2.length \
!== activeMapping.size || generators2.some((g) => {\n      var _a3;\n      \
return g.version !== ((_a3 = activeMapping.get(g)) == null ? void 0 : \
_a3.version);\n    });\n    this.needsUpdate = false;\n    let accumulator = \
null;\n    if (needsUpdate) {\n      accumulator = \
this.maybeAllocAccumulator();\n      if (!accumulator) {\n        throw new \
Error(\"Unreachable\");\n      }\n      const originChanged = \
!withinCoorientDist({\n        matrix1: originToWorld,\n        matrix2: \
this.active.toWorld,\n        maxDistance: 1e-5,\n        minCoorient: \
0.99999\n      });\n      const sorted = visibleGenerators.map((g, gIndex) => \
{\n        const lastGen = activeMapping.get(g);\n        return !lastGen ? \
[Number.POSITIVE_INFINITY, g.version, g] : (\n          // Sort by version \
deltas then by previous ordering in the mapping,\n          // attempting to \
keep unchanging generators near the front\n          // to improve our \
chances of avoiding a re-generation.\n          [g.version - lastGen.version, \
lastGen.base, g]\n        );\n      }).sort((a, b) => {\n        if (a[0] !== \
b[0]) {\n          return a[0] - b[0];\n        }\n        return a[1] - \
b[1];\n      });\n      const genOrder = sorted.map(([_version, _seq, g]) => \
g);\n      const splatCounts = genOrder.map((g) => g.numSplats);\n      const \
{ maxSplats, mapping } = accumulator.splats.generateMapping(splatCounts);\n   \
   const newGenerators = genOrder.map((node, gIndex) => {\n        const { \
base, count } = mapping[gIndex];\n        return {\n          node,\n         \
 generator: node.generator,\n          version: node.version,\n          \
base,\n          count\n        };\n      });\n      \
originToWorld.clone().invert().decompose(\n        \
this.translateToAccumulator.value,\n        this.rotateToAccumulator.value,\n \
       new THREE.Vector3()\n      );\n      \
accumulator.ensureGenerate(maxSplats);\n      \
accumulator.splats.splatEncoding = { ...this.splatEncoding };\n      \
accumulator.generateSplats({\n        renderer: this.renderer,\n        \
modifier: this.modifier,\n        generators: newGenerators,\n        \
forceUpdate: originChanged,\n        originToWorld\n      });\n      \
accumulator.splatsVersion = this.active.splatsVersion + 1;\n      const \
hasCorrespondence = accumulator.hasCorrespondence(this.active);\n      \
accumulator.mappingVersion = this.active.mappingVersion + (hasCorrespondence \
? 0 : 1);\n      this.releaseAccumulator(this.active);\n      this.active = \
accumulator;\n      this.prepareViewpoint();\n    }\n    setTimeout(() => {\n \
     for (const view of this.autoViewpoints) {\n        view.autoPoll({ \
accumulator: accumulator ?? void 0 });\n      }\n    }, 1);\n    return \
true;\n  }\n  compileScene(scene) {\n    const generators2 = [];\n    \
scene.traverse((node) => {\n      if (node instanceof SplatGenerator) {\n     \
   generators2.push(node);\n      }\n    });\n    const visibleGenerators = \
[];\n    scene.traverseVisible((node) => {\n      if (node instanceof \
SplatGenerator) {\n        visibleGenerators.push(node);\n      }\n    });\n  \
  const globalEdits = /* @__PURE__ */ new Set();\n    \
scene.traverseVisible((node) => {\n      if (node instanceof SplatEdit) {\n   \
     let ancestor = node.parent;\n        while (ancestor != null && \
!(ancestor instanceof SplatMesh)) {\n          ancestor = ancestor.parent;\n  \
      }\n        if (ancestor == null) {\n          globalEdits.add(node);\n  \
      }\n      }\n    });\n    return {\n      generators: generators2,\n     \
 visibleGenerators,\n      globalEdits: Array.from(globalEdits)\n    };\n  \
}\n  // Renders out the scene to an environment map that can be used for\n  \
// Image-based lighting or similar applications. First optionally updates \
Gsplats,\n  // sorts them with respect to the provided worldCenter, renders 6 \
cube faces,\n  // then pre-filters them using THREE.PMREMGenerator and \
returns a THREE.Texture\n  // that can assigned directly to a \
THREE.MeshStandardMaterial.envMap property.\n  async renderEnvMap({\n    \
renderer,\n    scene,\n    worldCenter,\n    size = 256,\n    near = 0.1,\n   \
 far = 1e3,\n    hideObjects = [],\n    update = false\n  }) {\n    var _a2, \
_b2;\n    if (!this.envViewpoint) {\n      this.envViewpoint = \
this.newViewpoint({ sort360: true });\n    }\n    if \
(!_SparkRenderer.cubeRender || _SparkRenderer.cubeRender.target.width !== \
size || _SparkRenderer.cubeRender.near !== near || \
_SparkRenderer.cubeRender.far !== far) {\n      if \
(_SparkRenderer.cubeRender) {\n        \
_SparkRenderer.cubeRender.target.dispose();\n      }\n      const target2 = \
new THREE.WebGLCubeRenderTarget(size, {\n        format: THREE.RGBAFormat,\n  \
      generateMipmaps: true,\n        minFilter: \
THREE.LinearMipMapLinearFilter\n      });\n      const camera2 = new \
THREE.CubeCamera(near, far, target2);\n      _SparkRenderer.cubeRender = { \
target: target2, camera: camera2, near, far };\n    }\n    if \
(!_SparkRenderer.pmrem) {\n      _SparkRenderer.pmrem = new \
THREE.PMREMGenerator(renderer ?? this.renderer);\n    }\n    const \
viewToWorld = new THREE.Matrix4().setPosition(worldCenter);\n    await ((_a2 \
= this.envViewpoint) == null ? void 0 : _a2.prepare({ scene, viewToWorld, \
update }));\n    const { target, camera } = _SparkRenderer.cubeRender;\n    \
camera.position.copy(worldCenter);\n    const objectVisibility = /* @__PURE__ \
*/ new Map();\n    for (const object of hideObjects) {\n      \
objectVisibility.set(object, object.visible);\n      object.visible = \
false;\n    }\n    this.prepareViewpoint(this.envViewpoint);\n    \
camera.update(renderer ?? this.renderer, scene);\n    \
this.prepareViewpoint(this.defaultView);\n    for (const [object, visible] of \
objectVisibility.entries()) {\n      object.visible = visible;\n    }\n    \
return (_b2 = _SparkRenderer.pmrem) == null ? void 0 : \
_b2.fromCubemap(target.texture).texture;\n  }\n  // Utility function to \
recursively set the envMap property for any\n  // THREE.MeshStandardMaterial \
within the subtree of root.\n  recurseSetEnvMap(root, envMap) {\n    \
root.traverse((node) => {\n      if (node instanceof THREE.Mesh) {\n        \
if (Array.isArray(node.material)) {\n          for (const material of \
node.material) {\n            if (material instanceof \
THREE.MeshStandardMaterial) {\n              material.envMap = envMap;\n      \
      }\n          }\n        } else {\n          if (node.material \
instanceof THREE.MeshStandardMaterial) {\n            node.material.envMap = \
envMap;\n          }\n        }\n      }\n    });\n  }\n  // Utility function \
that helps extract the Gsplat RGBA values from a\n  // SplatGenerator, \
including the result of any real-time RGBA SDF edits applied\n  // to a \
SplatMesh. This effectively \"bakes\" any computed RGBA values, which can\n  \
// now be used as a pipeline input via SplatMesh.splatRgba to inject these\n  \
// baked values into the Gsplat data.\n  getRgba({\n    generator,\n    \
rgba\n  }) {\n    const mapping = this.active.mapping.find(({ node }) => node \
=== generator);\n    if (!mapping) {\n      throw new Error(\"Generator not \
found\");\n    }\n    rgba = rgba ?? new RgbaArray();\n    \
rgba.fromPackedSplats({\n      packedSplats: this.active.splats,\n      base: \
mapping.base,\n      count: mapping.count,\n      renderer: this.renderer\n   \
 });\n    return rgba;\n  }\n  // Utility function that builds on getRgba({ \
generator }) and additionally\n  // reads back the RGBA values to the CPU in \
a Uint8Array with packed RGBA\n  // in that byte order.\n  async readRgba({\n \
   generator,\n    rgba\n  }) {\n    rgba = this.getRgba({ generator, rgba \
});\n    return rgba.read();\n  }\n};\n_SparkRenderer.cubeRender = \
null;\n_SparkRenderer.pmrem = null;\n_SparkRenderer.EMPTY_SPLAT_TEXTURE = new \
THREE.Data3DTexture();\nlet SparkRenderer = _SparkRenderer;\nconst \
EMPTY_GEOMETRY = new SplatGeometry(new Uint32Array(1), 0);\ndynoBlock(\n  { \
packedSplats: TPackedSplats, index: \"int\" },\n  { gsplat: Gsplat },\n  ({ \
packedSplats, index }) => {\n    if (!packedSplats || !index) {\n      throw \
new Error(\"Invalid input\");\n    }\n    const gsplat = \
readPackedSplat(packedSplats, index);\n    return { gsplat };\n  \
}\n);\nfunction averageOriginToWorlds(originToWorlds) {\n  if \
(originToWorlds.length === 0) {\n    return null;\n  }\n  const position = \
new THREE.Vector3();\n  const quaternion = new THREE.Quaternion();\n  const \
scale = new THREE.Vector3();\n  const positions = [];\n  const quaternions = \
[];\n  for (const matrix of originToWorlds) {\n    matrix.decompose(position, \
quaternion, scale);\n    positions.push(position);\n    \
quaternions.push(quaternion);\n  }\n  return new THREE.Matrix4().compose(\n   \
 averagePositions(positions),\n    averageQuaternions(quaternions),\n    new \
THREE.Vector3(1, 1, 1)\n  );\n}\nfunction decodeAntiSplat(fileBytes, \
initNumSplats, splatCallback) {\n  const numSplats = \
Math.floor(fileBytes.length / 32);\n  if (numSplats * 32 !== \
fileBytes.length) {\n    throw new Error(\"Invalid .splat file size\");\n  \
}\n  const f32 = new Float32Array(fileBytes.buffer);\n  for (let i = 0; i < \
numSplats; ++i) {\n    const i322 = i * 32;\n    const i8 = i * 8;\n    const \
x = f32[i8 + 0];\n    const y = f32[i8 + 1];\n    const z = f32[i8 + 2];\n    \
const scaleX = f32[i8 + 3];\n    const scaleY = f32[i8 + 4];\n    const \
scaleZ = f32[i8 + 5];\n    const r = fileBytes[i322 + 24] / 255;\n    const g \
= fileBytes[i322 + 25] / 255;\n    const b = fileBytes[i322 + 26] / 255;\n    \
const opacity = fileBytes[i322 + 27] / 255;\n    const quatW = \
(fileBytes[i322 + 28] - 128) / 128;\n    const quatX = (fileBytes[i322 + 29] \
- 128) / 128;\n    const quatY = (fileBytes[i322 + 30] - 128) / 128;\n    \
const quatZ = (fileBytes[i322 + 31] - 128) / 128;\n    splatCallback(\n      \
i,\n      x,\n      y,\n      z,\n      scaleX,\n      scaleY,\n      \
scaleZ,\n      quatX,\n      quatY,\n      quatZ,\n      quatW,\n      \
opacity,\n      r,\n      g,\n      b\n    );\n  }\n}\nconst \
KSPLAT_COMPRESSION = {\n  0: {\n    bytesPerCenter: 12,\n    bytesPerScale: \
12,\n    bytesPerRotation: 16,\n    bytesPerColor: 4,\n    \
bytesPerSphericalHarmonicsComponent: 4,\n    scaleOffsetBytes: 12,\n    \
rotationOffsetBytes: 24,\n    colorOffsetBytes: 40,\n    \
sphericalHarmonicsOffsetBytes: 44,\n    scaleRange: 1\n  },\n  1: {\n    \
bytesPerCenter: 6,\n    bytesPerScale: 6,\n    bytesPerRotation: 8,\n    \
bytesPerColor: 4,\n    bytesPerSphericalHarmonicsComponent: 2,\n    \
scaleOffsetBytes: 6,\n    rotationOffsetBytes: 12,\n    colorOffsetBytes: \
20,\n    sphericalHarmonicsOffsetBytes: 24,\n    scaleRange: 32767\n  },\n  \
2: {\n    bytesPerCenter: 6,\n    bytesPerScale: 6,\n    bytesPerRotation: \
8,\n    bytesPerColor: 4,\n    bytesPerSphericalHarmonicsComponent: 1,\n    \
scaleOffsetBytes: 6,\n    rotationOffsetBytes: 12,\n    colorOffsetBytes: \
20,\n    sphericalHarmonicsOffsetBytes: 24,\n    scaleRange: 32767\n  \
}\n};\nconst KSPLAT_SH_DEGREE_TO_COMPONENTS = {\n  0: 0,\n  1: 9,\n  2: 24,\n \
 3: 45\n};\nfunction decodeKsplat(fileBytes, initNumSplats, splatCallback, \
shCallback) {\n  var _a2;\n  const HEADER_BYTES = 4096;\n  const \
SECTION_BYTES = 1024;\n  let headerOffset = 0;\n  const header = new \
DataView(fileBytes.buffer, headerOffset, HEADER_BYTES);\n  headerOffset += \
HEADER_BYTES;\n  const versionMajor = header.getUint8(0);\n  const \
versionMinor = header.getUint8(1);\n  if (versionMajor !== 0 || versionMinor \
< 1) {\n    throw new Error(\n      `Unsupported .ksplat version: \
${versionMajor}.${versionMinor}`\n    );\n  }\n  const maxSectionCount = \
header.getUint32(4, true);\n  header.getUint32(16, true);\n  const \
compressionLevel = header.getUint16(20, true);\n  if (compressionLevel < 0 || \
compressionLevel > 2) {\n    throw new Error(`Invalid .ksplat compression \
level: ${compressionLevel}`);\n  }\n  const minSphericalHarmonicsCoeff = \
header.getFloat32(36, true) || -1.5;\n  const maxSphericalHarmonicsCoeff = \
header.getFloat32(40, true) || 1.5;\n  let sectionBase = HEADER_BYTES + \
maxSectionCount * SECTION_BYTES;\n  for (let section = 0; section < \
maxSectionCount; ++section) {\n    let getSh = function(splatOffset, \
component) {\n      if (compressionLevel === 0) {\n        return \
data.getFloat32(\n          splatOffset + sphericalHarmonicsOffsetBytes + \
component * 4,\n          true\n        );\n      }\n      if \
(compressionLevel === 1) {\n        return fromHalf(\n          \
data.getUint16(\n            splatOffset + sphericalHarmonicsOffsetBytes + \
component * 2,\n            true\n          )\n        );\n      }\n      \
const t = data.getUint8(splatOffset + sphericalHarmonicsOffsetBytes + \
component) / 255;\n      return minSphericalHarmonicsCoeff + t * \
(maxSphericalHarmonicsCoeff - minSphericalHarmonicsCoeff);\n    };\n    const \
section2 = new DataView(fileBytes.buffer, headerOffset, SECTION_BYTES);\n    \
headerOffset += SECTION_BYTES;\n    const sectionSplatCount = \
section2.getUint32(0, true);\n    const sectionMaxSplatCount = \
section2.getUint32(4, true);\n    const bucketSize = section2.getUint32(8, \
true);\n    const bucketCount = section2.getUint32(12, true);\n    const \
bucketBlockSize = section2.getFloat32(16, true);\n    const \
bucketStorageSizeBytes = section2.getUint16(20, true);\n    const \
compressionScaleRange = (section2.getUint32(24, true) || ((_a2 = \
KSPLAT_COMPRESSION[compressionLevel]) == null ? void 0 : _a2.scaleRange)) ?? \
1;\n    const fullBucketCount = section2.getUint32(32, true);\n    const \
fullBucketSplats = fullBucketCount * bucketSize;\n    const \
partiallyFilledBucketCount = section2.getUint32(36, true);\n    const \
bucketsMetaDataSizeBytes = partiallyFilledBucketCount * 4;\n    const \
bucketsStorageSizeBytes = bucketStorageSizeBytes * bucketCount + \
bucketsMetaDataSizeBytes;\n    const sphericalHarmonicsDegree = \
section2.getUint16(40, true);\n    const shComponents = \
KSPLAT_SH_DEGREE_TO_COMPONENTS[sphericalHarmonicsDegree];\n    const {\n      \
bytesPerCenter,\n      bytesPerScale,\n      bytesPerRotation,\n      \
bytesPerColor,\n      bytesPerSphericalHarmonicsComponent,\n      \
scaleOffsetBytes,\n      rotationOffsetBytes,\n      colorOffsetBytes,\n      \
sphericalHarmonicsOffsetBytes\n    } = \
KSPLAT_COMPRESSION[compressionLevel];\n    const bytesPerSplat = \
bytesPerCenter + bytesPerScale + bytesPerRotation + bytesPerColor + \
shComponents * bytesPerSphericalHarmonicsComponent;\n    const \
splatDataStorageSizeBytes = bytesPerSplat * sectionMaxSplatCount;\n    const \
storageSizeBytes = splatDataStorageSizeBytes + bucketsStorageSizeBytes;\n    \
const sh1Index = [0, 3, 6, 1, 4, 7, 2, 5, 8];\n    const sh2Index = [\n      \
9,\n      14,\n      19,\n      10,\n      15,\n      20,\n      11,\n      \
16,\n      21,\n      12,\n      17,\n      22,\n      13,\n      18,\n      \
23\n    ];\n    const sh3Index = [\n      24,\n      31,\n      38,\n      \
25,\n      32,\n      39,\n      26,\n      33,\n      40,\n      27,\n      \
34,\n      41,\n      28,\n      35,\n      42,\n      29,\n      36,\n      \
43,\n      30,\n      37,\n      44\n    ];\n    const sh1 = \
sphericalHarmonicsDegree >= 1 ? new Float32Array(3 * 3) : void 0;\n    const \
sh2 = sphericalHarmonicsDegree >= 2 ? new Float32Array(5 * 3) : void 0;\n    \
const sh3 = sphericalHarmonicsDegree >= 3 ? new Float32Array(7 * 3) : void \
0;\n    const compressionScaleFactor = bucketBlockSize / 2 / \
compressionScaleRange;\n    const bucketsBase = sectionBase + \
bucketsMetaDataSizeBytes;\n    const dataBase = sectionBase + \
bucketsStorageSizeBytes;\n    const data = new DataView(\n      \
fileBytes.buffer,\n      dataBase,\n      splatDataStorageSizeBytes\n    );\n \
   const bucketArray = new Float32Array(\n      fileBytes.buffer,\n      \
bucketsBase,\n      bucketCount * 3\n    );\n    const \
partiallyFilledBucketLengths = new Uint32Array(\n      fileBytes.buffer,\n    \
  sectionBase,\n      partiallyFilledBucketCount\n    );\n    let \
partialBucketIndex = fullBucketCount;\n    let partialBucketBase = \
fullBucketSplats;\n    for (let i = 0; i < sectionSplatCount; ++i) {\n      \
const splatOffset = i * bytesPerSplat;\n      let bucketIndex;\n      if (i < \
fullBucketSplats) {\n        bucketIndex = Math.floor(i / bucketSize);\n      \
} else {\n        const bucketLength = \
partiallyFilledBucketLengths[partialBucketIndex - fullBucketCount];\n        \
if (i >= partialBucketBase + bucketLength) {\n          partialBucketIndex += \
1;\n          partialBucketBase += bucketLength;\n        }\n        \
bucketIndex = partialBucketIndex;\n      }\n      const x = compressionLevel \
=== 0 ? data.getFloat32(splatOffset + 0, true) : (data.getUint16(splatOffset \
+ 0, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 \
* bucketIndex + 0];\n      const y = compressionLevel === 0 ? \
data.getFloat32(splatOffset + 4, true) : (data.getUint16(splatOffset + 2, \
true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * \
bucketIndex + 1];\n      const z = compressionLevel === 0 ? \
data.getFloat32(splatOffset + 8, true) : (data.getUint16(splatOffset + 4, \
true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * \
bucketIndex + 2];\n      const scaleX = compressionLevel === 0 ? \
data.getFloat32(splatOffset + scaleOffsetBytes + 0, true) : \
fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 0, true));\n      \
const scaleY = compressionLevel === 0 ? data.getFloat32(splatOffset + \
scaleOffsetBytes + 4, true) : fromHalf(data.getUint16(splatOffset + \
scaleOffsetBytes + 2, true));\n      const scaleZ = compressionLevel === 0 ? \
data.getFloat32(splatOffset + scaleOffsetBytes + 8, true) : \
fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 4, true));\n      \
const quatW = compressionLevel === 0 ? data.getFloat32(splatOffset + \
rotationOffsetBytes + 0, true) : fromHalf(\n        \
data.getUint16(splatOffset + rotationOffsetBytes + 0, true)\n      );\n      \
const quatX = compressionLevel === 0 ? data.getFloat32(splatOffset + \
rotationOffsetBytes + 4, true) : fromHalf(\n        \
data.getUint16(splatOffset + rotationOffsetBytes + 2, true)\n      );\n      \
const quatY = compressionLevel === 0 ? data.getFloat32(splatOffset + \
rotationOffsetBytes + 8, true) : fromHalf(\n        \
data.getUint16(splatOffset + rotationOffsetBytes + 4, true)\n      );\n      \
const quatZ = compressionLevel === 0 ? data.getFloat32(splatOffset + \
rotationOffsetBytes + 12, true) : fromHalf(\n        \
data.getUint16(splatOffset + rotationOffsetBytes + 6, true)\n      );\n      \
const r = data.getUint8(splatOffset + colorOffsetBytes + 0) / 255;\n      \
const g = data.getUint8(splatOffset + colorOffsetBytes + 1) / 255;\n      \
const b = data.getUint8(splatOffset + colorOffsetBytes + 2) / 255;\n      \
const opacity = data.getUint8(splatOffset + colorOffsetBytes + 3) / 255;\n    \
  splatCallback(\n        i,\n        x,\n        y,\n        z,\n        \
scaleX,\n        scaleY,\n        scaleZ,\n        quatX,\n        quatY,\n   \
     quatZ,\n        quatW,\n        opacity,\n        r,\n        g,\n       \
 b\n      );\n      if (sphericalHarmonicsDegree >= 1 && sh1) {\n        for \
(const [i2, key] of sh1Index.entries()) {\n          sh1[i2] = \
getSh(splatOffset, key);\n        }\n        if (sh2) {\n          for (const \
[i2, key] of sh2Index.entries()) {\n            sh2[i2] = getSh(splatOffset, \
key);\n          }\n        }\n        if (sh3) {\n          for (const [i2, \
key] of sh3Index.entries()) {\n            sh3[i2] = getSh(splatOffset, \
key);\n          }\n        }\n        shCallback == null ? void 0 : \
shCallback(i, sh1, sh2, sh3);\n      }\n    }\n    sectionBase += \
storageSizeBytes;\n  }\n}\nclass SpzReader {\n  constructor({ fileBytes }) \
{\n    this.version = -1;\n    this.numSplats = 0;\n    this.shDegree = 0;\n  \
  this.fractionalBits = 0;\n    this.flags = 0;\n    this.flagAntiAlias = \
false;\n    this.reserved = 0;\n    this.headerParsed = false;\n    \
this.parsed = false;\n    this.fileBytes = fileBytes instanceof ArrayBuffer ? \
new Uint8Array(fileBytes) : fileBytes;\n    this.reader = new GunzipReader({ \
fileBytes: this.fileBytes });\n  }\n  async parseHeader() {\n    if \
(this.headerParsed) {\n      throw new Error(\"SPZ file header already \
parsed\");\n    }\n    const header = new DataView((await \
this.reader.read(16)).buffer);\n    if (header.getUint32(0, true) !== \
1347635022) {\n      throw new Error(\"Invalid SPZ file\");\n    }\n    \
this.version = header.getUint32(4, true);\n    if (this.version < 1 || \
this.version > 3) {\n      throw new Error(`Unsupported SPZ version: \
${this.version}`);\n    }\n    this.numSplats = header.getUint32(8, true);\n  \
  this.shDegree = header.getUint8(12);\n    this.fractionalBits = \
header.getUint8(13);\n    this.flags = header.getUint8(14);\n    \
this.flagAntiAlias = (this.flags & 1) !== 0;\n    this.reserved = \
header.getUint8(15);\n    this.headerParsed = true;\n    this.parsed = \
false;\n  }\n  async parseSplats(centerCallback, alphaCallback, rgbCallback, \
scalesCallback, quatCallback, shCallback) {\n    if (!this.headerParsed) {\n  \
    throw new Error(\"SPZ file header must be parsed first\");\n    }\n    if \
(this.parsed) {\n      throw new Error(\"SPZ file already parsed\");\n    }\n \
   this.parsed = true;\n    if (this.version === 1) {\n      const \
centerBytes = await this.reader.read(this.numSplats * 3 * 2);\n      const \
centerUint16 = new Uint16Array(centerBytes.buffer);\n      for (let i = 0; i \
< this.numSplats; i++) {\n        const i3 = i * 3;\n        const x = \
fromHalf(centerUint16[i3]);\n        const y = fromHalf(centerUint16[i3 + \
1]);\n        const z = fromHalf(centerUint16[i3 + 2]);\n        \
centerCallback == null ? void 0 : centerCallback(i, x, y, z);\n      }\n    } \
else if (this.version === 2 || this.version === 3) {\n      const fixed = 1 \
<< this.fractionalBits;\n      const centerBytes = await \
this.reader.read(this.numSplats * 3 * 3);\n      for (let i = 0; i < \
this.numSplats; i++) {\n        const i9 = i * 9;\n        const x = \
((centerBytes[i9 + 2] << 24 | centerBytes[i9 + 1] << 16 | centerBytes[i9] << \
8) >> 8) / fixed;\n        const y = ((centerBytes[i9 + 5] << 24 | \
centerBytes[i9 + 4] << 16 | centerBytes[i9 + 3] << 8) >> 8) / fixed;\n        \
const z = ((centerBytes[i9 + 8] << 24 | centerBytes[i9 + 7] << 16 | \
centerBytes[i9 + 6] << 8) >> 8) / fixed;\n        centerCallback == null ? \
void 0 : centerCallback(i, x, y, z);\n      }\n    } else {\n      throw new \
Error(\"Unreachable\");\n    }\n    {\n      const bytes = await \
this.reader.read(this.numSplats);\n      for (let i = 0; i < this.numSplats; \
i++) {\n        alphaCallback == null ? void 0 : alphaCallback(i, bytes[i] / \
255);\n      }\n    }\n    {\n      const rgbBytes = await \
this.reader.read(this.numSplats * 3);\n      const scale = SH_C0 / 0.15;\n    \
  for (let i = 0; i < this.numSplats; i++) {\n        const i3 = i * 3;\n     \
   const r = (rgbBytes[i3] / 255 - 0.5) * scale + 0.5;\n        const g = \
(rgbBytes[i3 + 1] / 255 - 0.5) * scale + 0.5;\n        const b = (rgbBytes[i3 \
+ 2] / 255 - 0.5) * scale + 0.5;\n        rgbCallback == null ? void 0 : \
rgbCallback(i, r, g, b);\n      }\n    }\n    {\n      const scalesBytes = \
await this.reader.read(this.numSplats * 3);\n      for (let i = 0; i < \
this.numSplats; i++) {\n        const i3 = i * 3;\n        const scaleX = \
Math.exp(scalesBytes[i3] / 16 - 10);\n        const scaleY = \
Math.exp(scalesBytes[i3 + 1] / 16 - 10);\n        const scaleZ = \
Math.exp(scalesBytes[i3 + 2] / 16 - 10);\n        scalesCallback == null ? \
void 0 : scalesCallback(i, scaleX, scaleY, scaleZ);\n      }\n    }\n    if \
(this.version === 3) {\n      const maxValue = 1 / Math.sqrt(2);\n      const \
quatBytes = await this.reader.read(this.numSplats * 4);\n      for (let i = \
0; i < this.numSplats; i++) {\n        const i3 = i * 4;\n        const \
quaternion = [0, 0, 0, 0];\n        const values = [\n          \
quatBytes[i3],\n          quatBytes[i3 + 1],\n          quatBytes[i3 + 2],\n  \
        quatBytes[i3 + 3]\n        ];\n        const combinedValues = \
values[0] + (values[1] << 8) + (values[2] << 16) + (values[3] << 24);\n       \
 const valueMask = (1 << 9) - 1;\n        const largestIndex = combinedValues \
>>> 30;\n        let remainingValues = combinedValues;\n        let \
sumSquares = 0;\n        for (let i2 = 3; i2 >= 0; --i2) {\n          if (i2 \
!== largestIndex) {\n            const value = remainingValues & valueMask;\n \
           const sign2 = remainingValues >>> 9 & 1;\n            \
remainingValues = remainingValues >>> 10;\n            quaternion[i2] = \
maxValue * (value / valueMask);\n            quaternion[i2] = sign2 === 0 ? \
quaternion[i2] : -quaternion[i2];\n            sumSquares += quaternion[i2] * \
quaternion[i2];\n          }\n        }\n        const square = 1 - \
sumSquares;\n        quaternion[largestIndex] = Math.sqrt(Math.max(square, \
0));\n        quatCallback == null ? void 0 : quatCallback(\n          i,\n   \
       quaternion[0],\n          quaternion[1],\n          quaternion[2],\n   \
       quaternion[3]\n        );\n      }\n    } else {\n      const \
quatBytes = await this.reader.read(this.numSplats * 3);\n      for (let i = \
0; i < this.numSplats; i++) {\n        const i3 = i * 3;\n        const quatX \
= quatBytes[i3] / 127.5 - 1;\n        const quatY = quatBytes[i3 + 1] / 127.5 \
- 1;\n        const quatZ = quatBytes[i3 + 2] / 127.5 - 1;\n        const \
quatW = Math.sqrt(\n          Math.max(0, 1 - quatX * quatX - quatY * quatY - \
quatZ * quatZ)\n        );\n        quatCallback == null ? void 0 : \
quatCallback(i, quatX, quatY, quatZ, quatW);\n      }\n    }\n    if \
(shCallback && this.shDegree >= 1) {\n      const sh1 = new Float32Array(3 * \
3);\n      const sh2 = this.shDegree >= 2 ? new Float32Array(5 * 3) : void \
0;\n      const sh3 = this.shDegree >= 3 ? new Float32Array(7 * 3) : void \
0;\n      const shBytes = await this.reader.read(\n        this.numSplats * \
SH_DEGREE_TO_VECS[this.shDegree] * 3\n      );\n      let offset = 0;\n      \
for (let i = 0; i < this.numSplats; i++) {\n        for (let j = 0; j < 9; \
++j) {\n          sh1[j] = (shBytes[offset + j] - 128) / 128;\n        }\n    \
    offset += 9;\n        if (sh2) {\n          for (let j = 0; j < 15; ++j) \
{\n            sh2[j] = (shBytes[offset + j] - 128) / 128;\n          }\n     \
     offset += 15;\n        }\n        if (sh3) {\n          for (let j = 0; \
j < 21; ++j) {\n            sh3[j] = (shBytes[offset + j] - 128) / 128;\n     \
     }\n          offset += 21;\n        }\n        shCallback == null ? void \
0 : shCallback(i, sh1, sh2, sh3);\n      }\n    }\n  }\n}\nconst \
SH_DEGREE_TO_VECS = { 1: 3, 2: 8, 3: 15 };\nconst SH_C0 = \
0.28209479177387814;\nconst SPZ_MAGIC = 1347635022;\nconst SPZ_VERSION = \
3;\nconst FLAG_ANTIALIASED = 1;\nclass SpzWriter {\n  constructor({\n    \
numSplats,\n    shDegree,\n    fractionalBits = 12,\n    flagAntiAlias = \
true\n  }) {\n    this.clippedCount = 0;\n    const splatSize = 9 + // \
Position\n    1 + // Opacity\n    3 + // Scale\n    3 + // DC-rgb\n    4 + // \
Rotation\n    (shDegree >= 1 ? 9 : 0) + (shDegree >= 2 ? 15 : 0) + (shDegree \
>= 3 ? 21 : 0);\n    const bufferSize = 16 + numSplats * splatSize;\n    \
this.buffer = new ArrayBuffer(bufferSize);\n    this.view = new \
DataView(this.buffer);\n    this.view.setUint32(0, SPZ_MAGIC, true);\n    \
this.view.setUint32(4, SPZ_VERSION, true);\n    this.view.setUint32(8, \
numSplats, true);\n    this.view.setUint8(12, shDegree);\n    \
this.view.setUint8(13, fractionalBits);\n    this.view.setUint8(14, \
flagAntiAlias ? FLAG_ANTIALIASED : 0);\n    this.view.setUint8(15, 0);\n    \
this.numSplats = numSplats;\n    this.shDegree = shDegree;\n    \
this.fractionalBits = fractionalBits;\n    this.fraction = 1 << \
fractionalBits;\n    this.flagAntiAlias = flagAntiAlias;\n  }\n  \
setCenter(index, x, y, z) {\n    const xRounded = Math.round(x * \
this.fraction);\n    const xInt = Math.max(-8388607, Math.min(8388607, \
xRounded));\n    const yRounded = Math.round(y * this.fraction);\n    const \
yInt = Math.max(-8388607, Math.min(8388607, yRounded));\n    const zRounded = \
Math.round(z * this.fraction);\n    const zInt = Math.max(-8388607, \
Math.min(8388607, zRounded));\n    const clipped = xRounded !== xInt || \
yRounded !== yInt || zRounded !== zInt;\n    if (clipped) {\n      \
this.clippedCount += 1;\n    }\n    const i9 = index * 9;\n    const base = \
16 + i9;\n    this.view.setUint8(base, xInt & 255);\n    \
this.view.setUint8(base + 1, xInt >> 8 & 255);\n    this.view.setUint8(base + \
2, xInt >> 16 & 255);\n    this.view.setUint8(base + 3, yInt & 255);\n    \
this.view.setUint8(base + 4, yInt >> 8 & 255);\n    this.view.setUint8(base + \
5, yInt >> 16 & 255);\n    this.view.setUint8(base + 6, zInt & 255);\n    \
this.view.setUint8(base + 7, zInt >> 8 & 255);\n    this.view.setUint8(base + \
8, zInt >> 16 & 255);\n  }\n  setAlpha(index, alpha) {\n    const base = 16 + \
this.numSplats * 9 + index;\n    this.view.setUint8(\n      base,\n      \
Math.max(0, Math.min(255, Math.round(alpha * 255)))\n    );\n  }\n  static \
scaleRgb(r) {\n    const v = ((r - 0.5) / (SH_C0 / 0.15) + 0.5) * 255;\n    \
return Math.max(0, Math.min(255, Math.round(v)));\n  }\n  setRgb(index, r, g, \
b) {\n    const base = 16 + this.numSplats * 10 + index * 3;\n    \
this.view.setUint8(base, SpzWriter.scaleRgb(r));\n    this.view.setUint8(base \
+ 1, SpzWriter.scaleRgb(g));\n    this.view.setUint8(base + 2, \
SpzWriter.scaleRgb(b));\n  }\n  setScale(index, scaleX, scaleY, scaleZ) {\n   \
 const base = 16 + this.numSplats * 13 + index * 3;\n    \
this.view.setUint8(\n      base,\n      Math.max(0, Math.min(255, \
Math.round((Math.log(scaleX) + 10) * 16)))\n    );\n    this.view.setUint8(\n \
     base + 1,\n      Math.max(0, Math.min(255, Math.round((Math.log(scaleY) \
+ 10) * 16)))\n    );\n    this.view.setUint8(\n      base + 2,\n      \
Math.max(0, Math.min(255, Math.round((Math.log(scaleZ) + 10) * 16)))\n    \
);\n  }\n  setQuat(index, ...q) {\n    const base = 16 + this.numSplats * 16 \
+ index * 4;\n    const quat = normalize$1(q);\n    let iLargest = 0;\n    \
for (let i = 1; i < 4; ++i) {\n      if (Math.abs(quat[i]) > \
Math.abs(quat[iLargest])) {\n        iLargest = i;\n      }\n    }\n    const \
negate = quat[iLargest] < 0 ? 1 : 0;\n    let comp = iLargest;\n    for (let \
i = 0; i < 4; ++i) {\n      if (i !== iLargest) {\n        const negbit = \
(quat[i] < 0 ? 1 : 0) ^ negate;\n        const mag = Math.floor(\n          \
((1 << 9) - 1) * (Math.abs(quat[i]) / Math.SQRT1_2) + 0.5\n        );\n       \
 comp = comp << 10 | negbit << 9 | mag;\n      }\n    }\n    \
this.view.setUint8(base, comp & 255);\n    this.view.setUint8(base + 1, comp \
>> 8 & 255);\n    this.view.setUint8(base + 2, comp >> 16 & 255);\n    \
this.view.setUint8(base + 3, comp >>> 24 & 255);\n  }\n  static \
quantizeSh(sh, bits2) {\n    const value = Math.round(sh * 128) + 128;\n    \
const bucketSize = 1 << 8 - bits2;\n    const quantized = Math.floor((value + \
bucketSize / 2) / bucketSize) * bucketSize;\n    return Math.max(0, \
Math.min(255, quantized));\n  }\n  setSh(index, sh1, sh2, sh3) {\n    const \
shVecs = SH_DEGREE_TO_VECS[this.shDegree] || 0;\n    const base1 = 16 + \
this.numSplats * 20 + index * shVecs * 3;\n    for (let j = 0; j < 9; ++j) \
{\n      this.view.setUint8(base1 + j, SpzWriter.quantizeSh(sh1[j], 5));\n    \
}\n    if (sh2) {\n      const base2 = base1 + 9;\n      for (let j = 0; j < \
15; ++j) {\n        this.view.setUint8(base2 + j, \
SpzWriter.quantizeSh(sh2[j], 4));\n      }\n      if (sh3) {\n        const \
base3 = base2 + 15;\n        for (let j = 0; j < 21; ++j) {\n          \
this.view.setUint8(base3 + j, SpzWriter.quantizeSh(sh3[j], 4));\n        }\n  \
    }\n    }\n  }\n  async finalize() {\n    const input = new \
Uint8Array(this.buffer);\n    const stream = new ReadableStream({\n      \
async start(controller) {\n        controller.enqueue(input);\n        \
controller.close();\n      }\n    });\n    const compressed = \
stream.pipeThrough(new CompressionStream(\"gzip\"));\n    const response = \
new Response(compressed);\n    const buffer = await response.arrayBuffer();\n \
   console.log(\n      \"Compressed\",\n      input.length,\n      \"bytes \
to\",\n      buffer.byteLength,\n      \"bytes\"\n    );\n    return new \
Uint8Array(buffer);\n  }\n}\nasync function transcodeSpz(input) {\n  var _a2, \
_b2, _c;\n  const splats = new SplatData();\n  const {\n    inputs,\n    \
clipXyz,\n    maxSh,\n    fractionalBits = 12,\n    opacityThreshold\n  } = \
input;\n  for (const input2 of inputs) {\n    let transformPos2 = \
function(pos) {\n      pos.multiplyScalar(scale);\n      \
pos.applyQuaternion(quaternion);\n      pos.add(translate);\n      return \
pos;\n    }, transformScales = function(scales) {\n      \
scales.multiplyScalar(scale);\n      return scales;\n    }, \
transformQuaternion = function(quat) {\n      quat.premultiply(quaternion);\n \
     return quat;\n    }, withinClip = function(p) {\n      return !clip || \
clip.containsPoint(p);\n    }, withinOpacity = function(opacity) {\n      \
return opacityThreshold !== void 0 ? opacity >= opacityThreshold : true;\n    \
};\n    const scale = ((_a2 = input2.transform) == null ? void 0 : _a2.scale) \
?? 1;\n    const quaternion = new THREE.Quaternion().fromArray(\n      ((_b2 \
= input2.transform) == null ? void 0 : _b2.quaternion) ?? [0, 0, 0, 1]\n    \
);\n    const translate = new THREE.Vector3().fromArray(\n      ((_c = \
input2.transform) == null ? void 0 : _c.translate) ?? [0, 0, 0]\n    );\n    \
const clip = clipXyz ? new THREE.Box3(\n      new \
THREE.Vector3().fromArray(clipXyz.min),\n      new \
THREE.Vector3().fromArray(clipXyz.max)\n    ) : void 0;\n    let fileType = \
input2.fileType;\n    if (!fileType) {\n      fileType = \
getSplatFileType(input2.fileBytes);\n      if (!fileType && input2.pathOrUrl) \
{\n        fileType = getSplatFileTypeFromPath(input2.pathOrUrl);\n      }\n  \
  }\n    switch (fileType) {\n      case SplatFileType.PLY: {\n        const \
ply = new PlyReader({ fileBytes: input2.fileBytes });\n        await \
ply.parseHeader();\n        let lastIndex = null;\n        ply.parseSplats(\n \
         (index, x, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, \
opacity, r, g, b) => {\n            const center = transformPos2(new \
THREE.Vector3(x, y, z));\n            if (withinClip(center) && \
withinOpacity(opacity)) {\n              lastIndex = splats.pushSplat();\n    \
          splats.setCenter(lastIndex, center.x, center.y, center.z);\n        \
      const scales = transformScales(\n                new \
THREE.Vector3(scaleX, scaleY, scaleZ)\n              );\n              \
splats.setScale(lastIndex, scales.x, scales.y, scales.z);\n              \
const quaternion2 = transformQuaternion(\n                new \
THREE.Quaternion(quatX, quatY, quatZ, quatW)\n              );\n              \
splats.setQuaternion(\n                lastIndex,\n                \
quaternion2.x,\n                quaternion2.y,\n                \
quaternion2.z,\n                quaternion2.w\n              );\n             \
 splats.setOpacity(lastIndex, opacity);\n              \
splats.setColor(lastIndex, r, g, b);\n            } else {\n              \
lastIndex = null;\n            }\n          },\n          (index, sh1, sh2, \
sh3) => {\n            if (sh1 && lastIndex !== null) {\n              \
splats.setSh1(lastIndex, sh1);\n            }\n            if (sh2 && \
lastIndex !== null) {\n              splats.setSh2(lastIndex, sh2);\n         \
   }\n            if (sh3 && lastIndex !== null) {\n              \
splats.setSh3(lastIndex, sh3);\n            }\n          }\n        );\n      \
  break;\n      }\n      case SplatFileType.SPZ: {\n        const spz2 = new \
SpzReader({ fileBytes: input2.fileBytes });\n        await \
spz2.parseHeader();\n        const mapping = new \
Int32Array(spz2.numSplats);\n        mapping.fill(-1);\n        const centers \
= new Float32Array(spz2.numSplats * 3);\n        const center = new \
THREE.Vector3();\n        spz2.parseSplats(\n          (index, x, y, z) => \
{\n            const center2 = transformPos2(new THREE.Vector3(x, y, z));\n   \
         centers[index * 3] = center2.x;\n            centers[index * 3 + 1] \
= center2.y;\n            centers[index * 3 + 2] = center2.z;\n          },\n \
         (index, alpha) => {\n            center.fromArray(centers, index * \
3);\n            if (withinClip(center) && withinOpacity(alpha)) {\n          \
    mapping[index] = splats.pushSplat();\n              \
splats.setCenter(mapping[index], center.x, center.y, center.z);\n             \
 splats.setOpacity(mapping[index], alpha);\n            }\n          },\n     \
     (index, r, g, b) => {\n            if (mapping[index] >= 0) {\n          \
    splats.setColor(mapping[index], r, g, b);\n            }\n          },\n  \
        (index, scaleX, scaleY, scaleZ) => {\n            if (mapping[index] \
>= 0) {\n              const scales = transformScales(\n                new \
THREE.Vector3(scaleX, scaleY, scaleZ)\n              );\n              \
splats.setScale(mapping[index], scales.x, scales.y, scales.z);\n            \
}\n          },\n          (index, quatX, quatY, quatZ, quatW) => {\n         \
   if (mapping[index] >= 0) {\n              const quaternion2 = \
transformQuaternion(\n                new THREE.Quaternion(quatX, quatY, \
quatZ, quatW)\n              );\n              splats.setQuaternion(\n        \
        mapping[index],\n                quaternion2.x,\n                \
quaternion2.y,\n                quaternion2.z,\n                \
quaternion2.w\n              );\n            }\n          },\n          \
(index, sh1, sh2, sh3) => {\n            if (mapping[index] >= 0) {\n         \
     splats.setSh1(mapping[index], sh1);\n              if (sh2) {\n          \
      splats.setSh2(mapping[index], sh2);\n              }\n              if \
(sh3) {\n                splats.setSh3(mapping[index], sh3);\n              \
}\n            }\n          }\n        );\n        break;\n      }\n      \
case SplatFileType.SPLAT:\n        decodeAntiSplat(\n          \
input2.fileBytes,\n          (numSplats) => {\n          },\n          \
(index, x, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, \
r, g, b) => {\n            const center = transformPos2(new THREE.Vector3(x, \
y, z));\n            if (withinClip(center) && withinOpacity(opacity)) {\n    \
          const index2 = splats.pushSplat();\n              \
splats.setCenter(index2, center.x, center.y, center.z);\n              const \
scales = transformScales(\n                new THREE.Vector3(scaleX, scaleY, \
scaleZ)\n              );\n              splats.setScale(index2, scales.x, \
scales.y, scales.z);\n              const quaternion2 = \
transformQuaternion(\n                new THREE.Quaternion(quatX, quatY, \
quatZ, quatW)\n              );\n              splats.setQuaternion(\n        \
        index2,\n                quaternion2.x,\n                \
quaternion2.y,\n                quaternion2.z,\n                \
quaternion2.w\n              );\n              splats.setOpacity(index2, \
opacity);\n              splats.setColor(index2, r, g, b);\n            }\n   \
       }\n        );\n        break;\n      case SplatFileType.KSPLAT: {\n    \
    let lastIndex = null;\n        decodeKsplat(\n          \
input2.fileBytes,\n          (numSplats) => {\n          },\n          \
(index, x, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, \
r, g, b) => {\n            const center = transformPos2(new THREE.Vector3(x, \
y, z));\n            if (withinClip(center) && withinOpacity(opacity)) {\n    \
          lastIndex = splats.pushSplat();\n              \
splats.setCenter(lastIndex, center.x, center.y, center.z);\n              \
const scales = transformScales(\n                new THREE.Vector3(scaleX, \
scaleY, scaleZ)\n              );\n              splats.setScale(lastIndex, \
scales.x, scales.y, scales.z);\n              const quaternion2 = \
transformQuaternion(\n                new THREE.Quaternion(quatX, quatY, \
quatZ, quatW)\n              );\n              splats.setQuaternion(\n        \
        lastIndex,\n                quaternion2.x,\n                \
quaternion2.y,\n                quaternion2.z,\n                \
quaternion2.w\n              );\n              splats.setOpacity(lastIndex, \
opacity);\n              splats.setColor(lastIndex, r, g, b);\n            } \
else {\n              lastIndex = null;\n            }\n          },\n        \
  (index, sh1, sh2, sh3) => {\n            if (lastIndex !== null) {\n        \
      splats.setSh1(lastIndex, sh1);\n              if (sh2) {\n              \
  splats.setSh2(lastIndex, sh2);\n              }\n              if (sh3) {\n \
               splats.setSh3(lastIndex, sh3);\n              }\n            \
}\n          }\n        );\n        break;\n      }\n      default:\n        \
throw new Error(`transcodeSpz not implemented for ${fileType}`);\n    }\n  \
}\n  const shDegree = Math.min(\n    maxSh ?? 3,\n    splats.sh3 ? 3 : \
splats.sh2 ? 2 : splats.sh1 ? 1 : 0\n  );\n  const spz = new SpzWriter({\n    \
numSplats: splats.numSplats,\n    shDegree,\n    fractionalBits,\n    \
flagAntiAlias: true\n  });\n  for (let i = 0; i < splats.numSplats; ++i) {\n  \
  const i3 = i * 3;\n    const i4 = i * 4;\n    spz.setCenter(\n      i,\n    \
  splats.centers[i3],\n      splats.centers[i3 + 1],\n      splats.centers[i3 \
+ 2]\n    );\n    spz.setScale(\n      i,\n      splats.scales[i3],\n      \
splats.scales[i3 + 1],\n      splats.scales[i3 + 2]\n    );\n    \
spz.setQuat(\n      i,\n      splats.quaternions[i4],\n      \
splats.quaternions[i4 + 1],\n      splats.quaternions[i4 + 2],\n      \
splats.quaternions[i4 + 3]\n    );\n    spz.setAlpha(i, \
splats.opacities[i]);\n    spz.setRgb(\n      i,\n      splats.colors[i3],\n  \
    splats.colors[i3 + 1],\n      splats.colors[i3 + 2]\n    );\n    if \
(splats.sh1 && shDegree >= 1) {\n      spz.setSh(\n        i,\n        \
splats.sh1.slice(i * 9, (i + 1) * 9),\n        shDegree >= 2 && splats.sh2 ? \
splats.sh2.slice(i * 15, (i + 1) * 15) : void 0,\n        shDegree >= 3 && \
splats.sh3 ? splats.sh3.slice(i * 21, (i + 1) * 21) : void 0\n      );\n    \
}\n  }\n  const spzBytes = await spz.finalize();\n  return { fileBytes: \
spzBytes, clippedCount: spz.clippedCount };\n}\nclass SplatSkinning {\n  \
constructor(options) {\n    this.mesh = options.mesh;\n    this.numSplats = \
options.numSplats ?? this.mesh.numSplats;\n    const { width, height, depth, \
maxSplats } = getTextureSize(this.numSplats);\n    this.skinData = new \
Uint16Array(maxSplats * 4);\n    this.skinTexture = new \
THREE.DataArrayTexture(\n      this.skinData,\n      width,\n      height,\n  \
    depth\n    );\n    this.skinTexture.format = THREE.RGBAIntegerFormat;\n   \
 this.skinTexture.type = THREE.UnsignedShortType;\n    \
this.skinTexture.internalFormat = \"RGBA16UI\";\n    \
this.skinTexture.needsUpdate = true;\n    this.numBones = options.numBones ?? \
256;\n    this.boneData = new Float32Array(this.numBones * 16);\n    \
this.boneTexture = new THREE.DataTexture(\n      this.boneData,\n      4,\n   \
   this.numBones,\n      THREE.RGBAFormat,\n      THREE.FloatType\n    );\n   \
 this.boneTexture.internalFormat = \"RGBA32F\";\n    \
this.boneTexture.needsUpdate = true;\n    this.uniform = new DynoUniform({\n  \
    key: \"skinning\",\n      type: GsplatSkinning,\n      globals: () => \
[defineGsplatSkinning],\n      value: {\n        numSplats: this.numSplats,\n \
       numBones: this.numBones,\n        skinTexture: this.skinTexture,\n     \
   boneTexture: this.boneTexture\n      }\n    });\n  }\n  // Apply the \
skeletal animation to a Gsplat in a dyno program.\n  modify(gsplat) {\n    \
return applyGsplatSkinning(gsplat, this.uniform);\n  }\n  // Set the \"rest\" \
pose for a bone with position and quaternion orientation.\n  \
setRestQuatPos(boneIndex, quat, pos) {\n    const i16 = boneIndex * 16;\n    \
this.boneData[i16 + 0] = quat.x;\n    this.boneData[i16 + 1] = quat.y;\n    \
this.boneData[i16 + 2] = quat.z;\n    this.boneData[i16 + 3] = quat.w;\n    \
this.boneData[i16 + 4] = pos.x;\n    this.boneData[i16 + 5] = pos.y;\n    \
this.boneData[i16 + 6] = pos.z;\n    this.boneData[i16 + 7] = 0;\n    \
this.boneData[i16 + 8] = 0;\n    this.boneData[i16 + 9] = 0;\n    \
this.boneData[i16 + 10] = 0;\n    this.boneData[i16 + 11] = 1;\n    \
this.boneData[i16 + 12] = 0;\n    this.boneData[i16 + 13] = 0;\n    \
this.boneData[i16 + 14] = 0;\n    this.boneData[i16 + 15] = 0;\n  }\n  // Set \
the \"current\" position and orientation of a bone.\n  \
setBoneQuatPos(boneIndex, quat, pos) {\n    const i16 = boneIndex * 16;\n    \
const origQuat = new THREE.Quaternion(\n      this.boneData[i16 + 0],\n      \
this.boneData[i16 + 1],\n      this.boneData[i16 + 2],\n      \
this.boneData[i16 + 3]\n    );\n    const origPos = new THREE.Vector3(\n      \
this.boneData[i16 + 4],\n      this.boneData[i16 + 5],\n      \
this.boneData[i16 + 6]\n    );\n    const relQuat = \
origQuat.clone().invert();\n    const relPos = pos.clone().sub(origPos);\n    \
relPos.applyQuaternion(relQuat);\n    relQuat.multiply(quat);\n    const dual \
= new THREE.Quaternion(\n      relPos.x,\n      relPos.y,\n      relPos.z,\n  \
    0\n    ).multiply(origQuat);\n    this.boneData[i16 + 8] = relQuat.x;\n   \
 this.boneData[i16 + 9] = relQuat.y;\n    this.boneData[i16 + 10] = \
relQuat.z;\n    this.boneData[i16 + 11] = relQuat.w;\n    this.boneData[i16 + \
12] = 0.5 * dual.x;\n    this.boneData[i16 + 13] = 0.5 * dual.y;\n    \
this.boneData[i16 + 14] = 0.5 * dual.z;\n    this.boneData[i16 + 15] = 0.5 * \
dual.w;\n  }\n  // Set up to 4 bone indices and weights for a Gsplat. For \
fewer than 4 bones,\n  // you can set the remaining weights to 0 (and \
index=0).\n  setSplatBones(splatIndex, boneIndices, weights) {\n    const i4 \
= splatIndex * 4;\n    this.skinData[i4 + 0] = Math.min(255, Math.max(0, \
Math.round(weights.x * 255))) + (boneIndices.x << 8);\n    this.skinData[i4 + \
1] = Math.min(255, Math.max(0, Math.round(weights.y * 255))) + (boneIndices.y \
<< 8);\n    this.skinData[i4 + 2] = Math.min(255, Math.max(0, \
Math.round(weights.z * 255))) + (boneIndices.z << 8);\n    this.skinData[i4 + \
3] = Math.min(255, Math.max(0, Math.round(weights.w * 255))) + (boneIndices.w \
<< 8);\n  }\n  // Call this to indicate that the bones have changed and the \
Gsplats need to be\n  // re-generated with updated skinning.\n  updateBones() \
{\n    this.boneTexture.needsUpdate = true;\n    this.mesh.needsUpdate = \
true;\n  }\n}\nconst GsplatSkinning = { type: \"GsplatSkinning\" };\nconst \
defineGsplatSkinning = unindent(`\n  struct GsplatSkinning {\n    int \
numSplats;\n    int numBones;\n    usampler2DArray skinTexture;\n    \
sampler2D boneTexture;\n  };\n`);\nconst defineApplyGsplatSkinning = \
unindent(`\n  void applyGsplatSkinning(\n    int numSplats, int numBones,\n   \
 usampler2DArray skinTexture, sampler2D boneTexture,\n    int splatIndex, \
inout vec3 center, inout vec4 quaternion\n  ) {\n    if ((splatIndex < 0) || \
(splatIndex >= numSplats)) {\n      return;\n    }\n\n    uvec4 skinData = \
texelFetch(skinTexture, splatTexCoord(splatIndex), 0);\n\n    float \
weights[4];\n    weights[0] = float(skinData.x & 0xffu) / 255.0;\n    \
weights[1] = float(skinData.y & 0xffu) / 255.0;\n    weights[2] = \
float(skinData.z & 0xffu) / 255.0;\n    weights[3] = float(skinData.w & \
0xffu) / 255.0;\n\n    uint boneIndices[4];\n    boneIndices[0] = (skinData.x \
>> 8u) & 0xffu;\n    boneIndices[1] = (skinData.y >> 8u) & 0xffu;\n    \
boneIndices[2] = (skinData.z >> 8u) & 0xffu;\n    boneIndices[3] = \
(skinData.w >> 8u) & 0xffu;\n\n    vec4 quat = vec4(0.0);\n    vec4 dual = \
vec4(0.0);\n    for (int i = 0; i < 4; i++) {\n      if (weights[i] > 0.0) \
{\n        int boneIndex = int(boneIndices[i]);\n        vec4 boneQuat = \
vec4(0.0, 0.0, 0.0, 1.0);\n        vec4 boneDual = vec4(0.0);\n        if \
(boneIndex < numBones) {\n          boneQuat = texelFetch(boneTexture, \
ivec2(2, boneIndex), 0);\n          boneDual = texelFetch(boneTexture, \
ivec2(3, boneIndex), 0);\n        }\n\n        if ((i > 0) && (dot(quat, \
boneQuat) < 0.0)) {\n          // Flip sign if next blend is pointing in the \
opposite direction\n          boneQuat = -boneQuat;\n          boneDual = \
-boneDual;\n        }\n        quat += weights[i] * boneQuat;\n        dual \
+= weights[i] * boneDual;\n      }\n    }\n\n    // Normalize dual \
quaternion\n    float norm = length(quat);\n    quat /= norm;\n    dual /= \
norm;\n    vec3 translate = vec3(\n      2.0 * (-dual.w * quat.x + dual.x * \
quat.w - dual.y * quat.z + dual.z * quat.y),\n      2.0 * (-dual.w * quat.y + \
dual.x * quat.z + dual.y * quat.w - dual.z * quat.x),\n      2.0 * (-dual.w * \
quat.z - dual.x * quat.y + dual.y * quat.x + dual.z * quat.w)\n    );\n\n    \
center = quatVec(quat, center) + translate;\n    quaternion = quatQuat(quat, \
quaternion);\n  }\n`);\nfunction applyGsplatSkinning(gsplat, skinning) {\n  \
const dyno2 = new Dyno({\n    inTypes: { gsplat: Gsplat, skinning: \
GsplatSkinning },\n    outTypes: { gsplat: Gsplat },\n    globals: () => \
[defineGsplatSkinning, defineApplyGsplatSkinning],\n    inputs: { gsplat, \
skinning },\n    statements: ({ inputs, outputs }) => {\n      const { \
skinning: skinning2 } = inputs;\n      const { gsplat: gsplat2 } = outputs;\n \
     return unindentLines(`\n        ${gsplat2} = ${inputs.gsplat};\n        \
if (isGsplatActive(${gsplat2}.flags)) {\n          applyGsplatSkinning(\n     \
       ${skinning2}.numSplats, ${skinning2}.numBones,\n            \
${skinning2}.skinTexture, ${skinning2}.boneTexture,\n            \
${gsplat2}.index, ${gsplat2}.center, ${gsplat2}.quaternion\n          );\n    \
    }\n      `);\n    }\n  });\n  return dyno2.outputs.gsplat;\n}\nfunction \
constructGrid({\n  // PackedSplats object to add splats to\n  splats,\n  // \
min and max box extents of the grid\n  extents,\n  // step size along each \
grid axis\n  stepSize = 1,\n  // spherical radius of each Gsplat\n  \
pointRadius = 0.01,\n  // relative size of the \"shadow copy\" of each Gsplat \
placed behind it\n  pointShadowScale = 2,\n  // Gsplat opacity\n  opacity = \
1,\n  // Gsplat color (THREE.Color) or function to set color for position:\n  \
// ((THREE.Color, THREE.Vector3) => void) (default: RGB-modulated grid)\n  \
color\n}) {\n  const EPSILON = 1e-6;\n  const center = new THREE.Vector3();\n \
 const scales = new THREE.Vector3();\n  const quaternion = new \
THREE.Quaternion(0, 0, 0, 1);\n  if (color == null) {\n    color = (color2, \
point) => color2.set(\n      0.55 + 0.45 * Math.cos(point.x * 1),\n      0.55 \
+ 0.45 * Math.cos(point.y * 1),\n      0.55 + 0.45 * Math.cos(point.z * 1)\n  \
  );\n  }\n  const pointColor = new THREE.Color();\n  for (let z = \
extents.min.z; z < extents.max.z + EPSILON; z += stepSize) {\n    for (let y \
= extents.min.y; y < extents.max.y + EPSILON; y += stepSize) {\n      for \
(let x = extents.min.x; x < extents.max.x + EPSILON; x += stepSize) {\n       \
 center.set(x, y, z);\n        for (let layer = 0; layer < 2; ++layer) {\n    \
      scales.setScalar(pointRadius * (layer ? 1 : pointShadowScale));\n       \
   if (!layer) {\n            pointColor.setScalar(0);\n          } else if \
(typeof color === \"function\") {\n            color(pointColor, center);\n   \
       } else {\n            pointColor.copy(color);\n          }\n          \
splats.pushSplat(center, scales, quaternion, opacity, pointColor);\n        \
}\n      }\n    }\n  }\n}\nfunction constructAxes({\n  // PackedSplats object \
to add splats to\n  splats,\n  // scale (Gsplat scale along axis)\n  scale = \
0.25,\n  // radius of the axes (Gsplat scale orthogonal to axis)\n  \
axisRadius = 75e-4,\n  // relative size of the \"shadow copy\" of each Gsplat \
placed behind it\n  axisShadowScale = 2,\n  // origins of the axes (default \
single axis at origin)\n  origins = [new THREE.Vector3()]\n}) {\n  const \
center = new THREE.Vector3();\n  const scales = new THREE.Vector3();\n  const \
quaternion = new THREE.Quaternion(0, 0, 0, 1);\n  const color = new \
THREE.Color();\n  const opacity = 1;\n  for (const origin of origins) {\n    \
for (let axis = 0; axis < 3; ++axis) {\n      center.set(\n        origin.x + \
(axis === 0 ? scale : 0),\n        origin.y + (axis === 1 ? scale : 0),\n     \
   origin.z + (axis === 2 ? scale : 0)\n      );\n      for (let layer = 0; \
layer < 2; ++layer) {\n        scales.set(\n          (axis === 0 ? scale : \
axisRadius) * (layer ? 1 : axisShadowScale),\n          (axis === 1 ? scale : \
axisRadius) * (layer ? 1 : axisShadowScale),\n          (axis === 2 ? scale : \
axisRadius) * (layer ? 1 : axisShadowScale)\n        );\n        \
color.setRGB(\n          layer === 0 ? 0 : axis === 0 ? 1 : 0,\n          \
layer === 0 ? 0 : axis === 1 ? 1 : 0,\n          layer === 0 ? 0 : axis === 2 \
? 1 : 0\n        );\n        splats.pushSplat(center, scales, quaternion, \
opacity, color);\n      }\n    }\n  }\n}\nfunction constructSpherePoints({\n  \
// PackedSplats object to add splats to\n  splats,\n  // center of the sphere \
(default: origin)\n  origin = new THREE.Vector3(),\n  // radius of the \
sphere\n  radius = 1,\n  // maximum depth of recursion for subdividing the \
sphere\n  // Warning: Gsplat count grows exponentially with depth\n  maxDepth \
= 3,\n  // filter function to apply to each point, for example to select\n  \
// points in a certain direction or other function ((THREE.Vector3) => \
boolean)\n  // (default: null)\n  filter = null,\n  // radius of each \
oriented Gsplat\n  pointRadius = 0.02,\n  // flatness of each oriented \
Gsplat\n  pointThickness = 1e-3,\n  // color of each Gsplat (THREE.Color) or \
function to set color for point:\n  // ((THREE.Color, THREE.Vector3) => void) \
(default: white)\n  color = new THREE.Color(1, 1, 1)\n}) {\n  const \
pointsHash = {};\n  function addPoint(p) {\n    if (filter && !filter(p)) {\n \
     return;\n    }\n    const key = `${p.x},${p.y},${p.z}`;\n    if \
(!pointsHash[key]) {\n      pointsHash[key] = p;\n    }\n  }\n  function \
recurse(depth, p0, p1, p2) {\n    addPoint(p0);\n    addPoint(p1);\n    \
addPoint(p2);\n    if (depth >= maxDepth) {\n      return;\n    }\n    const \
p01 = new THREE.Vector3().addVectors(p0, p1).normalize();\n    const p12 = \
new THREE.Vector3().addVectors(p1, p2).normalize();\n    const p20 = new \
THREE.Vector3().addVectors(p2, p0).normalize();\n    recurse(depth + 1, p0, \
p01, p20);\n    recurse(depth + 1, p01, p1, p12);\n    recurse(depth + 1, \
p20, p12, p2);\n    recurse(depth + 1, p01, p12, p20);\n  }\n  for (const x \
of [-1, 1]) {\n    for (const y of [-1, 1]) {\n      for (const z of [-1, 1]) \
{\n        const p0 = new THREE.Vector3(x, 0, 0);\n        const p1 = new \
THREE.Vector3(0, y, 0);\n        const p2 = new THREE.Vector3(0, 0, z);\n     \
   recurse(0, p0, p1, p2);\n      }\n    }\n  }\n  const points = \
Object.values(pointsHash);\n  const scales = new THREE.Vector3(pointRadius, \
pointRadius, pointThickness);\n  const quaternion = new THREE.Quaternion();\n \
 const pointColor = typeof color === \"function\" ? new THREE.Color() : \
color;\n  for (const point of points) {\n    \
quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, -1), point);\n    if \
(typeof color === \"function\") {\n      color(pointColor, point);\n    }\n   \
 point.multiplyScalar(radius);\n    point.add(origin);\n    \
splats.pushSplat(point, scales, quaternion, 1, pointColor);\n  }\n}\nfunction \
textSplats({\n  // text string to display\n  text,\n  // browser font to \
render text with (default: \"Arial\")\n  font,\n  // font size in \
pixels/Gsplats (default: 32)\n  fontSize,\n  // SplatMesh.recolor tint \
assuming white Gsplats (default: white)\n  color,\n  // Individual Gsplat \
color (default: white)\n  rgb,\n  // Gsplat radius (default: 0.8 covers \
1-unit spacing well)\n  dotRadius,\n  // text alignment: \"left\", \
\"center\", \"right\", \"start\", \"end\" (default: \"start\")\n  \
textAlign,\n  // line spacing multiplier, lines delimited by \"\\n\" \
(default: 1.0)\n  lineHeight,\n  // Coordinate scale in object-space \
(default: 1.0)\n  objectScale\n}) {\n  font = font ?? \"Arial\";\n  fontSize \
= fontSize ?? 32;\n  color = color ?? new THREE.Color(1, 1, 1);\n  dotRadius \
= dotRadius ?? 0.8;\n  textAlign = textAlign ?? \"start\";\n  lineHeight = \
lineHeight ?? 1;\n  objectScale = objectScale ?? 1;\n  const lines = \
text.split(\"\\n\");\n  const canvas = document.createElement(\"canvas\");\n  \
const ctx = canvas.getContext(\"2d\");\n  if (!ctx) {\n    throw new \
Error(\"Failed to create canvas context\");\n  }\n  ctx.font = `${fontSize}px \
${font}`;\n  ctx.textAlign = textAlign;\n  const metrics = \
ctx.measureText(\"\");\n  const fontHeight = metrics.fontBoundingBoxAscent + \
metrics.fontBoundingBoxDescent;\n  let minLeft = Number.POSITIVE_INFINITY;\n  \
let maxRight = Number.NEGATIVE_INFINITY;\n  let minTop = \
Number.POSITIVE_INFINITY;\n  let maxBottom = Number.NEGATIVE_INFINITY;\n  for \
(let line = 0; line < lines.length; ++line) {\n    const metrics2 = \
ctx.measureText(lines[line]);\n    const y = fontHeight * lineHeight * \
line;\n    minLeft = Math.min(minLeft, -metrics2.actualBoundingBoxLeft);\n    \
maxRight = Math.max(maxRight, metrics2.actualBoundingBoxRight);\n    minTop = \
Math.min(minTop, y - metrics2.actualBoundingBoxAscent);\n    maxBottom = \
Math.max(maxBottom, y + metrics2.actualBoundingBoxDescent);\n  }\n  const \
originLeft = Math.floor(minLeft);\n  const originTop = Math.floor(minTop);\n  \
const width = Math.ceil(maxRight) - originLeft;\n  const height = \
Math.ceil(maxBottom) - originTop;\n  canvas.width = width;\n  canvas.height = \
height;\n  ctx.font = `${fontSize}px ${font}`;\n  ctx.textAlign = \
textAlign;\n  ctx.textBaseline = \"alphabetic\";\n  ctx.fillStyle = \
\"#FFFFFF\";\n  for (let i = 0; i < lines.length; ++i) {\n    const y = \
fontHeight * lineHeight * i - originTop;\n    ctx.fillText(lines[i], \
-originLeft, y);\n  }\n  const imageData = ctx.getImageData(0, 0, width, \
height);\n  const rgba = new Uint8Array(imageData.data.buffer);\n  const \
splats = new PackedSplats();\n  const center = new THREE.Vector3();\n  const \
scales = new THREE.Vector3().setScalar(dotRadius * objectScale);\n  const \
quaternion = new THREE.Quaternion(0, 0, 0, 1);\n  rgb = rgb ?? new \
THREE.Color(1, 1, 1);\n  let offset = 0;\n  for (let y = 0; y < height; ++y) \
{\n    for (let x = 0; x < width; ++x) {\n      const a = rgba[offset + 3];\n \
     if (a > 0) {\n        const opacity = a / 255;\n        center.set(x - \
0.5 * (width - 1), 0.5 * (height - 1) - y, 0);\n        \
center.multiplyScalar(objectScale);\n        splats.pushSplat(center, scales, \
quaternion, opacity, rgb);\n      }\n      offset += 4;\n    }\n  }\n  const \
mesh = new SplatMesh({ packedSplats: splats });\n  mesh.recolor = color;\n  \
return mesh;\n}\nfunction imageSplats({\n  // URL of the image to convert to \
splats (example: `url: \"./image.png\"`)\n  url,\n  // Radius of each Gsplat, \
default covers 1-unit spacing well (default: 0.8)\n  dotRadius,\n  // \
Subsampling factor for the image. Higher values reduce resolution,\n  // for \
example 2 will halve the width and height by averaging (default: 1)\n  \
subXY,\n  // Optional callback function to modify each Gsplat before it's \
added.\n  // Return null to skip adding the Gsplat, or a number to set the \
opacity\n  // and add the Gsplat with parameter values in the objects center, \
rgba etc. were\n  // passed into the forEachSplat callback. Ending the \
callback in `return opacity;`\n  // will retain the original opacity.\n  // \
((width: number, height: number, index: number, center: THREE.Vector3, \
scales: THREE.Vector3, quaternion: THREE.Quaternion, opacity: number, color: \
THREE.Color) => number | null)\n  forEachSplat\n}) {\n  dotRadius = dotRadius \
?? 0.8;\n  subXY = Math.max(1, Math.floor(subXY ?? 1));\n  return new \
SplatMesh({\n    constructSplats: async (splats) => {\n      return new \
Promise((resolve, reject) => {\n        const img = new Image();\n        \
img.crossOrigin = \"anonymous\";\n        img.onerror = reject;\n        \
img.onload = () => {\n          const { width, height } = img;\n          \
const canvas = document.createElement(\"canvas\");\n          canvas.width = \
width;\n          canvas.height = height;\n          const ctx = \
canvas.getContext(\"2d\");\n          if (!ctx) {\n            reject(new \
Error(\"Failed to create canvas context\"));\n            return;\n          \
}\n          ctx.imageSmoothingEnabled = true;\n          \
ctx.imageSmoothingQuality = \"high\";\n          const destWidth = \
Math.round(width / subXY);\n          const destHeight = Math.round(height / \
subXY);\n          ctx.drawImage(img, 0, 0, destWidth, destHeight);\n         \
 try {\n            const imageData = ctx.getImageData(0, 0, destWidth, \
destHeight);\n            const rgba = new \
Uint8Array(imageData.data.buffer);\n            const center = new \
THREE.Vector3();\n            const scales = new \
THREE.Vector3().setScalar(dotRadius);\n            const quaternion = new \
THREE.Quaternion(0, 0, 0, 1);\n            const rgb = new THREE.Color();\n   \
         let index = 0;\n            for (let y = 0; y < destHeight; ++y) {\n \
             for (let x = 0; x < destWidth; ++x) {\n                const \
offset = index * 4;\n                const a = rgba[offset + 3];\n            \
    if (a > 0) {\n                  let opacity = a / 255;\n                  \
rgb.set(\n                    rgba[offset + 0] / 255,\n                    \
rgba[offset + 1] / 255,\n                    rgba[offset + 2] / 255\n         \
         );\n                  center.set(\n                    x - 0.5 * \
(destWidth - 1),\n                    0.5 * (destHeight - 1) - y,\n           \
         0\n                  );\n                  \
scales.setScalar(dotRadius);\n                  quaternion.set(0, 0, 0, 1);\n \
                 let push = true;\n                  if (forEachSplat) {\n    \
                const maybeOpacity = forEachSplat(\n                      \
destWidth,\n                      destHeight,\n                      index,\n \
                     center,\n                      scales,\n                 \
     quaternion,\n                      opacity,\n                      rgb\n \
                   );\n                    opacity = maybeOpacity ?? \
opacity;\n                    push = maybeOpacity !== null;\n                 \
 }\n                  if (push) {\n                    \
splats.pushSplat(center, scales, quaternion, opacity, rgb);\n                 \
 }\n                }\n                index += 1;\n              }\n         \
   }\n            resolve();\n          } catch (error) {\n            \
reject(error);\n          }\n        };\n        img.src = url;\n      });\n  \
  }\n  });\n}\nfunction staticBox({\n  box,\n  cells,\n  dotScale,\n  \
color,\n  opacity\n}) {\n  cells.x = Math.max(1, Math.round(cells.x));\n  \
cells.y = Math.max(1, Math.round(cells.y));\n  cells.z = Math.max(1, \
Math.round(cells.z));\n  opacity = opacity ?? 1;\n  const numSplats = cells.x \
* cells.y * cells.z;\n  const dynoX = dynoConst(\"int\", cells.x);\n  const \
dynoY = dynoConst(\"int\", cells.y);\n  dynoConst(\"int\", cells.z);\n  const \
dynoTime = dynoFloat(0);\n  const generator = new SplatGenerator({\n    \
numSplats,\n    generator: dynoBlock(\n      { index: \"int\" },\n      { \
gsplat: Gsplat },\n      ({ index }) => {\n        if (!index) {\n          \
throw new Error(\"index is undefined\");\n        }\n        const cellX = \
imod(index, dynoX);\n        const index2 = div(index, dynoX);\n        const \
cellY = imod(index2, dynoY);\n        const cellZ = div(index2, dynoY);\n     \
   const cell = combine({\n          vectorType: \"ivec3\",\n          x: \
cellX,\n          y: cellY,\n          z: cellZ\n        });\n        const \
intTime = floatBitsToInt(dynoTime);\n        const inputs = combine({ \
vectorType: \"ivec2\", x: index, y: intTime });\n        const random = \
hashVec3(inputs);\n        const min2 = dynoConst(\"vec3\", box.min);\n       \
 const max2 = dynoConst(\"vec3\", box.max);\n        const size = sub(max2, \
min2);\n        const coord = div(add(vec3(cell), random), \
dynoConst(\"vec3\", cells));\n        let r;\n        let g;\n        let \
b;\n        if (color) {\n          r = dynoConst(\"float\", color.r);\n      \
    g = dynoConst(\"float\", color.g);\n          b = dynoConst(\"float\", \
color.b);\n        } else {\n          ({ r, g, b } = \
split(coord).outputs);\n        }\n        const rgba = combine({\n          \
vectorType: \"vec4\",\n          r,\n          g,\n          b,\n          a: \
dynoConst(\"float\", opacity)\n        });\n        const center = add(min2, \
mul(size, coord));\n        const scales = vec3(dynoConst(\"float\", \
dotScale));\n        const quaternion = dynoConst(\"vec4\", new \
THREE.Quaternion(0, 0, 0, 1));\n        let gsplat = combineGsplat({\n        \
  flags: dynoLiteral(\"uint\", \"GSPLAT_FLAG_ACTIVE\"),\n          index,\n   \
       center,\n          scales,\n          quaternion,\n          rgba\n    \
    });\n        gsplat = transformer.applyGsplat(gsplat);\n        return { \
gsplat };\n      },\n      {\n        globals: () => [defineGsplat]\n      \
}\n    ),\n    update: ({ time }) => {\n      dynoTime.value = time;\n      \
transformer.update(generator);\n      generator.updateVersion();\n    }\n  \
});\n  const transformer = new SplatTransformer();\n  return \
generator;\n}\nconst DEFAULT_SNOW = {\n  box: new THREE.Box3(\n    new \
THREE.Vector3(-1, -1, -1),\n    new THREE.Vector3(1, 1, 1)\n  ),\n  density: \
100,\n  fallDirection: new THREE.Vector3(-1, -3, 1).normalize(),\n  \
fallVelocity: 0.02,\n  wanderScale: 0.04,\n  wanderVariance: 2,\n  color1: \
new THREE.Color(1, 1, 1),\n  color2: new THREE.Color(0.5, 0.5, 1),\n  \
minScale: 1e-3,\n  maxScale: 5e-3,\n  anisoScale: new THREE.Vector3(1, 1, \
1)\n};\nconst DEFAULT_RAIN = {\n  box: new THREE.Box3(\n    new \
THREE.Vector3(-2, -1, -2),\n    new THREE.Vector3(2, 5, 2)\n  ),\n  density: \
10,\n  fallDirection: new THREE.Vector3(0, -1, 0),\n  fallVelocity: 2,\n  \
wanderScale: 0.1,\n  wanderVariance: 1,\n  color1: new THREE.Color(1, 1, \
1),\n  color2: new THREE.Color(0.25, 0.25, 0.5),\n  minScale: 5e-3,\n  \
maxScale: 0.01,\n  anisoScale: new THREE.Vector3(0.1, 1, 0.1)\n};\nfunction \
snowBox({\n  // min and max box extents of the snowBox\n  box,\n  // minimum \
y-coordinate to clamp particle position, which can be used to\n  // fake \
hitting a ground plane and lingering there for a bit\n  minY,\n  // number of \
Gsplats to generate (default: calculated from box and density)\n  \
numSplats,\n  // density of Gsplats per unit volume (default: 100)\n  \
density,\n  // The xyz anisotropic scale of the Gsplat, which can be used for \
example\n  // to elongate rain particles (default: (1, 1, 1))\n  \
anisoScale,\n  // Minimum Gsplat particle scale (default: 0.001)\n  \
minScale,\n  // Maximum Gsplat particle scale (default: 0.005)\n  maxScale,\n \
 // The average direction of fall (default: (0, -1, 0))\n  fallDirection,\n  \
// The average speed of the fall (multiplied with fallDirection) (default: \
0.02)\n  fallVelocity,\n  // The world scale of wandering overlay motion \
(default: 0.01)\n  wanderScale,\n  // Controls how uniformly the particles \
wander in sync, more variance mean\n  // more randomness in the motion \
(default: 2)\n  wanderVariance,\n  // Color 1 of the two colors interpolated \
between (default: (1, 1, 1))\n  color1,\n  // Color 2 of the two colors \
interpolated between (default: (0.5, 0.5, 1))\n  color2,\n  // The base \
opacity of the Gsplats (default: 1)\n  opacity,\n  // Optional callback \
function to call each frame.\n  onFrame\n}) {\n  box = box ?? new \
THREE.Box3(new THREE.Vector3(-1, -1, -1), new THREE.Vector3(1, 1, 1));\n  \
const volume = (box.max.x - box.min.x) * (box.max.y - box.min.y) * (box.max.z \
- box.min.z);\n  density = density ?? 100;\n  numSplats = numSplats ?? \
Math.max(1, Math.min(1e6, Math.round(volume * density)));\n  const \
dynoMinScale = dynoFloat(minScale ?? 1e-3);\n  const dynoMaxScale = \
dynoFloat(maxScale ?? 5e-3);\n  const dynoAnisoScale = dynoVec3(\n    \
((anisoScale == null ? void 0 : anisoScale.clone()) ?? new THREE.Vector3(1, \
1, 1)).normalize()\n  );\n  const dynoFallDirection = dynoVec3(\n    \
(fallDirection ?? new THREE.Vector3(0, -1, 0)).normalize()\n  );\n  const \
dynoFallVelocity = dynoFloat(fallVelocity ?? 0.02);\n  const dynoWanderScale \
= dynoFloat(wanderScale ?? 0.01);\n  const dynoWanderVariance = \
dynoFloat(wanderVariance ?? 2);\n  const dynoColor1 = dynoVec3(color1 ?? new \
THREE.Color(1, 1, 1));\n  const dynoColor2 = dynoVec3(color2 ?? new \
THREE.Color(0.5, 0.5, 1));\n  const dynoOpacity = dynoFloat(opacity ?? 1);\n  \
const dynoTime = dynoFloat(0);\n  const globalOffset = dynoVec3(new \
THREE.Vector3(0, 0, 0));\n  const dynoMin = dynoVec3(box.min);\n  const \
dynoMax = dynoVec3(box.max);\n  const dynoMinY = dynoFloat(minY ?? \
Number.NEGATIVE_INFINITY);\n  const minMax = sub(dynoMax, dynoMin);\n  const \
snow = new SplatGenerator({\n    numSplats,\n    generator: dynoBlock(\n      \
{ index: \"int\" },\n      { gsplat: Gsplat },\n      ({ index }) => {\n      \
  if (!index) {\n          throw new Error(\"index not defined\");\n        \
}\n        const random = hashVec4(index);\n        const randomW = \
split(random).outputs.w;\n        let position = vec3(random);\n        let \
size = fract(mul(randomW, dynoConst(\"float\", 100)));\n        size = \
sin(mul(dynoLiteral(\"float\", \"PI\"), size));\n        size = \
add(dynoMinScale, mul(size, sub(dynoMaxScale, dynoMinScale)));\n        const \
scales = mul(size, dynoAnisoScale);\n        const intensity = \
fract(mul(randomW, dynoConst(\"float\", 10)));\n        const hue = \
fract(randomW);\n        const color = mix(dynoColor1, dynoColor2, hue);\n    \
    const rgb = mul(color, intensity);\n        const random2 = hashVec4(\n   \
       combine({\n            vectorType: \"ivec2\",\n            x: index,\n \
           y: dynoConst(\"int\", 6837)\n          })\n        );\n        let \
perturb = vec3(random2);\n        let timeOffset = \
mul(split(random2).outputs.w, dynoWanderVariance);\n        timeOffset = \
add(dynoTime, timeOffset);\n        position = add(position, globalOffset);\n \
       const modulo = mod(\n          position,\n          \
dynoConst(\"vec3\", new THREE.Vector3(1, 1, 1))\n        );\n        position \
= add(dynoMin, mul(minMax, modulo));\n        const quaternion = \
dynoConst(\"vec4\", new THREE.Quaternion(0, 0, 0, 1));\n        perturb = \
sin(add(vec3(timeOffset), perturb));\n        perturb = mul(perturb, \
dynoWanderScale);\n        let center = add(position, perturb);\n        let \
centerY = split(center).outputs.y;\n        centerY = max(dynoMinY, \
centerY);\n        center = combine({ vector: center, y: centerY });\n        \
let gsplat = combineGsplat({\n          flags: dynoLiteral(\"uint\", \
\"GSPLAT_FLAG_ACTIVE\"),\n          index,\n          center,\n          \
scales,\n          quaternion,\n          rgb,\n          opacity: \
dynoOpacity\n        });\n        gsplat = transformer.applyGsplat(gsplat);\n \
       return { gsplat };\n      },\n      {\n        globals: () => \
[defineGsplat]\n      }\n    ),\n    update: ({ object, time, deltaTime }) => \
{\n      dynoTime.value = time;\n      transformer.update(snow);\n      const \
fallDelta = \
dynoFallDirection.value.clone().multiplyScalar(dynoFallVelocity.value * \
deltaTime);\n      globalOffset.value.add(fallDelta);\n      object.visible = \
dynoOpacity.value > 0;\n      onFrame == null ? void 0 : onFrame({ object, \
time, deltaTime });\n      snow.updateVersion();\n    }\n  });\n  const \
transformer = new SplatTransformer();\n  return {\n    snow,\n    min: \
dynoMin,\n    max: dynoMax,\n    minY: dynoMinY,\n    color1: dynoColor1,\n   \
 color2: dynoColor2,\n    opacity: dynoOpacity,\n    fallVelocity: \
dynoFallVelocity,\n    wanderVariance: dynoWanderVariance,\n    wanderScale: \
dynoWanderScale,\n    fallDirection: dynoFallDirection,\n    minScale: \
dynoMinScale,\n    maxScale: dynoMaxScale,\n    anisoScale: dynoAnisoScale\n  \
};\n}\nconst generators = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ \
Object.defineProperty({\n  __proto__: null,\n  DEFAULT_RAIN,\n  \
DEFAULT_SNOW,\n  snowBox,\n  staticBox\n}, Symbol.toStringTag, { value: \
\"Module\" }));\nfunction makeNormalColorModifier(splatToView) {\n  return \
dynoBlock({ gsplat: Gsplat }, { gsplat: Gsplat }, ({ gsplat }) => {\n    if \
(!gsplat) {\n      throw new Error(\"No gsplat input\");\n    }\n    let \
normal = gsplatNormal(gsplat);\n    const viewGsplat = \
splatToView.applyGsplat(gsplat);\n    const viewCenter = \
splitGsplat(viewGsplat).outputs.center;\n    const viewNormal = \
gsplatNormal(viewGsplat);\n    const splatDot = dot(viewCenter, \
viewNormal);\n    const sameDir = greaterThanEqual(splatDot, \
dynoConst(\"float\", 0));\n    normal = select(sameDir, neg(normal), \
normal);\n    const rgb = add(\n      mul(normal, dynoConst(\"float\", \
0.5)),\n      dynoConst(\"float\", 0.5)\n    );\n    gsplat = combineGsplat({ \
gsplat, rgb });\n    return { gsplat };\n  });\n}\nfunction \
setWorldNormalColor(splats) {\n  splats.enableWorldToView = true;\n  \
splats.worldModifier = makeNormalColorModifier(splats.context.worldToView);\n \
 splats.updateGenerator();\n}\nfunction makeDepthColorModifier(splatToView, \
minDepth, maxDepth, reverse) {\n  return dynoBlock({ gsplat: Gsplat }, { \
gsplat: Gsplat }, ({ gsplat }) => {\n    if (!gsplat) {\n      throw new \
Error(\"No gsplat input\");\n    }\n    let { center } = \
splitGsplat(gsplat).outputs;\n    center = splatToView.apply(center);\n    \
const { z } = split(center).outputs;\n    let depth = normalizedDepth(neg(z), \
minDepth, maxDepth);\n    depth = select(reverse, sub(dynoConst(\"float\", \
1), depth), depth);\n    gsplat = combineGsplat({ gsplat, r: depth, g: depth, \
b: depth });\n    return { gsplat };\n  });\n}\nfunction \
setDepthColor(splats, minDepth, maxDepth, reverse) {\n  \
splats.enableWorldToView = true;\n  const dynoMinDepth = dynoConst(\"float\", \
minDepth);\n  const dynoMaxDepth = dynoConst(\"float\", maxDepth);\n  const \
dynoReverse = dynoConst(\"bool\", reverse ?? false);\n  splats.worldModifier \
= makeDepthColorModifier(\n    splats.context.worldToView,\n    \
dynoMinDepth,\n    dynoMaxDepth,\n    dynoReverse\n  );\n  \
splats.updateGenerator();\n  return {\n    minDepth: dynoMinDepth,\n    \
maxDepth: dynoMaxDepth,\n    reverse: dynoReverse\n  };\n}\nconst modifiers = \
/* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  \
__proto__: null,\n  makeDepthColorModifier,\n  makeNormalColorModifier,\n  \
setDepthColor,\n  setWorldNormalColor\n}, Symbol.toStringTag, { value: \
\"Module\" }));\nconst _VRButton = class _VRButton {\n  static \
createButton(renderer, sessionInit = {}) {\n    const navigatorXr = \
navigator.xr;\n    if (!navigatorXr) {\n      return null;\n    }\n    const \
xr = navigatorXr;\n    const button = document.createElement(\"button\");\n   \
 renderer.xr.enabled = true;\n    \
renderer.xr.setReferenceSpaceType(\"local\");\n    function showEnterVR() {\n \
     let currentSession = null;\n      async function \
onSessionStarted(session) {\n        console.log(\"onSessionStarted\");\n     \
   session.addEventListener(\"end\", onSessionEnded);\n        await \
renderer.xr.setSession(session);\n        button.textContent = \"EXIT VR\";\n \
       currentSession = session;\n      }\n      function onSessionEnded() \
{\n        console.log(\"onSessionEnded\");\n        currentSession == null ? \
void 0 : currentSession.removeEventListener(\"end\", onSessionEnded);\n       \
 button.textContent = \"ENTER VR\";\n        currentSession = null;\n      \
}\n      button.style.display = \"\";\n      button.style.cursor = \
\"pointer\";\n      button.style.left = \"calc(50% - 100px)\";\n      \
button.style.width = \"200px\";\n      button.style.height = \"100px\";\n     \
 button.textContent = \"ENTER VR\";\n      const sessionOptions = {\n        \
...sessionInit,\n        optionalFeatures: [\n          // \"local-floor\",\n \
         // \"bounded-floor\",\n          // \"layers\",\n          \
...sessionInit.optionalFeatures || []\n        ]\n      };\n      \
button.onmouseenter = () => {\n        button.style.opacity = \"1.0\";\n      \
};\n      button.onmouseleave = () => {\n        button.style.opacity = \
\"0.5\";\n      };\n      button.onclick = () => {\n        if \
(currentSession === null) {\n          console.log(\"requesting session\");\n \
         xr.requestSession(\"immersive-vr\", sessionOptions).then(\n          \
  onSessionStarted\n          );\n        } else {\n          \
console.log(\"ending session\");\n          currentSession.end();\n        \
}\n      };\n    }\n    function disableButton() {\n      \
button.style.display = \"none\";\n      button.style.cursor = \"auto\";\n     \
 button.style.left = \"calc(50% - 75px)\";\n      button.style.width = \
\"150px\";\n      button.onmouseenter = null;\n      button.onmouseleave = \
null;\n      button.onclick = null;\n    }\n    function showWebXRNotFound() \
{\n      disableButton();\n      button.textContent = \"VR NOT SUPPORTED\";\n \
   }\n    function showVRNotAllowed(exception) {\n      disableButton();\n    \
  console.warn(\n        \"Exception when trying to call \
xr.isSessionSupported\",\n        exception\n      );\n      \
button.textContent = \"VR NOT ALLOWED\";\n    }\n    function \
stylizeElement(element) {\n      element.style.position = \"absolute\";\n     \
 element.style.bottom = \"20px\";\n      element.style.padding = \"12px \
6px\";\n      element.style.border = \"1px solid #fff\";\n      \
element.style.borderRadius = \"4px\";\n      element.style.background = \
\"rgba(0,0,0,0.1)\";\n      element.style.color = \"#fff\";\n      \
element.style.font = \"normal 13px sans-serif\";\n      \
element.style.textAlign = \"center\";\n      element.style.opacity = \
\"0.5\";\n      element.style.outline = \"none\";\n      element.style.zIndex \
= \"999\";\n    }\n    button.id = \"VRButton\";\n    button.style.display = \
\"none\";\n    stylizeElement(button);\n    \
xr.isSessionSupported(\"immersive-vr\").then((supported) => {\n      \
supported ? showEnterVR() : showWebXRNotFound();\n      if (supported && \
_VRButton.xrSessionIsGranted) {\n        button.click();\n      }\n    \
}).catch(showVRNotAllowed);\n    return button;\n  }\n  static \
registerSessionGrantedListener() {\n    const navigatorXr = navigator.xr;\n   \
 if (!navigatorXr) {\n      return null;\n    }\n    const xr = \
navigatorXr;\n    if (/WebXRViewer\\//i.test(navigator.userAgent)) return;\n  \
  xr.addEventListener(\"sessiongranted\", () => {\n      \
_VRButton.xrSessionIsGranted = true;\n    });\n  \
}\n};\n_VRButton.xrSessionIsGranted = false;\nlet VRButton = \
_VRButton;\nVRButton.registerSessionGrantedListener();\nconst \
DEFAULT_MOVE_INERTIA$1 = 0.5;\nconst DEFAULT_ROTATE_INERTIA$1 = 0.5;\nconst \
TOUCH_BIAS = 0;\nvar JointEnum = /* @__PURE__ */ ((JointEnum2) => {\n  \
JointEnum2[\"w\"] = \"wrist\";\n  JointEnum2[\"t0\"] = \
\"thumb-metacarpal\";\n  JointEnum2[\"t1\"] = \"thumb-phalanx-proximal\";\n  \
JointEnum2[\"t2\"] = \"thumb-phalanx-distal\";\n  JointEnum2[\"t3\"] = \
\"thumb-tip\";\n  JointEnum2[\"i0\"] = \"index-finger-metacarpal\";\n  \
JointEnum2[\"i1\"] = \"index-finger-phalanx-proximal\";\n  JointEnum2[\"i2\"] \
= \"index-finger-phalanx-intermediate\";\n  JointEnum2[\"i3\"] = \
\"index-finger-phalanx-distal\";\n  JointEnum2[\"i4\"] = \
\"index-finger-tip\";\n  JointEnum2[\"m0\"] = \"middle-finger-metacarpal\";\n \
 JointEnum2[\"m1\"] = \"middle-finger-phalanx-proximal\";\n  \
JointEnum2[\"m2\"] = \"middle-finger-phalanx-intermediate\";\n  \
JointEnum2[\"m3\"] = \"middle-finger-phalanx-distal\";\n  JointEnum2[\"m4\"] \
= \"middle-finger-tip\";\n  JointEnum2[\"r0\"] = \
\"ring-finger-metacarpal\";\n  JointEnum2[\"r1\"] = \
\"ring-finger-phalanx-proximal\";\n  JointEnum2[\"r2\"] = \
\"ring-finger-phalanx-intermediate\";\n  JointEnum2[\"r3\"] = \
\"ring-finger-phalanx-distal\";\n  JointEnum2[\"r4\"] = \
\"ring-finger-tip\";\n  JointEnum2[\"p0\"] = \"pinky-finger-metacarpal\";\n  \
JointEnum2[\"p1\"] = \"pinky-finger-phalanx-proximal\";\n  JointEnum2[\"p2\"] \
= \"pinky-finger-phalanx-intermediate\";\n  JointEnum2[\"p3\"] = \
\"pinky-finger-phalanx-distal\";\n  JointEnum2[\"p4\"] = \
\"pinky-finger-tip\";\n  return JointEnum2;\n})(JointEnum || {});\nconst \
JOINT_IDS = Object.keys(JointEnum);\nconst NUM_JOINTS = \
JOINT_IDS.length;\nconst JOINT_INDEX = {\n  w: 0,\n  t0: 1,\n  t1: 2,\n  t2: \
3,\n  t3: 4,\n  i0: 5,\n  i1: 6,\n  i2: 7,\n  i3: 8,\n  i4: 9,\n  m0: 10,\n  \
m1: 11,\n  m2: 12,\n  m3: 13,\n  m4: 14,\n  r0: 15,\n  r1: 16,\n  r2: 17,\n  \
r3: 18,\n  r4: 19,\n  p0: 20,\n  p1: 21,\n  p2: 22,\n  p3: 23,\n  p4: \
24\n};\nconst JOINT_RADIUS = {\n  w: 0.02,\n  t0: 0.02,\n  t1: 0.014,\n  t2: \
0.0115,\n  t3: 85e-4,\n  i0: 0.022,\n  i1: 0.012,\n  i2: 85e-4,\n  i3: \
75e-4,\n  i4: 65e-4,\n  m0: 0.021,\n  m1: 0.012,\n  m2: 8e-3,\n  m3: 75e-4,\n \
 m4: 65e-4,\n  r0: 0.019,\n  r1: 0.011,\n  r2: 75e-4,\n  r3: 7e-3,\n  r4: \
6e-3,\n  p0: 0.012,\n  p1: 0.01,\n  p2: 7e-3,\n  p3: 65e-4,\n  p4: \
55e-4\n};\nconst JOINT_SEGMENTS = [\n  [\"w\", \"t0\", \"t1\", \"t2\", \
\"t3\"],\n  [\"w\", \"i0\", \"i1\", \"i2\", \"i3\", \"i4\"],\n  [\"w\", \
\"m0\", \"m1\", \"m2\", \"m3\", \"m4\"],\n  [\"w\", \"r0\", \"r1\", \"r2\", \
\"r3\", \"r4\"],\n  [\"w\", \"p0\", \"p1\", \"p2\", \"p3\", \
\"p4\"]\n];\nconst JOINT_SEGMENT_STEPS = [\n  [8, 10, 8, 6],\n  [8, 19, 14, \
8, 6],\n  [8, 19, 14, 8, 6],\n  [8, 19, 14, 8, 6],\n  [8, 19, 14, 8, \
6]\n];\nconst JOINT_TIPS = [\"t3\", \"i4\", \"m4\", \"r4\", \"p4\"];\nconst \
FINGER_TIPS = [\"i4\", \"m4\", \"r4\", \"p4\"];\nvar Hand = /* @__PURE__ */ \
((Hand2) => {\n  Hand2[\"left\"] = \"left\";\n  Hand2[\"right\"] = \
\"right\";\n  return Hand2;\n})(Hand || {});\nconst HANDS = \
Object.keys(Hand);\nclass XrHands {\n  constructor() {\n    this.hands = \
{};\n    this.last = {};\n    this.values = {};\n    this.tests = {};\n    \
this.lastTests = {};\n    this.updated = false;\n  }\n  update({ xr, xrFrame \
}) {\n    const xrSession = xr.getSession();\n    if (!xrSession) {\n      \
return;\n    }\n    const referenceSpace = xr.getReferenceSpace();\n    if \
(!referenceSpace) {\n      return;\n    }\n    if (!xrFrame.getJointPose) {\n \
     return;\n    }\n    this.last = this.hands;\n    this.lastTests = \
this.tests;\n    this.hands = {};\n    this.values = {};\n    this.tests = \
{};\n    for (const inputSource of xrSession.inputSources) {\n      if \
(!inputSource.hand) {\n        continue;\n      }\n      const hand = \
inputSource.handedness;\n      this.hands[hand] = {};\n      for (const \
jointId of JOINT_IDS) {\n        const jointSpace = \
inputSource.hand.get(JointEnum[jointId]);\n        if (jointSpace) {\n        \
  const jointPose = xrFrame.getJointPose(jointSpace, referenceSpace);\n       \
   if (jointPose) {\n            const { position, orientation } = \
jointPose.transform;\n            this.hands[hand][jointId] = {\n             \
 position: new Vector3(position.x, position.y, position.z),\n              \
quaternion: new Quaternion(\n                orientation.x,\n                \
orientation.y,\n                orientation.z,\n                \
orientation.w\n              ),\n              radius: jointPose.radius || \
1e-3\n            };\n          }\n        }\n      }\n    }\n    for (const \
hand of HANDS) {\n      for (const { key, value } of [\n        { key: \
`${hand}AllTips`, value: this.allTipsTouching(hand) },\n        {\n          \
key: `${hand}IndexThumb`,\n          value: this.touching(hand, \"i4\", hand, \
\"t3\")\n        },\n        {\n          key: `${hand}MiddleThumb`,\n        \
  value: this.touching(hand, \"m4\", hand, \"t3\")\n        },\n        {\n   \
       key: `${hand}RingThumb`,\n          value: this.touching(hand, \"r4\", \
hand, \"t3\")\n        },\n        {\n          key: `${hand}PinkyThumb`,\n   \
       value: this.touching(hand, \"p4\", hand, \"t3\")\n        },\n        \
{ key: `${hand}TriTips`, value: this.triTipsTouching(hand) }\n      ]) {\n    \
    this.values[key] = value;\n        this.tests[key] = value === 1 ? true : \
value === 0 ? false : this.lastTests[key] ?? false;\n      }\n    }\n  }\n  \
makeGhostMesh() {\n    const center = new Vector3();\n    const scales = new \
Vector3(0.01, 0.01, 0.01);\n    const quaternion = new Quaternion(0, 0, 0, \
1);\n    const color = new Color(1, 1, 1);\n    const CYCLE = Math.PI * 3;\n  \
  new Color(1, 1, 1);\n    let opacity = 1;\n    const mesh = new \
SplatMesh({\n      onFrame: () => {\n        let splatIndex = 0;\n        for \
(const handedness of HANDS) {\n          const xrHand = \
this.hands[handedness];\n          for (const [index, segment] of \
JOINT_SEGMENTS.entries()) {\n            for (let i = 1; i < segment.length; \
++i) {\n              const segmentSplats = JOINT_SEGMENT_STEPS[index][i - 1] \
* 2;\n              const lastSegment = i + 1 === segment.length;\n           \
   const jointA = xrHand == null ? void 0 : xrHand[segment[i - 1]];\n         \
     const jointB = xrHand == null ? void 0 : xrHand[segment[i]];\n           \
   for (let j = 0; j < segmentSplats; ++j) {\n                const t = (j + \
0.5) / segmentSplats;\n                opacity = 0;\n                if \
(jointA && jointB) {\n                  \
center.copy(jointA.position).lerp(jointB.position, t);\n                  \
quaternion.copy(jointA.quaternion).slerp(jointB.quaternion, t);\n             \
     const radiusA = JOINT_RADIUS[segment[i - 1]];\n                  const \
radiusB = JOINT_RADIUS[segment[i]];\n                  let radius = (1 - t) * \
radiusA + t * radiusB;\n                  if (lastSegment && t > 0.8) {\n     \
               radius *= Math.sqrt(1 - ((t - 0.8) / 0.2) ** 2);\n             \
     }\n                  scales.set(0.65 * radius, 0.5 * radius, 3e-3);\n    \
              color.set(\n                    0.55 + 0.45 * Math.sin(center.x \
* CYCLE),\n                    0.55 + 0.45 * Math.sin(center.y * CYCLE),\n    \
                0.55 + 0.45 * Math.sin(center.z * CYCLE)\n                  \
);\n                  if (handedness === \"right\") {\n                    \
color.set(1 - color.r, 1 - color.g, 1 - color.b);\n                  }\n      \
            opacity = 0.75;\n                }\n                \
mesh.packedSplats.setSplat(\n                  splatIndex,\n                  \
center,\n                  scales,\n                  quaternion,\n           \
       opacity,\n                  color\n                );\n                \
splatIndex += 1;\n              }\n            }\n          }\n        }\n    \
    mesh.packedSplats.numSplats = splatIndex;\n        \
mesh.packedSplats.needsUpdate = true;\n        mesh.numSplats = splatIndex;\n \
       mesh.updateVersion();\n      }\n    });\n    return mesh;\n  }\n  \
distance(handA, jointA, handB, jointB, last = false) {\n    const hA = last ? \
this.last[handA] : this.hands[handA];\n    const hB = last ? this.last[handB] \
: this.hands[handB];\n    const jA = hA == null ? void 0 : hA[jointA];\n    \
const jB = hB == null ? void 0 : hB[jointB];\n    if (!jA || !jB) {\n      \
return Number.POSITIVE_INFINITY;\n    }\n    return \
jA.position.distanceTo(jB.position);\n  }\n  separation(handA, jointA, handB, \
jointB, last = false) {\n    const d = this.distance(handA, jointA, handB, \
jointB, last);\n    if (d === Number.POSITIVE_INFINITY) {\n      return \
Number.POSITIVE_INFINITY;\n    }\n    return d - JOINT_RADIUS[jointA] - \
JOINT_RADIUS[jointB];\n  }\n  touching(handA, jointA, handB, jointB, last = \
false) {\n    const d = this.separation(handA, jointA, handB, jointB, \
last);\n    if (d === Number.POSITIVE_INFINITY) {\n      return \
Number.POSITIVE_INFINITY;\n    }\n    return 1 - Math.max(0, Math.min(1, d / \
0.01 - TOUCH_BIAS));\n  }\n  allTipsTouching(hand, last = false) {\n    \
return Math.min(\n      this.touching(hand, \"t3\", hand, \"i4\", last),\n    \
  this.touching(hand, \"i4\", hand, \"m4\", last),\n      this.touching(hand, \
\"m4\", hand, \"r4\", last),\n      this.touching(hand, \"r4\", hand, \"p4\", \
last)\n      // this.touching(hand, \"p4\", hand, \"t3\", last),\n    );\n  \
}\n  triTipsTouching(hand, last = false) {\n    return Math.min(\n      \
this.touching(hand, \"t3\", hand, \"i4\", last),\n      this.touching(hand, \
\"i4\", hand, \"m4\", last),\n      this.touching(hand, \"m4\", hand, \"t3\", \
last)\n    );\n  }\n}\nclass HandMovement {\n  constructor({\n    xrHands,\n  \
  control,\n    moveInertia,\n    rotateInertia\n  }) {\n    this.lastGrip = \
{};\n    this.lastPivot = new Vector3();\n    this.rotateVelocity = 0;\n    \
this.velocity = new Vector3();\n    this.xrHands = xrHands;\n    this.control \
= control;\n    this.moveInertia = moveInertia ?? DEFAULT_MOVE_INERTIA$1;\n   \
 this.rotateInertia = rotateInertia ?? DEFAULT_ROTATE_INERTIA$1;\n  }\n  \
update(deltaTime) {\n    var _a2, _b2, _c, _d, _e;\n    const grip = {};\n    \
for (const handedness of HANDS) {\n      const hand = \
this.xrHands.hands[handedness];\n      if (hand && \
this.xrHands.tests[`${handedness}MiddleThumb`]) {\n        grip[handedness] = \
new Vector3().add(((_a2 = hand.t3) == null ? void 0 : _a2.position) ?? new \
Vector3()).add(((_b2 = hand.i4) == null ? void 0 : _b2.position) ?? new \
Vector3()).add(((_c = hand.m4) == null ? void 0 : _c.position) ?? new \
Vector3()).add(((_d = hand.r4) == null ? void 0 : _d.position) ?? new \
Vector3()).add(((_e = hand.p4) == null ? void 0 : _e.position) ?? new \
Vector3()).multiplyScalar(1 / 5);\n      }\n    }\n    if (grip.left && \
grip.right && this.lastGrip.left && this.lastGrip.right) {\n      const mid = \
grip.left.clone().add(grip.right).multiplyScalar(0.5);\n      const lastMid = \
this.lastGrip.left.clone().add(this.lastGrip.right).multiplyScalar(0.5);\n    \
  this.lastPivot = mid;\n      const delta = \
mid.clone().applyMatrix4(this.control.matrix);\n      \
delta.sub(lastMid.clone().applyMatrix4(this.control.matrix));\n      \
delta.multiplyScalar(1 / deltaTime);\n      this.velocity.lerp(delta, 1 - \
Math.exp(-20 * deltaTime));\n      const angle = Math.atan2(grip.left.z - \
mid.z, grip.left.x - mid.x);\n      const lastAngle = Math.atan2(\n        \
this.lastGrip.left.z - lastMid.z,\n        this.lastGrip.left.x - lastMid.x\n \
     );\n      let closestAngle = angle - lastAngle;\n      if (closestAngle \
> Math.PI) {\n        closestAngle -= Math.PI * 2;\n      } else if \
(closestAngle < -Math.PI) {\n        closestAngle += Math.PI * 2;\n      }\n  \
    const rotateVelocity = closestAngle / deltaTime;\n      const blend = \
Math.exp(-20 * deltaTime);\n      this.rotateVelocity = this.rotateVelocity * \
blend + rotateVelocity * (1 - blend);\n    } else {\n      \
this.rotateVelocity *= Math.exp(-deltaTime / this.rotateInertia);\n      if \
(grip.left && this.lastGrip.left) {\n        const delta = \
grip.left.clone().applyMatrix4(this.control.matrix);\n        \
delta.sub(this.lastGrip.left.clone().applyMatrix4(this.control.matrix));\n    \
    delta.multiplyScalar(1 / deltaTime);\n        this.velocity.lerp(delta, 1 \
- Math.exp(-20 * deltaTime));\n      } else if (grip.right && \
this.lastGrip.right) {\n        const delta = \
grip.right.clone().applyMatrix4(this.control.matrix);\n        delta.sub(\n   \
       this.lastGrip.right.clone().applyMatrix4(this.control.matrix)\n        \
);\n        delta.multiplyScalar(1 / deltaTime);\n        \
this.velocity.lerp(delta, 1 - Math.exp(-20 * deltaTime));\n      } else {\n   \
     this.velocity.multiplyScalar(Math.exp(-deltaTime / this.moveInertia));\n \
     }\n    }\n    const negPivot = this.lastPivot.clone().negate();\n    \
const rotate = new Matrix4().makeTranslation(negPivot).premultiply(new \
Matrix4().makeRotationY(this.rotateVelocity * deltaTime)).premultiply(new \
Matrix4().makeTranslation(this.lastPivot));\n    \
this.control.matrix.multiply(rotate);\n    this.control.matrix.decompose(\n   \
   this.control.position,\n      this.control.quaternion,\n      \
this.control.scale\n    );\n    this.control.updateMatrixWorld(true);\n    \
this.control.position.sub(this.velocity.clone().multiplyScalar(deltaTime));\n \
   this.lastGrip = grip;\n  }\n}\nconst DEFAULT_MOVEMENT_SPEED = 1;\nconst \
DEFAULT_ROLL_SPEED = 2;\nconst DEFAULT_ROTATE_SPEED = 2e-3;\nconst \
DEFAULT_SLIDE_SPEED = 6e-3;\nconst DEFAULT_SCROLL_SPEED = 15e-4;\nconst \
DEFAULT_ROTATE_INERTIA = 0.15;\nconst DEFAULT_MOVE_INERTIA = 0.15;\nconst \
DEFAULT_STICK_THRESHOLD = 0.1;\nconst DEFAULT_FPS_ROTATE_SPEED = 2;\nconst \
DEFAULT_POINTER_ROLL_SCALE = 1;\nconst DUAL_PRESS_MS = 200;\nconst \
DOUBLE_PRESS_LIMIT_MS = 400;\nconst DOUBLE_PRESS_DISTANCE = 50;\nconst \
WASD_KEYCODE_MOVE = {\n  KeyW: new THREE.Vector3(0, 0, -1),\n  KeyS: new \
THREE.Vector3(0, 0, 1),\n  KeyA: new THREE.Vector3(-1, 0, 0),\n  KeyD: new \
THREE.Vector3(1, 0, 0),\n  KeyR: new THREE.Vector3(0, 1, 0),\n  KeyF: new \
THREE.Vector3(0, -1, 0)\n};\nconst ARROW_KEYCODE_MOVE = {\n  ArrowUp: new \
THREE.Vector3(0, 0, -1),\n  ArrowDown: new THREE.Vector3(0, 0, 1),\n  \
ArrowLeft: new THREE.Vector3(-1, 0, 0),\n  ArrowRight: new THREE.Vector3(1, \
0, 0),\n  PageUp: new THREE.Vector3(0, 1, 0),\n  PageDown: new \
THREE.Vector3(0, -1, 0)\n};\nconst QE_KEYCODE_ROTATE = {\n  KeyQ: new \
THREE.Vector3(0, 0, 1),\n  KeyE: new THREE.Vector3(0, 0, -1)\n};\nconst \
ARROW_KEYCODE_ROTATE = {\n  Home: new THREE.Vector3(0, -1, 0),\n  End: new \
THREE.Vector3(0, 1, 0),\n  Insert: new THREE.Vector3(-1, 0, 0),\n  Delete: \
new THREE.Vector3(1, 0, 0)\n};\nclass SparkControls {\n  constructor({ canvas \
}) {\n    this.lastTime = 0;\n    this.fpsMovement = new FpsMovement({});\n   \
 this.pointerControls = new PointerControls({ canvas });\n  }\n  \
update(control) {\n    const time = performance.now();\n    const deltaTime = \
(time - (this.lastTime || time)) / 1e3;\n    this.lastTime = time;\n    \
this.fpsMovement.update(deltaTime, control);\n    \
this.pointerControls.update(deltaTime, control);\n  }\n}\nclass FpsMovement \
{\n  constructor({\n    moveSpeed,\n    rollSpeed,\n    stickThreshold,\n    \
rotateSpeed,\n    keycodeMoveMapping,\n    keycodeRotateMapping,\n    \
gamepadMapping,\n    capsMultiplier,\n    shiftMultiplier,\n    \
ctrlMultiplier,\n    xr\n  } = {}) {\n    this.enable = true;\n    \
this.moveSpeed = moveSpeed ?? DEFAULT_MOVEMENT_SPEED;\n    this.rollSpeed = \
rollSpeed ?? DEFAULT_ROLL_SPEED;\n    this.stickThreshold = stickThreshold ?? \
DEFAULT_STICK_THRESHOLD;\n    this.rotateSpeed = rotateSpeed ?? \
DEFAULT_FPS_ROTATE_SPEED;\n    this.keycodeMoveMapping = keycodeMoveMapping \
?? {\n      ...WASD_KEYCODE_MOVE,\n      ...ARROW_KEYCODE_MOVE\n    };\n    \
this.keycodeRotateMapping = keycodeRotateMapping ?? {\n      \
...QE_KEYCODE_ROTATE,\n      ...ARROW_KEYCODE_ROTATE\n    };\n    \
this.gamepadMapping = gamepadMapping ?? {\n      4: \"rollLeft\",\n      5: \
\"rollRight\",\n      6: \"ctrl\",\n      7: \"shift\"\n    };\n    \
this.capsMultiplier = capsMultiplier ?? 10;\n    this.shiftMultiplier = \
shiftMultiplier ?? 5;\n    this.ctrlMultiplier = ctrlMultiplier ?? 1 / 5;\n   \
 this.xr = xr;\n    this.keydown = {};\n    this.keycode = {};\n    \
document.addEventListener(\"keydown\", (event) => {\n      \
this.keydown[event.key] = true;\n      this.keycode[event.code] = true;\n    \
});\n    document.addEventListener(\"keyup\", (event) => {\n      \
this.keydown[event.key] = false;\n      this.keycode[event.code] = false;\n   \
 });\n    window.addEventListener(\"blur\", () => {\n      this.keydown = \
{};\n      this.keycode = {};\n    });\n  }\n  // Call this method in your \
render loop with `control` set to the object to control\n  // (`THREE.Camera` \
or a `THREE.Object3D` that contains it), with `deltaTime`\n  // in seconds \
since the last update.\n  update(deltaTime, control) {\n    var _a2, _b2;\n   \
 if (!this.enable) {\n      return;\n    }\n    const sticks = [new \
THREE.Vector2(), new THREE.Vector2()];\n    const gamepad = \
navigator.getGamepads()[0];\n    if (gamepad) {\n      \
sticks[0].set(gamepad.axes[0], gamepad.axes[1]);\n      \
sticks[1].set(gamepad.axes[2], gamepad.axes[3]);\n    }\n    const \
gamepadButtons = (gamepad == null ? void 0 : gamepad.buttons.map((button) => \
button.pressed)) || [];\n    const xrSources = Array.from(((_b2 = (_a2 = \
this.xr) == null ? void 0 : _a2.getSession()) == null ? void 0 : \
_b2.inputSources) ?? []);\n    for (const source of xrSources) {\n      const \
gamepad2 = source.gamepad;\n      if (gamepad2) {\n        switch \
(source.handedness) {\n          case \"none\": {\n            sticks[0].x += \
gamepad2.axes[0];\n            sticks[0].y += gamepad2.axes[1];\n            \
sticks[1].x += gamepad2.axes[2];\n            sticks[1].y += \
gamepad2.axes[3];\n            break;\n          }\n          case \"left\": \
{\n            sticks[0].x += gamepad2.axes[2];\n            sticks[0].y += \
gamepad2.axes[3];\n            break;\n          }\n          case \"right\": \
{\n            sticks[1].x += gamepad2.axes[2];\n            sticks[1].y += \
gamepad2.axes[3];\n            break;\n          }\n        }\n      }\n    \
}\n    for (const stick of sticks) {\n      stick.x = Math.abs(stick.x) >= \
this.stickThreshold ? stick.x : 0;\n      stick.y = Math.abs(stick.y) >= \
this.stickThreshold ? stick.y : 0;\n    }\n    const rotate = new \
THREE.Vector3(\n      sticks[1].x,\n      sticks[1].y,\n      0\n    \
).multiplyScalar(this.rotateSpeed);\n    for (const [keycode, rot] of \
Object.entries(this.keycodeRotateMapping)) {\n      if \
(this.keycode[keycode]) {\n        rotate.add(rot);\n      }\n    }\n    for \
(const button in this.gamepadMapping) {\n      if \
(gamepadButtons[Number.parseInt(button)]) {\n        switch \
(this.gamepadMapping[button]) {\n          case \"rollLeft\":\n            \
rotate.z += 1;\n            break;\n          case \"rollRight\":\n           \
 rotate.z -= 1;\n            break;\n        }\n      }\n    }\n    \
rotate.multiply(\n      new THREE.Vector3(this.rotateSpeed, this.rotateSpeed, \
this.rollSpeed)\n    );\n    if (rotate.manhattanLength() > 0) {\n      \
rotate.multiplyScalar(deltaTime);\n      const eulers = new \
THREE.Euler().setFromQuaternion(\n        control.quaternion,\n        \
\"YXZ\"\n      );\n      eulers.y -= rotate.x;\n      eulers.x = Math.max(\n  \
      -Math.PI / 2,\n        Math.min(Math.PI / 2, eulers.x - rotate.y)\n     \
 );\n      eulers.z = Math.max(-Math.PI, Math.min(Math.PI, eulers.z + \
rotate.z));\n      control.quaternion.setFromEuler(eulers);\n    }\n    const \
moveVector = new THREE.Vector3(sticks[0].x, 0, sticks[0].y);\n    for (const \
[keycode, move] of Object.entries(this.keycodeMoveMapping)) {\n      if \
(this.keycode[keycode]) {\n        moveVector.add(move);\n      }\n    }\n    \
let speedMultiplier = 1;\n    if (this.keydown.CapsLock) {\n      \
speedMultiplier *= this.capsMultiplier;\n    }\n    if \
(this.keycode.ShiftLeft || this.keycode.ShiftRight) {\n      speedMultiplier \
*= this.shiftMultiplier;\n    }\n    if (this.keycode.ControlLeft || \
this.keycode.ControlRight) {\n      speedMultiplier *= this.ctrlMultiplier;\n \
   }\n    for (const button in this.gamepadMapping) {\n      if \
(gamepadButtons[Number.parseInt(button)]) {\n        switch \
(this.gamepadMapping[button]) {\n          case \"shift\":\n            \
speedMultiplier *= this.shiftMultiplier;\n            break;\n          case \
\"ctrl\":\n            speedMultiplier *= this.ctrlMultiplier;\n            \
break;\n        }\n      }\n    }\n    \
moveVector.applyQuaternion(control.quaternion);\n    control.position.add(\n  \
    moveVector.multiplyScalar(this.moveSpeed * speedMultiplier * deltaTime)\n \
   );\n  }\n}\nclass PointerControls {\n  constructor({\n    // The HTML \
canvas element to attach pointer events to\n    canvas,\n    // Speed of \
rotation (default DEFAULT_ROTATE_SPEED)\n    rotateSpeed,\n    // Speed of \
sliding when dragging with right/middle mouse button or two fingers\n    // \
(default DEFAULT_SLIDE_SPEED)\n    slideSpeed,\n    // Speed of movement when \
using mouse scroll wheel (default DEFAULT_SCROLL_SPEED)\n    scrollSpeed,\n   \
 // Swap the direction of rotation and sliding (default: false)\n    \
swapRotateSlide,\n    // Reverse the direction of rotation (default: false)\n \
   reverseRotate,\n    // Reverse the direction of sliding (default: false)\n \
   reverseSlide,\n    // Reverse the direction of swipe gestures (default: \
false)\n    reverseSwipe,\n    // Reverse the direction of scroll wheel \
movement (default: false)\n    reverseScroll,\n    // Inertia factor for \
movement (default: DEFAULT_MOVE_INERTIA)\n    moveInertia,\n    // Inertia \
factor for rotation (default: DEFAULT_ROTATE_INERTIA)\n    rotateInertia,\n   \
 // Pointer rolling scale factor (default: DEFAULT_POINTER_ROLL_SCALE)\n    \
pointerRollScale,\n    // Callback for double press events (default: () => \
{})\n    doublePress\n  }) {\n    this.enable = true;\n    this.canvas = \
canvas;\n    this.rotateSpeed = rotateSpeed ?? DEFAULT_ROTATE_SPEED;\n    \
this.slideSpeed = slideSpeed ?? DEFAULT_SLIDE_SPEED;\n    this.scrollSpeed = \
scrollSpeed ?? DEFAULT_SCROLL_SPEED;\n    this.swapRotateSlide = \
swapRotateSlide ?? false;\n    this.reverseRotate = reverseRotate ?? false;\n \
   this.reverseSlide = reverseSlide ?? false;\n    this.reverseSwipe = \
reverseSwipe ?? false;\n    this.reverseScroll = reverseScroll ?? false;\n    \
this.moveInertia = moveInertia ?? DEFAULT_MOVE_INERTIA;\n    \
this.rotateInertia = rotateInertia ?? DEFAULT_ROTATE_INERTIA;\n    \
this.pointerRollScale = pointerRollScale ?? DEFAULT_POINTER_ROLL_SCALE;\n    \
this.doublePress = doublePress ?? (() => {\n    });\n    \
this.doublePressLimitMs = DOUBLE_PRESS_LIMIT_MS;\n    \
this.doublePressDistance = DOUBLE_PRESS_DISTANCE;\n    this.lastUp = null;\n  \
  this.rotating = null;\n    this.sliding = null;\n    this.dualPress = \
false;\n    this.scroll = new THREE.Vector3();\n    this.rotateVelocity = new \
THREE.Vector3();\n    this.moveVelocity = new THREE.Vector3();\n    \
canvas.addEventListener(\"pointerdown\", (event) => {\n      const position = \
this.getPointerPosition(event);\n      const initial = position.clone();\n    \
  const last = position.clone();\n      const isRotate = \
!this.swapRotateSlide && !this.rotating && (event.pointerType !== \"mouse\" \
|| event.button === 0) || this.swapRotateSlide && this.sliding && \
!this.rotating && (event.pointerType !== \"mouse\" || event.button === 1);\n  \
    const { pointerId, timeStamp } = event;\n      if (isRotate) {\n        \
this.rotating = { initial, last, position, pointerId, timeStamp };\n        \
canvas.setPointerCapture(event.pointerId);\n        this.dualPress = false;\n \
     } else if (!this.sliding) {\n        const button = event.pointerType \
=== \"mouse\" ? event.button : void 0;\n        this.sliding = {\n          \
initial,\n          last,\n          position,\n          pointerId,\n        \
  button,\n          timeStamp\n        };\n        \
canvas.setPointerCapture(event.pointerId);\n        this.dualPress = \
this.rotating != null && timeStamp - this.rotating.timeStamp < \
DUAL_PRESS_MS;\n      }\n    });\n    const pointerUp = (event) => {\n      \
var _a2, _b2;\n      if (((_a2 = this.rotating) == null ? void 0 : \
_a2.pointerId) === event.pointerId) {\n        this.rotating = null;\n        \
canvas.releasePointerCapture(event.pointerId);\n        if (this.dualPress && \
this.sliding) {\n          \
canvas.releasePointerCapture(this.sliding.pointerId);\n          this.sliding \
= null;\n        }\n      } else if (((_b2 = this.sliding) == null ? void 0 : \
_b2.pointerId) === event.pointerId) {\n        this.sliding = null;\n        \
canvas.releasePointerCapture(event.pointerId);\n        if (this.dualPress && \
this.rotating) {\n          \
canvas.releasePointerCapture(this.rotating.pointerId);\n          \
this.rotating = null;\n        }\n      }\n      const position = \
this.getPointerPosition(event);\n      const lastUp = this.lastUp;\n      \
this.lastUp = { position, time: event.timeStamp };\n      if (lastUp) {\n     \
   const distance2 = lastUp.position.distanceTo(position);\n        if \
(distance2 < this.doublePressDistance) {\n          const intervalMs = \
event.timeStamp - lastUp.time;\n          if (intervalMs < \
this.doublePressLimitMs) {\n            this.lastUp = null;\n            \
this.doublePress({ position, intervalMs });\n          }\n        }\n      \
}\n    };\n    document.addEventListener(\"pointerup\", pointerUp);\n    \
document.addEventListener(\"pointercancel\", pointerUp);\n    \
document.addEventListener(\"pointermove\", (event) => {\n      var _a2, \
_b2;\n      if (((_a2 = this.rotating) == null ? void 0 : _a2.pointerId) === \
event.pointerId) {\n        this.rotating.position = \
this.getPointerPosition(event);\n      } else if (((_b2 = this.sliding) == \
null ? void 0 : _b2.pointerId) === event.pointerId) {\n        \
this.sliding.position = this.getPointerPosition(event);\n      }\n    });\n   \
 canvas.addEventListener(\"contextmenu\", (event) => {\n      \
event.preventDefault();\n    });\n    canvas.addEventListener(\"wheel\", \
(event) => {\n      this.scroll.add(\n        new THREE.Vector3(event.deltaX, \
event.deltaY, event.deltaZ)\n      );\n      event.preventDefault();\n    \
});\n  }\n  getPointerPosition(event) {\n    const rect = \
this.canvas.getBoundingClientRect();\n    return new THREE.Vector2(\n      \
event.clientX - rect.left,\n      event.clientY - rect.top\n    );\n  }\n  \
update(deltaTime, control) {\n    if (!this.enable) {\n      return;\n    }\n \
   if (this.dualPress && this.rotating && this.sliding) {\n      const motion \
= [\n        this.rotating.position.clone().sub(this.rotating.last),\n        \
this.sliding.position.clone().sub(this.sliding.last)\n      ];\n      const \
coincidence = motion[0].dot(motion[1]);\n      if (coincidence >= 0.2) {\n    \
    const totalMotion = motion[0].clone().add(motion[1]);\n        const \
slide = new THREE.Vector3(totalMotion.x, -totalMotion.y, 0);\n        \
slide.multiplyScalar(this.slideSpeed * (this.reverseSwipe ? 1 : -1));\n       \
 slide.applyQuaternion(control.quaternion);\n        \
control.position.add(slide);\n        this.moveVelocity = \
slide.clone().multiplyScalar(1 / deltaTime);\n      } else if (coincidence <= \
-0.2) {\n        const deltaDir = \
this.sliding.last.clone().sub(this.rotating.last);\n        const deltaDist = \
deltaDir.length();\n        deltaDir.multiplyScalar(1 / \
deltaDist).normalize();\n        const orthoDir = new \
THREE.Vector2(-deltaDir.y, deltaDir.x);\n        const motionDir = \
[motion[0].dot(deltaDir), motion[1].dot(deltaDir)];\n        const \
motionOrtho = [motion[0].dot(orthoDir), motion[1].dot(orthoDir)];\n        \
const midpoint = \
this.rotating.last.clone().add(this.sliding.last).multiplyScalar(0.5);\n      \
  let midpointDir = new THREE.Vector3();\n        if (control instanceof \
THREE.Camera) {\n          const ndcMidpoint = new THREE.Vector2(\n           \
 midpoint.x / this.canvas.clientWidth * 2 - 1,\n            -(midpoint.y / \
this.canvas.clientHeight) * 2 + 1\n          );\n          const raycaster = \
new THREE.Raycaster();\n          raycaster.setFromCamera(ndcMidpoint, \
control);\n          midpointDir = raycaster.ray.direction;\n        }\n      \
  const pinchOut = motionDir[1] - motionDir[0];\n        const slide = \
midpointDir.multiplyScalar(pinchOut * this.slideSpeed);\n        \
control.position.add(slide);\n        this.moveVelocity = \
slide.clone().multiplyScalar(1 / deltaTime);\n        const angles = [\n      \
    Math.atan(motionOrtho[0] / (-0.5 * deltaDist)),\n          \
Math.atan(motionOrtho[1] / (0.5 * deltaDist))\n        ];\n        const \
rotate = 0.5 * (angles[0] + angles[1]) * this.pointerRollScale;\n        \
const eulers = new THREE.Euler().setFromQuaternion(\n          \
control.quaternion,\n          \"YXZ\"\n        );\n        eulers.z = \
Math.max(\n          -Math.PI,\n          Math.min(Math.PI, eulers.z + 0.5 * \
rotate)\n        );\n        control.quaternion.setFromEuler(eulers);\n      \
}\n      this.rotating.last.copy(this.rotating.position);\n      \
this.sliding.last.copy(this.sliding.position);\n    } else {\n      const \
rotate = new THREE.Vector3();\n      if (this.rotating && !this.dualPress) \
{\n        const delta = \
this.rotating.position.clone().sub(this.rotating.last);\n        \
this.rotating.last.copy(this.rotating.position);\n        rotate.set(delta.x, \
delta.y, 0);\n        rotate.multiplyScalar(this.rotateSpeed * \
(this.reverseRotate ? -1 : 1));\n        this.rotateVelocity = \
rotate.clone().multiplyScalar(1 / deltaTime);\n      } else {\n        \
this.rotateVelocity.multiplyScalar(\n          Math.exp(-deltaTime / \
this.rotateInertia)\n        );\n        \
rotate.addScaledVector(this.rotateVelocity, deltaTime);\n      }\n      const \
eulers = new THREE.Euler().setFromQuaternion(\n        control.quaternion,\n  \
      \"YXZ\"\n      );\n      eulers.y -= rotate.x;\n      eulers.x = \
Math.max(\n        -Math.PI / 2,\n        Math.min(Math.PI / 2, eulers.x - \
rotate.y)\n      );\n      eulers.z *= Math.exp(-0 * deltaTime);\n      \
control.quaternion.setFromEuler(eulers);\n      if (this.sliding && \
!this.dualPress) {\n        const delta = \
this.sliding.position.clone().sub(this.sliding.last);\n        \
this.sliding.last.copy(this.sliding.position);\n        const slide = \
this.sliding.button !== 2 ? new THREE.Vector3(delta.x, 0, delta.y) : new \
THREE.Vector3(delta.x, -delta.y, 0);\n        \
slide.multiplyScalar(this.slideSpeed * (this.reverseSlide ? -1 : 1));\n       \
 slide.applyQuaternion(control.quaternion);\n        \
control.position.add(slide);\n        this.moveVelocity = \
slide.clone().multiplyScalar(1 / deltaTime);\n      } else {\n        \
this.moveVelocity.multiplyScalar(\n          Math.exp(-deltaTime / \
this.moveInertia)\n        );\n        \
control.position.addScaledVector(this.moveVelocity, deltaTime);\n      }\n    \
}\n    const scroll = this.scroll.multiplyScalar(this.scrollSpeed);\n    \
scroll.set(scroll.x, scroll.z, scroll.y);\n    if (this.reverseScroll) {\n    \
  scroll.multiplyScalar(-1);\n    }\n    \
scroll.applyQuaternion(control.quaternion);\n    \
control.position.add(scroll);\n    this.scroll.set(0, 0, 0);\n  }\n}\n  \
loadSpark = () => SplatMesh;\n  return SplatMesh;\n}\n\ncore.SplatMesh = \
async (args, env) => {\n  const SplatMesh = await loadSpark();\n  const \
splatURL = await interpretate(args[0], env);\n  const butterfly = new \
SplatMesh({ url: splatURL });\n  env.mesh.add(butterfly); \n};", 
    "Display" -> "js", "Hash" -> "e711c3d9-b23c-49cc-a919-5bd171691ebe", 
    "Invisible" -> False, "MetaOnly" -> False, "Props" -> <||>, 
    "PublicFields" -> {"Properties"}, "State" -> "Idle", "Type" -> "Output", 
    "UID" -> Null, "Notebook" -> "86740df4-dd4a-49d0-81ce-da87f3e03e12"|>, 
   <|"Data" -> ".md\nLet's plot a butterfly splat on top of `Plot3D` like if \
it was a native `Graphics3D` primitive \|01f525", "Display" -> "codemirror", 
    "Hash" -> "d72c8db7-dd75-4e12-9c6f-6e677771ac13", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <|"Hidden" -> True|>, 
    "PublicFields" -> {"Properties"}, "State" -> "Idle", "Type" -> "Input", 
    "UID" -> Null, "Notebook" -> "86740df4-dd4a-49d0-81ce-da87f3e03e12"|>, 
   <|"Data" -> "Let's plot a butterfly splat on top of `Plot3D` like if it \
was a native `Graphics3D` primitive \|01f525", "Display" -> "markdown", 
    "Hash" -> "309105de-9601-42f7-998c-6a45962b8f13", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "PublicFields" -> {"Properties"}, 
    "State" -> "Idle", "Type" -> "Output", "UID" -> Null, 
    "Notebook" -> "86740df4-dd4a-49d0-81ce-da87f3e03e12"|>, 
   <|"Data" -> "Plot3D[Sin[x y], {x,-1,1}, {y,-1,1}, Epilog->{\n  Scale[\n    \
SplatMesh[\"https://sparkjs.dev/assets/splats/butterfly.spz\"]\n  , 0.8]\n}, \
ColorFunction->\"Rainbow\"]", "Display" -> "codemirror", 
    "Hash" -> "a80c23c7-02bf-404e-96b7-ae91af86c80a", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "PublicFields" -> {"Properties"}, 
    "State" -> "Idle", "Type" -> "Input", "UID" -> Null, 
    "Notebook" -> "86740df4-dd4a-49d0-81ce-da87f3e03e12"|>, 
   <|"Data" -> "(*VB[*)(FrontEndRef[\"dfbd9007-8bd8-4a34-b67c-0ffcc1868e35\"]\
)(*,*)(*\"1:eJxTTMoPSmNkYGAoZgESHvk5KRCeEJBwK8rPK3HNS3GtSE0uLUlMykkNVgEKp6Qlp\
VgaGJjrWiSlWOiaJBqb6CaZmSfrGqSlJScbWphZpBqbAgCQmxYN\"*)(*]VB*)", 
    "Display" -> "codemirror", "Hash" -> 
     "e47e2179-e077-4583-8a5d-340929e5dfc4", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "PublicFields" -> {"Properties"}, 
    "State" -> "Idle", "Type" -> "Output", "UID" -> Null, 
    "Notebook" -> "86740df4-dd4a-49d0-81ce-da87f3e03e12"|>, 
   <|"Data" -> ".md\nFor future development, it is worth writing a basic \
parser in Wolfram so that we can extract the metadata and possibly apply some \
modifications to the model before sending it to our rendering pipeline.\n\n> \
This is amazing how far one can go with a vast land of Javascript libraries \
bridged with Wolfram Language. See ya \|01f9d9\|01f3fc\:200d\[Mars]\:fe0f", 
    "Display" -> "codemirror", "Hash" -> 
     "5eb922ec-14d1-444f-a76d-05a98fb2789d", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <|"Hidden" -> True|>, 
    "PublicFields" -> {"Properties"}, "State" -> "Idle", "Type" -> "Input", 
    "UID" -> Null, "Notebook" -> "86740df4-dd4a-49d0-81ce-da87f3e03e12"|>, 
   <|"Data" -> "For future development, it is worth writing a basic parser in \
Wolfram so that we can extract the metadata and possibly apply some \
modifications to the model before sending it to our rendering pipeline.\n\n> \
This is amazing how far one can go with a vast land of Javascript libraries \
bridged with Wolfram Language. See ya \|01f9d9\|01f3fc\:200d\[Mars]\:fe0f", 
    "Display" -> "markdown", "Hash" -> 
     "5605790e-50de-494d-8aee-a785e7578d28", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "PublicFields" -> {"Properties"}, 
    "State" -> "Idle", "Type" -> "Output", "UID" -> Null, 
    "Notebook" -> "86740df4-dd4a-49d0-81ce-da87f3e03e12"|>}, 
 "serializer" -> "jsfn4"|>
