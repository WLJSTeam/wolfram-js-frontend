<|"Notebook" -> <|"Controller" -> "bdfd2bac-8d48-44fd-9c85-3418a186cc97", 
   "FocusedCell" -> CoffeeLiqueur`Notebook`Cells`CellObj[
     CoffeeLiqueur`Notebook`Cells`CellObj`$1037], "HaveToSaveAs" -> False, 
   "MessangerChannel" -> Messanger, "ModalsChannel" -> 
    "2c4352de-4bb6-4723-83c4-23b82fd0fe96", 
   "Objects" -> <|"ee52e033-8e00-49d5-9427-91a42d3e707e" -> 
      <|"Public" -> Hold[HeatMap[{{0.20167245124746752, 
            -0.29634719451357766}, {-0.06030205038415557, 
            -0.13739260297290964}, {0.029485017126598092, 
            0.1773676036178184}, {-0.15495869495874917, 0.0867887821552371}, 
           {0.11193746862579237, -0.19698866308522484}, {-0.3065504860028151, 
            0.13012353111867433}, {-0.11965488356474883, 0.3050161464667733}, 
           {0.10564954667261647, -0.1266275833498646}, {0.07116332595411712, 
            0.0871237838242374}, {0.18783942321959243, -0.12715674891910167}, 
           {0.05153634997134482, 0.04860954207049552}, {-0.1095759641862616, 
            0.12289444067809865}, {0.04902962419575388, 0.06073689304108018}, 
           {0.10492710057277932, 0.04729038516661387}, {-0.15343275228119813, 
            0.27448059779862716}, {0.24879094976132135, 
            0.027205269147550507}, {-0.15116107290073047, 
            -0.23466226654114533}, {-0.16779879195116323, 
            -0.0015568202351119078}, {-0.06849155112118543, 
            -0.062465674570145964}, {0.0665053448876869, 
            0.07042462314412146}, {-0.35670250594117764, 
            -0.028678480226359843}, {0.2820610681662536, 
            -0.21939642422393285}, {-0.24116771093087913, 
            0.2774806009722207}, {0.26845374135749606, 0.004438492772850677}, 
           {0.06241763719510077, -0.05397687851160985}, {-0.3419251283058585, 
            0.029655606849070683}, {-0.04990692026287413, 
            0.26348519583047114}, {0.34037222441499854, 
            -0.12567924824628987}, {0.08795844184284755, 
            0.25742970002738313}, {-0.3435446319833173, 
            -0.13018426687923434}}]]|>, 
     "be35c15b-4091-4c24-b269-8dbfceccd6af" -> 
      <|"Public" -> Hold[HTMLView["<div class=\"relative shrink-0 gap-y-3 \
pb-2 flex flex-col sm-controls\"><div class=\"flex gap-x-5 \
sm-controls\"><label for=\"default-range\" class=\"block mb-2 text-sm \
font-medium text-gray-900\"></label><input min=\"0\" max=\"313\" step=\"1\" \
value=\"0\" id=\"n-#instanceId\" type=\"number\" class=\"ml-auto h-2 grow \
max-w-60 block p-2.5 text-xs text-gray-900 bg-gray-50 rounded-md \
border-2-gray-50 border border-gray-300 focus:ring-blue-500 \
focus:border-blue-500\"></input></div><input min=\"0\" max=\"313\" step=\"1\" \
value=\"0\" id=\"r-#instanceId\" type=\"range\" class=\"sm-controls w-full \
h-1 bg-gray-200 rounded-lg appearance-none cursor-pointer \
\"></input></div>\n<script type=\"module\"> const num = \
document.getElementById('n-#instanceId');\n        const ran = \
document.getElementById('r-#instanceId');\n\n        let harpticQ = true;\n\n \
       function isNumber(value) { return typeof value === 'number'}\n\n       \
 num.addEventListener('input', (event)=> {\n            if (isNaN(num.value)) \
return;\n            ran.value = num.value;\n            \
server.kernel.io.fire('89e759c0-69d5-42d9-b9a2-ff5858d553eb', \
Number(num.value), 'Default');      \n        });\n\n        \
ran.addEventListener('input', (event)=> {\n            if (isNaN(ran.value)) \
return;\n            num.value = ran.value;\n            \
server.kernel.io.fire('89e759c0-69d5-42d9-b9a2-ff5858d553eb', \
Number(ran.value), 'Default');   \n            if (harpticQ) {\n              \
  if (!window.electronAPI) {harpticQ = false; return}\n                if \
(!window.electronAPI.harptic) {harpticQ = false; return}\n                \
window.electronAPI.harptic();\n            }               \n        \
});</script>", Prolog -> 
           CoffeeLiqueur`Extensions`InputsOutputs`Tools`TemplateProcessor[
            Association["instanceId" -> CreateUUID[]]]]]|>, 
     "cb4192e4-0c84-4904-9642-d1ff509ba599" -> 
      <|"Public" -> Hold[Graphics[{RGBColor[0.922526, 0.385626, 0.209179], 
           PointSize[0.03], Inset[HeatMap[{{-0.21562006217796975, 
               -0.06375831837627456}, {0.05276956964937328, 
               0.11757712881995948}, {0.1515755023605942, 
               -0.10501264411247414}, {0.07987761985745287, 
               -0.06723566249205264}, {-0.050655093896719926, 
               -0.06183675290945783}, {0.08610590253833032, 
               0.27593985196558846}, {-0.10459681931428816, 
               0.2428989111977458}, {0.05760983703819238, 
               -0.04647346988592159}, {-0.18605213295315795, 
               0.01206182893231701}, {0.2665143332698182, 
               0.0009718243559820087}, {-0.10803652487898104, 
               0.07638988899568483}, {0.12098717821191983, 
               0.10085936729020603}, {-0.11486348120432828, 
               0.2773269702233378}, {0.25868245353088903, 
               -0.13746279111199242}, {0.03589746351967983, 
               0.25214574047177074}, {-0.023684276185020708, 
               -0.14207361425240897}, {0.029375110730418263, 
               -0.2760369455117684}, {-0.04634003226427725, 
               -0.05324843887584626}, {0.22390421575211145, 
               -0.004692134510297814}, {0.31290369304254706, 
               -0.08988823126755327}, {0.008360471570538085, 
               0.2161441666154062}, {0.09511735500039081, 
               0.14916769807614888}, {-0.13816567498583168, 
               -0.1820775520660196}, {-0.13644291647805787, 
               -0.04267643017593324}, {0.3390267271368509, 
               0.13568317164922497}, {-0.23215439597689236, 
               -0.135031668426791}, {0.16312797534898468, 
               -0.14629600844745694}, {-0.14723117005887423, 
               0.1366712208622142}, {0.21507266658273005, 
               -0.07646911162761577}, {0.11805103196588998, 
               -0.2861804543385442}, {-0.05119733737186652, 
               0.2574227921804728}, {0.1463229005544827, 
               -0.04289693697586703}, {0.12345871769078587, 
               0.03741523684733971}, {0.07167770004730407, 
               -0.16461354947047843}, {-0.11652945084987304, 
               0.08050950905786701}, {-0.0018728727146404927, 
               -0.13842643200373542}, {0.30293547963005196, 
               0.2078048559657168}, {0.03244495304332802, 
               -0.2505104726025239}, {-0.1914270817323389, 
               -0.11109619532904462}, {-0.2641042261556785, 
               -0.0247075956871779}, {0.17862639431909472, 
               0.3123490867314156}, {0.12488231724756972, 
               0.15256439266233746}, {0.3449386846832469, 
               -0.06338544833142039}, {0.03256058316359999, 
               -0.290589176917069}, {0.22626891421588652, 
               -0.28318237190919004}, {0.11372123390996844, 
               -0.04103857177690996}, {0.005790828459590209, 
               0.1526273315701655}, {0.17234412047651085, 
               -0.20761165185886551}, {-0.1326622367490808, 
               -0.2893248712695535}, {-0.15664904242178107, 
               0.14258640367758352}}, 4000, PlotRange -> {{-0.5, 0.5}, {-0.5, 
                0.5}}, ImageSize -> {420, 320}], {0, 0}], GrayLevel[0], 
           Point[{{-0.21562006217796975, -0.06375831837627456}, 
             {0.05276956964937328, 0.11757712881995948}, {0.1515755023605942, 
              -0.10501264411247414}, {0.07987761985745287, 
              -0.06723566249205264}, {-0.050655093896719926, 
              -0.06183675290945783}, {0.08610590253833032, 
              0.27593985196558846}, {-0.10459681931428816, 
              0.2428989111977458}, {0.05760983703819238, 
              -0.04647346988592159}, {-0.18605213295315795, 
              0.01206182893231701}, {0.2665143332698182, 
              0.0009718243559820087}, {-0.10803652487898104, 
              0.07638988899568483}, {0.12098717821191983, 
              0.10085936729020603}, {-0.11486348120432828, 
              0.2773269702233378}, {0.25868245353088903, 
              -0.13746279111199242}, {0.03589746351967983, 
              0.25214574047177074}, {-0.023684276185020708, 
              -0.14207361425240897}, {0.029375110730418263, 
              -0.2760369455117684}, {-0.04634003226427725, 
              -0.05324843887584626}, {0.22390421575211145, 
              -0.004692134510297814}, {0.31290369304254706, 
              -0.08988823126755327}, {0.008360471570538085, 
              0.2161441666154062}, {0.09511735500039081, 
              0.14916769807614888}, {-0.13816567498583168, 
              -0.1820775520660196}, {-0.13644291647805787, 
              -0.04267643017593324}, {0.3390267271368509, 
              0.13568317164922497}, {-0.23215439597689236, 
              -0.135031668426791}, {0.16312797534898468, 
              -0.14629600844745694}, {-0.14723117005887423, 
              0.1366712208622142}, {0.21507266658273005, 
              -0.07646911162761577}, {0.11805103196588998, 
              -0.2861804543385442}, {-0.05119733737186652, 
              0.2574227921804728}, {0.1463229005544827, 
              -0.04289693697586703}, {0.12345871769078587, 
              0.03741523684733971}, {0.07167770004730407, 
              -0.16461354947047843}, {-0.11652945084987304, 
              0.08050950905786701}, {-0.0018728727146404927, 
              -0.13842643200373542}, {0.30293547963005196, 
              0.2078048559657168}, {0.03244495304332802, 
              -0.2505104726025239}, {-0.1914270817323389, 
              -0.11109619532904462}, {-0.2641042261556785, 
              -0.0247075956871779}, {0.17862639431909472, 
              0.3123490867314156}, {0.12488231724756972, 
              0.15256439266233746}, {0.3449386846832469, 
              -0.06338544833142039}, {0.03256058316359999, 
              -0.290589176917069}, {0.22626891421588652, 
              -0.28318237190919004}, {0.11372123390996844, 
              -0.04103857177690996}, {0.005790828459590209, 
              0.1526273315701655}, {0.17234412047651085, 
              -0.20761165185886551}, {-0.1326622367490808, 
              -0.2893248712695535}, {-0.15664904242178107, 
              0.14258640367758352}}]}, PlotRange -> {{-0.5, 0.5}, 
            {-0.5, 0.5}}, ImageSizeRaw -> {420*Graphics`DPR[], 
            320*Graphics`DPR[]}, ImagePadding -> 30, Frame -> True, 
          Axes -> True]]|>|>, "Path" -> "/Users/kirill/Documents/WLJS \
Notebooks/Demos/Javascript bindings/D - Heatmap GPUjs.wln", 
   "PublicFields" -> {"Properties"}, "Quick" -> True, 
   "Symbols" -> <|"points" -> 
      CoffeeLiqueur`Extensions`FrontendObject`Tools`ExtractJSONCompressed["eJ\
xF14mxHTcOBdCENC7uIGNxKf805oDsV7ZUltQfTQK4C9D//lv+6W3NMfuos61ovc4/no2z+xqjVs9\
PzPH3j8g9RtttllrnKqMcgZEh89RY8+xT141brZU9y+x1rOX3n/951wu9zNjlxKo9BHq6epxV1j4z\
1q5rOLH1dkqU1kc/pczzjqx7l9prrcPj2vPE0xwzTsQaXUovLvr09KzeRmutLwfOOvqcvey9exnru\
7n3VqPtTLPKoOWJOtB66UuG0zljv9Cp4r2qBOeapbzQU0uPEqGmMd/dWrXrEdj2iDHrvXuOHSEBXa\
q937hZFVZa7OGHIzKujb3WdNjy59h93sAjoajntNKOtru4/lNWX3vuczKDul5gq62MkHH2bO/bnTM\
TzzFW08Vab1xptZwFgnHm0uM9MrQD+LSjaWWKbq/qUdbZ/tn7gcgtep5S9bWCa8Iw25PIlDWnRrQo\
fnbmjVTWhNjsu3j6ylbajlWiavfuPdsDABhOnViI9JIc3sh+V/kM+CYdT1siRzt9hpeyj24JfYDKk\
cKJurKRY8+BtviLUXr0+gMnYCfHz5hz3jP31HQ1Snv2uBA6smSFAxo6TAv6l6c6yRVY3uvuEH6xG+\
P3Oivg1dFQIObWhlN4iWrnFbQx20X4OvGttZQNUQEcb7Nn392jzUNFetji7LiNrGs16BRYImakDi8\
jK/TmOWdQxRNYQZDeJ1mi9Sjk+7pJoav32EsoCUTGRrTVRm1n1NDQ89WO+xpMuil0ZMjQ5lzY+N2V\
XtpzAvqXfJ9L8fTzEuhRK654jllzv+Kjab6OlgZr+F0OZ5hs8HMTxYcmPQ7uMkv3R1fWJZJXVpvjE\
AWMH5P20aqq0esUMs7GV4IqG7MwqXGZpzQ3O8p//Il407Am4ScNkJVN1a/02TrBdNoFs/df5U5U4u\
CPbptJpQzldMpv3IA+d7qlkxhDdL+q9J8HdhkNJqYa1nGLGYcCJrGuTOBTz+xQQHkUg1OGrUDJtvp\
Gw3D0uzffpU+NbezsChcERbaScK0Snmmw7lCxlyd4r3D5D77kr3Xg+5iRbHPSDqGnXdO4xO0U1QHY\
f83hLGwkGhDieJo8x17ZuMdv7Pz0mCZJahij9KbmyigpY50UJGZ+UDOBMqTMzGB7m21UbFIAd+cT7\
XlLCZUe9pmVa8rFBYcVnq6mwTG++VBoWSbIYmY4LFXb+IPgNCJYP+YeT/NEdjVrCWXjIyPhiTp71L\
k/AwS6Hp7uiB30m0A35pSEuqpnKI9laXVqQ4uROWYcMWBm+jwP/PyiMvuiOrZT0HynERizFJ+Xnz3\
V/s3ZzCxfJwlWkG4VTGGMSD+d4zc+vUZflAlTBpFc1IIc5JdABPEFZl6nnLIcLD5uz2m84gMS5IDB\
tTfF1Bs50JvLcCNnsqT9fOlP7A2NeypsK2PuteWQYuiXavpVTKZjKKPG10q0sTmwQFRJb7/O5gFsz\
kRg5pJcAzijcTx9mxT+byNIxGHlfPnztjdt81DDjhjtGrrJM1+XWBxxyoDQP7fUROKCHa7p/ycJ1h\
OlIAgxc6HHDv9Wa98tdxmz4Xo1m/DXmQmPH5boZFcYLtPBbSok3xLaToz6AelvNJM/T5QCAHEi2SE\
7DuAiu04w0K/0tsx2oT3dlxldRVZZ5vTh598CkbdTrU4CxHoV+9wpnl5uWiNOOeK/NScNRifohTnz\
wLuU7FxPdAl2RtonILk0zlT9xKKUXKpow2aZAw5/HQKXHMFhA0gJXfGaiVDYfFAWrb2CBOiI95WAN\
zdy5cihCcIyE77thWNYF0wpQpLsW1+kyCJyHBqn19rydQHIsQyyb8GCp/Lw0iqkJfvRKKyQtGcM6i\
6Aspa7xIEFjBTyyYI7sCoD2mRbcfuooYJUwaDsrvVzVWUjO8IyA5MqT8QHCLBanZXVb6X1bGe74Y5\
KebezctuwfCUJDd83mbuDajJd/ZC55mZDw3N64Jae9fiRPR1MRd4xym+iOCDv3IqQCUcfi7r2G0UG\
bi7Cj0RYayqQsnmp0K94FpXA5iwVOz9PsDlANXEiNA74PCHdSZssvGpPrjMeArUqGcwU/bEt5xNbx\
m2k9UqynRBdgmkep09+AuLBdiwQcR7pf/PRoAEZ0lrh7zrInIfJJrutNJb2PiZUbfWgK+Zh1/xUkf\
1mXJFXs+PrxNQBNhhZP6T61QMXpqNpmoc9lx9g4E8JRNgxX6AdrRjiVhjb8Td101ussbnR8Nn2GZf\
G4n+QKIwN1rdnmRG5/9AunMfH4jstVslCc4m7drTtBuxJ2ySMZO9QAhjqgZz2a+LrEnwtK3mGDfKu\
eXkAI7p7li8UTbhnBr7oJDzBv75p3sl7kyTN4Em5YKK1dlqsgeWYj8jcP6kFZT08z2SqYrYMHef1D\
0tKxU+jwC5plX5OTOeGjUmo3MgjKx3kB5IpKHXfPnc/sO2JzC8IZr5+/pYbsACOaLZa5e93oXdwyf\
kGNbV+SicY/E2VG7bjj6lkUCJLfqH8twabajqRY9Js0808EEo+JVld7qz7GxbsWs44lEO0XC9SF7R\
Tk7kGWBN+msBqS5pPE2d+n1LifIphh92RzX31FHXA0S0Wuhy7OVZ8cOV+6Bpb52+7BIEtVEtyTPsq\
z1Zipe3rLffjtvKu5ZzekCJUHwNvezP7ciFGAN9a9+70Hvs8F810t0/CN3ptr3Z9wjLvfk2nZWLCd\
DtlCv2W7ssMdenHBLCL/P37fzBwXvQ="]|>, 
   "TOC" -> {CoffeeLiqueur`Extensions`TOC`Private`heading[1, 
      "Heatmap using GPU.js", CoffeeLiqueur`Notebook`Cells`CellObj[
       CoffeeLiqueur`Notebook`Cells`CellObj`$1014]], 
     CoffeeLiqueur`Extensions`TOC`Private`heading[2, 
      "Building common module (optional)", 
      CoffeeLiqueur`Notebook`Cells`CellObj[
       CoffeeLiqueur`Notebook`Cells`CellObj`$1014]], 
     CoffeeLiqueur`Extensions`TOC`Private`heading[2, "Compute shaders", 
      CoffeeLiqueur`Notebook`Cells`CellObj[
       CoffeeLiqueur`Notebook`Cells`CellObj`$1018]], 
     CoffeeLiqueur`Extensions`TOC`Private`heading[2, "Output form", 
      CoffeeLiqueur`Notebook`Cells`CellObj[
       CoffeeLiqueur`Notebook`Cells`CellObj`$1022]], 
     CoffeeLiqueur`Extensions`TOC`Private`heading[2, "Test", 
      CoffeeLiqueur`Notebook`Cells`CellObj[
       CoffeeLiqueur`Notebook`Cells`CellObj`$1025]], 
     CoffeeLiqueur`Extensions`TOC`Private`heading[2, 
      "Integration with Graphics", CoffeeLiqueur`Notebook`Cells`CellObj[
       CoffeeLiqueur`Notebook`Cells`CellObj`$1029]], 
     CoffeeLiqueur`Extensions`TOC`Private`heading[2, "Make it dynamic", 
      CoffeeLiqueur`Notebook`Cells`CellObj[
       CoffeeLiqueur`Notebook`Cells`CellObj`$1033]]}|>, 
 "Cells" -> {<|"Data" -> ".md\n# Heatmap using GPU.js\nIn this notebook, we \
use the Javascript framework [GPU.js](https://gpu.rocks/) to compile custom \
WebGL shaders to render and animate the heatmap together with normal Wolfram \
Language graphics primitives.\n\n*All dependencies are kept within this \
notebook and do not require installation or compilation.*\n\n## Building \
common module (optional)\nWe build a simple module, which will hook up a \
CommonJS module to a global variable so that we can continue experimenting \
with compute shader code without needing to rebuild the whole thing.", 
    "Display" -> "codemirror", "Hash" -> 
     "8941fc14-d043-4cf7-8894-f5a8b0820e38", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <|"Hidden" -> True|>, 
    "PublicFields" -> {"Properties"}, "State" -> "Idle", "Type" -> "Input", 
    "UID" -> Null, "Notebook" -> "f8a44bd9-03ea-4642-979c-20bee7c21c41"|>, 
   <|"Data" -> "# Heatmap using GPU.js\nIn this notebook, we use the \
Javascript framework [GPU.js](https://gpu.rocks/) to compile custom WebGL \
shaders to render and animate the heatmap together with normal Wolfram \
Language graphics primitives.\n\n*All dependencies are kept within this \
notebook and do not require installation or compilation.*\n\n## Building \
common module (optional)\nWe build a simple module, which will hook up a \
CommonJS module to a global variable so that we can continue experimenting \
with compute shader code without needing to rebuild the whole thing.", 
    "Display" -> "markdown", "Hash" -> 
     "6fb2b4b5-af38-479d-b91e-cb289352289c", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "PublicFields" -> {"Properties"}, 
    "State" -> "Idle", "Type" -> "Output", "UID" -> Null, 
    "Notebook" -> "f8a44bd9-03ea-4642-979c-20bee7c21c41"|>, 
   <|"Data" -> ".esm\nwindow.gpuJS = require('./js/gpu.js');", 
    "Display" -> "codemirror", "Hash" -> 
     "0f3a416b-6528-4902-859a-a47753b0336a", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "PublicFields" -> {"Properties"}, 
    "State" -> "Idle", "Type" -> "Input", "UID" -> Null, 
    "Notebook" -> "f8a44bd9-03ea-4642-979c-20bee7c21c41"|>, 
   <|"Data" -> "var __getOwnPropNames = Object.getOwnPropertyNames;\nvar \
__require = /* @__PURE__ */ ((x) => typeof require !== \"undefined\" ? \
require : typeof Proxy !== \"undefined\" ? new Proxy(x, {\n  get: (a, b) => \
(typeof require !== \"undefined\" ? require : a)[b]\n}) : x)(function(x) {\n  \
if (typeof require !== \"undefined\") return require.apply(this, \
arguments);\n  throw Error('Dynamic require of \"' + x + '\" is not \
supported');\n});\nvar __commonJS = (cb, mod) => function __require2() {\n  \
return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} \
}).exports, mod), mod.exports;\n};\n\n// js/gpu.js\nvar require_gpu = \
__commonJS({\n  \"js/gpu.js\"(exports, module) {\n    !function(e) {\n      \
if (\"object\" == typeof exports && \"undefined\" != typeof module) \
module.exports = e();\n      else if (\"function\" == typeof define && \
define.amd) define([], e);\n      else {\n        (\"undefined\" != typeof \
window ? window : \"undefined\" != typeof global ? global : \"undefined\" != \
typeof self ? self : this).GPU = e();\n      }\n    }(function() {\n      \
return function e(t, r, n) {\n        function i(a2, o) {\n          if \
(!r[a2]) {\n            if (!t[a2]) {\n              var u = \"function\" == \
typeof __require && __require;\n              if (!o && u) return u(a2, \
true);\n              if (s) return s(a2, true);\n              var l = new \
Error(\"Cannot find module '\" + a2 + \"'\");\n              throw l.code = \
\"MODULE_NOT_FOUND\", l;\n            }\n            var h = r[a2] = { \
exports: {} };\n            t[a2][0].call(h.exports, function(e2) {\n         \
     return i(t[a2][1][e2] || e2);\n            }, h, h.exports, e, t, r, \
n);\n          }\n          return r[a2].exports;\n        }\n        for \
(var s = \"function\" == typeof __require && __require, a = 0; a < n.length; \
a++) i(n[a]);\n        return i;\n      }({ 1: [function(e, t, r) {\n        \
!function(e2, n) {\n          \"object\" == typeof r && void 0 !== t ? n(r) : \
n((e2 = \"undefined\" != typeof globalThis ? globalThis : e2 || self).acorn = \
{});\n        }(this, function(e2) {\n          \"use strict\";\n          \
var t2 = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, \
166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, \
14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, \
0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, \
1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, \
2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, \
16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, \
2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, \
15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, \
0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, \
5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, \
0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, \
5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, \
2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, \
13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239], r2 = \
[0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, \
48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, \
39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, \
310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, \
22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, \
2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, \
111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, \
28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, \
24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, \
24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, \
2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, \
45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, \
42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, \
16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, \
20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, \
0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, \
103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, \
1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, \
63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, \
6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, \
8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, \
3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, \
24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, \
147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, \
2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, \
3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, \
0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, \
2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, \
1507, 4938, 6, 4191], n = \
\"\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\\
u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\
\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\\
u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05D0-\\u05EA\\u05EF-\\u05F2\\u06\
20-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u\
06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07E\
A\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u0\
860-\\u086A\\u0870-\\u0887\\u0889-\\u088E\\u08A0-\\u08C9\\u0904-\\u0939\\u093\
D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\\
u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF\
-\\u09E1\\u09F0\\u09F1\\u09FC\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0\
A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\\
u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0\
AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\\
u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3\
D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u\
0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\
\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\\
u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C5D\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E\
-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDD\\u0CDE\\u\
0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D04-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\
\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\\
u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E4\
0-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\\
u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40\
-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\\
u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A\
0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\
\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u\
12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u13\
10\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\
\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\\
u1700-\\u1711\\u171F-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1\
780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1878\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\
\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\\
u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4C\\u1B83-\\u1\
BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\
\\u1C80-\\u1C8A\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CE9-\\u1CEC\\u1CEE-\\u1CF3\\\
u1CF5\\u1CF6\\u1CFA\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F\
45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\
\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u\
1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u209\
0-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u\
2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C0\
0-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\\
u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2D\
B8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005\
-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309B-\
\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\\
u31BF\\u31F0-\\u31FF\\u3400-\\u4DBF\\u4E00-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA\
60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\
\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7CD\\uA7D0\\uA7D1\\uA7D3\\uA7D5-\\u\
A7DC\\uA7F2-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA8\
73\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA8FE\\uA90A-\\uA925\\uA930-\
\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\u\
A9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA\
7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\\
uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uA\
B16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB69\\uAB70-\\uABE\
2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\
\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\\
uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50\
-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\
\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\\
uFFD7\\uFFDA-\\uFFDC\", i = { 3: \"abstract boolean byte char class double \
enum export extends final float goto implements import int interface long \
native package private protected public short static super synchronized \
throws transient volatile\", 5: \"class enum extends super const export \
import\", 6: \"enum\", strict: \"implements interface let package private \
protected public static yield\", strictBind: \"eval arguments\" }, s = \
\"break case catch continue debugger default do else finally for function if \
return switch throw try var while with null true false instanceof typeof void \
delete new in this\", a = { 5: s, \"5module\": s + \" export import\", 6: s + \
\" const class extends export import super\" }, o = /^in(stanceof)?$/, u = \
new RegExp(\"[\" + n + \"]\"), l = new RegExp(\"[\" + n + \
\"\\u200C\\u200D\\xB7\\u0300-\\u036F\\u0387\\u0483-\\u0487\\u0591-\\u05BD\\u0\
5BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u0669\\u0670\\\
u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u06F0-\\u06F9\\u07\
11\\u0730-\\u074A\\u07A6-\\u07B0\\u07C0-\\u07C9\\u07EB-\\u07F3\\u07FD\\u0816-\
\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u0897-\\\
u089F\\u08CA-\\u08E1\\u08E3-\\u0903\\u093A-\\u093C\\u093E-\\u094F\\u0951-\\u0\
957\\u0962\\u0963\\u0966-\\u096F\\u0981-\\u0983\\u09BC\\u09BE-\\u09C4\\u09C7\
\\u09C8\\u09CB-\\u09CD\\u09D7\\u09E2\\u09E3\\u09E6-\\u09EF\\u09FE\\u0A01-\\u0\
A03\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A66-\\u0A71\
\\u0A75\\u0A81-\\u0A83\\u0ABC\\u0ABE-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u\
0AE2\\u0AE3\\u0AE6-\\u0AEF\\u0AFA-\\u0AFF\\u0B01-\\u0B03\\u0B3C\\u0B3E-\\u0B4\
4\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B55-\\u0B57\\u0B62\\u0B63\\u0B66-\\u0B6F\\u\
0B82\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD7\\u0BE6-\\u0BEF\\u0C0\
0-\\u0C04\\u0C3C\\u0C3E-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\\
u0C62\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0CBC\\u0CBE-\\u0CC4\\u0CC6-\\u0C\
C8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0CE6-\\u0CEF\\u0CF3\\u0D00-\\\
u0D03\\u0D3B\\u0D3C\\u0D3E-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4D\\u0D57\\u0D6\
2\\u0D63\\u0D66-\\u0D6F\\u0D81-\\u0D83\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\\
u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0E5\
0-\\u0E59\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECE\\u0ED0-\\u0ED9\\u0F18\\u0F19\\\
u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E\\u0F3F\\u0F71-\\u0F84\\u0F86\\u0F87\
\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102B-\\u103E\\u1040-\\u1049\\u1056-\\\
u1059\\u105E-\\u1060\\u1062-\\u1064\\u1067-\\u106D\\u1071-\\u1074\\u1082-\\u1\
08D\\u108F-\\u109D\\u135D-\\u135F\\u1369-\\u1371\\u1712-\\u1715\\u1732-\\u173\
4\\u1752\\u1753\\u1772\\u1773\\u17B4-\\u17D3\\u17DD\\u17E0-\\u17E9\\u180B-\\u\
180D\\u180F-\\u1819\\u18A9\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u194F\\u19D\
0-\\u19DA\\u1A17-\\u1A1B\\u1A55-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\
\\u1A99\\u1AB0-\\u1ABD\\u1ABF-\\u1ACE\\u1B00-\\u1B04\\u1B34-\\u1B44\\u1B50-\\\
u1B59\\u1B6B-\\u1B73\\u1B80-\\u1B82\\u1BA1-\\u1BAD\\u1BB0-\\u1BB9\\u1BE6-\\u1\
BF3\\u1C24-\\u1C37\\u1C40-\\u1C49\\u1C50-\\u1C59\\u1CD0-\\u1CD2\\u1CD4-\\u1CE\
8\\u1CED\\u1CF4\\u1CF7-\\u1CF9\\u1DC0-\\u1DFF\\u200C\\u200D\\u203F\\u2040\\u2\
054\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\
\\u302A-\\u302F\\u3099\\u309A\\u30FB\\uA620-\\uA629\\uA66F\\uA674-\\uA67D\\uA\
69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA823-\\uA827\\uA82C\\uA880\\u\
A881\\uA8B4-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F1\\uA8FF-\\uA909\\uA926-\\uA9\
2D\\uA947-\\uA953\\uA980-\\uA983\\uA9B3-\\uA9C0\\uA9D0-\\uA9D9\\uA9E5\\uA9F0-\
\\uA9F9\\uAA29-\\uAA36\\uAA43\\uAA4C\\uAA4D\\uAA50-\\uAA59\\uAA7B-\\uAA7D\\uA\
AB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEB-\\uAAEF\\uAAF5\\\
uAAF6\\uABE3-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uFB1E\\uFE00-\\uFE0F\\uFE2\
0-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF10-\\uFF19\\uFF3F\\uFF65]\");\n    \
      function h(e3, t3) {\n            for (var r3 = 65536, n2 = 0; n2 < \
t3.length; n2 += 2) {\n              if ((r3 += t3[n2]) > e3) return false;\n \
             if ((r3 += t3[n2 + 1]) >= e3) return true;\n            }\n      \
      return false;\n          }\n          function c(e3, t3) {\n            \
return e3 < 65 ? 36 === e3 : e3 < 91 || (e3 < 97 ? 95 === e3 : e3 < 123 || \
(e3 <= 65535 ? e3 >= 170 && u.test(String.fromCharCode(e3)) : false !== t3 && \
h(e3, r2)));\n          }\n          function p(e3, n2) {\n            return \
e3 < 48 ? 36 === e3 : e3 < 58 || !(e3 < 65) && (e3 < 91 || (e3 < 97 ? 95 === \
e3 : e3 < 123 || (e3 <= 65535 ? e3 >= 170 && l.test(String.fromCharCode(e3)) \
: false !== n2 && (h(e3, r2) || h(e3, t2)))));\n          }\n          var d \
= function(e3, t3) {\n            void 0 === t3 && (t3 = {}), this.label = \
e3, this.keyword = t3.keyword, this.beforeExpr = !!t3.beforeExpr, \
this.startsExpr = !!t3.startsExpr, this.isLoop = !!t3.isLoop, this.isAssign = \
!!t3.isAssign, this.prefix = !!t3.prefix, this.postfix = !!t3.postfix, \
this.binop = t3.binop || null, this.updateContext = null;\n          };\n     \
     function m(e3, t3) {\n            return new d(e3, { beforeExpr: true, \
binop: t3 });\n          }\n          var f = { beforeExpr: true }, g = { \
startsExpr: true }, x = {};\n          function y(e3, t3) {\n            \
return void 0 === t3 && (t3 = {}), t3.keyword = e3, x[e3] = new d(e3, t3);\n  \
        }\n          var b = { num: new d(\"num\", g), regexp: new \
d(\"regexp\", g), string: new d(\"string\", g), name: new d(\"name\", g), \
privateId: new d(\"privateId\", g), eof: new d(\"eof\"), bracketL: new \
d(\"[\", { beforeExpr: true, startsExpr: true }), bracketR: new d(\"]\"), \
braceL: new d(\"{\", { beforeExpr: true, startsExpr: true }), braceR: new \
d(\"}\"), parenL: new d(\"(\", { beforeExpr: true, startsExpr: true }), \
parenR: new d(\")\"), comma: new d(\",\", f), semi: new d(\";\", f), colon: \
new d(\":\", f), dot: new d(\".\"), question: new d(\"?\", f), questionDot: \
new d(\"?.\"), arrow: new d(\"=>\", f), template: new d(\"template\"), \
invalidTemplate: new d(\"invalidTemplate\"), ellipsis: new d(\"...\", f), \
backQuote: new d(\"`\", g), dollarBraceL: new d(\"${\", { beforeExpr: true, \
startsExpr: true }), eq: new d(\"=\", { beforeExpr: true, isAssign: true }), \
assign: new d(\"_=\", { beforeExpr: true, isAssign: true }), incDec: new \
d(\"++/--\", { prefix: true, postfix: true, startsExpr: true }), prefix: new \
d(\"!/~\", { beforeExpr: true, prefix: true, startsExpr: true }), logicalOR: \
m(\"||\", 1), logicalAND: m(\"&&\", 2), bitwiseOR: m(\"|\", 3), bitwiseXOR: \
m(\"^\", 4), bitwiseAND: m(\"&\", 5), equality: m(\"==/!=/===/!==\", 6), \
relational: m(\"</>/<=/>=\", 7), bitShift: m(\"<</>>/>>>\", 8), plusMin: new \
d(\"+/-\", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }), \
modulo: m(\"%\", 10), star: m(\"*\", 10), slash: m(\"/\", 10), starstar: new \
d(\"**\", { beforeExpr: true }), coalesce: m(\"??\", 1), _break: \
y(\"break\"), _case: y(\"case\", f), _catch: y(\"catch\"), _continue: \
y(\"continue\"), _debugger: y(\"debugger\"), _default: y(\"default\", f), \
_do: y(\"do\", { isLoop: true, beforeExpr: true }), _else: y(\"else\", f), \
_finally: y(\"finally\"), _for: y(\"for\", { isLoop: true }), _function: \
y(\"function\", g), _if: y(\"if\"), _return: y(\"return\", f), _switch: \
y(\"switch\"), _throw: y(\"throw\", f), _try: y(\"try\"), _var: y(\"var\"), \
_const: y(\"const\"), _while: y(\"while\", { isLoop: true }), _with: \
y(\"with\"), _new: y(\"new\", { beforeExpr: true, startsExpr: true }), _this: \
y(\"this\", g), _super: y(\"super\", g), _class: y(\"class\", g), _extends: \
y(\"extends\", f), _export: y(\"export\"), _import: y(\"import\", g), _null: \
y(\"null\", g), _true: y(\"true\", g), _false: y(\"false\", g), _in: \
y(\"in\", { beforeExpr: true, binop: 7 }), _instanceof: y(\"instanceof\", { \
beforeExpr: true, binop: 7 }), _typeof: y(\"typeof\", { beforeExpr: true, \
prefix: true, startsExpr: true }), _void: y(\"void\", { beforeExpr: true, \
prefix: true, startsExpr: true }), _delete: y(\"delete\", { beforeExpr: true, \
prefix: true, startsExpr: true }) }, T = /\\r\\n?|\\n|\\u2028|\\u2029/, v = \
new RegExp(T.source, \"g\");\n          function S(e3) {\n            return \
10 === e3 || 13 === e3 || 8232 === e3 || 8233 === e3;\n          }\n          \
function A(e3, t3, r3) {\n            void 0 === r3 && (r3 = e3.length);\n    \
        for (var n2 = t3; n2 < r3; n2++) {\n              var i2 = \
e3.charCodeAt(n2);\n              if (S(i2)) return n2 < r3 - 1 && 13 === i2 \
&& 10 === e3.charCodeAt(n2 + 1) ? n2 + 2 : n2 + 1;\n            }\n           \
 return -1;\n          }\n          var _ = \
/[\\u1680\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/, E = \
/(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g, w = Object.prototype, k = \
w.hasOwnProperty, I = w.toString, D = Object.hasOwn || function(e3, t3) {\n   \
         return k.call(e3, t3);\n          }, C = Array.isArray || \
function(e3) {\n            return \"[object Array]\" === I.call(e3);\n       \
   }, $ = /* @__PURE__ */ Object.create(null);\n          function L(e3) {\n  \
          return $[e3] || ($[e3] = new RegExp(\"^(?:\" + e3.replace(/ /g, \
\"|\") + \")$\"));\n          }\n          function R(e3) {\n            \
return e3 <= 65535 ? String.fromCharCode(e3) : (e3 -= 65536, \
String.fromCharCode(55296 + (e3 >> 10), 56320 + (1023 & e3)));\n          }\n \
         var F = \
/(?:[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\
\\uDFFF])/, N = function(e3, t3) {\n            this.line = e3, this.column = \
t3;\n          };\n          N.prototype.offset = function(e3) {\n            \
return new N(this.line, this.column + e3);\n          };\n          var V = \
function(e3, t3, r3) {\n            this.start = t3, this.end = r3, null !== \
e3.sourceFile && (this.source = e3.sourceFile);\n          };\n          \
function M(e3, t3) {\n            for (var r3 = 1, n2 = 0; ; ) {\n            \
  var i2 = A(e3, n2, t3);\n              if (i2 < 0) return new N(r3, t3 - \
n2);\n              ++r3, n2 = i2;\n            }\n          }\n          var \
O = { ecmaVersion: null, sourceType: \"script\", onInsertedSemicolon: null, \
onTrailingComma: null, allowReserved: null, allowReturnOutsideFunction: \
false, allowImportExportEverywhere: false, allowAwaitOutsideFunction: null, \
allowSuperOutsideMethod: null, allowHashBang: false, checkPrivateFields: \
true, locations: false, onToken: null, onComment: null, ranges: false, \
program: null, sourceFile: null, directSourceFile: null, preserveParens: \
false }, z = false;\n          function P(e3) {\n            var t3 = {};\n   \
         for (var r3 in O) t3[r3] = e3 && D(e3, r3) ? e3[r3] : O[r3];\n       \
     if (\"latest\" === t3.ecmaVersion ? t3.ecmaVersion = 1e8 : null == \
t3.ecmaVersion ? (!z && \"object\" == typeof console && console.warn && (z = \
true, console.warn(\"Since Acorn 8.0.0, options.ecmaVersion is \
required.\\nDefaulting to 2020, but this will stop working in the \
future.\")), t3.ecmaVersion = 11) : t3.ecmaVersion >= 2015 && (t3.ecmaVersion \
-= 2009), null == t3.allowReserved && (t3.allowReserved = t3.ecmaVersion < \
5), e3 && null != e3.allowHashBang || (t3.allowHashBang = t3.ecmaVersion >= \
14), C(t3.onToken)) {\n              var n2 = t3.onToken;\n              \
t3.onToken = function(e4) {\n                return n2.push(e4);\n            \
  };\n            }\n            return C(t3.onComment) && (t3.onComment = /* \
@__PURE__ */ function(e4, t4) {\n              return function(r4, n3, i2, \
s2, a2, o2) {\n                var u2 = { type: r4 ? \"Block\" : \"Line\", \
value: n3, start: i2, end: s2 };\n                e4.locations && (u2.loc = \
new V(this, a2, o2)), e4.ranges && (u2.range = [i2, s2]), t4.push(u2);\n      \
        };\n            }(t3, t3.onComment)), t3;\n          }\n          var \
K = 256;\n          function G(e3, t3) {\n            return 2 | (e3 ? 4 : 0) \
| (t3 ? 8 : 0);\n          }\n          var U = function(e3, t3, r3) {\n      \
      this.options = e3 = P(e3), this.sourceFile = e3.sourceFile, \
this.keywords = L(a[e3.ecmaVersion >= 6 ? 6 : \"module\" === e3.sourceType ? \
\"5module\" : 5]);\n            var n2 = \"\";\n            true !== \
e3.allowReserved && (n2 = i[e3.ecmaVersion >= 6 ? 6 : 5 === e3.ecmaVersion ? \
5 : 3], \"module\" === e3.sourceType && (n2 += \" await\")), \
this.reservedWords = L(n2);\n            var s2 = (n2 ? n2 + \" \" : \"\") + \
i.strict;\n            this.reservedWordsStrict = L(s2), \
this.reservedWordsStrictBind = L(s2 + \" \" + i.strictBind), this.input = \
String(t3), this.containsEsc = false, r3 ? (this.pos = r3, this.lineStart = \
this.input.lastIndexOf(\"\\n\", r3 - 1) + 1, this.curLine = \
this.input.slice(0, this.lineStart).split(T).length) : (this.pos = \
this.lineStart = 0, this.curLine = 1), this.type = b.eof, this.value = null, \
this.start = this.end = this.pos, this.startLoc = this.endLoc = \
this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, \
this.lastTokStart = this.lastTokEnd = this.pos, this.context = \
this.initialContext(), this.exprAllowed = true, this.inModule = \"module\" \
=== e3.sourceType, this.strict = this.inModule || \
this.strictDirective(this.pos), this.potentialArrowAt = -1, \
this.potentialArrowInForAwait = false, this.yieldPos = this.awaitPos = \
this.awaitIdentPos = 0, this.labels = [], this.undefinedExports = /* \
@__PURE__ */ Object.create(null), 0 === this.pos && e3.allowHashBang && \
\"#!\" === this.input.slice(0, 2) && this.skipLineComment(2), this.scopeStack \
= [], this.enterScope(1), this.regexpState = null, this.privateNameStack = \
[];\n          }, B = { inFunction: { configurable: true }, inGenerator: { \
configurable: true }, inAsync: { configurable: true }, canAwait: { \
configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { \
configurable: true }, treatFunctionsAsVar: { configurable: true }, \
allowNewDotTarget: { configurable: true }, inClassStaticBlock: { \
configurable: true } };\n          U.prototype.parse = function() {\n         \
   var e3 = this.options.program || this.startNode();\n            return \
this.nextToken(), this.parseTopLevel(e3);\n          }, B.inFunction.get = \
function() {\n            return (2 & this.currentVarScope().flags) > 0;\n    \
      }, B.inGenerator.get = function() {\n            return (8 & \
this.currentVarScope().flags) > 0 && \
!this.currentVarScope().inClassFieldInit;\n          }, B.inAsync.get = \
function() {\n            return (4 & this.currentVarScope().flags) > 0 && \
!this.currentVarScope().inClassFieldInit;\n          }, B.canAwait.get = \
function() {\n            for (var e3 = this.scopeStack.length - 1; e3 >= 0; \
e3--) {\n              var t3 = this.scopeStack[e3];\n              if \
(t3.inClassFieldInit || t3.flags & K) return false;\n              if (2 & \
t3.flags) return (4 & t3.flags) > 0;\n            }\n            return \
this.inModule && this.options.ecmaVersion >= 13 || \
this.options.allowAwaitOutsideFunction;\n          }, B.allowSuper.get = \
function() {\n            var e3 = this.currentThisScope(), t3 = e3.flags, r3 \
= e3.inClassFieldInit;\n            return (64 & t3) > 0 || r3 || \
this.options.allowSuperOutsideMethod;\n          }, B.allowDirectSuper.get = \
function() {\n            return (128 & this.currentThisScope().flags) > 0;\n \
         }, B.treatFunctionsAsVar.get = function() {\n            return \
this.treatFunctionsAsVarInScope(this.currentScope());\n          }, \
B.allowNewDotTarget.get = function() {\n            var e3 = \
this.currentThisScope(), t3 = e3.flags, r3 = e3.inClassFieldInit;\n           \
 return (258 & t3) > 0 || r3;\n          }, B.inClassStaticBlock.get = \
function() {\n            return (this.currentVarScope().flags & K) > 0;\n    \
      }, U.extend = function() {\n            for (var e3 = [], t3 = \
arguments.length; t3--; ) e3[t3] = arguments[t3];\n            for (var r3 = \
this, n2 = 0; n2 < e3.length; n2++) r3 = e3[n2](r3);\n            return \
r3;\n          }, U.parse = function(e3, t3) {\n            return new \
this(t3, e3).parse();\n          }, U.parseExpressionAt = function(e3, t3, \
r3) {\n            var n2 = new this(r3, e3, t3);\n            return \
n2.nextToken(), n2.parseExpression();\n          }, U.tokenizer = \
function(e3, t3) {\n            return new this(t3, e3);\n          }, \
Object.defineProperties(U.prototype, B);\n          var W = U.prototype, j = \
/^(?:'((?:\\\\[^]|[^'\\\\])*?)'|\"((?:\\\\[^]|[^\"\\\\])*?)\")/;\n          \
W.strictDirective = function(e3) {\n            if (this.options.ecmaVersion \
< 5) return false;\n            for (; ; ) {\n              E.lastIndex = e3, \
e3 += E.exec(this.input)[0].length;\n              var t3 = \
j.exec(this.input.slice(e3));\n              if (!t3) return false;\n         \
     if (\"use strict\" === (t3[1] || t3[2])) {\n                E.lastIndex \
= e3 + t3[0].length;\n                var r3 = E.exec(this.input), n2 = \
r3.index + r3[0].length, i2 = this.input.charAt(n2);\n                return \
\";\" === i2 || \"}\" === i2 || T.test(r3[0]) && \
!(/[(`.[+\\-/*%<>=,?^&]/.test(i2) || \"!\" === i2 && \"=\" === \
this.input.charAt(n2 + 1));\n              }\n              e3 += \
t3[0].length, E.lastIndex = e3, e3 += E.exec(this.input)[0].length, \";\" === \
this.input[e3] && e3++;\n            }\n          }, W.eat = function(e3) {\n \
           return this.type === e3 && (this.next(), true);\n          }, \
W.isContextual = function(e3) {\n            return this.type === b.name && \
this.value === e3 && !this.containsEsc;\n          }, W.eatContextual = \
function(e3) {\n            return !!this.isContextual(e3) && (this.next(), \
true);\n          }, W.expectContextual = function(e3) {\n            \
this.eatContextual(e3) || this.unexpected();\n          }, \
W.canInsertSemicolon = function() {\n            return this.type === b.eof \
|| this.type === b.braceR || T.test(this.input.slice(this.lastTokEnd, \
this.start));\n          }, W.insertSemicolon = function() {\n            if \
(this.canInsertSemicolon()) return this.options.onInsertedSemicolon && \
this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), \
true;\n          }, W.semicolon = function() {\n            this.eat(b.semi) \
|| this.insertSemicolon() || this.unexpected();\n          }, \
W.afterTrailingComma = function(e3, t3) {\n            if (this.type === e3) \
return this.options.onTrailingComma && \
this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), t3 || \
this.next(), true;\n          }, W.expect = function(e3) {\n            \
this.eat(e3) || this.unexpected();\n          }, W.unexpected = function(e3) \
{\n            this.raise(null != e3 ? e3 : this.start, \"Unexpected \
token\");\n          };\n          var H = function() {\n            \
this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = \
this.parenthesizedBind = this.doubleProto = -1;\n          };\n          \
W.checkPatternErrors = function(e3, t3) {\n            if (e3) {\n            \
  e3.trailingComma > -1 && this.raiseRecoverable(e3.trailingComma, \"Comma is \
not permitted after the rest element\");\n              var r3 = t3 ? \
e3.parenthesizedAssign : e3.parenthesizedBind;\n              r3 > -1 && \
this.raiseRecoverable(r3, t3 ? \"Assigning to rvalue\" : \"Parenthesized \
pattern\");\n            }\n          }, W.checkExpressionErrors = \
function(e3, t3) {\n            if (!e3) return false;\n            var r3 = \
e3.shorthandAssign, n2 = e3.doubleProto;\n            if (!t3) return r3 >= 0 \
|| n2 >= 0;\n            r3 >= 0 && this.raise(r3, \"Shorthand property \
assignments are valid only in destructuring patterns\"), n2 >= 0 && \
this.raiseRecoverable(n2, \"Redefinition of __proto__ property\");\n          \
}, W.checkYieldAwaitInDefaultParams = function() {\n            this.yieldPos \
&& (!this.awaitPos || this.yieldPos < this.awaitPos) && \
this.raise(this.yieldPos, \"Yield expression cannot be a default value\"), \
this.awaitPos && this.raise(this.awaitPos, \"Await expression cannot be a \
default value\");\n          }, W.isSimpleAssignTarget = function(e3) {\n     \
       return \"ParenthesizedExpression\" === e3.type ? \
this.isSimpleAssignTarget(e3.expression) : \"Identifier\" === e3.type || \
\"MemberExpression\" === e3.type;\n          };\n          var X = \
U.prototype;\n          X.parseTopLevel = function(e3) {\n            var t3 \
= /* @__PURE__ */ Object.create(null);\n            for (e3.body || (e3.body \
= []); this.type !== b.eof; ) {\n              var r3 = \
this.parseStatement(null, true, t3);\n              e3.body.push(r3);\n       \
     }\n            if (this.inModule) for (var n2 = 0, i2 = \
Object.keys(this.undefinedExports); n2 < i2.length; n2 += 1) {\n              \
var s2 = i2[n2];\n              \
this.raiseRecoverable(this.undefinedExports[s2].start, \"Export '\" + s2 + \
\"' is not defined\");\n            }\n            return \
this.adaptDirectivePrologue(e3.body), this.next(), e3.sourceType = \
this.options.sourceType, this.finishNode(e3, \"Program\");\n          };\n    \
      var q = { kind: \"loop\" }, Y = { kind: \"switch\" };\n          \
X.isLet = function(e3) {\n            if (this.options.ecmaVersion < 6 || \
!this.isContextual(\"let\")) return false;\n            E.lastIndex = \
this.pos;\n            var t3 = E.exec(this.input), r3 = this.pos + \
t3[0].length, n2 = this.input.charCodeAt(r3);\n            if (91 === n2 || \
92 === n2) return true;\n            if (e3) return false;\n            if \
(123 === n2 || n2 > 55295 && n2 < 56320) return true;\n            if (c(n2, \
true)) {\n              for (var i2 = r3 + 1; p(n2 = \
this.input.charCodeAt(i2), true); ) ++i2;\n              if (92 === n2 || n2 \
> 55295 && n2 < 56320) return true;\n              var s2 = \
this.input.slice(r3, i2);\n              if (!o.test(s2)) return true;\n      \
      }\n            return false;\n          }, X.isAsyncFunction = \
function() {\n            if (this.options.ecmaVersion < 8 || \
!this.isContextual(\"async\")) return false;\n            E.lastIndex = \
this.pos;\n            var e3, t3 = E.exec(this.input), r3 = this.pos + \
t3[0].length;\n            return !(T.test(this.input.slice(this.pos, r3)) || \
\"function\" !== this.input.slice(r3, r3 + 8) || r3 + 8 !== this.input.length \
&& (p(e3 = this.input.charCodeAt(r3 + 8)) || e3 > 55295 && e3 < 56320));\n    \
      }, X.parseStatement = function(e3, t3, r3) {\n            var n2, i2 = \
this.type, s2 = this.startNode();\n            switch (this.isLet(e3) && (i2 \
= b._var, n2 = \"let\"), i2) {\n              case b._break:\n              \
case b._continue:\n                return \
this.parseBreakContinueStatement(s2, i2.keyword);\n              case \
b._debugger:\n                return this.parseDebuggerStatement(s2);\n       \
       case b._do:\n                return this.parseDoStatement(s2);\n       \
       case b._for:\n                return this.parseForStatement(s2);\n     \
         case b._function:\n                return e3 && (this.strict || \
\"if\" !== e3 && \"label\" !== e3) && this.options.ecmaVersion >= 6 && \
this.unexpected(), this.parseFunctionStatement(s2, false, !e3);\n             \
 case b._class:\n                return e3 && this.unexpected(), \
this.parseClass(s2, true);\n              case b._if:\n                return \
this.parseIfStatement(s2);\n              case b._return:\n                \
return this.parseReturnStatement(s2);\n              case b._switch:\n        \
        return this.parseSwitchStatement(s2);\n              case b._throw:\n \
               return this.parseThrowStatement(s2);\n              case \
b._try:\n                return this.parseTryStatement(s2);\n              \
case b._const:\n              case b._var:\n                return n2 = n2 || \
this.value, e3 && \"var\" !== n2 && this.unexpected(), \
this.parseVarStatement(s2, n2);\n              case b._while:\n               \
 return this.parseWhileStatement(s2);\n              case b._with:\n          \
      return this.parseWithStatement(s2);\n              case b.braceL:\n     \
           return this.parseBlock(true, s2);\n              case b.semi:\n    \
            return this.parseEmptyStatement(s2);\n              case \
b._export:\n              case b._import:\n                if \
(this.options.ecmaVersion > 10 && i2 === b._import) {\n                  \
E.lastIndex = this.pos;\n                  var a2 = E.exec(this.input), o2 = \
this.pos + a2[0].length, u2 = this.input.charCodeAt(o2);\n                  \
if (40 === u2 || 46 === u2) return this.parseExpressionStatement(s2, \
this.parseExpression());\n                }\n                return \
this.options.allowImportExportEverywhere || (t3 || this.raise(this.start, \
\"'import' and 'export' may only appear at the top level\"), this.inModule || \
this.raise(this.start, \"'import' and 'export' may appear only with \
'sourceType: module'\")), i2 === b._import ? this.parseImport(s2) : \
this.parseExport(s2, r3);\n              default:\n                if \
(this.isAsyncFunction()) return e3 && this.unexpected(), this.next(), \
this.parseFunctionStatement(s2, true, !e3);\n                var l2 = \
this.value, h2 = this.parseExpression();\n                return i2 === \
b.name && \"Identifier\" === h2.type && this.eat(b.colon) ? \
this.parseLabeledStatement(s2, l2, h2, e3) : \
this.parseExpressionStatement(s2, h2);\n            }\n          }, \
X.parseBreakContinueStatement = function(e3, t3) {\n            var r3 = \
\"break\" === t3;\n            this.next(), this.eat(b.semi) || \
this.insertSemicolon() ? e3.label = null : this.type !== b.name ? \
this.unexpected() : (e3.label = this.parseIdent(), this.semicolon());\n       \
     for (var n2 = 0; n2 < this.labels.length; ++n2) {\n              var i2 \
= this.labels[n2];\n              if (null == e3.label || i2.name === \
e3.label.name) {\n                if (null != i2.kind && (r3 || \"loop\" === \
i2.kind)) break;\n                if (e3.label && r3) break;\n              \
}\n            }\n            return n2 === this.labels.length && \
this.raise(e3.start, \"Unsyntactic \" + t3), this.finishNode(e3, r3 ? \
\"BreakStatement\" : \"ContinueStatement\");\n          }, \
X.parseDebuggerStatement = function(e3) {\n            return this.next(), \
this.semicolon(), this.finishNode(e3, \"DebuggerStatement\");\n          }, \
X.parseDoStatement = function(e3) {\n            return this.next(), \
this.labels.push(q), e3.body = this.parseStatement(\"do\"), \
this.labels.pop(), this.expect(b._while), e3.test = \
this.parseParenExpression(), this.options.ecmaVersion >= 6 ? this.eat(b.semi) \
: this.semicolon(), this.finishNode(e3, \"DoWhileStatement\");\n          }, \
X.parseForStatement = function(e3) {\n            this.next();\n            \
var t3 = this.options.ecmaVersion >= 9 && this.canAwait && \
this.eatContextual(\"await\") ? this.lastTokStart : -1;\n            if \
(this.labels.push(q), this.enterScope(0), this.expect(b.parenL), this.type \
=== b.semi) return t3 > -1 && this.unexpected(t3), this.parseFor(e3, null);\n \
           var r3 = this.isLet();\n            if (this.type === b._var || \
this.type === b._const || r3) {\n              var n2 = this.startNode(), i2 \
= r3 ? \"let\" : this.value;\n              return this.next(), \
this.parseVar(n2, true, i2), this.finishNode(n2, \"VariableDeclaration\"), \
(this.type === b._in || this.options.ecmaVersion >= 6 && \
this.isContextual(\"of\")) && 1 === n2.declarations.length ? \
(this.options.ecmaVersion >= 9 && (this.type === b._in ? t3 > -1 && \
this.unexpected(t3) : e3.await = t3 > -1), this.parseForIn(e3, n2)) : (t3 > \
-1 && this.unexpected(t3), this.parseFor(e3, n2));\n            }\n           \
 var s2 = this.isContextual(\"let\"), a2 = false, o2 = this.containsEsc, u2 = \
new H(), l2 = this.start, h2 = t3 > -1 ? this.parseExprSubscripts(u2, \
\"await\") : this.parseExpression(true, u2);\n            return this.type \
=== b._in || (a2 = this.options.ecmaVersion >= 6 && \
this.isContextual(\"of\")) ? (t3 > -1 ? (this.type === b._in && \
this.unexpected(t3), e3.await = true) : a2 && this.options.ecmaVersion >= 8 \
&& (h2.start !== l2 || o2 || \"Identifier\" !== h2.type || \"async\" !== \
h2.name ? this.options.ecmaVersion >= 9 && (e3.await = false) : \
this.unexpected()), s2 && a2 && this.raise(h2.start, \"The left-hand side of \
a for-of loop may not start with 'let'.\"), this.toAssignable(h2, false, u2), \
this.checkLValPattern(h2), this.parseForIn(e3, h2)) : \
(this.checkExpressionErrors(u2, true), t3 > -1 && this.unexpected(t3), \
this.parseFor(e3, h2));\n          }, X.parseFunctionStatement = function(e3, \
t3, r3) {\n            return this.next(), this.parseFunction(e3, J | (r3 ? 0 \
: Q), false, t3);\n          }, X.parseIfStatement = function(e3) {\n         \
   return this.next(), e3.test = this.parseParenExpression(), e3.consequent = \
this.parseStatement(\"if\"), e3.alternate = this.eat(b._else) ? \
this.parseStatement(\"if\") : null, this.finishNode(e3, \"IfStatement\");\n   \
       }, X.parseReturnStatement = function(e3) {\n            return \
this.inFunction || this.options.allowReturnOutsideFunction || \
this.raise(this.start, \"'return' outside of function\"), this.next(), \
this.eat(b.semi) || this.insertSemicolon() ? e3.argument = null : \
(e3.argument = this.parseExpression(), this.semicolon()), this.finishNode(e3, \
\"ReturnStatement\");\n          }, X.parseSwitchStatement = function(e3) {\n \
           var t3;\n            this.next(), e3.discriminant = \
this.parseParenExpression(), e3.cases = [], this.expect(b.braceL), \
this.labels.push(Y), this.enterScope(0);\n            for (var r3 = false; \
this.type !== b.braceR; ) if (this.type === b._case || this.type === \
b._default) {\n              var n2 = this.type === b._case;\n              \
t3 && this.finishNode(t3, \"SwitchCase\"), e3.cases.push(t3 = \
this.startNode()), t3.consequent = [], this.next(), n2 ? t3.test = \
this.parseExpression() : (r3 && this.raiseRecoverable(this.lastTokStart, \
\"Multiple default clauses\"), r3 = true, t3.test = null), \
this.expect(b.colon);\n            } else t3 || this.unexpected(), \
t3.consequent.push(this.parseStatement(null));\n            return \
this.exitScope(), t3 && this.finishNode(t3, \"SwitchCase\"), this.next(), \
this.labels.pop(), this.finishNode(e3, \"SwitchStatement\");\n          }, \
X.parseThrowStatement = function(e3) {\n            return this.next(), \
T.test(this.input.slice(this.lastTokEnd, this.start)) && \
this.raise(this.lastTokEnd, \"Illegal newline after throw\"), e3.argument = \
this.parseExpression(), this.semicolon(), this.finishNode(e3, \
\"ThrowStatement\");\n          };\n          var Z = [];\n          \
X.parseCatchClauseParam = function() {\n            var e3 = \
this.parseBindingAtom(), t3 = \"Identifier\" === e3.type;\n            return \
this.enterScope(t3 ? 32 : 0), this.checkLValPattern(e3, t3 ? 4 : 2), \
this.expect(b.parenR), e3;\n          }, X.parseTryStatement = function(e3) \
{\n            if (this.next(), e3.block = this.parseBlock(), e3.handler = \
null, this.type === b._catch) {\n              var t3 = this.startNode();\n   \
           this.next(), this.eat(b.parenL) ? t3.param = \
this.parseCatchClauseParam() : (this.options.ecmaVersion < 10 && \
this.unexpected(), t3.param = null, this.enterScope(0)), t3.body = \
this.parseBlock(false), this.exitScope(), e3.handler = this.finishNode(t3, \
\"CatchClause\");\n            }\n            return e3.finalizer = \
this.eat(b._finally) ? this.parseBlock() : null, e3.handler || e3.finalizer \
|| this.raise(e3.start, \"Missing catch or finally clause\"), \
this.finishNode(e3, \"TryStatement\");\n          }, X.parseVarStatement = \
function(e3, t3, r3) {\n            return this.next(), this.parseVar(e3, \
false, t3, r3), this.semicolon(), this.finishNode(e3, \
\"VariableDeclaration\");\n          }, X.parseWhileStatement = function(e3) \
{\n            return this.next(), e3.test = this.parseParenExpression(), \
this.labels.push(q), e3.body = this.parseStatement(\"while\"), \
this.labels.pop(), this.finishNode(e3, \"WhileStatement\");\n          }, \
X.parseWithStatement = function(e3) {\n            return this.strict && \
this.raise(this.start, \"'with' in strict mode\"), this.next(), e3.object = \
this.parseParenExpression(), e3.body = this.parseStatement(\"with\"), \
this.finishNode(e3, \"WithStatement\");\n          }, X.parseEmptyStatement = \
function(e3) {\n            return this.next(), this.finishNode(e3, \
\"EmptyStatement\");\n          }, X.parseLabeledStatement = function(e3, t3, \
r3, n2) {\n            for (var i2 = 0, s2 = this.labels; i2 < s2.length; i2 \
+= 1) {\n              s2[i2].name === t3 && this.raise(r3.start, \"Label '\" \
+ t3 + \"' is already declared\");\n            }\n            for (var a2 = \
this.type.isLoop ? \"loop\" : this.type === b._switch ? \"switch\" : null, o2 \
= this.labels.length - 1; o2 >= 0; o2--) {\n              var u2 = \
this.labels[o2];\n              if (u2.statementStart !== e3.start) break;\n  \
            u2.statementStart = this.start, u2.kind = a2;\n            }\n    \
        return this.labels.push({ name: t3, kind: a2, statementStart: \
this.start }), e3.body = this.parseStatement(n2 ? -1 === \
n2.indexOf(\"label\") ? n2 + \"label\" : n2 : \"label\"), this.labels.pop(), \
e3.label = r3, this.finishNode(e3, \"LabeledStatement\");\n          }, \
X.parseExpressionStatement = function(e3, t3) {\n            return \
e3.expression = t3, this.semicolon(), this.finishNode(e3, \
\"ExpressionStatement\");\n          }, X.parseBlock = function(e3, t3, r3) \
{\n            for (void 0 === e3 && (e3 = true), void 0 === t3 && (t3 = \
this.startNode()), t3.body = [], this.expect(b.braceL), e3 && \
this.enterScope(0); this.type !== b.braceR; ) {\n              var n2 = \
this.parseStatement(null);\n              t3.body.push(n2);\n            }\n  \
          return r3 && (this.strict = false), this.next(), e3 && \
this.exitScope(), this.finishNode(t3, \"BlockStatement\");\n          }, \
X.parseFor = function(e3, t3) {\n            return e3.init = t3, \
this.expect(b.semi), e3.test = this.type === b.semi ? null : \
this.parseExpression(), this.expect(b.semi), e3.update = this.type === \
b.parenR ? null : this.parseExpression(), this.expect(b.parenR), e3.body = \
this.parseStatement(\"for\"), this.exitScope(), this.labels.pop(), \
this.finishNode(e3, \"ForStatement\");\n          }, X.parseForIn = \
function(e3, t3) {\n            var r3 = this.type === b._in;\n            \
return this.next(), \"VariableDeclaration\" === t3.type && null != \
t3.declarations[0].init && (!r3 || this.options.ecmaVersion < 8 || \
this.strict || \"var\" !== t3.kind || \"Identifier\" !== \
t3.declarations[0].id.type) && this.raise(t3.start, (r3 ? \"for-in\" : \
\"for-of\") + \" loop variable declaration may not have an initializer\"), \
e3.left = t3, e3.right = r3 ? this.parseExpression() : \
this.parseMaybeAssign(), this.expect(b.parenR), e3.body = \
this.parseStatement(\"for\"), this.exitScope(), this.labels.pop(), \
this.finishNode(e3, r3 ? \"ForInStatement\" : \"ForOfStatement\");\n          \
}, X.parseVar = function(e3, t3, r3, n2) {\n            for (e3.declarations \
= [], e3.kind = r3; ; ) {\n              var i2 = this.startNode();\n         \
     if (this.parseVarId(i2, r3), this.eat(b.eq) ? i2.init = \
this.parseMaybeAssign(t3) : n2 || \"const\" !== r3 || this.type === b._in || \
this.options.ecmaVersion >= 6 && this.isContextual(\"of\") ? n2 || \
\"Identifier\" === i2.id.type || t3 && (this.type === b._in || \
this.isContextual(\"of\")) ? i2.init = null : this.raise(this.lastTokEnd, \
\"Complex binding patterns require an initialization value\") : \
this.unexpected(), e3.declarations.push(this.finishNode(i2, \
\"VariableDeclarator\")), !this.eat(b.comma)) break;\n            }\n         \
   return e3;\n          }, X.parseVarId = function(e3, t3) {\n            \
e3.id = this.parseBindingAtom(), this.checkLValPattern(e3.id, \"var\" === t3 \
? 1 : 2, false);\n          };\n          var J = 1, Q = 2;\n          \
function ee(e3, t3) {\n            var r3 = t3.key.name, n2 = e3[r3], i2 = \
\"true\";\n            return \"MethodDefinition\" !== t3.type || \"get\" !== \
t3.kind && \"set\" !== t3.kind || (i2 = (t3.static ? \"s\" : \"i\") + \
t3.kind), \"iget\" === n2 && \"iset\" === i2 || \"iset\" === n2 && \"iget\" \
=== i2 || \"sget\" === n2 && \"sset\" === i2 || \"sset\" === n2 && \"sget\" \
=== i2 ? (e3[r3] = \"true\", false) : !!n2 || (e3[r3] = i2, false);\n         \
 }\n          function te(e3, t3) {\n            var r3 = e3.computed, n2 = \
e3.key;\n            return !r3 && (\"Identifier\" === n2.type && n2.name === \
t3 || \"Literal\" === n2.type && n2.value === t3);\n          }\n          \
X.parseFunction = function(e3, t3, r3, n2, i2) {\n            \
this.initFunction(e3), (this.options.ecmaVersion >= 9 || \
this.options.ecmaVersion >= 6 && !n2) && (this.type === b.star && t3 & Q && \
this.unexpected(), e3.generator = this.eat(b.star)), this.options.ecmaVersion \
>= 8 && (e3.async = !!n2), t3 & J && (e3.id = 4 & t3 && this.type !== b.name \
? null : this.parseIdent(), !e3.id || t3 & Q || this.checkLValSimple(e3.id, \
this.strict || e3.generator || e3.async ? this.treatFunctionsAsVar ? 1 : 2 : \
3));\n            var s2 = this.yieldPos, a2 = this.awaitPos, o2 = \
this.awaitIdentPos;\n            return this.yieldPos = 0, this.awaitPos = 0, \
this.awaitIdentPos = 0, this.enterScope(G(e3.async, e3.generator)), t3 & J || \
(e3.id = this.type === b.name ? this.parseIdent() : null), \
this.parseFunctionParams(e3), this.parseFunctionBody(e3, r3, false, i2), \
this.yieldPos = s2, this.awaitPos = a2, this.awaitIdentPos = o2, \
this.finishNode(e3, t3 & J ? \"FunctionDeclaration\" : \
\"FunctionExpression\");\n          }, X.parseFunctionParams = function(e3) \
{\n            this.expect(b.parenL), e3.params = \
this.parseBindingList(b.parenR, false, this.options.ecmaVersion >= 8), \
this.checkYieldAwaitInDefaultParams();\n          }, X.parseClass = \
function(e3, t3) {\n            this.next();\n            var r3 = \
this.strict;\n            this.strict = true, this.parseClassId(e3, t3), \
this.parseClassSuper(e3);\n            var n2 = this.enterClassBody(), i2 = \
this.startNode(), s2 = false;\n            for (i2.body = [], \
this.expect(b.braceL); this.type !== b.braceR; ) {\n              var a2 = \
this.parseClassElement(null !== e3.superClass);\n              a2 && \
(i2.body.push(a2), \"MethodDefinition\" === a2.type && \"constructor\" === \
a2.kind ? (s2 && this.raiseRecoverable(a2.start, \"Duplicate constructor in \
the same class\"), s2 = true) : a2.key && \"PrivateIdentifier\" === \
a2.key.type && ee(n2, a2) && this.raiseRecoverable(a2.key.start, \"Identifier \
'#\" + a2.key.name + \"' has already been declared\"));\n            }\n      \
      return this.strict = r3, this.next(), e3.body = this.finishNode(i2, \
\"ClassBody\"), this.exitClassBody(), this.finishNode(e3, t3 ? \
\"ClassDeclaration\" : \"ClassExpression\");\n          }, \
X.parseClassElement = function(e3) {\n            if (this.eat(b.semi)) \
return null;\n            var t3 = this.options.ecmaVersion, r3 = \
this.startNode(), n2 = \"\", i2 = false, s2 = false, a2 = \"method\", o2 = \
false;\n            if (this.eatContextual(\"static\")) {\n              if \
(t3 >= 13 && this.eat(b.braceL)) return this.parseClassStaticBlock(r3), r3;\n \
             this.isClassElementNameStart() || this.type === b.star ? o2 = \
true : n2 = \"static\";\n            }\n            if (r3.static = o2, !n2 \
&& t3 >= 8 && this.eatContextual(\"async\") && \
(!this.isClassElementNameStart() && this.type !== b.star || \
this.canInsertSemicolon() ? n2 = \"async\" : s2 = true), !n2 && (t3 >= 9 || \
!s2) && this.eat(b.star) && (i2 = true), !n2 && !s2 && !i2) {\n              \
var u2 = this.value;\n              (this.eatContextual(\"get\") || \
this.eatContextual(\"set\")) && (this.isClassElementNameStart() ? a2 = u2 : \
n2 = u2);\n            }\n            if (n2 ? (r3.computed = false, r3.key = \
this.startNodeAt(this.lastTokStart, this.lastTokStartLoc), r3.key.name = n2, \
this.finishNode(r3.key, \"Identifier\")) : this.parseClassElementName(r3), t3 \
< 13 || this.type === b.parenL || \"method\" !== a2 || i2 || s2) {\n          \
    var l2 = !r3.static && te(r3, \"constructor\"), h2 = l2 && e3;\n          \
    l2 && \"method\" !== a2 && this.raise(r3.key.start, \"Constructor can't \
have get/set modifier\"), r3.kind = l2 ? \"constructor\" : a2, \
this.parseClassMethod(r3, i2, s2, h2);\n            } else \
this.parseClassField(r3);\n            return r3;\n          }, \
X.isClassElementNameStart = function() {\n            return this.type === \
b.name || this.type === b.privateId || this.type === b.num || this.type === \
b.string || this.type === b.bracketL || this.type.keyword;\n          }, \
X.parseClassElementName = function(e3) {\n            this.type === \
b.privateId ? (\"constructor\" === this.value && this.raise(this.start, \
\"Classes can't have an element named '#constructor'\"), e3.computed = false, \
e3.key = this.parsePrivateIdent()) : this.parsePropertyName(e3);\n          \
}, X.parseClassMethod = function(e3, t3, r3, n2) {\n            var i2 = \
e3.key;\n            \"constructor\" === e3.kind ? (t3 && \
this.raise(i2.start, \"Constructor can't be a generator\"), r3 && \
this.raise(i2.start, \"Constructor can't be an async method\")) : e3.static \
&& te(e3, \"prototype\") && this.raise(i2.start, \"Classes may not have a \
static property named prototype\");\n            var s2 = e3.value = \
this.parseMethod(t3, r3, n2);\n            return \"get\" === e3.kind && 0 \
!== s2.params.length && this.raiseRecoverable(s2.start, \"getter should have \
no params\"), \"set\" === e3.kind && 1 !== s2.params.length && \
this.raiseRecoverable(s2.start, \"setter should have exactly one param\"), \
\"set\" === e3.kind && \"RestElement\" === s2.params[0].type && \
this.raiseRecoverable(s2.params[0].start, \"Setter cannot use rest params\"), \
this.finishNode(e3, \"MethodDefinition\");\n          }, X.parseClassField = \
function(e3) {\n            if (te(e3, \"constructor\") ? \
this.raise(e3.key.start, \"Classes can't have a field named 'constructor'\") \
: e3.static && te(e3, \"prototype\") && this.raise(e3.key.start, \"Classes \
can't have a static field named 'prototype'\"), this.eat(b.eq)) {\n           \
   var t3 = this.currentThisScope(), r3 = t3.inClassFieldInit;\n              \
t3.inClassFieldInit = true, e3.value = this.parseMaybeAssign(), \
t3.inClassFieldInit = r3;\n            } else e3.value = null;\n            \
return this.semicolon(), this.finishNode(e3, \"PropertyDefinition\");\n       \
   }, X.parseClassStaticBlock = function(e3) {\n            e3.body = [];\n   \
         var t3 = this.labels;\n            for (this.labels = [], \
this.enterScope(320); this.type !== b.braceR; ) {\n              var r3 = \
this.parseStatement(null);\n              e3.body.push(r3);\n            }\n  \
          return this.next(), this.exitScope(), this.labels = t3, \
this.finishNode(e3, \"StaticBlock\");\n          }, X.parseClassId = \
function(e3, t3) {\n            this.type === b.name ? (e3.id = \
this.parseIdent(), t3 && this.checkLValSimple(e3.id, 2, false)) : (true === \
t3 && this.unexpected(), e3.id = null);\n          }, X.parseClassSuper = \
function(e3) {\n            e3.superClass = this.eat(b._extends) ? \
this.parseExprSubscripts(null, false) : null;\n          }, X.enterClassBody \
= function() {\n            var e3 = { declared: /* @__PURE__ */ \
Object.create(null), used: [] };\n            return \
this.privateNameStack.push(e3), e3.declared;\n          }, X.exitClassBody = \
function() {\n            var e3 = this.privateNameStack.pop(), t3 = \
e3.declared, r3 = e3.used;\n            if (this.options.checkPrivateFields) \
for (var n2 = this.privateNameStack.length, i2 = 0 === n2 ? null : \
this.privateNameStack[n2 - 1], s2 = 0; s2 < r3.length; ++s2) {\n              \
var a2 = r3[s2];\n              D(t3, a2.name) || (i2 ? i2.used.push(a2) : \
this.raiseRecoverable(a2.start, \"Private field '#\" + a2.name + \"' must be \
declared in an enclosing class\"));\n            }\n          }, \
X.parseExportAllDeclaration = function(e3, t3) {\n            return \
this.options.ecmaVersion >= 11 && (this.eatContextual(\"as\") ? (e3.exported \
= this.parseModuleExportName(), this.checkExport(t3, e3.exported, \
this.lastTokStart)) : e3.exported = null), this.expectContextual(\"from\"), \
this.type !== b.string && this.unexpected(), e3.source = \
this.parseExprAtom(), this.options.ecmaVersion >= 16 && (e3.attributes = \
this.parseWithClause()), this.semicolon(), this.finishNode(e3, \
\"ExportAllDeclaration\");\n          }, X.parseExport = function(e3, t3) {\n \
           if (this.next(), this.eat(b.star)) return \
this.parseExportAllDeclaration(e3, t3);\n            if \
(this.eat(b._default)) return this.checkExport(t3, \"default\", \
this.lastTokStart), e3.declaration = this.parseExportDefaultDeclaration(), \
this.finishNode(e3, \"ExportDefaultDeclaration\");\n            if \
(this.shouldParseExportStatement()) e3.declaration = \
this.parseExportDeclaration(e3), \"VariableDeclaration\" === \
e3.declaration.type ? this.checkVariableExport(t3, \
e3.declaration.declarations) : this.checkExport(t3, e3.declaration.id, \
e3.declaration.id.start), e3.specifiers = [], e3.source = null;\n            \
else {\n              if (e3.declaration = null, e3.specifiers = \
this.parseExportSpecifiers(t3), this.eatContextual(\"from\")) this.type !== \
b.string && this.unexpected(), e3.source = this.parseExprAtom(), \
this.options.ecmaVersion >= 16 && (e3.attributes = this.parseWithClause());\n \
             else {\n                for (var r3 = 0, n2 = e3.specifiers; r3 \
< n2.length; r3 += 1) {\n                  var i2 = n2[r3];\n                 \
 this.checkUnreserved(i2.local), this.checkLocalExport(i2.local), \"Literal\" \
=== i2.local.type && this.raise(i2.local.start, \"A string literal cannot be \
used as an exported binding without `from`.\");\n                }\n          \
      e3.source = null;\n              }\n              this.semicolon();\n   \
         }\n            return this.finishNode(e3, \
\"ExportNamedDeclaration\");\n          }, X.parseExportDeclaration = \
function(e3) {\n            return this.parseStatement(null);\n          }, \
X.parseExportDefaultDeclaration = function() {\n            var e3;\n         \
   if (this.type === b._function || (e3 = this.isAsyncFunction())) {\n        \
      var t3 = this.startNode();\n              return this.next(), e3 && \
this.next(), this.parseFunction(t3, 4 | J, false, e3);\n            }\n       \
     if (this.type === b._class) {\n              var r3 = \
this.startNode();\n              return this.parseClass(r3, \
\"nullableID\");\n            }\n            var n2 = \
this.parseMaybeAssign();\n            return this.semicolon(), n2;\n          \
}, X.checkExport = function(e3, t3, r3) {\n            e3 && (\"string\" != \
typeof t3 && (t3 = \"Identifier\" === t3.type ? t3.name : t3.value), D(e3, \
t3) && this.raiseRecoverable(r3, \"Duplicate export '\" + t3 + \"'\"), e3[t3] \
= true);\n          }, X.checkPatternExport = function(e3, t3) {\n            \
var r3 = t3.type;\n            if (\"Identifier\" === r3) \
this.checkExport(e3, t3, t3.start);\n            else if (\"ObjectPattern\" \
=== r3) for (var n2 = 0, i2 = t3.properties; n2 < i2.length; n2 += 1) {\n     \
         var s2 = i2[n2];\n              this.checkPatternExport(e3, s2);\n   \
         }\n            else if (\"ArrayPattern\" === r3) for (var a2 = 0, o2 \
= t3.elements; a2 < o2.length; a2 += 1) {\n              var u2 = o2[a2];\n   \
           u2 && this.checkPatternExport(e3, u2);\n            }\n            \
else \"Property\" === r3 ? this.checkPatternExport(e3, t3.value) : \
\"AssignmentPattern\" === r3 ? this.checkPatternExport(e3, t3.left) : \
\"RestElement\" === r3 && this.checkPatternExport(e3, t3.argument);\n         \
 }, X.checkVariableExport = function(e3, t3) {\n            if (e3) for (var \
r3 = 0, n2 = t3; r3 < n2.length; r3 += 1) {\n              var i2 = n2[r3];\n \
             this.checkPatternExport(e3, i2.id);\n            }\n          }, \
X.shouldParseExportStatement = function() {\n            return \"var\" === \
this.type.keyword || \"const\" === this.type.keyword || \"class\" === \
this.type.keyword || \"function\" === this.type.keyword || this.isLet() || \
this.isAsyncFunction();\n          }, X.parseExportSpecifier = function(e3) \
{\n            var t3 = this.startNode();\n            return t3.local = \
this.parseModuleExportName(), t3.exported = this.eatContextual(\"as\") ? \
this.parseModuleExportName() : t3.local, this.checkExport(e3, t3.exported, \
t3.exported.start), this.finishNode(t3, \"ExportSpecifier\");\n          }, \
X.parseExportSpecifiers = function(e3) {\n            var t3 = [], r3 = \
true;\n            for (this.expect(b.braceL); !this.eat(b.braceR); ) {\n     \
         if (r3) r3 = false;\n              else if (this.expect(b.comma), \
this.afterTrailingComma(b.braceR)) break;\n              \
t3.push(this.parseExportSpecifier(e3));\n            }\n            return \
t3;\n          }, X.parseImport = function(e3) {\n            return \
this.next(), this.type === b.string ? (e3.specifiers = Z, e3.source = \
this.parseExprAtom()) : (e3.specifiers = this.parseImportSpecifiers(), \
this.expectContextual(\"from\"), e3.source = this.type === b.string ? \
this.parseExprAtom() : this.unexpected()), this.options.ecmaVersion >= 16 && \
(e3.attributes = this.parseWithClause()), this.semicolon(), \
this.finishNode(e3, \"ImportDeclaration\");\n          }, \
X.parseImportSpecifier = function() {\n            var e3 = \
this.startNode();\n            return e3.imported = \
this.parseModuleExportName(), this.eatContextual(\"as\") ? e3.local = \
this.parseIdent() : (this.checkUnreserved(e3.imported), e3.local = \
e3.imported), this.checkLValSimple(e3.local, 2), this.finishNode(e3, \
\"ImportSpecifier\");\n          }, X.parseImportDefaultSpecifier = \
function() {\n            var e3 = this.startNode();\n            return \
e3.local = this.parseIdent(), this.checkLValSimple(e3.local, 2), \
this.finishNode(e3, \"ImportDefaultSpecifier\");\n          }, \
X.parseImportNamespaceSpecifier = function() {\n            var e3 = \
this.startNode();\n            return this.next(), \
this.expectContextual(\"as\"), e3.local = this.parseIdent(), \
this.checkLValSimple(e3.local, 2), this.finishNode(e3, \
\"ImportNamespaceSpecifier\");\n          }, X.parseImportSpecifiers = \
function() {\n            var e3 = [], t3 = true;\n            if (this.type \
=== b.name && (e3.push(this.parseImportDefaultSpecifier()), \
!this.eat(b.comma))) return e3;\n            if (this.type === b.star) return \
e3.push(this.parseImportNamespaceSpecifier()), e3;\n            for \
(this.expect(b.braceL); !this.eat(b.braceR); ) {\n              if (t3) t3 = \
false;\n              else if (this.expect(b.comma), \
this.afterTrailingComma(b.braceR)) break;\n              \
e3.push(this.parseImportSpecifier());\n            }\n            return \
e3;\n          }, X.parseWithClause = function() {\n            var e3 = \
[];\n            if (!this.eat(b._with)) return e3;\n            \
this.expect(b.braceL);\n            for (var t3 = {}, r3 = true; \
!this.eat(b.braceR); ) {\n              if (r3) r3 = false;\n              \
else if (this.expect(b.comma), this.afterTrailingComma(b.braceR)) break;\n    \
          var n2 = this.parseImportAttribute(), i2 = \"Identifier\" === \
n2.key.type ? n2.key.name : n2.key.value;\n              D(t3, i2) && \
this.raiseRecoverable(n2.key.start, \"Duplicate attribute key '\" + i2 + \
\"'\"), t3[i2] = true, e3.push(n2);\n            }\n            return e3;\n  \
        }, X.parseImportAttribute = function() {\n            var e3 = \
this.startNode();\n            return e3.key = this.type === b.string ? \
this.parseExprAtom() : this.parseIdent(\"never\" !== \
this.options.allowReserved), this.expect(b.colon), this.type !== b.string && \
this.unexpected(), e3.value = this.parseExprAtom(), this.finishNode(e3, \
\"ImportAttribute\");\n          }, X.parseModuleExportName = function() {\n  \
          if (this.options.ecmaVersion >= 13 && this.type === b.string) {\n   \
           var e3 = this.parseLiteral(this.value);\n              return \
F.test(e3.value) && this.raise(e3.start, \"An export name cannot include a \
lone surrogate.\"), e3;\n            }\n            return \
this.parseIdent(true);\n          }, X.adaptDirectivePrologue = function(e3) \
{\n            for (var t3 = 0; t3 < e3.length && \
this.isDirectiveCandidate(e3[t3]); ++t3) e3[t3].directive = \
e3[t3].expression.raw.slice(1, -1);\n          }, X.isDirectiveCandidate = \
function(e3) {\n            return this.options.ecmaVersion >= 5 && \
\"ExpressionStatement\" === e3.type && \"Literal\" === e3.expression.type && \
\"string\" == typeof e3.expression.value && ('\"' === this.input[e3.start] || \
\"'\" === this.input[e3.start]);\n          };\n          var re = \
U.prototype;\n          re.toAssignable = function(e3, t3, r3) {\n            \
if (this.options.ecmaVersion >= 6 && e3) switch (e3.type) {\n              \
case \"Identifier\":\n                this.inAsync && \"await\" === e3.name \
&& this.raise(e3.start, \"Cannot use 'await' as identifier inside an async \
function\");\n                break;\n              case \"ObjectPattern\":\n \
             case \"ArrayPattern\":\n              case \
\"AssignmentPattern\":\n              case \"RestElement\":\n                \
break;\n              case \"ObjectExpression\":\n                e3.type = \
\"ObjectPattern\", r3 && this.checkPatternErrors(r3, true);\n                \
for (var n2 = 0, i2 = e3.properties; n2 < i2.length; n2 += 1) {\n             \
     var s2 = i2[n2];\n                  this.toAssignable(s2, t3), \
\"RestElement\" !== s2.type || \"ArrayPattern\" !== s2.argument.type && \
\"ObjectPattern\" !== s2.argument.type || this.raise(s2.argument.start, \
\"Unexpected token\");\n                }\n                break;\n           \
   case \"Property\":\n                \"init\" !== e3.kind && \
this.raise(e3.key.start, \"Object pattern can't contain getter or setter\"), \
this.toAssignable(e3.value, t3);\n                break;\n              case \
\"ArrayExpression\":\n                e3.type = \"ArrayPattern\", r3 && \
this.checkPatternErrors(r3, true), this.toAssignableList(e3.elements, t3);\n  \
              break;\n              case \"SpreadElement\":\n                \
e3.type = \"RestElement\", this.toAssignable(e3.argument, t3), \
\"AssignmentPattern\" === e3.argument.type && this.raise(e3.argument.start, \
\"Rest elements cannot have a default value\");\n                break;\n     \
         case \"AssignmentExpression\":\n                \"=\" !== \
e3.operator && this.raise(e3.left.end, \"Only '=' operator can be used for \
specifying default value.\"), e3.type = \"AssignmentPattern\", delete \
e3.operator, this.toAssignable(e3.left, t3);\n                break;\n        \
      case \"ParenthesizedExpression\":\n                \
this.toAssignable(e3.expression, t3, r3);\n                break;\n           \
   case \"ChainExpression\":\n                this.raiseRecoverable(e3.start, \
\"Optional chaining cannot appear in left-hand side\");\n                \
break;\n              case \"MemberExpression\":\n                if (!t3) \
break;\n              default:\n                this.raise(e3.start, \
\"Assigning to rvalue\");\n            }\n            else r3 && \
this.checkPatternErrors(r3, true);\n            return e3;\n          }, \
re.toAssignableList = function(e3, t3) {\n            for (var r3 = \
e3.length, n2 = 0; n2 < r3; n2++) {\n              var i2 = e3[n2];\n         \
     i2 && this.toAssignable(i2, t3);\n            }\n            if (r3) {\n \
             var s2 = e3[r3 - 1];\n              6 === \
this.options.ecmaVersion && t3 && s2 && \"RestElement\" === s2.type && \
\"Identifier\" !== s2.argument.type && this.unexpected(s2.argument.start);\n  \
          }\n            return e3;\n          }, re.parseSpread = \
function(e3) {\n            var t3 = this.startNode();\n            return \
this.next(), t3.argument = this.parseMaybeAssign(false, e3), \
this.finishNode(t3, \"SpreadElement\");\n          }, re.parseRestBinding = \
function() {\n            var e3 = this.startNode();\n            return \
this.next(), 6 === this.options.ecmaVersion && this.type !== b.name && \
this.unexpected(), e3.argument = this.parseBindingAtom(), this.finishNode(e3, \
\"RestElement\");\n          }, re.parseBindingAtom = function() {\n          \
  if (this.options.ecmaVersion >= 6) switch (this.type) {\n              case \
b.bracketL:\n                var e3 = this.startNode();\n                \
return this.next(), e3.elements = this.parseBindingList(b.bracketR, true, \
true), this.finishNode(e3, \"ArrayPattern\");\n              case b.braceL:\n \
               return this.parseObj(true);\n            }\n            return \
this.parseIdent();\n          }, re.parseBindingList = function(e3, t3, r3, \
n2) {\n            for (var i2 = [], s2 = true; !this.eat(e3); ) if (s2 ? s2 \
= false : this.expect(b.comma), t3 && this.type === b.comma) i2.push(null);\n \
           else {\n              if (r3 && this.afterTrailingComma(e3)) \
break;\n              if (this.type === b.ellipsis) {\n                var a2 \
= this.parseRestBinding();\n                this.parseBindingListItem(a2), \
i2.push(a2), this.type === b.comma && this.raiseRecoverable(this.start, \
\"Comma is not permitted after the rest element\"), this.expect(e3);\n        \
        break;\n              }\n              \
i2.push(this.parseAssignableListItem(n2));\n            }\n            return \
i2;\n          }, re.parseAssignableListItem = function(e3) {\n            \
var t3 = this.parseMaybeDefault(this.start, this.startLoc);\n            \
return this.parseBindingListItem(t3), t3;\n          }, \
re.parseBindingListItem = function(e3) {\n            return e3;\n          \
}, re.parseMaybeDefault = function(e3, t3, r3) {\n            if (r3 = r3 || \
this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(b.eq)) \
return r3;\n            var n2 = this.startNodeAt(e3, t3);\n            \
return n2.left = r3, n2.right = this.parseMaybeAssign(), this.finishNode(n2, \
\"AssignmentPattern\");\n          }, re.checkLValSimple = function(e3, t3, \
r3) {\n            void 0 === t3 && (t3 = 0);\n            var n2 = 0 !== \
t3;\n            switch (e3.type) {\n              case \"Identifier\":\n     \
           this.strict && this.reservedWordsStrictBind.test(e3.name) && \
this.raiseRecoverable(e3.start, (n2 ? \"Binding \" : \"Assigning to \") + \
e3.name + \" in strict mode\"), n2 && (2 === t3 && \"let\" === e3.name && \
this.raiseRecoverable(e3.start, \"let is disallowed as a lexically bound \
name\"), r3 && (D(r3, e3.name) && this.raiseRecoverable(e3.start, \"Argument \
name clash\"), r3[e3.name] = true), 5 !== t3 && this.declareName(e3.name, t3, \
e3.start));\n                break;\n              case \
\"ChainExpression\":\n                this.raiseRecoverable(e3.start, \
\"Optional chaining cannot appear in left-hand side\");\n                \
break;\n              case \"MemberExpression\":\n                n2 && \
this.raiseRecoverable(e3.start, \"Binding member expression\");\n             \
   break;\n              case \"ParenthesizedExpression\":\n                \
return n2 && this.raiseRecoverable(e3.start, \"Binding parenthesized \
expression\"), this.checkLValSimple(e3.expression, t3, r3);\n              \
default:\n                this.raise(e3.start, (n2 ? \"Binding\" : \
\"Assigning to\") + \" rvalue\");\n            }\n          }, \
re.checkLValPattern = function(e3, t3, r3) {\n            switch (void 0 === \
t3 && (t3 = 0), e3.type) {\n              case \"ObjectPattern\":\n           \
     for (var n2 = 0, i2 = e3.properties; n2 < i2.length; n2 += 1) {\n        \
          var s2 = i2[n2];\n                  this.checkLValInnerPattern(s2, \
t3, r3);\n                }\n                break;\n              case \
\"ArrayPattern\":\n                for (var a2 = 0, o2 = e3.elements; a2 < \
o2.length; a2 += 1) {\n                  var u2 = o2[a2];\n                  \
u2 && this.checkLValInnerPattern(u2, t3, r3);\n                }\n            \
    break;\n              default:\n                this.checkLValSimple(e3, \
t3, r3);\n            }\n          }, re.checkLValInnerPattern = function(e3, \
t3, r3) {\n            switch (void 0 === t3 && (t3 = 0), e3.type) {\n        \
      case \"Property\":\n                \
this.checkLValInnerPattern(e3.value, t3, r3);\n                break;\n       \
       case \"AssignmentPattern\":\n                \
this.checkLValPattern(e3.left, t3, r3);\n                break;\n             \
 case \"RestElement\":\n                this.checkLValPattern(e3.argument, \
t3, r3);\n                break;\n              default:\n                \
this.checkLValPattern(e3, t3, r3);\n            }\n          };\n          \
var ne = function(e3, t3, r3, n2, i2) {\n            this.token = e3, \
this.isExpr = !!t3, this.preserveSpace = !!r3, this.override = n2, \
this.generator = !!i2;\n          }, ie = { b_stat: new ne(\"{\", false), \
b_expr: new ne(\"{\", true), b_tmpl: new ne(\"${\", false), p_stat: new \
ne(\"(\", false), p_expr: new ne(\"(\", true), q_tmpl: new ne(\"`\", true, \
true, function(e3) {\n            return e3.tryReadTemplateToken();\n         \
 }), f_stat: new ne(\"function\", false), f_expr: new ne(\"function\", true), \
f_expr_gen: new ne(\"function\", true, false, null, true), f_gen: new \
ne(\"function\", false, false, null, true) }, se = U.prototype;\n          \
se.initialContext = function() {\n            return [ie.b_stat];\n          \
}, se.curContext = function() {\n            return \
this.context[this.context.length - 1];\n          }, se.braceIsBlock = \
function(e3) {\n            var t3 = this.curContext();\n            return \
t3 === ie.f_expr || t3 === ie.f_stat || (e3 !== b.colon || t3 !== ie.b_stat \
&& t3 !== ie.b_expr ? e3 === b._return || e3 === b.name && this.exprAllowed ? \
T.test(this.input.slice(this.lastTokEnd, this.start)) : e3 === b._else || e3 \
=== b.semi || e3 === b.eof || e3 === b.parenR || e3 === b.arrow || (e3 === \
b.braceL ? t3 === ie.b_stat : e3 !== b._var && e3 !== b._const && e3 !== \
b.name && !this.exprAllowed) : !t3.isExpr);\n          }, \
se.inGeneratorContext = function() {\n            for (var e3 = \
this.context.length - 1; e3 >= 1; e3--) {\n              var t3 = \
this.context[e3];\n              if (\"function\" === t3.token) return \
t3.generator;\n            }\n            return false;\n          }, \
se.updateContext = function(e3) {\n            var t3, r3 = this.type;\n      \
      r3.keyword && e3 === b.dot ? this.exprAllowed = false : (t3 = \
r3.updateContext) ? t3.call(this, e3) : this.exprAllowed = r3.beforeExpr;\n   \
       }, se.overrideContext = function(e3) {\n            this.curContext() \
!== e3 && (this.context[this.context.length - 1] = e3);\n          }, \
b.parenR.updateContext = b.braceR.updateContext = function() {\n            \
if (1 !== this.context.length) {\n              var e3 = \
this.context.pop();\n              e3 === ie.b_stat && \"function\" === \
this.curContext().token && (e3 = this.context.pop()), this.exprAllowed = \
!e3.isExpr;\n            } else this.exprAllowed = true;\n          }, \
b.braceL.updateContext = function(e3) {\n            \
this.context.push(this.braceIsBlock(e3) ? ie.b_stat : ie.b_expr), \
this.exprAllowed = true;\n          }, b.dollarBraceL.updateContext = \
function() {\n            this.context.push(ie.b_tmpl), this.exprAllowed = \
true;\n          }, b.parenL.updateContext = function(e3) {\n            var \
t3 = e3 === b._if || e3 === b._for || e3 === b._with || e3 === b._while;\n    \
        this.context.push(t3 ? ie.p_stat : ie.p_expr), this.exprAllowed = \
true;\n          }, b.incDec.updateContext = function() {\n          }, \
b._function.updateContext = b._class.updateContext = function(e3) {\n         \
   !e3.beforeExpr || e3 === b._else || e3 === b.semi && this.curContext() !== \
ie.p_stat || e3 === b._return && T.test(this.input.slice(this.lastTokEnd, \
this.start)) || (e3 === b.colon || e3 === b.braceL) && this.curContext() === \
ie.b_stat ? this.context.push(ie.f_stat) : this.context.push(ie.f_expr), \
this.exprAllowed = false;\n          }, b.colon.updateContext = function() \
{\n            \"function\" === this.curContext().token && \
this.context.pop(), this.exprAllowed = true;\n          }, \
b.backQuote.updateContext = function() {\n            this.curContext() === \
ie.q_tmpl ? this.context.pop() : this.context.push(ie.q_tmpl), \
this.exprAllowed = false;\n          }, b.star.updateContext = function(e3) \
{\n            if (e3 === b._function) {\n              var t3 = \
this.context.length - 1;\n              this.context[t3] === ie.f_expr ? \
this.context[t3] = ie.f_expr_gen : this.context[t3] = ie.f_gen;\n            \
}\n            this.exprAllowed = true;\n          }, b.name.updateContext = \
function(e3) {\n            var t3 = false;\n            \
this.options.ecmaVersion >= 6 && e3 !== b.dot && (\"of\" === this.value && \
!this.exprAllowed || \"yield\" === this.value && this.inGeneratorContext()) \
&& (t3 = true), this.exprAllowed = t3;\n          };\n          var ae = \
U.prototype;\n          function oe(e3) {\n            return \"Identifier\" \
=== e3.type || \"ParenthesizedExpression\" === e3.type && \
oe(e3.expression);\n          }\n          function ue(e3) {\n            \
return \"MemberExpression\" === e3.type && \"PrivateIdentifier\" === \
e3.property.type || \"ChainExpression\" === e3.type && ue(e3.expression) || \
\"ParenthesizedExpression\" === e3.type && ue(e3.expression);\n          }\n  \
        ae.checkPropClash = function(e3, t3, r3) {\n            if \
(!(this.options.ecmaVersion >= 9 && \"SpreadElement\" === e3.type || \
this.options.ecmaVersion >= 6 && (e3.computed || e3.method || e3.shorthand))) \
{\n              var n2, i2 = e3.key;\n              switch (i2.type) {\n     \
           case \"Identifier\":\n                  n2 = i2.name;\n            \
      break;\n                case \"Literal\":\n                  n2 = \
String(i2.value);\n                  break;\n                default:\n       \
           return;\n              }\n              var s2 = e3.kind;\n        \
      if (this.options.ecmaVersion >= 6) \"__proto__\" === n2 && \"init\" === \
s2 && (t3.proto && (r3 ? r3.doubleProto < 0 && (r3.doubleProto = i2.start) : \
this.raiseRecoverable(i2.start, \"Redefinition of __proto__ property\")), \
t3.proto = true);\n              else {\n                var a2 = t3[n2 = \
\"$\" + n2];\n                if (a2) (\"init\" === s2 ? this.strict && \
a2.init || a2.get || a2.set : a2.init || a2[s2]) && \
this.raiseRecoverable(i2.start, \"Redefinition of property\");\n              \
  else a2 = t3[n2] = { init: false, get: false, set: false };\n               \
 a2[s2] = true;\n              }\n            }\n          }, \
ae.parseExpression = function(e3, t3) {\n            var r3 = this.start, n2 \
= this.startLoc, i2 = this.parseMaybeAssign(e3, t3);\n            if \
(this.type === b.comma) {\n              var s2 = this.startNodeAt(r3, n2);\n \
             for (s2.expressions = [i2]; this.eat(b.comma); ) \
s2.expressions.push(this.parseMaybeAssign(e3, t3));\n              return \
this.finishNode(s2, \"SequenceExpression\");\n            }\n            \
return i2;\n          }, ae.parseMaybeAssign = function(e3, t3, r3) {\n       \
     if (this.isContextual(\"yield\")) {\n              if (this.inGenerator) \
return this.parseYield(e3);\n              this.exprAllowed = false;\n        \
    }\n            var n2 = false, i2 = -1, s2 = -1, a2 = -1;\n            t3 \
? (i2 = t3.parenthesizedAssign, s2 = t3.trailingComma, a2 = t3.doubleProto, \
t3.parenthesizedAssign = t3.trailingComma = -1) : (t3 = new H(), n2 = \
true);\n            var o2 = this.start, u2 = this.startLoc;\n            \
this.type !== b.parenL && this.type !== b.name || (this.potentialArrowAt = \
this.start, this.potentialArrowInForAwait = \"await\" === e3);\n            \
var l2 = this.parseMaybeConditional(e3, t3);\n            if (r3 && (l2 = \
r3.call(this, l2, o2, u2)), this.type.isAssign) {\n              var h2 = \
this.startNodeAt(o2, u2);\n              return h2.operator = this.value, \
this.type === b.eq && (l2 = this.toAssignable(l2, false, t3)), n2 || \
(t3.parenthesizedAssign = t3.trailingComma = t3.doubleProto = -1), \
t3.shorthandAssign >= l2.start && (t3.shorthandAssign = -1), this.type === \
b.eq ? this.checkLValPattern(l2) : this.checkLValSimple(l2), h2.left = l2, \
this.next(), h2.right = this.parseMaybeAssign(e3), a2 > -1 && (t3.doubleProto \
= a2), this.finishNode(h2, \"AssignmentExpression\");\n            }\n        \
    return n2 && this.checkExpressionErrors(t3, true), i2 > -1 && \
(t3.parenthesizedAssign = i2), s2 > -1 && (t3.trailingComma = s2), l2;\n      \
    }, ae.parseMaybeConditional = function(e3, t3) {\n            var r3 = \
this.start, n2 = this.startLoc, i2 = this.parseExprOps(e3, t3);\n            \
if (this.checkExpressionErrors(t3)) return i2;\n            if \
(this.eat(b.question)) {\n              var s2 = this.startNodeAt(r3, n2);\n  \
            return s2.test = i2, s2.consequent = this.parseMaybeAssign(), \
this.expect(b.colon), s2.alternate = this.parseMaybeAssign(e3), \
this.finishNode(s2, \"ConditionalExpression\");\n            }\n            \
return i2;\n          }, ae.parseExprOps = function(e3, t3) {\n            \
var r3 = this.start, n2 = this.startLoc, i2 = this.parseMaybeUnary(t3, false, \
false, e3);\n            return this.checkExpressionErrors(t3) || i2.start \
=== r3 && \"ArrowFunctionExpression\" === i2.type ? i2 : this.parseExprOp(i2, \
r3, n2, -1, e3);\n          }, ae.parseExprOp = function(e3, t3, r3, n2, i2) \
{\n            var s2 = this.type.binop;\n            if (null != s2 && (!i2 \
|| this.type !== b._in) && s2 > n2) {\n              var a2 = this.type === \
b.logicalOR || this.type === b.logicalAND, o2 = this.type === b.coalesce;\n   \
           o2 && (s2 = b.logicalAND.binop);\n              var u2 = \
this.value;\n              this.next();\n              var l2 = this.start, \
h2 = this.startLoc, c2 = this.parseExprOp(this.parseMaybeUnary(null, false, \
false, i2), l2, h2, s2, i2), p2 = this.buildBinary(t3, r3, e3, c2, u2, a2 || \
o2);\n              return (a2 && this.type === b.coalesce || o2 && \
(this.type === b.logicalOR || this.type === b.logicalAND)) && \
this.raiseRecoverable(this.start, \"Logical expressions and coalesce \
expressions cannot be mixed. Wrap either by parentheses\"), \
this.parseExprOp(p2, t3, r3, n2, i2);\n            }\n            return \
e3;\n          }, ae.buildBinary = function(e3, t3, r3, n2, i2, s2) {\n       \
     \"PrivateIdentifier\" === n2.type && this.raise(n2.start, \"Private \
identifier can only be left side of binary expression\");\n            var a2 \
= this.startNodeAt(e3, t3);\n            return a2.left = r3, a2.operator = \
i2, a2.right = n2, this.finishNode(a2, s2 ? \"LogicalExpression\" : \
\"BinaryExpression\");\n          }, ae.parseMaybeUnary = function(e3, t3, \
r3, n2) {\n            var i2, s2 = this.start, a2 = this.startLoc;\n         \
   if (this.isContextual(\"await\") && this.canAwait) i2 = \
this.parseAwait(n2), t3 = true;\n            else if (this.type.prefix) {\n   \
           var o2 = this.startNode(), u2 = this.type === b.incDec;\n          \
    o2.operator = this.value, o2.prefix = true, this.next(), o2.argument = \
this.parseMaybeUnary(null, true, u2, n2), this.checkExpressionErrors(e3, \
true), u2 ? this.checkLValSimple(o2.argument) : this.strict && \"delete\" === \
o2.operator && oe(o2.argument) ? this.raiseRecoverable(o2.start, \"Deleting \
local variable in strict mode\") : \"delete\" === o2.operator && \
ue(o2.argument) ? this.raiseRecoverable(o2.start, \"Private fields can not be \
deleted\") : t3 = true, i2 = this.finishNode(o2, u2 ? \"UpdateExpression\" : \
\"UnaryExpression\");\n            } else if (t3 || this.type !== \
b.privateId) {\n              if (i2 = this.parseExprSubscripts(e3, n2), \
this.checkExpressionErrors(e3)) return i2;\n              for (; \
this.type.postfix && !this.canInsertSemicolon(); ) {\n                var l2 \
= this.startNodeAt(s2, a2);\n                l2.operator = this.value, \
l2.prefix = false, l2.argument = i2, this.checkLValSimple(i2), this.next(), \
i2 = this.finishNode(l2, \"UpdateExpression\");\n              }\n            \
} else (n2 || 0 === this.privateNameStack.length) && \
this.options.checkPrivateFields && this.unexpected(), i2 = \
this.parsePrivateIdent(), this.type !== b._in && this.unexpected();\n         \
   return r3 || !this.eat(b.starstar) ? i2 : t3 ? void \
this.unexpected(this.lastTokStart) : this.buildBinary(s2, a2, i2, \
this.parseMaybeUnary(null, false, false, n2), \"**\", false);\n          }, \
ae.parseExprSubscripts = function(e3, t3) {\n            var r3 = this.start, \
n2 = this.startLoc, i2 = this.parseExprAtom(e3, t3);\n            if \
(\"ArrowFunctionExpression\" === i2.type && \")\" !== \
this.input.slice(this.lastTokStart, this.lastTokEnd)) return i2;\n            \
var s2 = this.parseSubscripts(i2, r3, n2, false, t3);\n            return e3 \
&& \"MemberExpression\" === s2.type && (e3.parenthesizedAssign >= s2.start && \
(e3.parenthesizedAssign = -1), e3.parenthesizedBind >= s2.start && \
(e3.parenthesizedBind = -1), e3.trailingComma >= s2.start && \
(e3.trailingComma = -1)), s2;\n          }, ae.parseSubscripts = function(e3, \
t3, r3, n2, i2) {\n            for (var s2 = this.options.ecmaVersion >= 8 && \
\"Identifier\" === e3.type && \"async\" === e3.name && this.lastTokEnd === \
e3.end && !this.canInsertSemicolon() && e3.end - e3.start == 5 && \
this.potentialArrowAt === e3.start, a2 = false; ; ) {\n              var o2 = \
this.parseSubscript(e3, t3, r3, n2, s2, a2, i2);\n              if \
(o2.optional && (a2 = true), o2 === e3 || \"ArrowFunctionExpression\" === \
o2.type) {\n                if (a2) {\n                  var u2 = \
this.startNodeAt(t3, r3);\n                  u2.expression = o2, o2 = \
this.finishNode(u2, \"ChainExpression\");\n                }\n                \
return o2;\n              }\n              e3 = o2;\n            }\n          \
}, ae.shouldParseAsyncArrow = function() {\n            return \
!this.canInsertSemicolon() && this.eat(b.arrow);\n          }, \
ae.parseSubscriptAsyncArrow = function(e3, t3, r3, n2) {\n            return \
this.parseArrowExpression(this.startNodeAt(e3, t3), r3, true, n2);\n          \
}, ae.parseSubscript = function(e3, t3, r3, n2, i2, s2, a2) {\n            \
var o2 = this.options.ecmaVersion >= 11, u2 = o2 && \
this.eat(b.questionDot);\n            n2 && u2 && \
this.raise(this.lastTokStart, \"Optional chaining cannot appear in the callee \
of new expressions\");\n            var l2 = this.eat(b.bracketL);\n          \
  if (l2 || u2 && this.type !== b.parenL && this.type !== b.backQuote || \
this.eat(b.dot)) {\n              var h2 = this.startNodeAt(t3, r3);\n        \
      h2.object = e3, l2 ? (h2.property = this.parseExpression(), \
this.expect(b.bracketR)) : this.type === b.privateId && \"Super\" !== e3.type \
? h2.property = this.parsePrivateIdent() : h2.property = \
this.parseIdent(\"never\" !== this.options.allowReserved), h2.computed = \
!!l2, o2 && (h2.optional = u2), e3 = this.finishNode(h2, \
\"MemberExpression\");\n            } else if (!n2 && this.eat(b.parenL)) {\n \
             var c2 = new H(), p2 = this.yieldPos, d2 = this.awaitPos, m2 = \
this.awaitIdentPos;\n              this.yieldPos = 0, this.awaitPos = 0, \
this.awaitIdentPos = 0;\n              var f2 = this.parseExprList(b.parenR, \
this.options.ecmaVersion >= 8, false, c2);\n              if (i2 && !u2 && \
this.shouldParseAsyncArrow()) return this.checkPatternErrors(c2, false), \
this.checkYieldAwaitInDefaultParams(), this.awaitIdentPos > 0 && \
this.raise(this.awaitIdentPos, \"Cannot use 'await' as identifier inside an \
async function\"), this.yieldPos = p2, this.awaitPos = d2, this.awaitIdentPos \
= m2, this.parseSubscriptAsyncArrow(t3, r3, f2, a2);\n              \
this.checkExpressionErrors(c2, true), this.yieldPos = p2 || this.yieldPos, \
this.awaitPos = d2 || this.awaitPos, this.awaitIdentPos = m2 || \
this.awaitIdentPos;\n              var g2 = this.startNodeAt(t3, r3);\n       \
       g2.callee = e3, g2.arguments = f2, o2 && (g2.optional = u2), e3 = \
this.finishNode(g2, \"CallExpression\");\n            } else if (this.type \
=== b.backQuote) {\n              (u2 || s2) && this.raise(this.start, \
\"Optional chaining cannot appear in the tag of tagged template \
expressions\");\n              var x2 = this.startNodeAt(t3, r3);\n           \
   x2.tag = e3, x2.quasi = this.parseTemplate({ isTagged: true }), e3 = \
this.finishNode(x2, \"TaggedTemplateExpression\");\n            }\n           \
 return e3;\n          }, ae.parseExprAtom = function(e3, t3, r3) {\n         \
   this.type === b.slash && this.readRegexp();\n            var n2, i2 = \
this.potentialArrowAt === this.start;\n            switch (this.type) {\n     \
         case b._super:\n                return this.allowSuper || \
this.raise(this.start, \"'super' keyword outside a method\"), n2 = \
this.startNode(), this.next(), this.type !== b.parenL || \
this.allowDirectSuper || this.raise(n2.start, \"super() call outside \
constructor of a subclass\"), this.type !== b.dot && this.type !== b.bracketL \
&& this.type !== b.parenL && this.unexpected(), this.finishNode(n2, \
\"Super\");\n              case b._this:\n                return n2 = \
this.startNode(), this.next(), this.finishNode(n2, \"ThisExpression\");\n     \
         case b.name:\n                var s2 = this.start, a2 = \
this.startLoc, o2 = this.containsEsc, u2 = this.parseIdent(false);\n          \
      if (this.options.ecmaVersion >= 8 && !o2 && \"async\" === u2.name && \
!this.canInsertSemicolon() && this.eat(b._function)) return \
this.overrideContext(ie.f_expr), this.parseFunction(this.startNodeAt(s2, a2), \
0, false, true, t3);\n                if (i2 && !this.canInsertSemicolon()) \
{\n                  if (this.eat(b.arrow)) return \
this.parseArrowExpression(this.startNodeAt(s2, a2), [u2], false, t3);\n       \
           if (this.options.ecmaVersion >= 8 && \"async\" === u2.name && \
this.type === b.name && !o2 && (!this.potentialArrowInForAwait || \"of\" !== \
this.value || this.containsEsc)) return u2 = this.parseIdent(false), \
!this.canInsertSemicolon() && this.eat(b.arrow) || this.unexpected(), \
this.parseArrowExpression(this.startNodeAt(s2, a2), [u2], true, t3);\n        \
        }\n                return u2;\n              case b.regexp:\n         \
       var l2 = this.value;\n                return (n2 = \
this.parseLiteral(l2.value)).regex = { pattern: l2.pattern, flags: l2.flags \
}, n2;\n              case b.num:\n              case b.string:\n             \
   return this.parseLiteral(this.value);\n              case b._null:\n       \
       case b._true:\n              case b._false:\n                return \
(n2 = this.startNode()).value = this.type === b._null ? null : this.type === \
b._true, n2.raw = this.type.keyword, this.next(), this.finishNode(n2, \
\"Literal\");\n              case b.parenL:\n                var h2 = \
this.start, c2 = this.parseParenAndDistinguishExpression(i2, t3);\n           \
     return e3 && (e3.parenthesizedAssign < 0 && \
!this.isSimpleAssignTarget(c2) && (e3.parenthesizedAssign = h2), \
e3.parenthesizedBind < 0 && (e3.parenthesizedBind = h2)), c2;\n              \
case b.bracketL:\n                return n2 = this.startNode(), this.next(), \
n2.elements = this.parseExprList(b.bracketR, true, true, e3), \
this.finishNode(n2, \"ArrayExpression\");\n              case b.braceL:\n     \
           return this.overrideContext(ie.b_expr), this.parseObj(false, \
e3);\n              case b._function:\n                return n2 = \
this.startNode(), this.next(), this.parseFunction(n2, 0);\n              case \
b._class:\n                return this.parseClass(this.startNode(), false);\n \
             case b._new:\n                return this.parseNew();\n          \
    case b.backQuote:\n                return this.parseTemplate();\n         \
     case b._import:\n                return this.options.ecmaVersion >= 11 ? \
this.parseExprImport(r3) : this.unexpected();\n              default:\n       \
         return this.parseExprAtomDefault();\n            }\n          }, \
ae.parseExprAtomDefault = function() {\n            this.unexpected();\n      \
    }, ae.parseExprImport = function(e3) {\n            var t3 = \
this.startNode();\n            if (this.containsEsc && \
this.raiseRecoverable(this.start, \"Escape sequence in keyword import\"), \
this.next(), this.type === b.parenL && !e3) return \
this.parseDynamicImport(t3);\n            if (this.type === b.dot) {\n        \
      var r3 = this.startNodeAt(t3.start, t3.loc && t3.loc.start);\n          \
    return r3.name = \"import\", t3.meta = this.finishNode(r3, \
\"Identifier\"), this.parseImportMeta(t3);\n            }\n            \
this.unexpected();\n          }, ae.parseDynamicImport = function(e3) {\n     \
       if (this.next(), e3.source = this.parseMaybeAssign(), \
this.options.ecmaVersion >= 16) this.eat(b.parenR) ? e3.options = null : \
(this.expect(b.comma), this.afterTrailingComma(b.parenR) ? e3.options = null \
: (e3.options = this.parseMaybeAssign(), this.eat(b.parenR) || \
(this.expect(b.comma), this.afterTrailingComma(b.parenR) || \
this.unexpected())));\n            else if (!this.eat(b.parenR)) {\n          \
    var t3 = this.start;\n              this.eat(b.comma) && \
this.eat(b.parenR) ? this.raiseRecoverable(t3, \"Trailing comma is not \
allowed in import()\") : this.unexpected(t3);\n            }\n            \
return this.finishNode(e3, \"ImportExpression\");\n          }, \
ae.parseImportMeta = function(e3) {\n            this.next();\n            \
var t3 = this.containsEsc;\n            return e3.property = \
this.parseIdent(true), \"meta\" !== e3.property.name && \
this.raiseRecoverable(e3.property.start, \"The only valid meta property for \
import is 'import.meta'\"), t3 && this.raiseRecoverable(e3.start, \
\"'import.meta' must not contain escaped characters\"), \"module\" === \
this.options.sourceType || this.options.allowImportExportEverywhere || \
this.raiseRecoverable(e3.start, \"Cannot use 'import.meta' outside a \
module\"), this.finishNode(e3, \"MetaProperty\");\n          }, \
ae.parseLiteral = function(e3) {\n            var t3 = this.startNode();\n    \
        return t3.value = e3, t3.raw = this.input.slice(this.start, \
this.end), 110 === t3.raw.charCodeAt(t3.raw.length - 1) && (t3.bigint = \
t3.raw.slice(0, -1).replace(/_/g, \"\")), this.next(), this.finishNode(t3, \
\"Literal\");\n          }, ae.parseParenExpression = function() {\n          \
  this.expect(b.parenL);\n            var e3 = this.parseExpression();\n      \
      return this.expect(b.parenR), e3;\n          }, ae.shouldParseArrow = \
function(e3) {\n            return !this.canInsertSemicolon();\n          }, \
ae.parseParenAndDistinguishExpression = function(e3, t3) {\n            var \
r3, n2 = this.start, i2 = this.startLoc, s2 = this.options.ecmaVersion >= \
8;\n            if (this.options.ecmaVersion >= 6) {\n              \
this.next();\n              var a2, o2 = this.start, u2 = this.startLoc, l2 = \
[], h2 = true, c2 = false, p2 = new H(), d2 = this.yieldPos, m2 = \
this.awaitPos;\n              for (this.yieldPos = 0, this.awaitPos = 0; \
this.type !== b.parenR; ) {\n                if (h2 ? h2 = false : \
this.expect(b.comma), s2 && this.afterTrailingComma(b.parenR, true)) {\n      \
            c2 = true;\n                  break;\n                }\n         \
       if (this.type === b.ellipsis) {\n                  a2 = this.start, \
l2.push(this.parseParenItem(this.parseRestBinding())), this.type === b.comma \
&& this.raiseRecoverable(this.start, \"Comma is not permitted after the rest \
element\");\n                  break;\n                }\n                \
l2.push(this.parseMaybeAssign(false, p2, this.parseParenItem));\n             \
 }\n              var f2 = this.lastTokEnd, g2 = this.lastTokEndLoc;\n        \
      if (this.expect(b.parenR), e3 && this.shouldParseArrow(l2) && \
this.eat(b.arrow)) return this.checkPatternErrors(p2, false), \
this.checkYieldAwaitInDefaultParams(), this.yieldPos = d2, this.awaitPos = \
m2, this.parseParenArrowList(n2, i2, l2, t3);\n              l2.length && !c2 \
|| this.unexpected(this.lastTokStart), a2 && this.unexpected(a2), \
this.checkExpressionErrors(p2, true), this.yieldPos = d2 || this.yieldPos, \
this.awaitPos = m2 || this.awaitPos, l2.length > 1 ? ((r3 = \
this.startNodeAt(o2, u2)).expressions = l2, this.finishNodeAt(r3, \
\"SequenceExpression\", f2, g2)) : r3 = l2[0];\n            } else r3 = \
this.parseParenExpression();\n            if (this.options.preserveParens) \
{\n              var x2 = this.startNodeAt(n2, i2);\n              return \
x2.expression = r3, this.finishNode(x2, \"ParenthesizedExpression\");\n       \
     }\n            return r3;\n          }, ae.parseParenItem = function(e3) \
{\n            return e3;\n          }, ae.parseParenArrowList = function(e3, \
t3, r3, n2) {\n            return \
this.parseArrowExpression(this.startNodeAt(e3, t3), r3, false, n2);\n         \
 };\n          var le = [];\n          ae.parseNew = function() {\n           \
 this.containsEsc && this.raiseRecoverable(this.start, \"Escape sequence in \
keyword new\");\n            var e3 = this.startNode();\n            if \
(this.next(), this.options.ecmaVersion >= 6 && this.type === b.dot) {\n       \
       var t3 = this.startNodeAt(e3.start, e3.loc && e3.loc.start);\n         \
     t3.name = \"new\", e3.meta = this.finishNode(t3, \"Identifier\"), \
this.next();\n              var r3 = this.containsEsc;\n              return \
e3.property = this.parseIdent(true), \"target\" !== e3.property.name && \
this.raiseRecoverable(e3.property.start, \"The only valid meta property for \
new is 'new.target'\"), r3 && this.raiseRecoverable(e3.start, \"'new.target' \
must not contain escaped characters\"), this.allowNewDotTarget || \
this.raiseRecoverable(e3.start, \"'new.target' can only be used in functions \
and class static block\"), this.finishNode(e3, \"MetaProperty\");\n           \
 }\n            var n2 = this.start, i2 = this.startLoc;\n            return \
e3.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), n2, \
i2, true, false), this.eat(b.parenL) ? e3.arguments = \
this.parseExprList(b.parenR, this.options.ecmaVersion >= 8, false) : \
e3.arguments = le, this.finishNode(e3, \"NewExpression\");\n          }, \
ae.parseTemplateElement = function(e3) {\n            var t3 = e3.isTagged, \
r3 = this.startNode();\n            return this.type === b.invalidTemplate ? \
(t3 || this.raiseRecoverable(this.start, \"Bad escape sequence in untagged \
template literal\"), r3.value = { raw: this.value.replace(/\\r\\n?/g, \
\"\\n\"), cooked: null }) : r3.value = { raw: this.input.slice(this.start, \
this.end).replace(/\\r\\n?/g, \"\\n\"), cooked: this.value }, this.next(), \
r3.tail = this.type === b.backQuote, this.finishNode(r3, \
\"TemplateElement\");\n          }, ae.parseTemplate = function(e3) {\n       \
     void 0 === e3 && (e3 = {});\n            var t3 = e3.isTagged;\n         \
   void 0 === t3 && (t3 = false);\n            var r3 = this.startNode();\n   \
         this.next(), r3.expressions = [];\n            var n2 = \
this.parseTemplateElement({ isTagged: t3 });\n            for (r3.quasis = \
[n2]; !n2.tail; ) this.type === b.eof && this.raise(this.pos, \"Unterminated \
template literal\"), this.expect(b.dollarBraceL), \
r3.expressions.push(this.parseExpression()), this.expect(b.braceR), \
r3.quasis.push(n2 = this.parseTemplateElement({ isTagged: t3 }));\n           \
 return this.next(), this.finishNode(r3, \"TemplateLiteral\");\n          }, \
ae.isAsyncProp = function(e3) {\n            return !e3.computed && \
\"Identifier\" === e3.key.type && \"async\" === e3.key.name && (this.type === \
b.name || this.type === b.num || this.type === b.string || this.type === \
b.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type \
=== b.star) && !T.test(this.input.slice(this.lastTokEnd, this.start));\n      \
    }, ae.parseObj = function(e3, t3) {\n            var r3 = \
this.startNode(), n2 = true, i2 = {};\n            for (r3.properties = [], \
this.next(); !this.eat(b.braceR); ) {\n              if (n2) n2 = false;\n    \
          else if (this.expect(b.comma), this.options.ecmaVersion >= 5 && \
this.afterTrailingComma(b.braceR)) break;\n              var s2 = \
this.parseProperty(e3, t3);\n              e3 || this.checkPropClash(s2, i2, \
t3), r3.properties.push(s2);\n            }\n            return \
this.finishNode(r3, e3 ? \"ObjectPattern\" : \"ObjectExpression\");\n         \
 }, ae.parseProperty = function(e3, t3) {\n            var r3, n2, i2, s2, a2 \
= this.startNode();\n            if (this.options.ecmaVersion >= 9 && \
this.eat(b.ellipsis)) return e3 ? (a2.argument = this.parseIdent(false), \
this.type === b.comma && this.raiseRecoverable(this.start, \"Comma is not \
permitted after the rest element\"), this.finishNode(a2, \"RestElement\")) : \
(a2.argument = this.parseMaybeAssign(false, t3), this.type === b.comma && t3 \
&& t3.trailingComma < 0 && (t3.trailingComma = this.start), \
this.finishNode(a2, \"SpreadElement\"));\n            \
this.options.ecmaVersion >= 6 && (a2.method = false, a2.shorthand = false, \
(e3 || t3) && (i2 = this.start, s2 = this.startLoc), e3 || (r3 = \
this.eat(b.star)));\n            var o2 = this.containsEsc;\n            \
return this.parsePropertyName(a2), !e3 && !o2 && this.options.ecmaVersion >= \
8 && !r3 && this.isAsyncProp(a2) ? (n2 = true, r3 = this.options.ecmaVersion \
>= 9 && this.eat(b.star), this.parsePropertyName(a2)) : n2 = false, \
this.parsePropertyValue(a2, e3, r3, n2, i2, s2, t3, o2), this.finishNode(a2, \
\"Property\");\n          }, ae.parseGetterSetter = function(e3) {\n          \
  e3.kind = e3.key.name, this.parsePropertyName(e3), e3.value = \
this.parseMethod(false);\n            var t3 = \"get\" === e3.kind ? 0 : 1;\n \
           if (e3.value.params.length !== t3) {\n              var r3 = \
e3.value.start;\n              \"get\" === e3.kind ? \
this.raiseRecoverable(r3, \"getter should have no params\") : \
this.raiseRecoverable(r3, \"setter should have exactly one param\");\n        \
    } else \"set\" === e3.kind && \"RestElement\" === e3.value.params[0].type \
&& this.raiseRecoverable(e3.value.params[0].start, \"Setter cannot use rest \
params\");\n          }, ae.parsePropertyValue = function(e3, t3, r3, n2, i2, \
s2, a2, o2) {\n            (r3 || n2) && this.type === b.colon && \
this.unexpected(), this.eat(b.colon) ? (e3.value = t3 ? \
this.parseMaybeDefault(this.start, this.startLoc) : \
this.parseMaybeAssign(false, a2), e3.kind = \"init\") : \
this.options.ecmaVersion >= 6 && this.type === b.parenL ? (t3 && \
this.unexpected(), e3.kind = \"init\", e3.method = true, e3.value = \
this.parseMethod(r3, n2)) : t3 || o2 || !(this.options.ecmaVersion >= 5) || \
e3.computed || \"Identifier\" !== e3.key.type || \"get\" !== e3.key.name && \
\"set\" !== e3.key.name || this.type === b.comma || this.type === b.braceR || \
this.type === b.eq ? this.options.ecmaVersion >= 6 && !e3.computed && \
\"Identifier\" === e3.key.type ? ((r3 || n2) && this.unexpected(), \
this.checkUnreserved(e3.key), \"await\" !== e3.key.name || this.awaitIdentPos \
|| (this.awaitIdentPos = i2), e3.kind = \"init\", t3 ? e3.value = \
this.parseMaybeDefault(i2, s2, this.copyNode(e3.key)) : this.type === b.eq && \
a2 ? (a2.shorthandAssign < 0 && (a2.shorthandAssign = this.start), e3.value = \
this.parseMaybeDefault(i2, s2, this.copyNode(e3.key))) : e3.value = \
this.copyNode(e3.key), e3.shorthand = true) : this.unexpected() : ((r3 || n2) \
&& this.unexpected(), this.parseGetterSetter(e3));\n          }, \
ae.parsePropertyName = function(e3) {\n            if \
(this.options.ecmaVersion >= 6) {\n              if (this.eat(b.bracketL)) \
return e3.computed = true, e3.key = this.parseMaybeAssign(), \
this.expect(b.bracketR), e3.key;\n              e3.computed = false;\n        \
    }\n            return e3.key = this.type === b.num || this.type === \
b.string ? this.parseExprAtom() : this.parseIdent(\"never\" !== \
this.options.allowReserved);\n          }, ae.initFunction = function(e3) {\n \
           e3.id = null, this.options.ecmaVersion >= 6 && (e3.generator = \
e3.expression = false), this.options.ecmaVersion >= 8 && (e3.async = \
false);\n          }, ae.parseMethod = function(e3, t3, r3) {\n            \
var n2 = this.startNode(), i2 = this.yieldPos, s2 = this.awaitPos, a2 = \
this.awaitIdentPos;\n            return this.initFunction(n2), \
this.options.ecmaVersion >= 6 && (n2.generator = e3), \
this.options.ecmaVersion >= 8 && (n2.async = !!t3), this.yieldPos = 0, \
this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(64 | G(t3, \
n2.generator) | (r3 ? 128 : 0)), this.expect(b.parenL), n2.params = \
this.parseBindingList(b.parenR, false, this.options.ecmaVersion >= 8), \
this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(n2, false, \
true, false), this.yieldPos = i2, this.awaitPos = s2, this.awaitIdentPos = \
a2, this.finishNode(n2, \"FunctionExpression\");\n          }, \
ae.parseArrowExpression = function(e3, t3, r3, n2) {\n            var i2 = \
this.yieldPos, s2 = this.awaitPos, a2 = this.awaitIdentPos;\n            \
return this.enterScope(16 | G(r3, false)), this.initFunction(e3), \
this.options.ecmaVersion >= 8 && (e3.async = !!r3), this.yieldPos = 0, \
this.awaitPos = 0, this.awaitIdentPos = 0, e3.params = \
this.toAssignableList(t3, true), this.parseFunctionBody(e3, true, false, n2), \
this.yieldPos = i2, this.awaitPos = s2, this.awaitIdentPos = a2, \
this.finishNode(e3, \"ArrowFunctionExpression\");\n          }, \
ae.parseFunctionBody = function(e3, t3, r3, n2) {\n            var i2 = t3 && \
this.type !== b.braceL, s2 = this.strict, a2 = false;\n            if (i2) \
e3.body = this.parseMaybeAssign(n2), e3.expression = true, \
this.checkParams(e3, false);\n            else {\n              var o2 = \
this.options.ecmaVersion >= 7 && !this.isSimpleParamList(e3.params);\n        \
      s2 && !o2 || (a2 = this.strictDirective(this.end)) && o2 && \
this.raiseRecoverable(e3.start, \"Illegal 'use strict' directive in function \
with non-simple parameter list\");\n              var u2 = this.labels;\n     \
         this.labels = [], a2 && (this.strict = true), this.checkParams(e3, \
!s2 && !a2 && !t3 && !r3 && this.isSimpleParamList(e3.params)), this.strict \
&& e3.id && this.checkLValSimple(e3.id, 5), e3.body = this.parseBlock(false, \
void 0, a2 && !s2), e3.expression = false, \
this.adaptDirectivePrologue(e3.body.body), this.labels = u2;\n            }\n \
           this.exitScope();\n          }, ae.isSimpleParamList = \
function(e3) {\n            for (var t3 = 0, r3 = e3; t3 < r3.length; t3 += \
1) {\n              if (\"Identifier\" !== r3[t3].type) return false;\n       \
     }\n            return true;\n          }, ae.checkParams = function(e3, \
t3) {\n            for (var r3 = /* @__PURE__ */ Object.create(null), n2 = 0, \
i2 = e3.params; n2 < i2.length; n2 += 1) {\n              var s2 = i2[n2];\n  \
            this.checkLValInnerPattern(s2, 1, t3 ? null : r3);\n            \
}\n          }, ae.parseExprList = function(e3, t3, r3, n2) {\n            \
for (var i2 = [], s2 = true; !this.eat(e3); ) {\n              if (s2) s2 = \
false;\n              else if (this.expect(b.comma), t3 && \
this.afterTrailingComma(e3)) break;\n              var a2 = void 0;\n         \
     r3 && this.type === b.comma ? a2 = null : this.type === b.ellipsis ? (a2 \
= this.parseSpread(n2), n2 && this.type === b.comma && n2.trailingComma < 0 \
&& (n2.trailingComma = this.start)) : a2 = this.parseMaybeAssign(false, n2), \
i2.push(a2);\n            }\n            return i2;\n          }, \
ae.checkUnreserved = function(e3) {\n            var t3 = e3.start, r3 = \
e3.end, n2 = e3.name;\n            (this.inGenerator && \"yield\" === n2 && \
this.raiseRecoverable(t3, \"Cannot use 'yield' as identifier inside a \
generator\"), this.inAsync && \"await\" === n2 && this.raiseRecoverable(t3, \
\"Cannot use 'await' as identifier inside an async function\"), \
this.currentThisScope().inClassFieldInit && \"arguments\" === n2 && \
this.raiseRecoverable(t3, \"Cannot use 'arguments' in class field \
initializer\"), !this.inClassStaticBlock || \"arguments\" !== n2 && \"await\" \
!== n2 || this.raise(t3, \"Cannot use \" + n2 + \" in class static \
initialization block\"), this.keywords.test(n2) && this.raise(t3, \
\"Unexpected keyword '\" + n2 + \"'\"), this.options.ecmaVersion < 6 && -1 \
!== this.input.slice(t3, r3).indexOf(\"\\\\\")) || (this.strict ? \
this.reservedWordsStrict : this.reservedWords).test(n2) && (this.inAsync || \
\"await\" !== n2 || this.raiseRecoverable(t3, \"Cannot use keyword 'await' \
outside an async function\"), this.raiseRecoverable(t3, \"The keyword '\" + \
n2 + \"' is reserved\"));\n          }, ae.parseIdent = function(e3) {\n      \
      var t3 = this.parseIdentNode();\n            return this.next(!!e3), \
this.finishNode(t3, \"Identifier\"), e3 || (this.checkUnreserved(t3), \
\"await\" !== t3.name || this.awaitIdentPos || (this.awaitIdentPos = \
t3.start)), t3;\n          }, ae.parseIdentNode = function() {\n            \
var e3 = this.startNode();\n            return this.type === b.name ? e3.name \
= this.value : this.type.keyword ? (e3.name = this.type.keyword, \"class\" \
!== e3.name && \"function\" !== e3.name || this.lastTokEnd === \
this.lastTokStart + 1 && 46 === this.input.charCodeAt(this.lastTokStart) || \
this.context.pop(), this.type = b.name) : this.unexpected(), e3;\n          \
}, ae.parsePrivateIdent = function() {\n            var e3 = \
this.startNode();\n            return this.type === b.privateId ? e3.name = \
this.value : this.unexpected(), this.next(), this.finishNode(e3, \
\"PrivateIdentifier\"), this.options.checkPrivateFields && (0 === \
this.privateNameStack.length ? this.raise(e3.start, \"Private field '#\" + \
e3.name + \"' must be declared in an enclosing class\") : \
this.privateNameStack[this.privateNameStack.length - 1].used.push(e3)), e3;\n \
         }, ae.parseYield = function(e3) {\n            this.yieldPos || \
(this.yieldPos = this.start);\n            var t3 = this.startNode();\n       \
     return this.next(), this.type === b.semi || this.canInsertSemicolon() || \
this.type !== b.star && !this.type.startsExpr ? (t3.delegate = false, \
t3.argument = null) : (t3.delegate = this.eat(b.star), t3.argument = \
this.parseMaybeAssign(e3)), this.finishNode(t3, \"YieldExpression\");\n       \
   }, ae.parseAwait = function(e3) {\n            this.awaitPos || \
(this.awaitPos = this.start);\n            var t3 = this.startNode();\n       \
     return this.next(), t3.argument = this.parseMaybeUnary(null, true, \
false, e3), this.finishNode(t3, \"AwaitExpression\");\n          };\n         \
 var he = U.prototype;\n          he.raise = function(e3, t3) {\n            \
var r3 = M(this.input, e3);\n            t3 += \" (\" + r3.line + \":\" + \
r3.column + \")\";\n            var n2 = new SyntaxError(t3);\n            \
throw n2.pos = e3, n2.loc = r3, n2.raisedAt = this.pos, n2;\n          }, \
he.raiseRecoverable = he.raise, he.curPosition = function() {\n            if \
(this.options.locations) return new N(this.curLine, this.pos - \
this.lineStart);\n          };\n          var ce = U.prototype, pe = \
function(e3) {\n            this.flags = e3, this.var = [], this.lexical = \
[], this.functions = [], this.inClassFieldInit = false;\n          };\n       \
   ce.enterScope = function(e3) {\n            this.scopeStack.push(new \
pe(e3));\n          }, ce.exitScope = function() {\n            \
this.scopeStack.pop();\n          }, ce.treatFunctionsAsVarInScope = \
function(e3) {\n            return 2 & e3.flags || !this.inModule && 1 & \
e3.flags;\n          }, ce.declareName = function(e3, t3, r3) {\n            \
var n2 = false;\n            if (2 === t3) {\n              var i2 = \
this.currentScope();\n              n2 = i2.lexical.indexOf(e3) > -1 || \
i2.functions.indexOf(e3) > -1 || i2.var.indexOf(e3) > -1, \
i2.lexical.push(e3), this.inModule && 1 & i2.flags && delete \
this.undefinedExports[e3];\n            } else if (4 === t3) {\n              \
this.currentScope().lexical.push(e3);\n            } else if (3 === t3) {\n   \
           var s2 = this.currentScope();\n              n2 = \
this.treatFunctionsAsVar ? s2.lexical.indexOf(e3) > -1 : \
s2.lexical.indexOf(e3) > -1 || s2.var.indexOf(e3) > -1, \
s2.functions.push(e3);\n            } else for (var a2 = \
this.scopeStack.length - 1; a2 >= 0; --a2) {\n              var o2 = \
this.scopeStack[a2];\n              if (o2.lexical.indexOf(e3) > -1 && !(32 & \
o2.flags && o2.lexical[0] === e3) || !this.treatFunctionsAsVarInScope(o2) && \
o2.functions.indexOf(e3) > -1) {\n                n2 = true;\n                \
break;\n              }\n              if (o2.var.push(e3), this.inModule && \
1 & o2.flags && delete this.undefinedExports[e3], 259 & o2.flags) break;\n    \
        }\n            n2 && this.raiseRecoverable(r3, \"Identifier '\" + e3 \
+ \"' has already been declared\");\n          }, ce.checkLocalExport = \
function(e3) {\n            -1 === \
this.scopeStack[0].lexical.indexOf(e3.name) && -1 === \
this.scopeStack[0].var.indexOf(e3.name) && (this.undefinedExports[e3.name] = \
e3);\n          }, ce.currentScope = function() {\n            return \
this.scopeStack[this.scopeStack.length - 1];\n          }, ce.currentVarScope \
= function() {\n            for (var e3 = this.scopeStack.length - 1; ; e3--) \
{\n              var t3 = this.scopeStack[e3];\n              if (259 & \
t3.flags) return t3;\n            }\n          }, ce.currentThisScope = \
function() {\n            for (var e3 = this.scopeStack.length - 1; ; e3--) \
{\n              var t3 = this.scopeStack[e3];\n              if (259 & \
t3.flags && !(16 & t3.flags)) return t3;\n            }\n          };\n       \
   var de = function(e3, t3, r3) {\n            this.type = \"\", this.start \
= t3, this.end = 0, e3.options.locations && (this.loc = new V(e3, r3)), \
e3.options.directSourceFile && (this.sourceFile = \
e3.options.directSourceFile), e3.options.ranges && (this.range = [t3, 0]);\n  \
        }, me = U.prototype;\n          function fe(e3, t3, r3, n2) {\n       \
     return e3.type = t3, e3.end = r3, this.options.locations && (e3.loc.end \
= n2), this.options.ranges && (e3.range[1] = r3), e3;\n          }\n          \
me.startNode = function() {\n            return new de(this, this.start, \
this.startLoc);\n          }, me.startNodeAt = function(e3, t3) {\n           \
 return new de(this, e3, t3);\n          }, me.finishNode = function(e3, t3) \
{\n            return fe.call(this, e3, t3, this.lastTokEnd, \
this.lastTokEndLoc);\n          }, me.finishNodeAt = function(e3, t3, r3, n2) \
{\n            return fe.call(this, e3, t3, r3, n2);\n          }, \
me.copyNode = function(e3) {\n            var t3 = new de(this, e3.start, \
this.startLoc);\n            for (var r3 in e3) t3[r3] = e3[r3];\n            \
return t3;\n          };\n          var ge = \"ASCII ASCII_Hex_Digit AHex \
Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M \
Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped \
CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF \
Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash \
Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji \
Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation \
Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex \
IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start \
IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE \
Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn \
Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI \
Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term \
Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space \
space XID_Continue XIDC XID_Start XIDS\", xe = ge + \" \
Extended_Pictographic\", ye = xe + \" EBase EComp EMod EPres ExtPict\", be = \
{ 9: ge, 10: xe, 11: xe, 12: ye, 13: ye, 14: ye }, Te = { 9: \"\", 10: \"\", \
11: \"\", 12: \"\", 13: \"\", 14: \"Basic_Emoji Emoji_Keycap_Sequence \
RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence \
RGI_Emoji_ZWJ_Sequence RGI_Emoji\" }, ve = \"Cased_Letter LC \
Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl \
Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark \
Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L \
Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark \
Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn \
Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No \
Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co \
Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate \
Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu\", Se = \
\"Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn \
Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng \
Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid \
Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm \
Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot \
Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl \
Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic \
Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani \
Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira \
Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli \
Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana \
Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao \
Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu \
Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean \
Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend \
Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong \
Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa \
Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic \
Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo \
Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma \
Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician \
Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra \
Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh \
Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc \
Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr \
Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt \
Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii \
Zanabazar_Square Zanb\", Ae = Se + \" Dogra Dogr Gunjala_Gondi Gong \
Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian \
Sogd\", _e = Ae + \" Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong \
Hmnp Wancho Wcho\", Ee = _e + \" Chorasmian Chrs Diak Dives_Akuru \
Khitan_Small_Script Kits Yezi Yezidi\", we = Ee + \" Cypro_Minoan Cpmn \
Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith\", ke = { 9: Se, 10: Ae, 11: \
_e, 12: Ee, 13: we, 14: we + \" Gara Garay Gukh Gurung_Khema Hrkt \
Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu \
Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz\" }, Ie = {};\n          \
function De(e3) {\n            var t3 = Ie[e3] = { binary: L(be[e3] + \" \" + \
ve), binaryOfStrings: L(Te[e3]), nonBinary: { General_Category: L(ve), \
Script: L(ke[e3]) } };\n            t3.nonBinary.Script_Extensions = \
t3.nonBinary.Script, t3.nonBinary.gc = t3.nonBinary.General_Category, \
t3.nonBinary.sc = t3.nonBinary.Script, t3.nonBinary.scx = \
t3.nonBinary.Script_Extensions;\n          }\n          for (var Ce = 0, $e = \
[9, 10, 11, 12, 13, 14]; Ce < $e.length; Ce += 1) {\n            \
De($e[Ce]);\n          }\n          var Le = U.prototype, Re = function(e3, \
t3) {\n            this.parent = e3, this.base = t3 || this;\n          };\n  \
        Re.prototype.separatedFrom = function(e3) {\n            for (var t3 \
= this; t3; t3 = t3.parent) for (var r3 = e3; r3; r3 = r3.parent) if (t3.base \
=== r3.base && t3 !== r3) return true;\n            return false;\n          \
}, Re.prototype.sibling = function() {\n            return new \
Re(this.parent, this.base);\n          };\n          var Fe = function(e3) \
{\n            this.parser = e3, this.validFlags = \"gim\" + \
(e3.options.ecmaVersion >= 6 ? \"uy\" : \"\") + (e3.options.ecmaVersion >= 9 \
? \"s\" : \"\") + (e3.options.ecmaVersion >= 13 ? \"d\" : \"\") + \
(e3.options.ecmaVersion >= 15 ? \"v\" : \"\"), this.unicodeProperties = \
Ie[e3.options.ecmaVersion >= 14 ? 14 : e3.options.ecmaVersion], this.source = \
\"\", this.flags = \"\", this.start = 0, this.switchU = false, this.switchV = \
false, this.switchN = false, this.pos = 0, this.lastIntValue = 0, \
this.lastStringValue = \"\", this.lastAssertionIsQuantifiable = false, \
this.numCapturingParens = 0, this.maxBackReference = 0, this.groupNames = /* \
@__PURE__ */ Object.create(null), this.backReferenceNames = [], this.branchID \
= null;\n          };\n          function Ne(e3) {\n            return 105 \
=== e3 || 109 === e3 || 115 === e3;\n          }\n          function Ve(e3) \
{\n            return 36 === e3 || e3 >= 40 && e3 <= 43 || 46 === e3 || 63 \
=== e3 || e3 >= 91 && e3 <= 94 || e3 >= 123 && e3 <= 125;\n          }\n      \
    function Me(e3) {\n            return e3 >= 65 && e3 <= 90 || e3 >= 97 && \
e3 <= 122;\n          }\n          Fe.prototype.reset = function(e3, t3, r3) \
{\n            var n2 = -1 !== r3.indexOf(\"v\"), i2 = -1 !== \
r3.indexOf(\"u\");\n            this.start = 0 | e3, this.source = t3 + \"\", \
this.flags = r3, n2 && this.parser.options.ecmaVersion >= 15 ? (this.switchU \
= true, this.switchV = true, this.switchN = true) : (this.switchU = i2 && \
this.parser.options.ecmaVersion >= 6, this.switchV = false, this.switchN = i2 \
&& this.parser.options.ecmaVersion >= 9);\n          }, Fe.prototype.raise = \
function(e3) {\n            this.parser.raiseRecoverable(this.start, \
\"Invalid regular expression: /\" + this.source + \"/: \" + e3);\n          \
}, Fe.prototype.at = function(e3, t3) {\n            void 0 === t3 && (t3 = \
false);\n            var r3 = this.source, n2 = r3.length;\n            if \
(e3 >= n2) return -1;\n            var i2 = r3.charCodeAt(e3);\n            \
if (!t3 && !this.switchU || i2 <= 55295 || i2 >= 57344 || e3 + 1 >= n2) \
return i2;\n            var s2 = r3.charCodeAt(e3 + 1);\n            return \
s2 >= 56320 && s2 <= 57343 ? (i2 << 10) + s2 - 56613888 : i2;\n          }, \
Fe.prototype.nextIndex = function(e3, t3) {\n            void 0 === t3 && (t3 \
= false);\n            var r3 = this.source, n2 = r3.length;\n            if \
(e3 >= n2) return n2;\n            var i2, s2 = r3.charCodeAt(e3);\n          \
  return !t3 && !this.switchU || s2 <= 55295 || s2 >= 57344 || e3 + 1 >= n2 \
|| (i2 = r3.charCodeAt(e3 + 1)) < 56320 || i2 > 57343 ? e3 + 1 : e3 + 2;\n    \
      }, Fe.prototype.current = function(e3) {\n            return void 0 === \
e3 && (e3 = false), this.at(this.pos, e3);\n          }, \
Fe.prototype.lookahead = function(e3) {\n            return void 0 === e3 && \
(e3 = false), this.at(this.nextIndex(this.pos, e3), e3);\n          }, \
Fe.prototype.advance = function(e3) {\n            void 0 === e3 && (e3 = \
false), this.pos = this.nextIndex(this.pos, e3);\n          }, \
Fe.prototype.eat = function(e3, t3) {\n            return void 0 === t3 && \
(t3 = false), this.current(t3) === e3 && (this.advance(t3), true);\n          \
}, Fe.prototype.eatChars = function(e3, t3) {\n            void 0 === t3 && \
(t3 = false);\n            for (var r3 = this.pos, n2 = 0, i2 = e3; n2 < \
i2.length; n2 += 1) {\n              var s2 = i2[n2], a2 = this.at(r3, t3);\n \
             if (-1 === a2 || a2 !== s2) return false;\n              r3 = \
this.nextIndex(r3, t3);\n            }\n            return this.pos = r3, \
true;\n          }, Le.validateRegExpFlags = function(e3) {\n            for \
(var t3 = e3.validFlags, r3 = e3.flags, n2 = false, i2 = false, s2 = 0; s2 < \
r3.length; s2++) {\n              var a2 = r3.charAt(s2);\n              -1 \
=== t3.indexOf(a2) && this.raise(e3.start, \"Invalid regular expression \
flag\"), r3.indexOf(a2, s2 + 1) > -1 && this.raise(e3.start, \"Duplicate \
regular expression flag\"), \"u\" === a2 && (n2 = true), \"v\" === a2 && (i2 \
= true);\n            }\n            this.options.ecmaVersion >= 15 && n2 && \
i2 && this.raise(e3.start, \"Invalid regular expression flag\");\n          \
}, Le.validateRegExpPattern = function(e3) {\n            \
this.regexp_pattern(e3), !e3.switchN && this.options.ecmaVersion >= 9 && \
function(e4) {\n              for (var t3 in e4) return true;\n              \
return false;\n            }(e3.groupNames) && (e3.switchN = true, \
this.regexp_pattern(e3));\n          }, Le.regexp_pattern = function(e3) {\n  \
          e3.pos = 0, e3.lastIntValue = 0, e3.lastStringValue = \"\", \
e3.lastAssertionIsQuantifiable = false, e3.numCapturingParens = 0, \
e3.maxBackReference = 0, e3.groupNames = /* @__PURE__ */ Object.create(null), \
e3.backReferenceNames.length = 0, e3.branchID = null, \
this.regexp_disjunction(e3), e3.pos !== e3.source.length && (e3.eat(41) && \
e3.raise(\"Unmatched ')'\"), (e3.eat(93) || e3.eat(125)) && e3.raise(\"Lone \
quantifier brackets\")), e3.maxBackReference > e3.numCapturingParens && \
e3.raise(\"Invalid escape\");\n            for (var t3 = 0, r3 = \
e3.backReferenceNames; t3 < r3.length; t3 += 1) {\n              var n2 = \
r3[t3];\n              e3.groupNames[n2] || e3.raise(\"Invalid named capture \
referenced\");\n            }\n          }, Le.regexp_disjunction = \
function(e3) {\n            var t3 = this.options.ecmaVersion >= 16;\n        \
    for (t3 && (e3.branchID = new Re(e3.branchID, null)), \
this.regexp_alternative(e3); e3.eat(124); ) t3 && (e3.branchID = \
e3.branchID.sibling()), this.regexp_alternative(e3);\n            t3 && \
(e3.branchID = e3.branchID.parent), this.regexp_eatQuantifier(e3, true) && \
e3.raise(\"Nothing to repeat\"), e3.eat(123) && e3.raise(\"Lone quantifier \
brackets\");\n          }, Le.regexp_alternative = function(e3) {\n           \
 for (; e3.pos < e3.source.length && this.regexp_eatTerm(e3); ) ;\n          \
}, Le.regexp_eatTerm = function(e3) {\n            return \
this.regexp_eatAssertion(e3) ? (e3.lastAssertionIsQuantifiable && \
this.regexp_eatQuantifier(e3) && e3.switchU && e3.raise(\"Invalid \
quantifier\"), true) : !!(e3.switchU ? this.regexp_eatAtom(e3) : \
this.regexp_eatExtendedAtom(e3)) && (this.regexp_eatQuantifier(e3), true);\n  \
        }, Le.regexp_eatAssertion = function(e3) {\n            var t3 = \
e3.pos;\n            if (e3.lastAssertionIsQuantifiable = false, e3.eat(94) \
|| e3.eat(36)) return true;\n            if (e3.eat(92)) {\n              if \
(e3.eat(66) || e3.eat(98)) return true;\n              e3.pos = t3;\n         \
   }\n            if (e3.eat(40) && e3.eat(63)) {\n              var r3 = \
false;\n              if (this.options.ecmaVersion >= 9 && (r3 = e3.eat(60)), \
e3.eat(61) || e3.eat(33)) return this.regexp_disjunction(e3), e3.eat(41) || \
e3.raise(\"Unterminated group\"), e3.lastAssertionIsQuantifiable = !r3, \
true;\n            }\n            return e3.pos = t3, false;\n          }, \
Le.regexp_eatQuantifier = function(e3, t3) {\n            return void 0 === \
t3 && (t3 = false), !!this.regexp_eatQuantifierPrefix(e3, t3) && (e3.eat(63), \
true);\n          }, Le.regexp_eatQuantifierPrefix = function(e3, t3) {\n     \
       return e3.eat(42) || e3.eat(43) || e3.eat(63) || \
this.regexp_eatBracedQuantifier(e3, t3);\n          }, \
Le.regexp_eatBracedQuantifier = function(e3, t3) {\n            var r3 = \
e3.pos;\n            if (e3.eat(123)) {\n              var n2 = 0, i2 = -1;\n \
             if (this.regexp_eatDecimalDigits(e3) && (n2 = e3.lastIntValue, \
e3.eat(44) && this.regexp_eatDecimalDigits(e3) && (i2 = e3.lastIntValue), \
e3.eat(125))) return -1 !== i2 && i2 < n2 && !t3 && e3.raise(\"numbers out of \
order in {} quantifier\"), true;\n              e3.switchU && !t3 && \
e3.raise(\"Incomplete quantifier\"), e3.pos = r3;\n            }\n            \
return false;\n          }, Le.regexp_eatAtom = function(e3) {\n            \
return this.regexp_eatPatternCharacters(e3) || e3.eat(46) || \
this.regexp_eatReverseSolidusAtomEscape(e3) || \
this.regexp_eatCharacterClass(e3) || this.regexp_eatUncapturingGroup(e3) || \
this.regexp_eatCapturingGroup(e3);\n          }, \
Le.regexp_eatReverseSolidusAtomEscape = function(e3) {\n            var t3 = \
e3.pos;\n            if (e3.eat(92)) {\n              if \
(this.regexp_eatAtomEscape(e3)) return true;\n              e3.pos = t3;\n    \
        }\n            return false;\n          }, \
Le.regexp_eatUncapturingGroup = function(e3) {\n            var t3 = \
e3.pos;\n            if (e3.eat(40)) {\n              if (e3.eat(63)) {\n     \
           if (this.options.ecmaVersion >= 16) {\n                  var r3 = \
this.regexp_eatModifiers(e3), n2 = e3.eat(45);\n                  if (r3 || \
n2) {\n                    for (var i2 = 0; i2 < r3.length; i2++) {\n         \
             var s2 = r3.charAt(i2);\n                      r3.indexOf(s2, i2 \
+ 1) > -1 && e3.raise(\"Duplicate regular expression modifiers\");\n          \
          }\n                    if (n2) {\n                      var a2 = \
this.regexp_eatModifiers(e3);\n                      r3 || a2 || 58 !== \
e3.current() || e3.raise(\"Invalid regular expression modifiers\");\n         \
             for (var o2 = 0; o2 < a2.length; o2++) {\n                       \
 var u2 = a2.charAt(o2);\n                        (a2.indexOf(u2, o2 + 1) > \
-1 || r3.indexOf(u2) > -1) && e3.raise(\"Duplicate regular expression \
modifiers\");\n                      }\n                    }\n               \
   }\n                }\n                if (e3.eat(58)) {\n                  \
if (this.regexp_disjunction(e3), e3.eat(41)) return true;\n                  \
e3.raise(\"Unterminated group\");\n                }\n              }\n       \
       e3.pos = t3;\n            }\n            return false;\n          }, \
Le.regexp_eatCapturingGroup = function(e3) {\n            if (e3.eat(40)) {\n \
             if (this.options.ecmaVersion >= 9 ? \
this.regexp_groupSpecifier(e3) : 63 === e3.current() && e3.raise(\"Invalid \
group\"), this.regexp_disjunction(e3), e3.eat(41)) return \
e3.numCapturingParens += 1, true;\n              e3.raise(\"Unterminated \
group\");\n            }\n            return false;\n          }, \
Le.regexp_eatModifiers = function(e3) {\n            for (var t3 = \"\", r3 = \
0; -1 !== (r3 = e3.current()) && Ne(r3); ) t3 += R(r3), e3.advance();\n       \
     return t3;\n          }, Le.regexp_eatExtendedAtom = function(e3) {\n    \
        return e3.eat(46) || this.regexp_eatReverseSolidusAtomEscape(e3) || \
this.regexp_eatCharacterClass(e3) || this.regexp_eatUncapturingGroup(e3) || \
this.regexp_eatCapturingGroup(e3) || \
this.regexp_eatInvalidBracedQuantifier(e3) || \
this.regexp_eatExtendedPatternCharacter(e3);\n          }, \
Le.regexp_eatInvalidBracedQuantifier = function(e3) {\n            return \
this.regexp_eatBracedQuantifier(e3, true) && e3.raise(\"Nothing to repeat\"), \
false;\n          }, Le.regexp_eatSyntaxCharacter = function(e3) {\n          \
  var t3 = e3.current();\n            return !!Ve(t3) && (e3.lastIntValue = \
t3, e3.advance(), true);\n          }, Le.regexp_eatPatternCharacters = \
function(e3) {\n            for (var t3 = e3.pos, r3 = 0; -1 !== (r3 = \
e3.current()) && !Ve(r3); ) e3.advance();\n            return e3.pos !== \
t3;\n          }, Le.regexp_eatExtendedPatternCharacter = function(e3) {\n    \
        var t3 = e3.current();\n            return !(-1 === t3 || 36 === t3 \
|| t3 >= 40 && t3 <= 43 || 46 === t3 || 63 === t3 || 91 === t3 || 94 === t3 \
|| 124 === t3) && (e3.advance(), true);\n          }, \
Le.regexp_groupSpecifier = function(e3) {\n            if (e3.eat(63)) {\n    \
          this.regexp_eatGroupName(e3) || e3.raise(\"Invalid group\");\n      \
        var t3 = this.options.ecmaVersion >= 16, r3 = \
e3.groupNames[e3.lastStringValue];\n              if (r3) if (t3) for (var n2 \
= 0, i2 = r3; n2 < i2.length; n2 += 1) {\n                \
i2[n2].separatedFrom(e3.branchID) || e3.raise(\"Duplicate capture group \
name\");\n              }\n              else e3.raise(\"Duplicate capture \
group name\");\n              t3 ? (r3 || (e3.groupNames[e3.lastStringValue] \
= [])).push(e3.branchID) : e3.groupNames[e3.lastStringValue] = true;\n        \
    }\n          }, Le.regexp_eatGroupName = function(e3) {\n            if \
(e3.lastStringValue = \"\", e3.eat(60)) {\n              if \
(this.regexp_eatRegExpIdentifierName(e3) && e3.eat(62)) return true;\n        \
      e3.raise(\"Invalid capture group name\");\n            }\n            \
return false;\n          }, Le.regexp_eatRegExpIdentifierName = function(e3) \
{\n            if (e3.lastStringValue = \"\", \
this.regexp_eatRegExpIdentifierStart(e3)) {\n              for \
(e3.lastStringValue += R(e3.lastIntValue); \
this.regexp_eatRegExpIdentifierPart(e3); ) e3.lastStringValue += \
R(e3.lastIntValue);\n              return true;\n            }\n            \
return false;\n          }, Le.regexp_eatRegExpIdentifierStart = function(e3) \
{\n            var t3 = e3.pos, r3 = this.options.ecmaVersion >= 11, n2 = \
e3.current(r3);\n            return e3.advance(r3), 92 === n2 && \
this.regexp_eatRegExpUnicodeEscapeSequence(e3, r3) && (n2 = e3.lastIntValue), \
function(e4) {\n              return c(e4, true) || 36 === e4 || 95 === e4;\n \
           }(n2) ? (e3.lastIntValue = n2, true) : (e3.pos = t3, false);\n     \
     }, Le.regexp_eatRegExpIdentifierPart = function(e3) {\n            var \
t3 = e3.pos, r3 = this.options.ecmaVersion >= 11, n2 = e3.current(r3);\n      \
      return e3.advance(r3), 92 === n2 && \
this.regexp_eatRegExpUnicodeEscapeSequence(e3, r3) && (n2 = e3.lastIntValue), \
function(e4) {\n              return p(e4, true) || 36 === e4 || 95 === e4 || \
8204 === e4 || 8205 === e4;\n            }(n2) ? (e3.lastIntValue = n2, true) \
: (e3.pos = t3, false);\n          }, Le.regexp_eatAtomEscape = function(e3) \
{\n            return !!(this.regexp_eatBackReference(e3) || \
this.regexp_eatCharacterClassEscape(e3) || this.regexp_eatCharacterEscape(e3) \
|| e3.switchN && this.regexp_eatKGroupName(e3)) || (e3.switchU && (99 === \
e3.current() && e3.raise(\"Invalid unicode escape\"), e3.raise(\"Invalid \
escape\")), false);\n          }, Le.regexp_eatBackReference = function(e3) \
{\n            var t3 = e3.pos;\n            if \
(this.regexp_eatDecimalEscape(e3)) {\n              var r3 = \
e3.lastIntValue;\n              if (e3.switchU) return r3 > \
e3.maxBackReference && (e3.maxBackReference = r3), true;\n              if \
(r3 <= e3.numCapturingParens) return true;\n              e3.pos = t3;\n      \
      }\n            return false;\n          }, Le.regexp_eatKGroupName = \
function(e3) {\n            if (e3.eat(107)) {\n              if \
(this.regexp_eatGroupName(e3)) return \
e3.backReferenceNames.push(e3.lastStringValue), true;\n              \
e3.raise(\"Invalid named reference\");\n            }\n            return \
false;\n          }, Le.regexp_eatCharacterEscape = function(e3) {\n          \
  return this.regexp_eatControlEscape(e3) || \
this.regexp_eatCControlLetter(e3) || this.regexp_eatZero(e3) || \
this.regexp_eatHexEscapeSequence(e3) || \
this.regexp_eatRegExpUnicodeEscapeSequence(e3, false) || !e3.switchU && \
this.regexp_eatLegacyOctalEscapeSequence(e3) || \
this.regexp_eatIdentityEscape(e3);\n          }, Le.regexp_eatCControlLetter \
= function(e3) {\n            var t3 = e3.pos;\n            if (e3.eat(99)) \
{\n              if (this.regexp_eatControlLetter(e3)) return true;\n         \
     e3.pos = t3;\n            }\n            return false;\n          }, \
Le.regexp_eatZero = function(e3) {\n            return 48 === e3.current() && \
!Pe(e3.lookahead()) && (e3.lastIntValue = 0, e3.advance(), true);\n          \
}, Le.regexp_eatControlEscape = function(e3) {\n            var t3 = \
e3.current();\n            return 116 === t3 ? (e3.lastIntValue = 9, \
e3.advance(), true) : 110 === t3 ? (e3.lastIntValue = 10, e3.advance(), true) \
: 118 === t3 ? (e3.lastIntValue = 11, e3.advance(), true) : 102 === t3 ? \
(e3.lastIntValue = 12, e3.advance(), true) : 114 === t3 && (e3.lastIntValue = \
13, e3.advance(), true);\n          }, Le.regexp_eatControlLetter = \
function(e3) {\n            var t3 = e3.current();\n            return \
!!Me(t3) && (e3.lastIntValue = t3 % 32, e3.advance(), true);\n          }, \
Le.regexp_eatRegExpUnicodeEscapeSequence = function(e3, t3) {\n            \
void 0 === t3 && (t3 = false);\n            var r3, n2 = e3.pos, i2 = t3 || \
e3.switchU;\n            if (e3.eat(117)) {\n              if \
(this.regexp_eatFixedHexDigits(e3, 4)) {\n                var s2 = \
e3.lastIntValue;\n                if (i2 && s2 >= 55296 && s2 <= 56319) {\n   \
               var a2 = e3.pos;\n                  if (e3.eat(92) && \
e3.eat(117) && this.regexp_eatFixedHexDigits(e3, 4)) {\n                    \
var o2 = e3.lastIntValue;\n                    if (o2 >= 56320 && o2 <= \
57343) return e3.lastIntValue = 1024 * (s2 - 55296) + (o2 - 56320) + 65536, \
true;\n                  }\n                  e3.pos = a2, e3.lastIntValue = \
s2;\n                }\n                return true;\n              }\n       \
       if (i2 && e3.eat(123) && this.regexp_eatHexDigits(e3) && e3.eat(125) \
&& ((r3 = e3.lastIntValue) >= 0 && r3 <= 1114111)) return true;\n             \
 i2 && e3.raise(\"Invalid unicode escape\"), e3.pos = n2;\n            }\n    \
        return false;\n          }, Le.regexp_eatIdentityEscape = \
function(e3) {\n            if (e3.switchU) return \
!!this.regexp_eatSyntaxCharacter(e3) || !!e3.eat(47) && (e3.lastIntValue = \
47, true);\n            var t3 = e3.current();\n            return !(99 === \
t3 || e3.switchN && 107 === t3) && (e3.lastIntValue = t3, e3.advance(), \
true);\n          }, Le.regexp_eatDecimalEscape = function(e3) {\n            \
e3.lastIntValue = 0;\n            var t3 = e3.current();\n            if (t3 \
>= 49 && t3 <= 57) {\n              do {\n                e3.lastIntValue = \
10 * e3.lastIntValue + (t3 - 48), e3.advance();\n              } while ((t3 = \
e3.current()) >= 48 && t3 <= 57);\n              return true;\n            \
}\n            return false;\n          };\n          function Oe(e3) {\n     \
       return Me(e3) || 95 === e3;\n          }\n          function ze(e3) \
{\n            return Oe(e3) || Pe(e3);\n          }\n          function \
Pe(e3) {\n            return e3 >= 48 && e3 <= 57;\n          }\n          \
function Ke(e3) {\n            return e3 >= 48 && e3 <= 57 || e3 >= 65 && e3 \
<= 70 || e3 >= 97 && e3 <= 102;\n          }\n          function Ge(e3) {\n   \
         return e3 >= 65 && e3 <= 70 ? e3 - 65 + 10 : e3 >= 97 && e3 <= 102 ? \
e3 - 97 + 10 : e3 - 48;\n          }\n          function Ue(e3) {\n           \
 return e3 >= 48 && e3 <= 55;\n          }\n          \
Le.regexp_eatCharacterClassEscape = function(e3) {\n            var t3 = \
e3.current();\n            if (/* @__PURE__ */ function(e4) {\n              \
return 100 === e4 || 68 === e4 || 115 === e4 || 83 === e4 || 119 === e4 || 87 \
=== e4;\n            }(t3)) return e3.lastIntValue = -1, e3.advance(), 1;\n   \
         var r3 = false;\n            if (e3.switchU && \
this.options.ecmaVersion >= 9 && ((r3 = 80 === t3) || 112 === t3)) {\n        \
      var n2;\n              if (e3.lastIntValue = -1, e3.advance(), \
e3.eat(123) && (n2 = this.regexp_eatUnicodePropertyValueExpression(e3)) && \
e3.eat(125)) return r3 && 2 === n2 && e3.raise(\"Invalid property name\"), \
n2;\n              e3.raise(\"Invalid property name\");\n            }\n      \
      return 0;\n          }, Le.regexp_eatUnicodePropertyValueExpression = \
function(e3) {\n            var t3 = e3.pos;\n            if \
(this.regexp_eatUnicodePropertyName(e3) && e3.eat(61)) {\n              var \
r3 = e3.lastStringValue;\n              if \
(this.regexp_eatUnicodePropertyValue(e3)) {\n                var n2 = \
e3.lastStringValue;\n                return \
this.regexp_validateUnicodePropertyNameAndValue(e3, r3, n2), 1;\n             \
 }\n            }\n            if (e3.pos = t3, \
this.regexp_eatLoneUnicodePropertyNameOrValue(e3)) {\n              var i2 = \
e3.lastStringValue;\n              return \
this.regexp_validateUnicodePropertyNameOrValue(e3, i2);\n            }\n      \
      return 0;\n          }, Le.regexp_validateUnicodePropertyNameAndValue = \
function(e3, t3, r3) {\n            D(e3.unicodeProperties.nonBinary, t3) || \
e3.raise(\"Invalid property name\"), \
e3.unicodeProperties.nonBinary[t3].test(r3) || e3.raise(\"Invalid property \
value\");\n          }, Le.regexp_validateUnicodePropertyNameOrValue = \
function(e3, t3) {\n            return e3.unicodeProperties.binary.test(t3) ? \
1 : e3.switchV && e3.unicodeProperties.binaryOfStrings.test(t3) ? 2 : void \
e3.raise(\"Invalid property name\");\n          }, \
Le.regexp_eatUnicodePropertyName = function(e3) {\n            var t3 = 0;\n  \
          for (e3.lastStringValue = \"\"; Oe(t3 = e3.current()); ) \
e3.lastStringValue += R(t3), e3.advance();\n            return \"\" !== \
e3.lastStringValue;\n          }, Le.regexp_eatUnicodePropertyValue = \
function(e3) {\n            var t3 = 0;\n            for (e3.lastStringValue \
= \"\"; ze(t3 = e3.current()); ) e3.lastStringValue += R(t3), e3.advance();\n \
           return \"\" !== e3.lastStringValue;\n          }, \
Le.regexp_eatLoneUnicodePropertyNameOrValue = function(e3) {\n            \
return this.regexp_eatUnicodePropertyValue(e3);\n          }, \
Le.regexp_eatCharacterClass = function(e3) {\n            if (e3.eat(91)) {\n \
             var t3 = e3.eat(94), r3 = this.regexp_classContents(e3);\n       \
       return e3.eat(93) || e3.raise(\"Unterminated character class\"), t3 && \
2 === r3 && e3.raise(\"Negated character class may contain strings\"), \
true;\n            }\n            return false;\n          }, \
Le.regexp_classContents = function(e3) {\n            return 93 === \
e3.current() ? 1 : e3.switchV ? this.regexp_classSetExpression(e3) : \
(this.regexp_nonEmptyClassRanges(e3), 1);\n          }, \
Le.regexp_nonEmptyClassRanges = function(e3) {\n            for (; \
this.regexp_eatClassAtom(e3); ) {\n              var t3 = e3.lastIntValue;\n  \
            if (e3.eat(45) && this.regexp_eatClassAtom(e3)) {\n               \
 var r3 = e3.lastIntValue;\n                !e3.switchU || -1 !== t3 && -1 \
!== r3 || e3.raise(\"Invalid character class\"), -1 !== t3 && -1 !== r3 && t3 \
> r3 && e3.raise(\"Range out of order in character class\");\n              \
}\n            }\n          }, Le.regexp_eatClassAtom = function(e3) {\n      \
      var t3 = e3.pos;\n            if (e3.eat(92)) {\n              if \
(this.regexp_eatClassEscape(e3)) return true;\n              if (e3.switchU) \
{\n                var r3 = e3.current();\n                (99 === r3 || \
Ue(r3)) && e3.raise(\"Invalid class escape\"), e3.raise(\"Invalid \
escape\");\n              }\n              e3.pos = t3;\n            }\n      \
      var n2 = e3.current();\n            return 93 !== n2 && \
(e3.lastIntValue = n2, e3.advance(), true);\n          }, \
Le.regexp_eatClassEscape = function(e3) {\n            var t3 = e3.pos;\n     \
       if (e3.eat(98)) return e3.lastIntValue = 8, true;\n            if \
(e3.switchU && e3.eat(45)) return e3.lastIntValue = 45, true;\n            if \
(!e3.switchU && e3.eat(99)) {\n              if \
(this.regexp_eatClassControlLetter(e3)) return true;\n              e3.pos = \
t3;\n            }\n            return \
this.regexp_eatCharacterClassEscape(e3) || \
this.regexp_eatCharacterEscape(e3);\n          }, \
Le.regexp_classSetExpression = function(e3) {\n            var t3, r3 = 1;\n  \
          if (this.regexp_eatClassSetRange(e3)) ;\n            else if (t3 = \
this.regexp_eatClassSetOperand(e3)) {\n              2 === t3 && (r3 = 2);\n  \
            for (var n2 = e3.pos; e3.eatChars([38, 38]); ) 38 !== \
e3.current() && (t3 = this.regexp_eatClassSetOperand(e3)) ? 2 !== t3 && (r3 = \
1) : e3.raise(\"Invalid character in character class\");\n              if \
(n2 !== e3.pos) return r3;\n              for (; e3.eatChars([45, 45]); ) \
this.regexp_eatClassSetOperand(e3) || e3.raise(\"Invalid character in \
character class\");\n              if (n2 !== e3.pos) return r3;\n            \
} else e3.raise(\"Invalid character in character class\");\n            for \
(; ; ) if (!this.regexp_eatClassSetRange(e3)) {\n              if (!(t3 = \
this.regexp_eatClassSetOperand(e3))) return r3;\n              2 === t3 && \
(r3 = 2);\n            }\n          }, Le.regexp_eatClassSetRange = \
function(e3) {\n            var t3 = e3.pos;\n            if \
(this.regexp_eatClassSetCharacter(e3)) {\n              var r3 = \
e3.lastIntValue;\n              if (e3.eat(45) && \
this.regexp_eatClassSetCharacter(e3)) {\n                var n2 = \
e3.lastIntValue;\n                return -1 !== r3 && -1 !== n2 && r3 > n2 && \
e3.raise(\"Range out of order in character class\"), true;\n              }\n \
             e3.pos = t3;\n            }\n            return false;\n         \
 }, Le.regexp_eatClassSetOperand = function(e3) {\n            return \
this.regexp_eatClassSetCharacter(e3) ? 1 : \
this.regexp_eatClassStringDisjunction(e3) || \
this.regexp_eatNestedClass(e3);\n          }, Le.regexp_eatNestedClass = \
function(e3) {\n            var t3 = e3.pos;\n            if (e3.eat(91)) {\n \
             var r3 = e3.eat(94), n2 = this.regexp_classContents(e3);\n       \
       if (e3.eat(93)) return r3 && 2 === n2 && e3.raise(\"Negated character \
class may contain strings\"), n2;\n              e3.pos = t3;\n            \
}\n            if (e3.eat(92)) {\n              var i2 = \
this.regexp_eatCharacterClassEscape(e3);\n              if (i2) return i2;\n  \
            e3.pos = t3;\n            }\n            return null;\n          \
}, Le.regexp_eatClassStringDisjunction = function(e3) {\n            var t3 = \
e3.pos;\n            if (e3.eatChars([92, 113])) {\n              if \
(e3.eat(123)) {\n                var r3 = \
this.regexp_classStringDisjunctionContents(e3);\n                if \
(e3.eat(125)) return r3;\n              } else e3.raise(\"Invalid \
escape\");\n              e3.pos = t3;\n            }\n            return \
null;\n          }, Le.regexp_classStringDisjunctionContents = function(e3) \
{\n            for (var t3 = this.regexp_classString(e3); e3.eat(124); ) 2 \
=== this.regexp_classString(e3) && (t3 = 2);\n            return t3;\n        \
  }, Le.regexp_classString = function(e3) {\n            for (var t3 = 0; \
this.regexp_eatClassSetCharacter(e3); ) t3++;\n            return 1 === t3 ? \
1 : 2;\n          }, Le.regexp_eatClassSetCharacter = function(e3) {\n        \
    var t3 = e3.pos;\n            if (e3.eat(92)) return \
!(!this.regexp_eatCharacterEscape(e3) && \
!this.regexp_eatClassSetReservedPunctuator(e3)) || (e3.eat(98) ? \
(e3.lastIntValue = 8, true) : (e3.pos = t3, false));\n            var r3 = \
e3.current();\n            return !(r3 < 0 || r3 === e3.lookahead() && \
function(e4) {\n              return 33 === e4 || e4 >= 35 && e4 <= 38 || e4 \
>= 42 && e4 <= 44 || 46 === e4 || e4 >= 58 && e4 <= 64 || 94 === e4 || 96 === \
e4 || 126 === e4;\n            }(r3)) && (!function(e4) {\n              \
return 40 === e4 || 41 === e4 || 45 === e4 || 47 === e4 || e4 >= 91 && e4 <= \
93 || e4 >= 123 && e4 <= 125;\n            }(r3) && (e3.advance(), \
e3.lastIntValue = r3, true));\n          }, \
Le.regexp_eatClassSetReservedPunctuator = function(e3) {\n            var t3 \
= e3.current();\n            return !!function(e4) {\n              return 33 \
=== e4 || 35 === e4 || 37 === e4 || 38 === e4 || 44 === e4 || 45 === e4 || e4 \
>= 58 && e4 <= 62 || 64 === e4 || 96 === e4 || 126 === e4;\n            }(t3) \
&& (e3.lastIntValue = t3, e3.advance(), true);\n          }, \
Le.regexp_eatClassControlLetter = function(e3) {\n            var t3 = \
e3.current();\n            return !(!Pe(t3) && 95 !== t3) && (e3.lastIntValue \
= t3 % 32, e3.advance(), true);\n          }, Le.regexp_eatHexEscapeSequence \
= function(e3) {\n            var t3 = e3.pos;\n            if (e3.eat(120)) \
{\n              if (this.regexp_eatFixedHexDigits(e3, 2)) return true;\n     \
         e3.switchU && e3.raise(\"Invalid escape\"), e3.pos = t3;\n           \
 }\n            return false;\n          }, Le.regexp_eatDecimalDigits = \
function(e3) {\n            var t3 = e3.pos, r3 = 0;\n            for \
(e3.lastIntValue = 0; Pe(r3 = e3.current()); ) e3.lastIntValue = 10 * \
e3.lastIntValue + (r3 - 48), e3.advance();\n            return e3.pos !== \
t3;\n          }, Le.regexp_eatHexDigits = function(e3) {\n            var t3 \
= e3.pos, r3 = 0;\n            for (e3.lastIntValue = 0; Ke(r3 = \
e3.current()); ) e3.lastIntValue = 16 * e3.lastIntValue + Ge(r3), \
e3.advance();\n            return e3.pos !== t3;\n          }, \
Le.regexp_eatLegacyOctalEscapeSequence = function(e3) {\n            if \
(this.regexp_eatOctalDigit(e3)) {\n              var t3 = e3.lastIntValue;\n  \
            if (this.regexp_eatOctalDigit(e3)) {\n                var r3 = \
e3.lastIntValue;\n                t3 <= 3 && this.regexp_eatOctalDigit(e3) ? \
e3.lastIntValue = 64 * t3 + 8 * r3 + e3.lastIntValue : e3.lastIntValue = 8 * \
t3 + r3;\n              } else e3.lastIntValue = t3;\n              return \
true;\n            }\n            return false;\n          }, \
Le.regexp_eatOctalDigit = function(e3) {\n            var t3 = \
e3.current();\n            return Ue(t3) ? (e3.lastIntValue = t3 - 48, \
e3.advance(), true) : (e3.lastIntValue = 0, false);\n          }, \
Le.regexp_eatFixedHexDigits = function(e3, t3) {\n            var r3 = \
e3.pos;\n            e3.lastIntValue = 0;\n            for (var n2 = 0; n2 < \
t3; ++n2) {\n              var i2 = e3.current();\n              if (!Ke(i2)) \
return e3.pos = r3, false;\n              e3.lastIntValue = 16 * \
e3.lastIntValue + Ge(i2), e3.advance();\n            }\n            return \
true;\n          };\n          var Be = function(e3) {\n            this.type \
= e3.type, this.value = e3.value, this.start = e3.start, this.end = e3.end, \
e3.options.locations && (this.loc = new V(e3, e3.startLoc, e3.endLoc)), \
e3.options.ranges && (this.range = [e3.start, e3.end]);\n          }, We = \
U.prototype;\n          function je(e3) {\n            return \"function\" != \
typeof BigInt ? null : BigInt(e3.replace(/_/g, \"\"));\n          }\n         \
 We.next = function(e3) {\n            !e3 && this.type.keyword && \
this.containsEsc && this.raiseRecoverable(this.start, \"Escape sequence in \
keyword \" + this.type.keyword), this.options.onToken && \
this.options.onToken(new Be(this)), this.lastTokEnd = this.end, \
this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, \
this.lastTokStartLoc = this.startLoc, this.nextToken();\n          }, \
We.getToken = function() {\n            return this.next(), new Be(this);\n   \
       }, \"undefined\" != typeof Symbol && (We[Symbol.iterator] = function() \
{\n            var e3 = this;\n            return { next: function() {\n      \
        var t3 = e3.getToken();\n              return { done: t3.type === \
b.eof, value: t3 };\n            } };\n          }), We.nextToken = \
function() {\n            var e3 = this.curContext();\n            return e3 \
&& e3.preserveSpace || this.skipSpace(), this.start = this.pos, \
this.options.locations && (this.startLoc = this.curPosition()), this.pos >= \
this.input.length ? this.finishToken(b.eof) : e3.override ? e3.override(this) \
: void this.readToken(this.fullCharCodeAtPos());\n          }, We.readToken = \
function(e3) {\n            return c(e3, this.options.ecmaVersion >= 6) || 92 \
=== e3 ? this.readWord() : this.getTokenFromCode(e3);\n          }, \
We.fullCharCodeAtPos = function() {\n            var e3 = \
this.input.charCodeAt(this.pos);\n            if (e3 <= 55295 || e3 >= 56320) \
return e3;\n            var t3 = this.input.charCodeAt(this.pos + 1);\n       \
     return t3 <= 56319 || t3 >= 57344 ? e3 : (e3 << 10) + t3 - 56613888;\n   \
       }, We.skipBlockComment = function() {\n            var e3 = \
this.options.onComment && this.curPosition(), t3 = this.pos, r3 = \
this.input.indexOf(\"*/\", this.pos += 2);\n            if (-1 === r3 && \
this.raise(this.pos - 2, \"Unterminated comment\"), this.pos = r3 + 2, \
this.options.locations) for (var n2 = void 0, i2 = t3; (n2 = A(this.input, \
i2, this.pos)) > -1; ) ++this.curLine, i2 = this.lineStart = n2;\n            \
this.options.onComment && this.options.onComment(true, this.input.slice(t3 + \
2, r3), t3, this.pos, e3, this.curPosition());\n          }, \
We.skipLineComment = function(e3) {\n            for (var t3 = this.pos, r3 = \
this.options.onComment && this.curPosition(), n2 = \
this.input.charCodeAt(this.pos += e3); this.pos < this.input.length && \
!S(n2); ) n2 = this.input.charCodeAt(++this.pos);\n            \
this.options.onComment && this.options.onComment(false, this.input.slice(t3 + \
e3, this.pos), t3, this.pos, r3, this.curPosition());\n          }, \
We.skipSpace = function() {\n            e: for (; this.pos < \
this.input.length; ) {\n              var e3 = \
this.input.charCodeAt(this.pos);\n              switch (e3) {\n               \
 case 32:\n                case 160:\n                  ++this.pos;\n         \
         break;\n                case 13:\n                  10 === \
this.input.charCodeAt(this.pos + 1) && ++this.pos;\n                case \
10:\n                case 8232:\n                case 8233:\n                 \
 ++this.pos, this.options.locations && (++this.curLine, this.lineStart = \
this.pos);\n                  break;\n                case 47:\n              \
    switch (this.input.charCodeAt(this.pos + 1)) {\n                    case \
42:\n                      this.skipBlockComment();\n                      \
break;\n                    case 47:\n                      \
this.skipLineComment(2);\n                      break;\n                    \
default:\n                      break e;\n                  }\n               \
   break;\n                default:\n                  if (!(e3 > 8 && e3 < \
14 || e3 >= 5760 && _.test(String.fromCharCode(e3)))) break e;\n              \
    ++this.pos;\n              }\n            }\n          }, We.finishToken \
= function(e3, t3) {\n            this.end = this.pos, this.options.locations \
&& (this.endLoc = this.curPosition());\n            var r3 = this.type;\n     \
       this.type = e3, this.value = t3, this.updateContext(r3);\n          }, \
We.readToken_dot = function() {\n            var e3 = \
this.input.charCodeAt(this.pos + 1);\n            if (e3 >= 48 && e3 <= 57) \
return this.readNumber(true);\n            var t3 = \
this.input.charCodeAt(this.pos + 2);\n            return \
this.options.ecmaVersion >= 6 && 46 === e3 && 46 === t3 ? (this.pos += 3, \
this.finishToken(b.ellipsis)) : (++this.pos, this.finishToken(b.dot));\n      \
    }, We.readToken_slash = function() {\n            var e3 = \
this.input.charCodeAt(this.pos + 1);\n            return this.exprAllowed ? \
(++this.pos, this.readRegexp()) : 61 === e3 ? this.finishOp(b.assign, 2) : \
this.finishOp(b.slash, 1);\n          }, We.readToken_mult_modulo_exp = \
function(e3) {\n            var t3 = this.input.charCodeAt(this.pos + 1), r3 \
= 1, n2 = 42 === e3 ? b.star : b.modulo;\n            return \
this.options.ecmaVersion >= 7 && 42 === e3 && 42 === t3 && (++r3, n2 = \
b.starstar, t3 = this.input.charCodeAt(this.pos + 2)), 61 === t3 ? \
this.finishOp(b.assign, r3 + 1) : this.finishOp(n2, r3);\n          }, \
We.readToken_pipe_amp = function(e3) {\n            var t3 = \
this.input.charCodeAt(this.pos + 1);\n            if (t3 === e3) {\n          \
    if (this.options.ecmaVersion >= 12) {\n                if (61 === \
this.input.charCodeAt(this.pos + 2)) return this.finishOp(b.assign, 3);\n     \
         }\n              return this.finishOp(124 === e3 ? b.logicalOR : \
b.logicalAND, 2);\n            }\n            return 61 === t3 ? \
this.finishOp(b.assign, 2) : this.finishOp(124 === e3 ? b.bitwiseOR : \
b.bitwiseAND, 1);\n          }, We.readToken_caret = function() {\n           \
 return 61 === this.input.charCodeAt(this.pos + 1) ? this.finishOp(b.assign, \
2) : this.finishOp(b.bitwiseXOR, 1);\n          }, We.readToken_plus_min = \
function(e3) {\n            var t3 = this.input.charCodeAt(this.pos + 1);\n   \
         return t3 === e3 ? 45 !== t3 || this.inModule || 62 !== \
this.input.charCodeAt(this.pos + 2) || 0 !== this.lastTokEnd && \
!T.test(this.input.slice(this.lastTokEnd, this.pos)) ? \
this.finishOp(b.incDec, 2) : (this.skipLineComment(3), this.skipSpace(), \
this.nextToken()) : 61 === t3 ? this.finishOp(b.assign, 2) : \
this.finishOp(b.plusMin, 1);\n          }, We.readToken_lt_gt = function(e3) \
{\n            var t3 = this.input.charCodeAt(this.pos + 1), r3 = 1;\n        \
    return t3 === e3 ? (r3 = 62 === e3 && 62 === \
this.input.charCodeAt(this.pos + 2) ? 3 : 2, 61 === \
this.input.charCodeAt(this.pos + r3) ? this.finishOp(b.assign, r3 + 1) : \
this.finishOp(b.bitShift, r3)) : 33 !== t3 || 60 !== e3 || this.inModule || \
45 !== this.input.charCodeAt(this.pos + 2) || 45 !== \
this.input.charCodeAt(this.pos + 3) ? (61 === t3 && (r3 = 2), \
this.finishOp(b.relational, r3)) : (this.skipLineComment(4), \
this.skipSpace(), this.nextToken());\n          }, We.readToken_eq_excl = \
function(e3) {\n            var t3 = this.input.charCodeAt(this.pos + 1);\n   \
         return 61 === t3 ? this.finishOp(b.equality, 61 === \
this.input.charCodeAt(this.pos + 2) ? 3 : 2) : 61 === e3 && 62 === t3 && \
this.options.ecmaVersion >= 6 ? (this.pos += 2, this.finishToken(b.arrow)) : \
this.finishOp(61 === e3 ? b.eq : b.prefix, 1);\n          }, \
We.readToken_question = function() {\n            var e3 = \
this.options.ecmaVersion;\n            if (e3 >= 11) {\n              var t3 \
= this.input.charCodeAt(this.pos + 1);\n              if (46 === t3) {\n      \
          var r3 = this.input.charCodeAt(this.pos + 2);\n                if \
(r3 < 48 || r3 > 57) return this.finishOp(b.questionDot, 2);\n              \
}\n              if (63 === t3) {\n                if (e3 >= 12) {\n          \
        if (61 === this.input.charCodeAt(this.pos + 2)) return \
this.finishOp(b.assign, 3);\n                }\n                return \
this.finishOp(b.coalesce, 2);\n              }\n            }\n            \
return this.finishOp(b.question, 1);\n          }, We.readToken_numberSign = \
function() {\n            var e3 = 35;\n            if \
(this.options.ecmaVersion >= 13 && (++this.pos, c(e3 = \
this.fullCharCodeAtPos(), true) || 92 === e3)) return \
this.finishToken(b.privateId, this.readWord1());\n            \
this.raise(this.pos, \"Unexpected character '\" + R(e3) + \"'\");\n          \
}, We.getTokenFromCode = function(e3) {\n            switch (e3) {\n          \
    case 46:\n                return this.readToken_dot();\n              \
case 40:\n                return ++this.pos, this.finishToken(b.parenL);\n    \
          case 41:\n                return ++this.pos, \
this.finishToken(b.parenR);\n              case 59:\n                return \
++this.pos, this.finishToken(b.semi);\n              case 44:\n               \
 return ++this.pos, this.finishToken(b.comma);\n              case 91:\n      \
          return ++this.pos, this.finishToken(b.bracketL);\n              \
case 93:\n                return ++this.pos, this.finishToken(b.bracketR);\n  \
            case 123:\n                return ++this.pos, \
this.finishToken(b.braceL);\n              case 125:\n                return \
++this.pos, this.finishToken(b.braceR);\n              case 58:\n             \
   return ++this.pos, this.finishToken(b.colon);\n              case 96:\n    \
            if (this.options.ecmaVersion < 6) break;\n                return \
++this.pos, this.finishToken(b.backQuote);\n              case 48:\n          \
      var t3 = this.input.charCodeAt(this.pos + 1);\n                if (120 \
=== t3 || 88 === t3) return this.readRadixNumber(16);\n                if \
(this.options.ecmaVersion >= 6) {\n                  if (111 === t3 || 79 === \
t3) return this.readRadixNumber(8);\n                  if (98 === t3 || 66 \
=== t3) return this.readRadixNumber(2);\n                }\n              \
case 49:\n              case 50:\n              case 51:\n              case \
52:\n              case 53:\n              case 54:\n              case 55:\n \
             case 56:\n              case 57:\n                return \
this.readNumber(false);\n              case 34:\n              case 39:\n     \
           return this.readString(e3);\n              case 47:\n              \
  return this.readToken_slash();\n              case 37:\n              case \
42:\n                return this.readToken_mult_modulo_exp(e3);\n             \
 case 124:\n              case 38:\n                return \
this.readToken_pipe_amp(e3);\n              case 94:\n                return \
this.readToken_caret();\n              case 43:\n              case 45:\n     \
           return this.readToken_plus_min(e3);\n              case 60:\n      \
        case 62:\n                return this.readToken_lt_gt(e3);\n          \
    case 61:\n              case 33:\n                return \
this.readToken_eq_excl(e3);\n              case 63:\n                return \
this.readToken_question();\n              case 126:\n                return \
this.finishOp(b.prefix, 1);\n              case 35:\n                return \
this.readToken_numberSign();\n            }\n            this.raise(this.pos, \
\"Unexpected character '\" + R(e3) + \"'\");\n          }, We.finishOp = \
function(e3, t3) {\n            var r3 = this.input.slice(this.pos, this.pos \
+ t3);\n            return this.pos += t3, this.finishToken(e3, r3);\n        \
  }, We.readRegexp = function() {\n            for (var e3, t3, r3 = \
this.pos; ; ) {\n              this.pos >= this.input.length && \
this.raise(r3, \"Unterminated regular expression\");\n              var n2 = \
this.input.charAt(this.pos);\n              if (T.test(n2) && this.raise(r3, \
\"Unterminated regular expression\"), e3) e3 = false;\n              else {\n \
               if (\"[\" === n2) t3 = true;\n                else if (\"]\" \
=== n2 && t3) t3 = false;\n                else if (\"/\" === n2 && !t3) \
break;\n                e3 = \"\\\\\" === n2;\n              }\n              \
++this.pos;\n            }\n            var i2 = this.input.slice(r3, \
this.pos);\n            ++this.pos;\n            var s2 = this.pos, a2 = \
this.readWord1();\n            this.containsEsc && this.unexpected(s2);\n     \
       var o2 = this.regexpState || (this.regexpState = new Fe(this));\n      \
      o2.reset(r3, i2, a2), this.validateRegExpFlags(o2), \
this.validateRegExpPattern(o2);\n            var u2 = null;\n            try \
{\n              u2 = new RegExp(i2, a2);\n            } catch (e4) {\n       \
     }\n            return this.finishToken(b.regexp, { pattern: i2, flags: \
a2, value: u2 });\n          }, We.readInt = function(e3, t3, r3) {\n         \
   for (var n2 = this.options.ecmaVersion >= 12 && void 0 === t3, i2 = r3 && \
48 === this.input.charCodeAt(this.pos), s2 = this.pos, a2 = 0, o2 = 0, u2 = \
0, l2 = null == t3 ? 1 / 0 : t3; u2 < l2; ++u2, ++this.pos) {\n              \
var h2 = this.input.charCodeAt(this.pos), c2 = void 0;\n              if (n2 \
&& 95 === h2) i2 && this.raiseRecoverable(this.pos, \"Numeric separator is \
not allowed in legacy octal numeric literals\"), 95 === o2 && \
this.raiseRecoverable(this.pos, \"Numeric separator must be exactly one \
underscore\"), 0 === u2 && this.raiseRecoverable(this.pos, \"Numeric \
separator is not allowed at the first of digits\"), o2 = h2;\n              \
else {\n                if ((c2 = h2 >= 97 ? h2 - 97 + 10 : h2 >= 65 ? h2 - \
65 + 10 : h2 >= 48 && h2 <= 57 ? h2 - 48 : 1 / 0) >= e3) break;\n             \
   o2 = h2, a2 = a2 * e3 + c2;\n              }\n            }\n            \
return n2 && 95 === o2 && this.raiseRecoverable(this.pos - 1, \"Numeric \
separator is not allowed at the last of digits\"), this.pos === s2 || null != \
t3 && this.pos - s2 !== t3 ? null : a2;\n          }, We.readRadixNumber = \
function(e3) {\n            var t3 = this.pos;\n            this.pos += 2;\n  \
          var r3 = this.readInt(e3);\n            return null == r3 && \
this.raise(this.start + 2, \"Expected number in radix \" + e3), \
this.options.ecmaVersion >= 11 && 110 === this.input.charCodeAt(this.pos) ? \
(r3 = je(this.input.slice(t3, this.pos)), ++this.pos) : \
c(this.fullCharCodeAtPos()) && this.raise(this.pos, \"Identifier directly \
after number\"), this.finishToken(b.num, r3);\n          }, We.readNumber = \
function(e3) {\n            var t3 = this.pos;\n            e3 || null !== \
this.readInt(10, void 0, true) || this.raise(t3, \"Invalid number\");\n       \
     var r3 = this.pos - t3 >= 2 && 48 === this.input.charCodeAt(t3);\n       \
     r3 && this.strict && this.raise(t3, \"Invalid number\");\n            \
var n2 = this.input.charCodeAt(this.pos);\n            if (!r3 && !e3 && \
this.options.ecmaVersion >= 11 && 110 === n2) {\n              var i2 = \
je(this.input.slice(t3, this.pos));\n              return ++this.pos, \
c(this.fullCharCodeAtPos()) && this.raise(this.pos, \"Identifier directly \
after number\"), this.finishToken(b.num, i2);\n            }\n            r3 \
&& /[89]/.test(this.input.slice(t3, this.pos)) && (r3 = false), 46 !== n2 || \
r3 || (++this.pos, this.readInt(10), n2 = this.input.charCodeAt(this.pos)), \
69 !== n2 && 101 !== n2 || r3 || (43 !== (n2 = \
this.input.charCodeAt(++this.pos)) && 45 !== n2 || ++this.pos, null === \
this.readInt(10) && this.raise(t3, \"Invalid number\")), \
c(this.fullCharCodeAtPos()) && this.raise(this.pos, \"Identifier directly \
after number\");\n            var s2, a2 = (s2 = this.input.slice(t3, \
this.pos), r3 ? parseInt(s2, 8) : parseFloat(s2.replace(/_/g, \"\")));\n      \
      return this.finishToken(b.num, a2);\n          }, We.readCodePoint = \
function() {\n            var e3;\n            if (123 === \
this.input.charCodeAt(this.pos)) {\n              this.options.ecmaVersion < \
6 && this.unexpected();\n              var t3 = ++this.pos;\n              e3 \
= this.readHexChar(this.input.indexOf(\"}\", this.pos) - this.pos), \
++this.pos, e3 > 1114111 && this.invalidStringToken(t3, \"Code point out of \
bounds\");\n            } else e3 = this.readHexChar(4);\n            return \
e3;\n          }, We.readString = function(e3) {\n            for (var t3 = \
\"\", r3 = ++this.pos; ; ) {\n              this.pos >= this.input.length && \
this.raise(this.start, \"Unterminated string constant\");\n              var \
n2 = this.input.charCodeAt(this.pos);\n              if (n2 === e3) break;\n  \
            92 === n2 ? (t3 += this.input.slice(r3, this.pos), t3 += \
this.readEscapedChar(false), r3 = this.pos) : 8232 === n2 || 8233 === n2 ? \
(this.options.ecmaVersion < 10 && this.raise(this.start, \"Unterminated \
string constant\"), ++this.pos, this.options.locations && (this.curLine++, \
this.lineStart = this.pos)) : (S(n2) && this.raise(this.start, \"Unterminated \
string constant\"), ++this.pos);\n            }\n            return t3 += \
this.input.slice(r3, this.pos++), this.finishToken(b.string, t3);\n          \
};\n          var He = {};\n          We.tryReadTemplateToken = function() \
{\n            this.inTemplateElement = true;\n            try {\n            \
  this.readTmplToken();\n            } catch (e3) {\n              if (e3 !== \
He) throw e3;\n              this.readInvalidTemplateToken();\n            \
}\n            this.inTemplateElement = false;\n          }, \
We.invalidStringToken = function(e3, t3) {\n            if \
(this.inTemplateElement && this.options.ecmaVersion >= 9) throw He;\n         \
   this.raise(e3, t3);\n          }, We.readTmplToken = function() {\n        \
    for (var e3 = \"\", t3 = this.pos; ; ) {\n              this.pos >= \
this.input.length && this.raise(this.start, \"Unterminated template\");\n     \
         var r3 = this.input.charCodeAt(this.pos);\n              if (96 === \
r3 || 36 === r3 && 123 === this.input.charCodeAt(this.pos + 1)) return \
this.pos !== this.start || this.type !== b.template && this.type !== \
b.invalidTemplate ? (e3 += this.input.slice(t3, this.pos), \
this.finishToken(b.template, e3)) : 36 === r3 ? (this.pos += 2, \
this.finishToken(b.dollarBraceL)) : (++this.pos, \
this.finishToken(b.backQuote));\n              if (92 === r3) e3 += \
this.input.slice(t3, this.pos), e3 += this.readEscapedChar(true), t3 = \
this.pos;\n              else if (S(r3)) {\n                switch (e3 += \
this.input.slice(t3, this.pos), ++this.pos, r3) {\n                  case \
13:\n                    10 === this.input.charCodeAt(this.pos) && \
++this.pos;\n                  case 10:\n                    e3 += \"\\n\";\n \
                   break;\n                  default:\n                    e3 \
+= String.fromCharCode(r3);\n                }\n                \
this.options.locations && (++this.curLine, this.lineStart = this.pos), t3 = \
this.pos;\n              } else ++this.pos;\n            }\n          }, \
We.readInvalidTemplateToken = function() {\n            for (; this.pos < \
this.input.length; this.pos++) switch (this.input[this.pos]) {\n              \
case \"\\\\\":\n                ++this.pos;\n                break;\n         \
     case \"$\":\n                if (\"{\" !== this.input[this.pos + 1]) \
break;\n              case \"`\":\n                return \
this.finishToken(b.invalidTemplate, this.input.slice(this.start, \
this.pos));\n              case \"\\r\":\n                \"\\n\" === \
this.input[this.pos + 1] && ++this.pos;\n              case \"\\n\":\n        \
      case \"\\u2028\":\n              case \"\\u2029\":\n                \
++this.curLine, this.lineStart = this.pos + 1;\n            }\n            \
this.raise(this.start, \"Unterminated template\");\n          }, \
We.readEscapedChar = function(e3) {\n            var t3 = \
this.input.charCodeAt(++this.pos);\n            switch (++this.pos, t3) {\n   \
           case 110:\n                return \"\\n\";\n              case \
114:\n                return \"\\r\";\n              case 120:\n              \
  return String.fromCharCode(this.readHexChar(2));\n              case 117:\n \
               return R(this.readCodePoint());\n              case 116:\n     \
           return \"\t\";\n              case 98:\n                return \
\"\\b\";\n              case 118:\n                return \"\\v\";\n          \
    case 102:\n                return \"\\f\";\n              case 13:\n      \
          10 === this.input.charCodeAt(this.pos) && ++this.pos;\n             \
 case 10:\n                return this.options.locations && (this.lineStart = \
this.pos, ++this.curLine), \"\";\n              case 56:\n              case \
57:\n                if (this.strict && this.invalidStringToken(this.pos - 1, \
\"Invalid escape sequence\"), e3) {\n                  var r3 = this.pos - \
1;\n                  this.invalidStringToken(r3, \"Invalid escape sequence \
in template string\");\n                }\n              default:\n           \
     if (t3 >= 48 && t3 <= 55) {\n                  var n2 = \
this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0], i2 = parseInt(n2, \
8);\n                  return i2 > 255 && (n2 = n2.slice(0, -1), i2 = \
parseInt(n2, 8)), this.pos += n2.length - 1, t3 = \
this.input.charCodeAt(this.pos), \"0\" === n2 && 56 !== t3 && 57 !== t3 || \
!this.strict && !e3 || this.invalidStringToken(this.pos - 1 - n2.length, e3 ? \
\"Octal literal in template string\" : \"Octal literal in strict mode\"), \
String.fromCharCode(i2);\n                }\n                return S(t3) ? \
(this.options.locations && (this.lineStart = this.pos, ++this.curLine), \"\") \
: String.fromCharCode(t3);\n            }\n          }, We.readHexChar = \
function(e3) {\n            var t3 = this.pos, r3 = this.readInt(16, e3);\n   \
         return null === r3 && this.invalidStringToken(t3, \"Bad character \
escape sequence\"), r3;\n          }, We.readWord1 = function() {\n           \
 this.containsEsc = false;\n            for (var e3 = \"\", t3 = true, r3 = \
this.pos, n2 = this.options.ecmaVersion >= 6; this.pos < this.input.length; ) \
{\n              var i2 = this.fullCharCodeAtPos();\n              if (p(i2, \
n2)) this.pos += i2 <= 65535 ? 1 : 2;\n              else {\n                \
if (92 !== i2) break;\n                this.containsEsc = true, e3 += \
this.input.slice(r3, this.pos);\n                var s2 = this.pos;\n         \
       117 !== this.input.charCodeAt(++this.pos) && \
this.invalidStringToken(this.pos, \"Expecting Unicode escape sequence \
\\\\uXXXX\"), ++this.pos;\n                var a2 = this.readCodePoint();\n   \
             (t3 ? c : p)(a2, n2) || this.invalidStringToken(s2, \"Invalid \
Unicode escape\"), e3 += R(a2), r3 = this.pos;\n              }\n             \
 t3 = false;\n            }\n            return e3 + this.input.slice(r3, \
this.pos);\n          }, We.readWord = function() {\n            var e3 = \
this.readWord1(), t3 = b.name;\n            return this.keywords.test(e3) && \
(t3 = x[e3]), this.finishToken(t3, e3);\n          };\n          var Xe = \
\"8.14.0\";\n          U.acorn = { Parser: U, version: Xe, defaultOptions: O, \
Position: N, SourceLocation: V, getLineInfo: M, Node: de, TokenType: d, \
tokTypes: b, keywordTypes: x, TokContext: ne, tokContexts: ie, \
isIdentifierChar: p, isIdentifierStart: c, Token: Be, isNewLine: S, \
lineBreak: T, lineBreakG: v, nonASCIIwhitespace: _ }, e2.Node = de, e2.Parser \
= U, e2.Position = N, e2.SourceLocation = V, e2.TokContext = ne, e2.Token = \
Be, e2.TokenType = d, e2.defaultOptions = O, e2.getLineInfo = M, \
e2.isIdentifierChar = p, e2.isIdentifierStart = c, e2.isNewLine = S, \
e2.keywordTypes = x, e2.lineBreak = T, e2.lineBreakG = v, \
e2.nonASCIIwhitespace = _, e2.parse = function(e3, t3) {\n            return \
U.parse(e3, t3);\n          }, e2.parseExpressionAt = function(e3, t3, r3) \
{\n            return U.parseExpressionAt(e3, t3, r3);\n          }, \
e2.tokContexts = ie, e2.tokTypes = b, e2.tokenizer = function(e3, t3) {\n     \
       return U.tokenizer(e3, t3);\n          }, e2.version = Xe;\n        \
});\n      }, {}], 2: [function(e, t, r) {\n      }, {}], 3: [function(e, t, \
r) {\n        function n(e2, t2 = {}) {\n          const { contextName: r2 = \
\"gl\", throwGetError: n2, useTrackablePrimitives: o, readPixelsFile: u, \
recording: l = [], variables: h = {}, onReadPixels: c, \
onUnrecognizedArgumentLookup: p } = t2, d = new Proxy(e2, { get: function(t3, \
d2) {\n            switch (d2) {\n              case \"addComment\":\n        \
        return E;\n              case \"checkThrowError\":\n                \
return w;\n              case \"getReadPixelsVariableName\":\n                \
return g;\n              case \"insertVariable\":\n                return \
v;\n              case \"reset\":\n                return T;\n              \
case \"setIndent\":\n                return A;\n              case \
\"toString\":\n                return b;\n              case \
\"getContextVariableName\":\n                return I;\n            }\n       \
     if (\"function\" == typeof e2[d2]) return function() {\n              \
switch (d2) {\n                case \"getError\":\n                  return \
n2 ? l.push(`${y}if (${r2}.getError() !== ${r2}.NONE) throw new \
Error('error');`) : l.push(`${y}${r2}.getError();`), e2.getError();\n         \
       case \"getExtension\": {\n                  const t6 = \
`${r2}Variables${m.length}`;\n                  l.push(`${y}const ${t6} = \
${r2}.getExtension('${arguments[0]}');`);\n                  const n3 = \
e2.getExtension(arguments[0]);\n                  if (n3 && \"object\" == \
typeof n3) {\n                    const e3 = i(n3, { getEntity: S, \
useTrackablePrimitives: o, recording: l, contextName: t6, contextVariables: \
m, variables: h, indent: y, onUnrecognizedArgumentLookup: p });\n             \
       return m.push(e3), e3;\n                  }\n                  return \
m.push(null), n3;\n                }\n                case \"readPixels\":\n  \
                const t5 = m.indexOf(arguments[6]);\n                  let \
a2;\n                  if (-1 === t5) {\n                    const e3 = \
function(e4) {\n                      if (h) {\n                        for \
(const t6 in h) if (h[t6] === e4) return t6;\n                      }\n       \
               return null;\n                    }(arguments[6]);\n           \
         e3 ? (a2 = e3, l.push(`${y}${e3}`)) : (a2 = \
`${r2}Variable${m.length}`, m.push(arguments[6]), l.push(`${y}const ${a2} = \
new ${arguments[6].constructor.name}(${arguments[6].length});`));\n           \
       } else a2 = `${r2}Variable${t5}`;\n                  g = a2;\n         \
         const d3 = [arguments[0], arguments[1], arguments[2], arguments[3], \
S(arguments[4]), S(arguments[5]), a2];\n                  return \
l.push(`${y}${r2}.readPixels(${d3.join(\", \")});`), u && function(e3, t6) \
{\n                    const n3 = `${r2}Variable${m.length}`, i2 = \
`imageDatum${x}`;\n                    l.push(`${y}let ${i2} = [\"P3\\\\n# \
${u}.ppm\\\\n\", ${e3}, ' ', ${t6}, \"\\\\n255\\\\n\"].join(\"\");`), \
l.push(`${y}for (let i = 0; i < ${i2}.length; i += 4) {`), l.push(`${y}  \
${i2} += ${n3}[i] + ' ' + ${n3}[i + 1] + ' ' + ${n3}[i + 2] + ' ';`), \
l.push(`${y}}`), l.push(`${y}if (typeof require !== \"undefined\") {`), \
l.push(`${y}  require('fs').writeFileSync('./${u}.ppm', ${i2});`), \
l.push(`${y}}`), x++;\n                  }(arguments[2], arguments[3]), c && \
c(a2, d3), e2.readPixels.apply(e2, arguments);\n                case \
\"drawBuffers\":\n                  return \
l.push(`${y}${r2}.drawBuffers([${s(arguments[0], { contextName: r2, \
contextVariables: m, getEntity: S, addVariable: _, variables: h, \
onUnrecognizedArgumentLookup: p })}]);`), e2.drawBuffers(arguments[0]);\n     \
         }\n              let t4 = e2[d2].apply(e2, arguments);\n             \
 switch (typeof t4) {\n                case \"undefined\":\n                  \
return void l.push(`${y}${k(d2, arguments)};`);\n                case \
\"number\":\n                case \"boolean\":\n                  if (o && -1 \
=== m.indexOf(a(t4))) {\n                    l.push(`${y}const \
${r2}Variable${m.length} = ${k(d2, arguments)};`), m.push(t4 = a(t4));\n      \
              break;\n                  }\n                default:\n         \
         null === t4 ? l.push(`${k(d2, arguments)};`) : l.push(`${y}const \
${r2}Variable${m.length} = ${k(d2, arguments)};`), m.push(t4);\n              \
}\n              return t4;\n            };\n            return f[e2[d2]] = \
d2, e2[d2];\n          } }), m = [], f = {};\n          let g, x = 0, y = \
\"\";\n          return d;\n          function b() {\n            return \
l.join(\"\\n\");\n          }\n          function T() {\n            for (; \
l.length > 0; ) l.pop();\n          }\n          function v(e3, t3) {\n       \
     h[e3] = t3;\n          }\n          function S(e3) {\n            const \
t3 = f[e3];\n            return t3 ? r2 + \".\" + t3 : e3;\n          }\n     \
     function A(e3) {\n            y = \" \".repeat(e3);\n          }\n       \
   function _(e3, t3) {\n            const n3 = `${r2}Variable${m.length}`;\n \
           return l.push(`${y}const ${n3} = ${t3};`), m.push(e3), n3;\n       \
   }\n          function E(e3) {\n            l.push(`${y}// ${e3}`);\n       \
   }\n          function w() {\n            l.push(`${y}(() => {\n${y}const \
error = ${r2}.getError();\n${y}if (error !== ${r2}.NONE) {\n${y}  const names \
= Object.getOwnPropertyNames(gl);\n${y}  for (let i = 0; i < names.length; \
i++) {\n${y}    const name = names[i];\n${y}    if (${r2}[name] === error) \
{\n${y}      throw new Error('${r2} threw ' + name);\n${y}    }\n${y}  \
}\n${y}}\n${y}})();`);\n          }\n          function k(e3, t3) {\n         \
   return `${r2}.${e3}(${s(t3, { contextName: r2, contextVariables: m, \
getEntity: S, addVariable: _, variables: h, onUnrecognizedArgumentLookup: p \
})})`;\n          }\n          function I(e3) {\n            const t3 = \
m.indexOf(e3);\n            return -1 !== t3 ? `${r2}Variable${t3}` : null;\n \
         }\n        }\n        function i(e2, t2) {\n          const r2 = new \
Proxy(e2, { get: function(t3, r3) {\n            if (\"function\" == typeof \
t3[r3]) return function() {\n              if (\"drawBuffersWEBGL\" === r3) \
return h.push(`${p}${i2}.drawBuffersWEBGL([${s(arguments[0], { contextName: \
i2, contextVariables: o, getEntity: m, addVariable: g, variables: c, \
onUnrecognizedArgumentLookup: d })}]);`), \
e2.drawBuffersWEBGL(arguments[0]);\n              let t4 = e2[r3].apply(e2, \
arguments);\n              switch (typeof t4) {\n                case \
\"undefined\":\n                  return void h.push(`${p}${f(r3, \
arguments)};`);\n                case \"number\":\n                case \
\"boolean\":\n                  l && -1 === o.indexOf(a(t4)) ? \
(h.push(`${p}const ${i2}Variable${o.length} = ${f(r3, arguments)};`), \
o.push(t4 = a(t4))) : (h.push(`${p}const ${i2}Variable${o.length} = ${f(r3, \
arguments)};`), o.push(t4));\n                  break;\n                \
default:\n                  null === t4 ? h.push(`${f(r3, arguments)};`) : \
h.push(`${p}const ${i2}Variable${o.length} = ${f(r3, arguments)};`), \
o.push(t4);\n              }\n              return t4;\n            };\n      \
      return n2[e2[r3]] = r3, e2[r3];\n          } }), n2 = {}, { \
contextName: i2, contextVariables: o, getEntity: u, useTrackablePrimitives: \
l, recording: h, variables: c, indent: p, onUnrecognizedArgumentLookup: d } = \
t2;\n          return r2;\n          function m(e3) {\n            return \
n2.hasOwnProperty(e3) ? `${i2}.${n2[e3]}` : u(e3);\n          }\n          \
function f(e3, t3) {\n            return `${i2}.${e3}(${s(t3, { contextName: \
i2, contextVariables: o, getEntity: m, addVariable: g, variables: c, \
onUnrecognizedArgumentLookup: d })})`;\n          }\n          function g(e3, \
t3) {\n            const r3 = `${i2}Variable${o.length}`;\n            return \
o.push(e3), h.push(`${p}const ${r3} = ${t3};`), r3;\n          }\n        }\n \
       function s(e2, t2) {\n          const { variables: r2, \
onUnrecognizedArgumentLookup: n2 } = t2;\n          return \
Array.from(e2).map((e3) => {\n            const i2 = function(e4) {\n         \
     if (r2) {\n                for (const t3 in r2) if \
(r2.hasOwnProperty(t3) && r2[t3] === e4) return t3;\n              }\n        \
      if (n2) return n2(e4);\n              return null;\n            \
}(e3);\n            return i2 || function(e4, t3) {\n              const { \
contextName: r3, contextVariables: n3, getEntity: i3, addVariable: s2, \
onUnrecognizedArgumentLookup: a2 } = t3;\n              if (void 0 === e4) \
return \"undefined\";\n              if (null === e4) return \"null\";\n      \
        const o = n3.indexOf(e4);\n              if (o > -1) return \
`${r3}Variable${o}`;\n              switch (e4.constructor.name) {\n          \
      case \"String\":\n                  const t4 = /\\n/.test(e4), r4 = \
/'/.test(e4), n4 = /\"/.test(e4);\n                  return t4 ? \"`\" + e4 + \
\"`\" : r4 && !n4 ? '\"' + e4 + '\"' : \"'\" + e4 + \"'\";\n                \
case \"Number\":\n                case \"Boolean\":\n                  return \
i3(e4);\n                case \"Array\":\n                  return s2(e4, \
`new ${e4.constructor.name}([${Array.from(e4).join(\",\")}])`);\n             \
   case \"Float32Array\":\n                case \"Uint8Array\":\n             \
   case \"Uint16Array\":\n                case \"Int32Array\":\n              \
    return s2(e4, `new \
${e4.constructor.name}(${JSON.stringify(Array.from(e4))})`);\n                \
default:\n                  if (a2) {\n                    const t5 = \
a2(e4);\n                    if (t5) return t5;\n                  }\n        \
          throw new Error(`unrecognized argument type \
${e4.constructor.name}`);\n              }\n            }(e3, t2);\n          \
}).join(\", \");\n        }\n        function a(e2) {\n          return new \
e2.constructor(e2);\n        }\n        void 0 !== t && (t.exports = { \
glWiretap: n, glExtensionWiretap: i }), \"undefined\" != typeof window && \
(n.glExtensionWiretap = i, window.glWiretap = n);\n      }, {}], 4: \
[function(e, t, r) {\n        function n(e2) {\n          const t2 = new \
Array(e2.length);\n          for (let r2 = 0; r2 < e2.length; r2++) {\n       \
     const n2 = e2[r2];\n            n2.toArray ? t2[r2] = n2.toArray() : \
t2[r2] = n2;\n          }\n          return t2;\n        }\n        function \
i() {\n          const e2 = n(arguments), t2 = new \
Float32Array(this.output.x);\n          for (let r2 = 0; r2 < this.output.x; \
r2++) this.thread.x = r2, this.thread.y = 0, this.thread.z = 0, t2[r2] = \
this._fn.apply(this, e2);\n          return t2;\n        }\n        function \
s() {\n          const e2 = n(arguments), t2 = new Array(this.output.y);\n    \
      for (let r2 = 0; r2 < this.output.y; r2++) {\n            const n2 = \
new Float32Array(this.output.x);\n            for (let t3 = 0; t3 < \
this.output.x; t3++) this.thread.x = t3, this.thread.y = r2, this.thread.z = \
0, n2[t3] = this._fn.apply(this, e2);\n            t2[r2] = n2;\n          \
}\n          return t2;\n        }\n        function a() {\n          const \
e2 = n(arguments);\n          for (let t2 = 0; t2 < this.output.y; t2++) for \
(let r2 = 0; r2 < this.output.x; r2++) this.thread.x = r2, this.thread.y = \
t2, this.thread.z = 0, this._fn.apply(this, e2);\n        }\n        function \
o() {\n          const e2 = n(arguments), t2 = new Array(this.output.z);\n    \
      for (let r2 = 0; r2 < this.output.z; r2++) {\n            const n2 = \
new Array(this.output.y);\n            for (let t3 = 0; t3 < this.output.y; \
t3++) {\n              const i2 = new Float32Array(this.output.x);\n          \
    for (let n3 = 0; n3 < this.output.x; n3++) this.thread.x = n3, \
this.thread.y = t3, this.thread.z = r2, i2[n3] = this._fn.apply(this, e2);\n  \
            n2[t3] = i2;\n            }\n            t2[r2] = n2;\n          \
}\n          return t2;\n        }\n        function u(e2) {\n          \
e2.setOutput = (t3) => {\n            e2.output = h(t3), e2.graphical && \
l(e2);\n          }, e2.toJSON = () => {\n            throw new Error(\"Not \
usable with gpuMock\");\n          }, e2.setConstants = (t3) => (e2.constants \
= t3, e2), e2.setGraphical = (t3) => (e2.graphical = t3, e2), e2.setCanvas = \
(t3) => (e2.canvas = t3, e2), e2.setContext = (t3) => (e2.context = t3, e2), \
e2.destroy = () => {\n          }, e2.validateSettings = () => {\n          \
}, e2.graphical && e2.output && l(e2), e2.exec = function() {\n            \
return new Promise((t3, r3) => {\n              try {\n                \
t3(e2.apply(e2, arguments));\n              } catch (e3) {\n                \
r3(e3);\n              }\n            });\n          }, e2.getPixels = (t3) \
=> {\n            const { x: r3, y: n2 } = e2.output;\n            return t3 \
? function(e3, t4, r4) {\n              const n3 = r4 / 2 | 0, i2 = 4 * t4, \
s2 = new Uint8ClampedArray(4 * t4), a2 = e3.slice(0);\n              for (let \
e4 = 0; e4 < n3; ++e4) {\n                const t5 = e4 * i2, n4 = (r4 - e4 - \
1) * i2;\n                s2.set(a2.subarray(t5, t5 + i2)), a2.copyWithin(t5, \
n4, n4 + i2), a2.set(s2, n4);\n              }\n              return a2;\n    \
        }(e2._imageData.data, r3, n2) : e2._imageData.data.slice(0);\n        \
  }, e2.color = function(t3, r3, n2, i2) {\n            void 0 === i2 && (i2 \
= 1), t3 = Math.floor(255 * t3), r3 = Math.floor(255 * r3), n2 = \
Math.floor(255 * n2), i2 = Math.floor(255 * i2);\n            const s2 = \
e2.output.x, a2 = e2.output.y, o2 = e2.thread.x + (a2 - e2.thread.y - 1) * \
s2;\n            e2._colorData[4 * o2 + 0] = t3, e2._colorData[4 * o2 + 1] = \
r3, e2._colorData[4 * o2 + 2] = n2, e2._colorData[4 * o2 + 3] = i2;\n         \
 };\n          const t2 = () => e2, r2 = [\"setWarnVarUsage\", \
\"setArgumentTypes\", \"setTactic\", \"setOptimizeFloatMemory\", \
\"setDebug\", \"setLoopMaxIterations\", \"setConstantTypes\", \
\"setFunctions\", \"setNativeFunctions\", \"setInjectedNative\", \
\"setPipeline\", \"setPrecision\", \"setOutputToTexture\", \"setImmutable\", \
\"setStrictIntegers\", \"setDynamicOutput\", \"setHardcodeConstants\", \
\"setDynamicArguments\", \"setUseLegacyEncoder\", \"setWarnVarUsage\", \
\"addSubKernel\"];\n          for (let n2 = 0; n2 < r2.length; n2++) \
e2[r2[n2]] = t2;\n          return e2;\n        }\n        function l(e2) {\n \
         const { x: t2, y: r2 } = e2.output;\n          if (e2.context && \
e2.context.createImageData) {\n            const n2 = new \
Uint8ClampedArray(t2 * r2 * 4);\n            e2._imageData = \
e2.context.createImageData(t2, r2), e2._colorData = n2;\n          } else {\n \
           const n2 = new Uint8ClampedArray(t2 * r2 * 4);\n            \
e2._imageData = { data: n2 }, e2._colorData = n2;\n          }\n        }\n   \
     function h(e2) {\n          let t2 = null;\n          if (e2.length) if \
(3 === e2.length) {\n            const [r2, n2, i2] = e2;\n            t2 = { \
x: r2, y: n2, z: i2 };\n          } else if (2 === e2.length) {\n            \
const [r2, n2] = e2;\n            t2 = { x: r2, y: n2 };\n          } else \
{\n            const [r2] = e2;\n            t2 = { x: r2 };\n          }\n   \
       else t2 = e2;\n          return t2;\n        }\n        t.exports = { \
gpuMock: function(e2, t2 = {}) {\n          const r2 = t2.output ? \
h(t2.output) : null;\n          function n2() {\n            return \
n2.output.z ? o.apply(n2, arguments) : n2.output.y ? n2.graphical ? \
a.apply(n2, arguments) : s.apply(n2, arguments) : i.apply(n2, arguments);\n   \
       }\n          return n2._fn = e2, n2.constants = t2.constants || null, \
n2.context = t2.context || null, n2.canvas = t2.canvas || null, n2.graphical \
= t2.graphical || false, n2._imageData = null, n2._colorData = null, \
n2.output = r2, n2.thread = { x: 0, y: 0, z: 0 }, u(n2);\n        } };\n      \
}, {}], 5: [function(e, t, r) {\n        const { utils: n } = \
e(\"./utils\");\n        t.exports = { alias: function(e2, t2) {\n          \
const r2 = t2.toString();\n          return new Function(`return function \
${e2} (${n.getArgumentNamesFromString(r2).join(\", \")}) {\n  \
${n.getFunctionBodyFromString(r2)}\n}`)();\n        } };\n      }, { \
\"./utils\": 114 }], 6: [function(e, t, r) {\n        const { FunctionNode: n \
} = e(\"../function-node\");\n        t.exports = { CPUFunctionNode: class \
extends n {\n          astFunction(e2, t2) {\n            if \
(!this.isRootKernel) {\n              t2.push(\"function\"), t2.push(\" \"), \
t2.push(this.name), t2.push(\"(\");\n              for (let e3 = 0; e3 < \
this.argumentNames.length; ++e3) {\n                const r2 = \
this.argumentNames[e3];\n                e3 > 0 && t2.push(\", \"), \
t2.push(\"user_\"), t2.push(r2);\n              }\n              t2.push(\") \
{\\n\");\n            }\n            for (let r2 = 0; r2 < \
e2.body.body.length; ++r2) this.astGeneric(e2.body.body[r2], t2), \
t2.push(\"\\n\");\n            return this.isRootKernel || t2.push(\"}\\n\"), \
t2;\n          }\n          astReturnStatement(e2, t2) {\n            const \
r2 = this.returnType || this.getType(e2.argument);\n            return \
this.returnType || (this.returnType = r2), this.isRootKernel ? \
(t2.push(this.leadingReturnStatement), this.astGeneric(e2.argument, t2), \
t2.push(\";\\n\"), t2.push(this.followingReturnStatement), \
t2.push(\"continue;\\n\")) : this.isSubKernel ? \
(t2.push(`subKernelResult_${this.name} = `), this.astGeneric(e2.argument, \
t2), t2.push(\";\"), t2.push(`return subKernelResult_${this.name};`)) : \
(t2.push(\"return \"), this.astGeneric(e2.argument, t2), t2.push(\";\")), \
t2;\n          }\n          astLiteral(e2, t2) {\n            if \
(isNaN(e2.value)) throw this.astErrorOutput(\"Non-numeric literal not \
supported : \" + e2.value, e2);\n            return t2.push(e2.value), t2;\n  \
        }\n          astBinaryExpression(e2, t2) {\n            return \
t2.push(\"(\"), this.astGeneric(e2.left, t2), t2.push(e2.operator), \
this.astGeneric(e2.right, t2), t2.push(\")\"), t2;\n          }\n          \
astIdentifierExpression(e2, t2) {\n            if (\"Identifier\" !== \
e2.type) throw this.astErrorOutput(\"IdentifierExpression - not an \
Identifier\", e2);\n            if (\"Infinity\" === e2.name) \
t2.push(\"Infinity\");\n            else this.constants && \
this.constants.hasOwnProperty(e2.name) ? t2.push(\"constants_\" + e2.name) : \
t2.push(\"user_\" + e2.name);\n            return t2;\n          }\n          \
astForStatement(e2, t2) {\n            if (\"ForStatement\" !== e2.type) \
throw this.astErrorOutput(\"Invalid for statement\", e2);\n            const \
r2 = [], n2 = [], i = [], s = [];\n            let a = null;\n            if \
(e2.init) {\n              this.pushState(\"in-for-loop-init\"), \
this.astGeneric(e2.init, r2);\n              for (let e3 = 0; e3 < r2.length; \
e3++) r2[e3].includes && r2[e3].includes(\",\") && (a = false);\n             \
 this.popState(\"in-for-loop-init\");\n            } else a = false;\n        \
    if (e2.test ? this.astGeneric(e2.test, n2) : a = false, e2.update ? \
this.astGeneric(e2.update, i) : a = false, e2.body && \
(this.pushState(\"loop-body\"), this.astGeneric(e2.body, s), \
this.popState(\"loop-body\")), null === a && (a = this.isSafe(e2.init) && \
this.isSafe(e2.test)), a) t2.push(`for \
(${r2.join(\"\")};${n2.join(\"\")};${i.join(\"\")}){\n`), \
t2.push(s.join(\"\")), t2.push(\"}\\n\");\n            else {\n              \
const e3 = this.getInternalVariableName(\"safeI\");\n              r2.length \
> 0 && t2.push(r2.join(\"\"), \";\\n\"), t2.push(`for (let \
${e3}=0;${e3}<LOOP_MAX;${e3}++){\n`), n2.length > 0 && t2.push(`if \
(!${n2.join(\"\")}) break;\n`), t2.push(s.join(\"\")), \
t2.push(`\n${i.join(\"\")};`), t2.push(\"}\\n\");\n            }\n            \
return t2;\n          }\n          astWhileStatement(e2, t2) {\n            \
if (\"WhileStatement\" !== e2.type) throw this.astErrorOutput(\"Invalid while \
statement\", e2);\n            return t2.push(\"for (let i = 0; i < LOOP_MAX; \
i++) {\"), t2.push(\"if (\"), this.astGeneric(e2.test, t2), t2.push(\") \
{\\n\"), this.astGeneric(e2.body, t2), t2.push(\"} else {\\n\"), \
t2.push(\"break;\\n\"), t2.push(\"}\\n\"), t2.push(\"}\\n\"), t2;\n          \
}\n          astDoWhileStatement(e2, t2) {\n            if \
(\"DoWhileStatement\" !== e2.type) throw this.astErrorOutput(\"Invalid while \
statement\", e2);\n            return t2.push(\"for (let i = 0; i < LOOP_MAX; \
i++) {\"), this.astGeneric(e2.body, t2), t2.push(\"if (!\"), \
this.astGeneric(e2.test, t2), t2.push(\") {\\n\"), t2.push(\"break;\\n\"), \
t2.push(\"}\\n\"), t2.push(\"}\\n\"), t2;\n          }\n          \
astAssignmentExpression(e2, t2) {\n            const r2 = \
this.getDeclaration(e2.left);\n            if (r2 && !r2.assignable) throw \
this.astErrorOutput(`Variable ${e2.left.name} is not assignable here`, e2);\n \
           return this.astGeneric(e2.left, t2), t2.push(e2.operator), \
this.astGeneric(e2.right, t2), t2;\n          }\n          \
astBlockStatement(e2, t2) {\n            if (this.isState(\"loop-body\")) {\n \
             this.pushState(\"block-body\");\n              for (let r2 = 0; \
r2 < e2.body.length; r2++) this.astGeneric(e2.body[r2], t2);\n              \
this.popState(\"block-body\");\n            } else {\n              \
t2.push(\"{\\n\");\n              for (let r2 = 0; r2 < e2.body.length; r2++) \
this.astGeneric(e2.body[r2], t2);\n              t2.push(\"}\\n\");\n         \
   }\n            return t2;\n          }\n          \
astVariableDeclaration(e2, t2) {\n            t2.push(`${e2.kind} `);\n       \
     const { declarations: r2 } = e2;\n            for (let e3 = 0; e3 < \
r2.length; e3++) {\n              e3 > 0 && t2.push(\",\");\n              \
const n2 = r2[e3], i = this.getDeclaration(n2.id);\n              i.valueType \
|| (i.valueType = this.getType(n2.init)), this.astGeneric(n2, t2);\n          \
  }\n            return this.isState(\"in-for-loop-init\") || t2.push(\";\"), \
t2;\n          }\n          astIfStatement(e2, t2) {\n            return \
t2.push(\"if (\"), this.astGeneric(e2.test, t2), t2.push(\")\"), \
\"BlockStatement\" === e2.consequent.type ? this.astGeneric(e2.consequent, \
t2) : (t2.push(\" {\\n\"), this.astGeneric(e2.consequent, t2), \
t2.push(\"\\n}\\n\")), e2.alternate && (t2.push(\"else \"), \
\"BlockStatement\" === e2.alternate.type || \"IfStatement\" === \
e2.alternate.type ? this.astGeneric(e2.alternate, t2) : (t2.push(\" {\\n\"), \
this.astGeneric(e2.alternate, t2), t2.push(\"\\n}\\n\"))), t2;\n          }\n \
         astSwitchStatement(e2, t2) {\n            const { discriminant: r2, \
cases: n2 } = e2;\n            t2.push(\"switch (\"), this.astGeneric(r2, \
t2), t2.push(\") {\\n\");\n            for (let e3 = 0; e3 < n2.length; e3++) \
null !== n2[e3].test ? (t2.push(\"case \"), this.astGeneric(n2[e3].test, t2), \
t2.push(\":\\n\"), n2[e3].consequent && n2[e3].consequent.length > 0 && \
(this.astGeneric(n2[e3].consequent, t2), t2.push(\"break;\\n\"))) : \
(t2.push(\"default:\\n\"), this.astGeneric(n2[e3].consequent, t2), \
n2[e3].consequent && n2[e3].consequent.length > 0 && \
t2.push(\"break;\\n\"));\n            t2.push(\"\\n}\");\n          }\n       \
   astThisExpression(e2, t2) {\n            return t2.push(\"_this\"), t2;\n  \
        }\n          astMemberExpression(e2, t2) {\n            const { \
signature: r2, type: n2, property: i, xProperty: s, yProperty: a, zProperty: \
o, name: u, origin: l } = this.getMemberExpressionDetails(e2);\n            \
switch (r2) {\n              case \"this.thread.value\":\n                \
return t2.push(`_this.thread.${u}`), t2;\n              case \
\"this.output.value\":\n                switch (u) {\n                  case \
\"x\":\n                    t2.push(\"outputX\");\n                    \
break;\n                  case \"y\":\n                    \
t2.push(\"outputY\");\n                    break;\n                  case \
\"z\":\n                    t2.push(\"outputZ\");\n                    \
break;\n                  default:\n                    throw \
this.astErrorOutput(\"Unexpected expression\", e2);\n                }\n      \
          return t2;\n              case \"value\":\n              default:\n \
               throw this.astErrorOutput(\"Unexpected expression\", e2);\n    \
          case \"value[]\":\n              case \"value[][]\":\n              \
case \"value[][][]\":\n              case \"value.value\":\n                \
if (\"Math\" === l) return t2.push(Math[u]), t2;\n                switch (i) \
{\n                  case \"r\":\n                    return \
t2.push(`user_${u}[0]`), t2;\n                  case \"g\":\n                 \
   return t2.push(`user_${u}[1]`), t2;\n                  case \"b\":\n       \
             return t2.push(`user_${u}[2]`), t2;\n                  case \
\"a\":\n                    return t2.push(`user_${u}[3]`), t2;\n             \
   }\n                break;\n              case \"this.constants.value\":\n  \
            case \"this.constants.value[]\":\n              case \
\"this.constants.value[][]\":\n              case \
\"this.constants.value[][][]\":\n                break;\n              case \
\"fn()[]\":\n                return this.astGeneric(e2.object, t2), \
t2.push(\"[\"), this.astGeneric(e2.property, t2), t2.push(\"]\"), t2;\n       \
       case \"fn()[][]\":\n                return \
this.astGeneric(e2.object.object, t2), t2.push(\"[\"), \
this.astGeneric(e2.object.property, t2), t2.push(\"]\"), t2.push(\"[\"), \
this.astGeneric(e2.property, t2), t2.push(\"]\"), t2;\n            }\n        \
    if (!e2.computed) switch (n2) {\n              case \"Number\":\n         \
     case \"Integer\":\n              case \"Float\":\n              case \
\"Boolean\":\n                return t2.push(`${l}_${u}`), t2;\n            \
}\n            const h = `${l}_${u}`;\n            {\n              let e3, \
r3;\n              if (\"constants\" === l) {\n                const t3 = \
this.constants[u];\n                r3 = \"Input\" === this.constantTypes[u], \
e3 = r3 ? t3.size : null;\n              } else r3 = this.isInput(u), e3 = r3 \
? this.argumentSizes[this.argumentNames.indexOf(u)] : null;\n              \
t2.push(`${h}`), o && a ? r3 ? (t2.push(\"[(\"), this.astGeneric(o, t2), \
t2.push(`*${this.dynamicArguments ? \"(outputY * outputX)\" : e3[1] * \
e3[0]})+(`), this.astGeneric(a, t2), t2.push(`*${this.dynamicArguments ? \
\"outputX\" : e3[0]})+`), this.astGeneric(s, t2), t2.push(\"]\")) : \
(t2.push(\"[\"), this.astGeneric(o, t2), t2.push(\"]\"), t2.push(\"[\"), \
this.astGeneric(a, t2), t2.push(\"]\"), t2.push(\"[\"), this.astGeneric(s, \
t2), t2.push(\"]\")) : a ? r3 ? (t2.push(\"[(\"), this.astGeneric(a, t2), \
t2.push(`*${this.dynamicArguments ? \"outputX\" : e3[0]})+`), \
this.astGeneric(s, t2), t2.push(\"]\")) : (t2.push(\"[\"), this.astGeneric(a, \
t2), t2.push(\"]\"), t2.push(\"[\"), this.astGeneric(s, t2), t2.push(\"]\")) \
: void 0 !== s && (t2.push(\"[\"), this.astGeneric(s, t2), t2.push(\"]\"));\n \
           }\n            return t2;\n          }\n          \
astCallExpression(e2, t2) {\n            if (\"CallExpression\" !== e2.type) \
throw this.astErrorOutput(\"Unknown CallExpression\", e2);\n            let \
r2 = this.astMemberExpressionUnroll(e2.callee);\n            \
this.calledFunctions.indexOf(r2) < 0 && this.calledFunctions.push(r2);\n      \
      this.isAstMathFunction(e2);\n            this.onFunctionCall && \
this.onFunctionCall(this.name, r2, e2.arguments), t2.push(r2), \
t2.push(\"(\");\n            const n2 = this.lookupFunctionArgumentTypes(r2) \
|| [];\n            for (let i = 0; i < e2.arguments.length; ++i) {\n         \
     const s = e2.arguments[i];\n              let a = this.getType(s);\n     \
         n2[i] || this.triggerImplyArgumentType(r2, i, a, this), i > 0 && \
t2.push(\", \"), this.astGeneric(s, t2);\n            }\n            return \
t2.push(\")\"), t2;\n          }\n          astArrayExpression(e2, t2) {\n    \
        const r2 = this.getType(e2), n2 = e2.elements.length, i = [];\n       \
     for (let t3 = 0; t3 < n2; ++t3) {\n              const r3 = [];\n        \
      this.astGeneric(e2.elements[t3], r3), i.push(r3.join(\"\"));\n          \
  }\n            switch (r2) {\n              case \"Matrix(2)\":\n           \
   case \"Matrix(3)\":\n              case \"Matrix(4)\":\n                \
t2.push(`[${i.join(\", \")}]`);\n                break;\n              \
default:\n                t2.push(`new Float32Array([${i.join(\", \")}])`);\n \
           }\n            return t2;\n          }\n          \
astDebuggerStatement(e2, t2) {\n            return t2.push(\"debugger;\"), \
t2;\n          }\n        } };\n      }, { \"../function-node\": 10 }], 7: \
[function(e, t, r) {\n        const { utils: n } = e(\"../../utils\");\n      \
  t.exports = { cpuKernelString: function(e2, t2) {\n          const r2 = [], \
i = [], s = [], a = !/^function/.test(e2.color.toString());\n          if \
(r2.push(\"  const { context, canvas, constants: incomingConstants } = \
settings;\", `  const output = new \
Int32Array(${JSON.stringify(Array.from(e2.output))});`, `  const \
_constantTypes = ${JSON.stringify(e2.constantTypes)};`, `  const _constants = \
${function(e3, t3) {\n            const r3 = [];\n            for (const n2 \
in t3) {\n              if (!t3.hasOwnProperty(n2)) continue;\n              \
const i2 = t3[n2], s2 = e3[n2];\n              switch (i2) {\n                \
case \"Number\":\n                case \"Integer\":\n                case \
\"Float\":\n                case \"Boolean\":\n                  \
r3.push(`${n2}:${s2}`);\n                  break;\n                case \
\"Array(2)\":\n                case \"Array(3)\":\n                case \
\"Array(4)\":\n                case \"Matrix(2)\":\n                case \
\"Matrix(3)\":\n                case \"Matrix(4)\":\n                  \
r3.push(`${n2}:new \
${s2.constructor.name}(${JSON.stringify(Array.from(s2))})`);\n              \
}\n            }\n            return `{ ${r3.join()} }`;\n          \
}(e2.constants, e2.constantTypes)};`), i.push(\"    constants: _constants,\", \
\"    context,\", \"    output,\", \"    thread: {x: 0, y: 0, z: 0},\"), \
e2.graphical) {\n            r2.push(`  const _imageData = \
context.createImageData(${e2.output[0]}, ${e2.output[1]});`), r2.push(`  \
const _colorData = new Uint8ClampedArray(${e2.output[0]} * ${e2.output[1]} * \
4);`);\n            const t3 = n.flattenFunctionToString((a ? \"function \" : \
\"\") + e2.color.toString(), { thisLookup: (t4) => {\n              switch \
(t4) {\n                case \"_colorData\":\n                  return \
\"_colorData\";\n                case \"_imageData\":\n                  \
return \"_imageData\";\n                case \"output\":\n                  \
return \"output\";\n                case \"thread\":\n                  \
return \"this.thread\";\n              }\n              return \
JSON.stringify(e2[t4]);\n            }, findDependency: (e3, t4) => null }), \
o2 = n.flattenFunctionToString((a ? \"function \" : \"\") + \
e2.getPixels.toString(), { thisLookup: (t4) => {\n              switch (t4) \
{\n                case \"_colorData\":\n                  return \
\"_colorData\";\n                case \"_imageData\":\n                  \
return \"_imageData\";\n                case \"output\":\n                  \
return \"output\";\n                case \"thread\":\n                  \
return \"this.thread\";\n              }\n              return \
JSON.stringify(e2[t4]);\n            }, findDependency: () => null });\n      \
      i.push(\"    _imageData,\", \"    _colorData,\", `    color: ${t3},`), \
s.push(`  kernel.getPixels = ${o2};`);\n          }\n          const o = [], \
u = Object.keys(e2.constantTypes);\n          for (let t3 = 0; t3 < u.length; \
t3++) o.push(e2.constantTypes[u]);\n          if (-1 !== \
e2.argumentTypes.indexOf(\"HTMLImageArray\") || -1 !== \
o.indexOf(\"HTMLImageArray\")) {\n            const t3 = \
n.flattenFunctionToString((a ? \"function \" : \"\") + \
e2._imageTo3DArray.toString(), { doNotDefine: [\"canvas\"], findDependency: \
(t4, r3) => \"this\" === t4 ? (a ? \"function \" : \"\") + e2[r3].toString() \
: null, thisLookup: (e3) => {\n              switch (e3) {\n                \
case \"canvas\":\n                  return;\n                case \
\"context\":\n                  return \"context\";\n              }\n        \
    } });\n            s.push(t3), i.push(\"    _mediaTo2DArray,\"), \
i.push(\"    _imageTo3DArray,\");\n          } else if (-1 !== \
e2.argumentTypes.indexOf(\"HTMLImage\") || -1 !== o.indexOf(\"HTMLImage\")) \
{\n            const t3 = n.flattenFunctionToString((a ? \"function \" : \
\"\") + e2._mediaTo2DArray.toString(), { findDependency: (e3, t4) => null, \
thisLookup: (e3) => {\n              switch (e3) {\n                case \
\"canvas\":\n                  return \"settings.canvas\";\n                \
case \"context\":\n                  return \"settings.context\";\n           \
   }\n              throw new Error(\"unhandled thisLookup\");\n            } \
});\n            s.push(t3), i.push(\"    _mediaTo2DArray,\");\n          }\n \
         return `function(settings) {\n${r2.join(\"\\n\")}\n  for (const p in \
_constantTypes) {\n    if (!_constantTypes.hasOwnProperty(p)) continue;\n    \
const type = _constantTypes[p];\n    switch (type) {\n      case 'Number':\n  \
    case 'Integer':\n      case 'Float':\n      case 'Boolean':\n      case \
'Array(2)':\n      case 'Array(3)':\n      case 'Array(4)':\n      case \
'Matrix(2)':\n      case 'Matrix(3)':\n      case 'Matrix(4)':\n        if \
(incomingConstants.hasOwnProperty(p)) {\n          console.warn('constant ' + \
p + ' of type ' + type + ' cannot be resigned');\n        }\n        \
continue;\n    }\n    if (!incomingConstants.hasOwnProperty(p)) {\n      \
throw new Error('constant ' + p + ' not found');\n    }\n    _constants[p] = \
incomingConstants[p];\n  }\n  const kernel = (function() \
{\n${e2._kernelString}\n  })\n    .apply({ ${i.join(\"\\n\")} });\n  \
${s.join(\"\\n\")}\n  return kernel;\n}`;\n        } };\n      }, { \
\"../../utils\": 114 }], 8: [function(e, t, r) {\n        const { Kernel: n } \
= e(\"../kernel\"), { FunctionBuilder: i } = e(\"../function-builder\"), { \
CPUFunctionNode: s } = e(\"./function-node\"), { utils: a } = \
e(\"../../utils\"), { cpuKernelString: o } = e(\"./kernel-string\");\n        \
t.exports = { CPUKernel: class extends n {\n          static getFeatures() \
{\n            return this.features;\n          }\n          static get \
features() {\n            return Object.freeze({ kernelMap: true, \
isIntegerDivisionAccurate: true });\n          }\n          static get \
isSupported() {\n            return true;\n          }\n          static \
isContextMatch(e2) {\n            return false;\n          }\n          \
static get mode() {\n            return \"cpu\";\n          }\n          \
static nativeFunctionArguments() {\n            return null;\n          }\n   \
       static nativeFunctionReturnType() {\n            throw new \
Error(`Looking up native function return type not supported on \
${this.name}`);\n          }\n          static combineKernels(e2) {\n         \
   return e2;\n          }\n          static getSignature(e2, t2) {\n         \
   return \"cpu\" + (t2.length > 0 ? \":\" + t2.join(\",\") : \"\");\n        \
  }\n          constructor(e2, t2) {\n            super(e2, t2), \
this.mergeSettings(e2.settings || t2), this._imageData = null, \
this._colorData = null, this._kernelString = null, this._prependedString = \
[], this.thread = { x: 0, y: 0, z: 0 }, this.translatedSources = null;\n      \
    }\n          initCanvas() {\n            return \"undefined\" != typeof \
document ? document.createElement(\"canvas\") : \"undefined\" != typeof \
OffscreenCanvas ? new OffscreenCanvas(0, 0) : void 0;\n          }\n          \
initContext() {\n            return this.canvas ? \
this.canvas.getContext(\"2d\") : null;\n          }\n          \
initPlugins(e2) {\n            return [];\n          }\n          \
validateSettings(e2) {\n            if (!this.output || 0 === \
this.output.length) {\n              if (1 !== e2.length) throw new \
Error(\"Auto output only supported for kernels with only one input\");\n      \
        const t2 = a.getVariableType(e2[0], this.strictIntegers);\n           \
   if (\"Array\" === t2) this.output = a.getDimensions(t2);\n              \
else {\n                if (\"NumberTexture\" !== t2 && \"ArrayTexture(4)\" \
!== t2) throw new Error(\"Auto output not supported for input type: \" + \
t2);\n                this.output = e2[0].output;\n              }\n          \
  }\n            if (this.graphical && 2 !== this.output.length) throw new \
Error(\"Output must have 2 dimensions on graphical mode\");\n            \
this.checkOutput();\n          }\n          translateSource() {\n            \
if (this.leadingReturnStatement = this.output.length > 1 ? \"resultX[x] = \" \
: \"result[x] = \", this.subKernels) {\n              const e3 = [];\n        \
      for (let t2 = 0; t2 < this.subKernels.length; t2++) {\n                \
const { name: r2 } = this.subKernels[t2];\n                \
e3.push(this.output.length > 1 ? `resultX_${r2}[x] = \
subKernelResult_${r2};\n` : `result_${r2}[x] = subKernelResult_${r2};\n`);\n  \
            }\n              this.followingReturnStatement = e3.join(\"\");\n \
           }\n            const e2 = i.fromKernel(this, s);\n            \
this.translatedSources = e2.getPrototypes(\"kernel\"), this.graphical || \
this.returnType || (this.returnType = e2.getKernelResultType());\n          \
}\n          build() {\n            if (this.built) return;\n            if \
(this.setupConstants(), this.setupArguments(arguments), \
this.validateSettings(arguments), this.translateSource(), this.graphical) {\n \
             const { canvas: e3, output: t2 } = this;\n              if (!e3) \
throw new Error(\"no canvas available for using graphical output\");\n        \
      const r2 = t2[0], n2 = t2[1] || 1;\n              e3.width = r2, \
e3.height = n2, this._imageData = this.context.createImageData(r2, n2), \
this._colorData = new Uint8ClampedArray(r2 * n2 * 4);\n            }\n        \
    const e2 = this.getKernelString();\n            this.kernelString = e2, \
this.debug && (console.log(\"Function output:\"), console.log(e2));\n         \
   try {\n              this.run = new Function([], e2).bind(this)();\n       \
     } catch (e3) {\n              console.error(\"An error occurred \
compiling the javascript: \", e3);\n            }\n            \
this.buildSignature(arguments), this.built = true;\n          }\n          \
color(e2, t2, r2, n2) {\n            void 0 === n2 && (n2 = 1), e2 = \
Math.floor(255 * e2), t2 = Math.floor(255 * t2), r2 = Math.floor(255 * r2), \
n2 = Math.floor(255 * n2);\n            const i2 = this.output[0], s2 = \
this.output[1], a2 = this.thread.x + (s2 - this.thread.y - 1) * i2;\n         \
   this._colorData[4 * a2 + 0] = e2, this._colorData[4 * a2 + 1] = t2, \
this._colorData[4 * a2 + 2] = r2, this._colorData[4 * a2 + 3] = n2;\n         \
 }\n          getKernelString() {\n            if (null !== \
this._kernelString) return this._kernelString;\n            let e2 = null, { \
translatedSources: t2 } = this;\n            return t2.length > 1 ? t2 = \
t2.filter((t3) => /^function/.test(t3) ? t3 : (e2 = t3, false)) : e2 = \
t2.shift(), this._kernelString = `  const LOOP_MAX = \
${this._getLoopMaxString()};\n  ${this.injectedNative || \"\"}\n  const _this \
= this;\n  ${this._resultKernelHeader()}\n  ${this._processConstants()}\n  \
return (${this.argumentNames.map((e3) => \"user_\" + e3).join(\", \")}) => \
{\n    ${this._prependedString.join(\"\")}\n    ${this._earlyThrows()}\n    \
${this._processArguments()}\n    ${this.graphical ? \
this._graphicalKernelBody(e2) : this._resultKernelBody(e2)}\n    ${t2.length \
> 0 ? t2.join(\"\\n\") : \"\"}\n  };`;\n          }\n          toString() {\n \
           return o(this);\n          }\n          _getLoopMaxString() {\n    \
        return this.loopMaxIterations ? ` \
${parseInt(this.loopMaxIterations)};` : \" 1000;\";\n          }\n          \
_processConstants() {\n            if (!this.constants) return \"\";\n        \
    const e2 = [];\n            for (let t2 in this.constants) {\n            \
  switch (this.constantTypes[t2]) {\n                case \"HTMLCanvas\":\n   \
             case \"OffscreenCanvas\":\n                case \"HTMLImage\":\n \
               case \"ImageBitmap\":\n                case \"ImageData\":\n   \
             case \"HTMLVideo\":\n                  e2.push(`    const \
constants_${t2} = this._mediaTo2DArray(this.constants.${t2});\n`);\n          \
        break;\n                case \"HTMLImageArray\":\n                  \
e2.push(`    const constants_${t2} = \
this._imageTo3DArray(this.constants.${t2});\n`);\n                  break;\n  \
              case \"Input\":\n                  e2.push(`    const \
constants_${t2} = this.constants.${t2}.value;\n`);\n                  \
break;\n                default:\n                  e2.push(`    const \
constants_${t2} = this.constants.${t2};\n`);\n              }\n            \
}\n            return e2.join(\"\");\n          }\n          _earlyThrows() \
{\n            if (this.graphical) return \"\";\n            if \
(this.immutable) return \"\";\n            if (!this.pipeline) return \"\";\n \
           const e2 = [];\n            for (let t3 = 0; t3 < \
this.argumentTypes.length; t3++) \"Array\" === this.argumentTypes[t3] && \
e2.push(this.argumentNames[t3]);\n            if (0 === e2.length) return \
\"\";\n            const t2 = [];\n            for (let r2 = 0; r2 < \
e2.length; r2++) {\n              const n2 = e2[r2], i2 = \
this._mapSubKernels((e3) => `user_${n2} === result_${e3.name}`).join(\" || \
\");\n              t2.push(`user_${n2} === result${i2 ? ` || ${i2}` : \
\"\"}`);\n            }\n            return `if (${t2.join(\" || \")}) throw \
new Error('Source and destination arrays are the same.  Use immutable = \
true');`;\n          }\n          _processArguments() {\n            const e2 \
= [];\n            for (let t2 = 0; t2 < this.argumentTypes.length; t2++) {\n \
             const r2 = `user_${this.argumentNames[t2]}`;\n              \
switch (this.argumentTypes[t2]) {\n                case \"HTMLCanvas\":\n     \
           case \"OffscreenCanvas\":\n                case \"HTMLImage\":\n   \
             case \"ImageBitmap\":\n                case \"ImageData\":\n     \
           case \"HTMLVideo\":\n                  e2.push(`    ${r2} = \
this._mediaTo2DArray(${r2});\n`);\n                  break;\n                \
case \"HTMLImageArray\":\n                  e2.push(`    ${r2} = \
this._imageTo3DArray(${r2});\n`);\n                  break;\n                \
case \"Input\":\n                  e2.push(`    ${r2} = ${r2}.value;\n`);\n   \
               break;\n                case \"ArrayTexture(1)\":\n            \
    case \"ArrayTexture(2)\":\n                case \"ArrayTexture(3)\":\n    \
            case \"ArrayTexture(4)\":\n                case \
\"NumberTexture\":\n                case \"MemoryOptimizedNumberTexture\":\n  \
                e2.push(`\n    if (${r2}.toArray) {\n      if \
(!_this.textureCache) {\n        _this.textureCache = [];\n        \
_this.arrayCache = [];\n      }\n      const textureIndex = \
_this.textureCache.indexOf(${r2});\n      if (textureIndex !== -1) {\n        \
${r2} = _this.arrayCache[textureIndex];\n      } else {\n        \
_this.textureCache.push(${r2});\n        ${r2} = ${r2}.toArray();\n        \
_this.arrayCache.push(${r2});\n      }\n    }`);\n              }\n           \
 }\n            return e2.join(\"\");\n          }\n          \
_mediaTo2DArray(e2) {\n            const t2 = this.canvas, r2 = e2.width > 0 \
? e2.width : e2.videoWidth, n2 = e2.height > 0 ? e2.height : \
e2.videoHeight;\n            t2.width < r2 && (t2.width = r2), t2.height < n2 \
&& (t2.height = n2);\n            const i2 = this.context;\n            let \
s2;\n            e2.constructor === ImageData ? s2 = e2.data : \
(i2.drawImage(e2, 0, 0, r2, n2), s2 = i2.getImageData(0, 0, r2, n2).data);\n  \
          const a2 = new Array(n2);\n            let o2 = 0;\n            for \
(let e3 = n2 - 1; e3 >= 0; e3--) {\n              const t3 = a2[e3] = new \
Array(r2);\n              for (let e4 = 0; e4 < r2; e4++) {\n                \
const r3 = new Float32Array(4);\n                r3[0] = s2[o2++] / 255, \
r3[1] = s2[o2++] / 255, r3[2] = s2[o2++] / 255, r3[3] = s2[o2++] / 255, \
t3[e4] = r3;\n              }\n            }\n            return a2;\n        \
  }\n          getPixels(e2) {\n            const [t2, r2] = this.output;\n   \
         return e2 ? a.flipPixels(this._imageData.data, t2, r2) : \
this._imageData.data.slice(0);\n          }\n          _imageTo3DArray(e2) \
{\n            const t2 = new Array(e2.length);\n            for (let r2 = 0; \
r2 < e2.length; r2++) t2[r2] = this._mediaTo2DArray(e2[r2]);\n            \
return t2;\n          }\n          _resultKernelHeader() {\n            if \
(this.graphical) return \"\";\n            if (this.immutable) return \"\";\n \
           if (!this.pipeline) return \"\";\n            switch \
(this.output.length) {\n              case 1:\n                return \
this._mutableKernel1DResults();\n              case 2:\n                \
return this._mutableKernel2DResults();\n              case 3:\n               \
 return this._mutableKernel3DResults();\n            }\n          }\n         \
 _resultKernelBody(e2) {\n            switch (this.output.length) {\n         \
     case 1:\n                return (!this.immutable && this.pipeline ? \
this._resultMutableKernel1DLoop(e2) : this._resultImmutableKernel1DLoop(e2)) \
+ this._kernelOutput();\n              case 2:\n                return \
(!this.immutable && this.pipeline ? this._resultMutableKernel2DLoop(e2) : \
this._resultImmutableKernel2DLoop(e2)) + this._kernelOutput();\n              \
case 3:\n                return (!this.immutable && this.pipeline ? \
this._resultMutableKernel3DLoop(e2) : this._resultImmutableKernel3DLoop(e2)) \
+ this._kernelOutput();\n              default:\n                throw new \
Error(\"unsupported size kernel\");\n            }\n          }\n          \
_graphicalKernelBody(e2) {\n            if (2 === this.output.length) return \
this._graphicalKernel2DLoop(e2) + this._graphicalOutput();\n            throw \
new Error(\"unsupported size kernel\");\n          }\n          \
_graphicalOutput() {\n            return \"\\n    \
this._imageData.data.set(this._colorData);\\n    \
this.context.putImageData(this._imageData, 0, 0);\\n    return;\";\n          \
}\n          _getKernelResultTypeConstructorString() {\n            switch \
(this.returnType) {\n              case \"LiteralInteger\":\n              \
case \"Number\":\n              case \"Integer\":\n              case \
\"Float\":\n                return \"Float32Array\";\n              case \
\"Array(2)\":\n              case \"Array(3)\":\n              case \
\"Array(4)\":\n                return \"Array\";\n              default:\n    \
            if (this.graphical) return \"Float32Array\";\n                \
throw new Error(`unhandled returnType ${this.returnType}`);\n            }\n  \
        }\n          _resultImmutableKernel1DLoop(e2) {\n            const t2 \
= this._getKernelResultTypeConstructorString();\n            return `  const \
outputX = _this.output[0];\n    const result = new ${t2}(outputX);\n    \
${this._mapSubKernels((e3) => `const result_${e3.name} = new \
${t2}(outputX);\n`).join(\"    \")}\n    ${this._mapSubKernels((e3) => `let \
subKernelResult_${e3.name};\n`).join(\"    \")}\n    for (let x = 0; x < \
outputX; x++) {\n      this.thread.x = x;\n      this.thread.y = 0;\n      \
this.thread.z = 0;\n      ${e2}\n    }`;\n          }\n          \
_mutableKernel1DResults() {\n            const e2 = \
this._getKernelResultTypeConstructorString();\n            return `  const \
outputX = _this.output[0];\n    const result = new ${e2}(outputX);\n    \
${this._mapSubKernels((t2) => `const result_${t2.name} = new \
${e2}(outputX);\n`).join(\"    \")}\n    ${this._mapSubKernels((e3) => `let \
subKernelResult_${e3.name};\n`).join(\"    \")}`;\n          }\n          \
_resultMutableKernel1DLoop(e2) {\n            return `  const outputX = \
_this.output[0];\n    for (let x = 0; x < outputX; x++) {\n      \
this.thread.x = x;\n      this.thread.y = 0;\n      this.thread.z = 0;\n      \
${e2}\n    }`;\n          }\n          _resultImmutableKernel2DLoop(e2) {\n   \
         const t2 = this._getKernelResultTypeConstructorString();\n           \
 return `  const outputX = _this.output[0];\n    const outputY = \
_this.output[1];\n    const result = new Array(outputY);\n    \
${this._mapSubKernels((e3) => `const result_${e3.name} = new \
Array(outputY);\n`).join(\"    \")}\n    ${this._mapSubKernels((e3) => `let \
subKernelResult_${e3.name};\n`).join(\"    \")}\n    for (let y = 0; y < \
outputY; y++) {\n      this.thread.z = 0;\n      this.thread.y = y;\n      \
const resultX = result[y] = new ${t2}(outputX);\n      \
${this._mapSubKernels((e3) => `const resultX_${e3.name} = \
result_${e3.name}[y] = new ${t2}(outputX);\n`).join(\"\")}\n      for (let x \
= 0; x < outputX; x++) {\n        this.thread.x = x;\n        ${e2}\n      \
}\n    }`;\n          }\n          _mutableKernel2DResults() {\n            \
const e2 = this._getKernelResultTypeConstructorString();\n            return \
`  const outputX = _this.output[0];\n    const outputY = _this.output[1];\n   \
 const result = new Array(outputY);\n    ${this._mapSubKernels((e3) => `const \
result_${e3.name} = new Array(outputY);\n`).join(\"    \")}\n    \
${this._mapSubKernels((e3) => `let subKernelResult_${e3.name};\n`).join(\"    \
\")}\n    for (let y = 0; y < outputY; y++) {\n      const resultX = \
result[y] = new ${e2}(outputX);\n      ${this._mapSubKernels((t2) => `const \
resultX_${t2.name} = result_${t2.name}[y] = new \
${e2}(outputX);\n`).join(\"\")}\n    }`;\n          }\n          \
_resultMutableKernel2DLoop(e2) {\n            const t2 = \
this._getKernelResultTypeConstructorString();\n            return `  const \
outputX = _this.output[0];\n    const outputY = _this.output[1];\n    for \
(let y = 0; y < outputY; y++) {\n      this.thread.z = 0;\n      \
this.thread.y = y;\n      const resultX = result[y];\n      \
${this._mapSubKernels((e3) => `const resultX_${e3.name} = \
result_${e3.name}[y] = new ${t2}(outputX);\n`).join(\"\")}\n      for (let x \
= 0; x < outputX; x++) {\n        this.thread.x = x;\n        ${e2}\n      \
}\n    }`;\n          }\n          _graphicalKernel2DLoop(e2) {\n            \
return `  const outputX = _this.output[0];\n    const outputY = \
_this.output[1];\n    for (let y = 0; y < outputY; y++) {\n      \
this.thread.z = 0;\n      this.thread.y = y;\n      for (let x = 0; x < \
outputX; x++) {\n        this.thread.x = x;\n        ${e2}\n      }\n    \
}`;\n          }\n          _resultImmutableKernel3DLoop(e2) {\n            \
const t2 = this._getKernelResultTypeConstructorString();\n            return \
`  const outputX = _this.output[0];\n    const outputY = _this.output[1];\n   \
 const outputZ = _this.output[2];\n    const result = new Array(outputZ);\n   \
 ${this._mapSubKernels((e3) => `const result_${e3.name} = new \
Array(outputZ);\n`).join(\"    \")}\n    ${this._mapSubKernels((e3) => `let \
subKernelResult_${e3.name};\n`).join(\"    \")}\n    for (let z = 0; z < \
outputZ; z++) {\n      this.thread.z = z;\n      const resultY = result[z] = \
new Array(outputY);\n      ${this._mapSubKernels((e3) => `const \
resultY_${e3.name} = result_${e3.name}[z] = new Array(outputY);\n`).join(\"   \
   \")}\n      for (let y = 0; y < outputY; y++) {\n        this.thread.y = \
y;\n        const resultX = resultY[y] = new ${t2}(outputX);\n        \
${this._mapSubKernels((e3) => `const resultX_${e3.name} = \
resultY_${e3.name}[y] = new ${t2}(outputX);\n`).join(\"        \")}\n        \
for (let x = 0; x < outputX; x++) {\n          this.thread.x = x;\n          \
${e2}\n        }\n      }\n    }`;\n          }\n          \
_mutableKernel3DResults() {\n            const e2 = \
this._getKernelResultTypeConstructorString();\n            return `  const \
outputX = _this.output[0];\n    const outputY = _this.output[1];\n    const \
outputZ = _this.output[2];\n    const result = new Array(outputZ);\n    \
${this._mapSubKernels((e3) => `const result_${e3.name} = new \
Array(outputZ);\n`).join(\"    \")}\n    ${this._mapSubKernels((e3) => `let \
subKernelResult_${e3.name};\n`).join(\"    \")}\n    for (let z = 0; z < \
outputZ; z++) {\n      const resultY = result[z] = new Array(outputY);\n      \
${this._mapSubKernels((e3) => `const resultY_${e3.name} = \
result_${e3.name}[z] = new Array(outputY);\n`).join(\"      \")}\n      for \
(let y = 0; y < outputY; y++) {\n        const resultX = resultY[y] = new \
${e2}(outputX);\n        ${this._mapSubKernels((t2) => `const \
resultX_${t2.name} = resultY_${t2.name}[y] = new ${e2}(outputX);\n`).join(\"  \
      \")}\n      }\n    }`;\n          }\n          \
_resultMutableKernel3DLoop(e2) {\n            return `  const outputX = \
_this.output[0];\n    const outputY = _this.output[1];\n    const outputZ = \
_this.output[2];\n    for (let z = 0; z < outputZ; z++) {\n      \
this.thread.z = z;\n      const resultY = result[z];\n      for (let y = 0; y \
< outputY; y++) {\n        this.thread.y = y;\n        const resultX = \
resultY[y];\n        for (let x = 0; x < outputX; x++) {\n          \
this.thread.x = x;\n          ${e2}\n        }\n      }\n    }`;\n          \
}\n          _kernelOutput() {\n            return this.subKernels ? `\n    \
return {\n      result: result,\n      ${this.subKernels.map((e2) => \
`${e2.property}: result_${e2.name}`).join(\",\\n      \")}\n    };` : \"\\n   \
 return result;\";\n          }\n          _mapSubKernels(e2) {\n            \
return null === this.subKernels ? [\"\"] : this.subKernels.map(e2);\n         \
 }\n          destroy(e2) {\n            e2 && delete this.canvas;\n          \
}\n          static destroyContext(e2) {\n          }\n          toJSON() {\n \
           const e2 = super.toJSON();\n            return e2.functionNodes = \
i.fromKernel(this, s).toJSON(), e2;\n          }\n          setOutput(e2) {\n \
           super.setOutput(e2);\n            const [t2, r2] = this.output;\n  \
          this.graphical && (this._imageData = \
this.context.createImageData(t2, r2), this._colorData = new \
Uint8ClampedArray(t2 * r2 * 4));\n          }\n          prependString(e2) \
{\n            if (this._kernelString) throw new Error(\"Kernel already \
built\");\n            this._prependedString.push(e2);\n          }\n         \
 hasPrependString(e2) {\n            return this._prependedString.indexOf(e2) \
> -1;\n          }\n        } };\n      }, { \"../../utils\": 114, \
\"../function-builder\": 9, \"../kernel\": 36, \"./function-node\": 6, \
\"./kernel-string\": 7 }], 9: [function(e, t, r) {\n        class n {\n       \
   static fromKernel(e2, t2, r2) {\n            const { kernelArguments: i, \
kernelConstants: s, argumentNames: a, argumentSizes: o, argumentBitRatios: u, \
constants: l, constantBitRatios: h, debug: c, loopMaxIterations: p, \
nativeFunctions: d, output: m, optimizeFloatMemory: f, precision: g, plugins: \
x, source: y, subKernels: b, functions: T, leadingReturnStatement: v, \
followingReturnStatement: S, dynamicArguments: A, dynamicOutput: _ } = e2, E \
= new Array(i.length), w = {};\n            for (let e3 = 0; e3 < i.length; \
e3++) E[e3] = i[e3].type;\n            for (let e3 = 0; e3 < s.length; e3++) \
{\n              const t3 = s[e3];\n              w[t3.name] = t3.type;\n     \
       }\n            const k = (e3, t3) => G.needsArgumentType(e3, t3), I = \
(e3, t3, r3) => {\n              G.assignArgumentType(e3, t3, r3);\n          \
  }, D = (e3, t3, r3) => G.lookupReturnType(e3, t3, r3), C = (e3) => \
G.lookupFunctionArgumentTypes(e3), $ = (e3, t3) => \
G.lookupFunctionArgumentName(e3, t3), L = (e3, t3) => \
G.lookupFunctionArgumentBitRatio(e3, t3), R = (e3, t3, r3, n2) => {\n         \
     G.assignArgumentType(e3, t3, r3, n2);\n            }, F = (e3, t3, r3, \
n2) => {\n              G.assignArgumentBitRatio(e3, t3, r3, n2);\n           \
 }, N = (e3, t3, r3) => {\n              G.trackFunctionCall(e3, t3, r3);\n   \
         }, V = (e3, r3) => {\n              const n2 = [];\n              \
for (let t3 = 0; t3 < e3.params.length; t3++) n2.push(e3.params[t3].name);\n  \
            const i2 = new t2(r3, Object.assign({}, M, { returnType: null, \
ast: e3, name: e3.id.name, argumentNames: n2, lookupReturnType: D, \
lookupFunctionArgumentTypes: C, lookupFunctionArgumentName: $, \
lookupFunctionArgumentBitRatio: L, needsArgumentType: k, assignArgumentType: \
I, triggerImplyArgumentType: R, triggerImplyArgumentBitRatio: F, \
onFunctionCall: N }));\n              i2.traceFunctionAST(e3), \
G.addFunctionNode(i2);\n            }, M = Object.assign({ isRootKernel: \
false, onNestedFunction: V, lookupReturnType: D, lookupFunctionArgumentTypes: \
C, lookupFunctionArgumentName: $, lookupFunctionArgumentBitRatio: L, \
needsArgumentType: k, assignArgumentType: I, triggerImplyArgumentType: R, \
triggerImplyArgumentBitRatio: F, onFunctionCall: N, optimizeFloatMemory: f, \
precision: g, constants: l, constantTypes: w, constantBitRatios: h, debug: c, \
loopMaxIterations: p, output: m, plugins: x, dynamicArguments: A, \
dynamicOutput: _ }, r2 || {}), O = Object.assign({}, M, { isRootKernel: true, \
name: \"kernel\", argumentNames: a, argumentTypes: E, argumentSizes: o, \
argumentBitRatios: u, leadingReturnStatement: v, followingReturnStatement: S \
});\n            if (\"object\" == typeof y && y.functionNodes) return new \
n().fromJSON(y.functionNodes, t2);\n            const z = new t2(y, O);\n     \
       let P = null;\n            T && (P = T.map((e3) => new t2(e3.source, { \
returnType: e3.returnType, argumentTypes: e3.argumentTypes, output: m, \
plugins: x, constants: l, constantTypes: w, constantBitRatios: h, \
optimizeFloatMemory: f, precision: g, lookupReturnType: D, \
lookupFunctionArgumentTypes: C, lookupFunctionArgumentName: $, \
lookupFunctionArgumentBitRatio: L, needsArgumentType: k, assignArgumentType: \
I, triggerImplyArgumentType: R, triggerImplyArgumentBitRatio: F, \
onFunctionCall: N, onNestedFunction: V })));\n            let K = null;\n     \
       b && (K = b.map((e3) => {\n              const { name: r3, source: n2 \
} = e3;\n              return new t2(n2, Object.assign({}, M, { name: r3, \
isSubKernel: true, isRootKernel: false }));\n            }));\n            \
const G = new n({ kernel: e2, rootNode: z, functionNodes: P, nativeFunctions: \
d, subKernelNodes: K });\n            return G;\n          }\n          \
constructor(e2) {\n            if (e2 = e2 || {}, this.kernel = e2.kernel, \
this.rootNode = e2.rootNode, this.functionNodes = e2.functionNodes || [], \
this.subKernelNodes = e2.subKernelNodes || [], this.nativeFunctions = \
e2.nativeFunctions || [], this.functionMap = {}, this.nativeFunctionNames = \
[], this.lookupChain = [], this.functionNodeDependencies = {}, \
this.functionCalls = {}, this.rootNode && (this.functionMap.kernel = \
this.rootNode), this.functionNodes) for (let e3 = 0; e3 < \
this.functionNodes.length; e3++) \
this.functionMap[this.functionNodes[e3].name] = this.functionNodes[e3];\n     \
       if (this.subKernelNodes) for (let e3 = 0; e3 < \
this.subKernelNodes.length; e3++) \
this.functionMap[this.subKernelNodes[e3].name] = this.subKernelNodes[e3];\n   \
         if (this.nativeFunctions) for (let e3 = 0; e3 < \
this.nativeFunctions.length; e3++) {\n              const t2 = \
this.nativeFunctions[e3];\n              \
this.nativeFunctionNames.push(t2.name);\n            }\n          }\n         \
 addFunctionNode(e2) {\n            if (!e2.name) throw new \
Error(\"functionNode.name needs set\");\n            \
this.functionMap[e2.name] = e2, e2.isRootKernel && (this.rootNode = e2);\n    \
      }\n          traceFunctionCalls(e2, t2) {\n            if (e2 = e2 || \
\"kernel\", t2 = t2 || [], this.nativeFunctionNames.indexOf(e2) > -1) {\n     \
         const r3 = t2.indexOf(e2);\n              if (-1 === r3) \
t2.push(e2);\n              else {\n                const e3 = t2.splice(r3, \
1)[0];\n                t2.push(e3);\n              }\n              return \
t2;\n            }\n            const r2 = this.functionMap[e2];\n            \
if (r2) {\n              const n2 = t2.indexOf(e2);\n              if (-1 === \
n2) {\n                t2.push(e2), r2.toString();\n                for (let \
e3 = 0; e3 < r2.calledFunctions.length; ++e3) \
this.traceFunctionCalls(r2.calledFunctions[e3], t2);\n              } else \
{\n                const e3 = t2.splice(n2, 1)[0];\n                \
t2.push(e3);\n              }\n            }\n            return t2;\n        \
  }\n          getPrototypeString(e2) {\n            return \
this.getPrototypes(e2).join(\"\\n\");\n          }\n          \
getPrototypes(e2) {\n            return this.rootNode && \
this.rootNode.toString(), e2 ? \
this.getPrototypesFromFunctionNames(this.traceFunctionCalls(e2, \
[]).reverse()) : \
this.getPrototypesFromFunctionNames(Object.keys(this.functionMap));\n         \
 }\n          getStringFromFunctionNames(e2) {\n            const t2 = [];\n  \
          for (let r2 = 0; r2 < e2.length; ++r2) {\n              \
this.functionMap[e2[r2]] && t2.push(this.functionMap[e2[r2]].toString());\n   \
         }\n            return t2.join(\"\\n\");\n          }\n          \
getPrototypesFromFunctionNames(e2) {\n            const t2 = [];\n            \
for (let r2 = 0; r2 < e2.length; ++r2) {\n              const n2 = e2[r2], i \
= this.nativeFunctionNames.indexOf(n2);\n              if (i > -1) {\n        \
        t2.push(this.nativeFunctions[i].source);\n                continue;\n \
             }\n              const s = this.functionMap[n2];\n              \
s && t2.push(s.toString());\n            }\n            return t2;\n          \
}\n          toJSON() {\n            return \
this.traceFunctionCalls(this.rootNode.name).reverse().map((e2) => {\n         \
     const t2 = this.nativeFunctions.indexOf(e2);\n              if (t2 > -1) \
return { name: e2, source: this.nativeFunctions[t2].source };\n              \
if (this.functionMap[e2]) return this.functionMap[e2].toJSON();\n             \
 throw new Error(`function ${e2} not found`);\n            });\n          }\n \
         fromJSON(e2, t2) {\n            this.functionMap = {};\n            \
for (let r2 = 0; r2 < e2.length; r2++) {\n              const n2 = e2[r2];\n  \
            this.functionMap[n2.settings.name] = new t2(n2.ast, \
n2.settings);\n            }\n            return this;\n          }\n         \
 getString(e2) {\n            return e2 ? \
this.getStringFromFunctionNames(this.traceFunctionCalls(e2).reverse()) : \
this.getStringFromFunctionNames(Object.keys(this.functionMap));\n          \
}\n          lookupReturnType(e2, t2, r2) {\n            if \
(\"CallExpression\" !== t2.type) throw new Error(`expected ast type of \
\"CallExpression\", but is ${t2.type}`);\n            if \
(this._isNativeFunction(e2)) return \
this._lookupNativeFunctionReturnType(e2);\n            if \
(this._isFunction(e2)) {\n              const n2 = this._getFunction(e2);\n   \
           if (n2.returnType) return n2.returnType;\n              {\n        \
        for (let e4 = 0; e4 < this.lookupChain.length; e4++) if \
(this.lookupChain[e4].ast === t2) {\n                  if (0 === \
n2.argumentTypes.length && t2.arguments.length > 0) {\n                    \
const i = t2.arguments;\n                    for (let t3 = 0; t3 < i.length; \
t3++) this.lookupChain.push({ name: r2.name, ast: i[e4], requestingNode: r2 \
}), n2.argumentTypes[t3] = r2.getType(i[t3]), this.lookupChain.pop();\n       \
             return n2.returnType = n2.getType(n2.getJsAST());\n              \
    }\n                  throw new Error(\"circlical logic detected!\");\n    \
            }\n                this.lookupChain.push({ name: r2.name, ast: \
t2, requestingNode: r2 });\n                const e3 = \
n2.getType(n2.getJsAST());\n                return this.lookupChain.pop(), \
n2.returnType = e3;\n              }\n            }\n            return \
null;\n          }\n          _getFunction(e2) {\n            return \
this._isFunction(e2) || new Error(`Function ${e2} not found`), \
this.functionMap[e2];\n          }\n          _isFunction(e2) {\n            \
return Boolean(this.functionMap[e2]);\n          }\n          \
_getNativeFunction(e2) {\n            for (let t2 = 0; t2 < \
this.nativeFunctions.length; t2++) if (this.nativeFunctions[t2].name === e2) \
return this.nativeFunctions[t2];\n            return null;\n          }\n     \
     _isNativeFunction(e2) {\n            return \
Boolean(this._getNativeFunction(e2));\n          }\n          \
_lookupNativeFunctionReturnType(e2) {\n            let t2 = \
this._getNativeFunction(e2);\n            if (t2) return t2.returnType;\n     \
       throw new Error(`Native function ${e2} not found`);\n          }\n     \
     lookupFunctionArgumentTypes(e2) {\n            return \
this._isNativeFunction(e2) ? this._getNativeFunction(e2).argumentTypes : \
this._isFunction(e2) ? this._getFunction(e2).argumentTypes : null;\n          \
}\n          lookupFunctionArgumentName(e2, t2) {\n            return \
this._getFunction(e2).argumentNames[t2];\n          }\n          \
lookupFunctionArgumentBitRatio(e2, t2) {\n            if \
(!this._isFunction(e2)) throw new Error(\"function not found\");\n            \
if (this.rootNode.name === e2) {\n              const e3 = \
this.rootNode.argumentNames.indexOf(t2);\n              if (-1 !== e3) return \
this.rootNode.argumentBitRatios[e3];\n            }\n            const r2 = \
this._getFunction(e2), n2 = r2.argumentNames.indexOf(t2);\n            if (-1 \
=== n2) throw new Error(\"argument not found\");\n            const i = \
r2.argumentBitRatios[n2];\n            if (\"number\" != typeof i) throw new \
Error(\"argument bit ratio not found\");\n            return i;\n          \
}\n          needsArgumentType(e2, t2) {\n            if \
(!this._isFunction(e2)) return false;\n            return \
!this._getFunction(e2).argumentTypes[t2];\n          }\n          \
assignArgumentType(e2, t2, r2, n2) {\n            if (!this._isFunction(e2)) \
return;\n            const i = this._getFunction(e2);\n            \
i.argumentTypes[t2] || (i.argumentTypes[t2] = r2);\n          }\n          \
assignArgumentBitRatio(e2, t2, r2, n2) {\n            const i = \
this._getFunction(e2);\n            if (this._isNativeFunction(r2)) return \
null;\n            const s = this._getFunction(r2), a = \
i.argumentNames.indexOf(t2);\n            if (-1 === a) throw new \
Error(`Argument ${t2} not found in arguments from function ${e2}`);\n         \
   const o = i.argumentBitRatios[a];\n            if (\"number\" != typeof o) \
throw new Error(`Bit ratio for argument ${t2} not found in function \
${e2}`);\n            s.argumentBitRatios || (s.argumentBitRatios = new \
Array(s.argumentNames.length));\n            const u = \
s.argumentBitRatios[a];\n            if (\"number\" == typeof u) {\n          \
    if (u !== o) throw new Error(`Incompatible bit ratio found at function \
${e2} at argument ${t2}`);\n              return u;\n            }\n          \
  return s.argumentBitRatios[a] = o, o;\n          }\n          \
trackFunctionCall(e2, t2, r2) {\n            \
this.functionNodeDependencies[e2] || (this.functionNodeDependencies[e2] = /* \
@__PURE__ */ new Set(), this.functionCalls[e2] = []), \
this.functionNodeDependencies[e2].add(t2), this.functionCalls[e2].push(r2);\n \
         }\n          getKernelResultType() {\n            return \
this.rootNode.returnType || this.rootNode.getType(this.rootNode.ast);\n       \
   }\n          getSubKernelResultType(e2) {\n            const t2 = \
this.subKernelNodes[e2];\n            let r2 = false;\n            for (let \
e3 = 0; e3 < this.rootNode.functionCalls.length; e3++) {\n              \
this.rootNode.functionCalls[e3].ast.callee.name === t2.name && (r2 = true);\n \
           }\n            if (!r2) throw new Error(`SubKernel ${t2.name} \
never called by kernel`);\n            return t2.returnType || \
t2.getType(t2.getJsAST());\n          }\n          getReturnTypes() {\n       \
     const e2 = { [this.rootNode.name]: \
this.rootNode.getType(this.rootNode.ast) }, t2 = \
this.traceFunctionCalls(this.rootNode.name);\n            for (let r2 = 0; r2 \
< t2.length; r2++) {\n              const n2 = t2[r2], i = \
this.functionMap[n2];\n              e2[n2] = i.getType(i.ast);\n            \
}\n            return e2;\n          }\n        }\n        t.exports = { \
FunctionBuilder: n };\n      }, {}], 10: [function(e, t, r) {\n        const \
n = e(\"acorn\"), { utils: i } = e(\"../utils\"), { FunctionTracer: s } = \
e(\"./function-tracer\");\n        const a = { Number: \"Number\", Float: \
\"Float\", Integer: \"Integer\", Array: \"Number\", \"Array(2)\": \"Number\", \
\"Array(3)\": \"Number\", \"Array(4)\": \"Number\", \"Matrix(2)\": \
\"Number\", \"Matrix(3)\": \"Number\", \"Matrix(4)\": \"Number\", Array2D: \
\"Number\", Array3D: \"Number\", Input: \"Number\", HTMLCanvas: \"Array(4)\", \
OffscreenCanvas: \"Array(4)\", HTMLImage: \"Array(4)\", ImageBitmap: \
\"Array(4)\", ImageData: \"Array(4)\", HTMLVideo: \"Array(4)\", \
HTMLImageArray: \"Array(4)\", NumberTexture: \"Number\", \
MemoryOptimizedNumberTexture: \"Number\", \"Array1D(2)\": \"Array(2)\", \
\"Array1D(3)\": \"Array(3)\", \"Array1D(4)\": \"Array(4)\", \"Array2D(2)\": \
\"Array(2)\", \"Array2D(3)\": \"Array(3)\", \"Array2D(4)\": \"Array(4)\", \
\"Array3D(2)\": \"Array(2)\", \"Array3D(3)\": \"Array(3)\", \"Array3D(4)\": \
\"Array(4)\", \"ArrayTexture(1)\": \"Number\", \"ArrayTexture(2)\": \
\"Array(2)\", \"ArrayTexture(3)\": \"Array(3)\", \"ArrayTexture(4)\": \
\"Array(4)\" };\n        t.exports = { FunctionNode: class {\n          \
constructor(e2, t2) {\n            if (!e2 && !t2.ast) throw new \
Error(\"source parameter is missing\");\n            if (t2 = t2 || {}, \
this.source = e2, this.ast = null, this.name = \"string\" == typeof e2 ? \
t2.isRootKernel ? \"kernel\" : t2.name || i.getFunctionNameFromString(e2) : \
null, this.calledFunctions = [], this.constants = {}, this.constantTypes = \
{}, this.constantBitRatios = {}, this.isRootKernel = false, this.isSubKernel \
= false, this.debug = null, this.functions = null, this.identifiers = null, \
this.contexts = null, this.functionCalls = null, this.states = [], \
this.needsArgumentType = null, this.assignArgumentType = null, \
this.lookupReturnType = null, this.lookupFunctionArgumentTypes = null, \
this.lookupFunctionArgumentBitRatio = null, this.triggerImplyArgumentType = \
null, this.triggerImplyArgumentBitRatio = null, this.onNestedFunction = null, \
this.onFunctionCall = null, this.optimizeFloatMemory = null, this.precision = \
null, this.loopMaxIterations = null, this.argumentNames = \"string\" == \
typeof this.source ? i.getArgumentNamesFromString(this.source) : null, \
this.argumentTypes = [], this.argumentSizes = [], this.argumentBitRatios = \
null, this.returnType = null, this.output = [], this.plugins = null, \
this.leadingReturnStatement = null, this.followingReturnStatement = null, \
this.dynamicOutput = null, this.dynamicArguments = null, \
this.strictTypingChecking = false, this.fixIntegerDivisionAccuracy = null, \
t2) for (const e3 in t2) t2.hasOwnProperty(e3) && this.hasOwnProperty(e3) && \
(this[e3] = t2[e3]);\n            this.literalTypes = {}, this.validate(), \
this._string = null, this._internalVariableNames = {};\n          }\n         \
 validate() {\n            if (\"string\" != typeof this.source && !this.ast) \
throw new Error(\"this.source not a string\");\n            if (!this.ast && \
!i.isFunctionString(this.source)) throw new Error(\"this.source not a \
function string\");\n            if (!this.name) throw new Error(\"this.name \
could not be set\");\n            if (this.argumentTypes.length > 0 && \
this.argumentTypes.length !== this.argumentNames.length) throw new \
Error(`argumentTypes count of ${this.argumentTypes.length} exceeds \
${this.argumentNames.length}`);\n            if (this.output.length < 1) \
throw new Error(\"this.output is not big enough\");\n          }\n          \
isIdentifierConstant(e2) {\n            return !!this.constants && \
this.constants.hasOwnProperty(e2);\n          }\n          isInput(e2) {\n    \
        return \"Input\" === \
this.argumentTypes[this.argumentNames.indexOf(e2)];\n          }\n          \
pushState(e2) {\n            this.states.push(e2);\n          }\n          \
popState(e2) {\n            if (this.state !== e2) throw new Error(`Cannot \
popState ${e2} when in ${this.state}`);\n            this.states.pop();\n     \
     }\n          isState(e2) {\n            return this.state === e2;\n      \
    }\n          get state() {\n            return \
this.states[this.states.length - 1];\n          }\n          \
astMemberExpressionUnroll(e2) {\n            if (\"Identifier\" === e2.type) \
return e2.name;\n            if (\"ThisExpression\" === e2.type) return \
\"this\";\n            if (\"MemberExpression\" === e2.type && e2.object && \
e2.property) return e2.object.hasOwnProperty(\"name\") && \"Math\" !== \
e2.object.name ? this.astMemberExpressionUnroll(e2.property) : \
this.astMemberExpressionUnroll(e2.object) + \".\" + \
this.astMemberExpressionUnroll(e2.property);\n            if \
(e2.hasOwnProperty(\"expressions\")) {\n              const t2 = \
e2.expressions[0];\n              if (\"Literal\" === t2.type && 0 === \
t2.value && 2 === e2.expressions.length) return \
this.astMemberExpressionUnroll(e2.expressions[1]);\n            }\n           \
 throw this.astErrorOutput(\"Unknown astMemberExpressionUnroll\", e2);\n      \
    }\n          getJsAST(e2) {\n            if (this.ast) return this.ast;\n \
           if (\"object\" == typeof this.source) return \
this.traceFunctionAST(this.source), this.ast = this.source;\n            if \
(null === (e2 = e2 || n)) throw new Error(\"Missing JS to AST parser\");\n    \
        const t2 = Object.freeze(e2.parse(`const parser_${this.name} = \
${this.source};`, { locations: true })), r2 = \
t2.body[0].declarations[0].init;\n            if (this.traceFunctionAST(r2), \
!t2) throw new Error(\"Failed to parse JS code\");\n            return \
this.ast = r2;\n          }\n          traceFunctionAST(e2) {\n            \
const { contexts: t2, declarations: r2, functions: n2, identifiers: i2, \
functionCalls: a2 } = new s(e2);\n            this.contexts = t2, \
this.identifiers = i2, this.functionCalls = a2, this.functions = n2;\n        \
    for (let e3 = 0; e3 < r2.length; e3++) {\n              const t3 = \
r2[e3], { ast: n3, inForLoopInit: i3, inForLoopTest: s2 } = t3, { init: a3 } \
= n3, o = this.getDependencies(a3);\n              let u = null;\n            \
  if (i3 && s2) u = \"Integer\";\n              else if (a3) {\n              \
  const e4 = this.getType(a3);\n                switch (e4) {\n               \
   case \"Integer\":\n                  case \"Float\":\n                  \
case \"Number\":\n                    u = \"MemberExpression\" === a3.type ? \
e4 : \"Number\";\n                    break;\n                  case \
\"LiteralInteger\":\n                    u = \"Number\";\n                    \
break;\n                  default:\n                    u = e4;\n             \
   }\n              }\n              t3.valueType = u, t3.dependencies = o, \
t3.isSafe = this.isSafeDependencies(o);\n            }\n            for (let \
e3 = 0; e3 < n2.length; e3++) this.onNestedFunction(n2[e3], this.source);\n   \
       }\n          getDeclaration(e2) {\n            for (let t2 = 0; t2 < \
this.identifiers.length; t2++) {\n              const r2 = \
this.identifiers[t2];\n              if (e2 === r2.ast) return \
r2.declaration;\n            }\n            return null;\n          }\n       \
   getVariableType(e2) {\n            if (\"Identifier\" !== e2.type) throw \
new Error(`ast of ${e2.type} not \"Identifier\"`);\n            let t2 = \
null;\n            const r2 = this.argumentNames.indexOf(e2.name);\n          \
  if (-1 === r2) {\n              const t3 = this.getDeclaration(e2);\n       \
       if (t3) return t3.valueType;\n            } else {\n              \
const e3 = this.argumentTypes[r2];\n              e3 && (t2 = e3);\n          \
  }\n            if (!t2 && this.strictTypingChecking) throw new \
Error(`Declaration of ${name} not found`);\n            return t2;\n          \
}\n          getLookupType(e2) {\n            if (!a.hasOwnProperty(e2)) \
throw new Error(`unknown typeLookupMap ${e2}`);\n            return a[e2];\n  \
        }\n          getConstantType(e2) {\n            if \
(this.constantTypes[e2]) {\n              const t2 = \
this.constantTypes[e2];\n              return \"Float\" === t2 ? \"Number\" : \
t2;\n            }\n            throw new Error(`Type for constant \"${e2}\" \
not declared`);\n          }\n          toString() {\n            return \
this._string ? this._string : this._string = this.astGeneric(this.getJsAST(), \
[]).join(\"\").trim();\n          }\n          toJSON() {\n            const \
e2 = { source: this.source, name: this.name, constants: this.constants, \
constantTypes: this.constantTypes, isRootKernel: this.isRootKernel, \
isSubKernel: this.isSubKernel, debug: this.debug, output: this.output, \
loopMaxIterations: this.loopMaxIterations, argumentNames: this.argumentNames, \
argumentTypes: this.argumentTypes, argumentSizes: this.argumentSizes, \
returnType: this.returnType, leadingReturnStatement: \
this.leadingReturnStatement, followingReturnStatement: \
this.followingReturnStatement };\n            return { ast: this.ast, \
settings: e2 };\n          }\n          getType(e2) {\n            if \
(Array.isArray(e2)) return this.getType(e2[e2.length - 1]);\n            \
switch (e2.type) {\n              case \"BlockStatement\":\n                \
return this.getType(e2.body);\n              case \"ArrayExpression\":\n      \
          switch (this.getType(e2.elements[0])) {\n                  case \
\"Array(2)\":\n                  case \"Array(3)\":\n                  case \
\"Array(4)\":\n                    return `Matrix(${e2.elements.length})`;\n  \
              }\n                return `Array(${e2.elements.length})`;\n     \
         case \"Literal\":\n                const t2 = this.astKey(e2);\n     \
           return this.literalTypes[t2] ? this.literalTypes[t2] : \
Number.isInteger(e2.value) ? \"LiteralInteger\" : true === e2.value || false \
=== e2.value ? \"Boolean\" : \"Number\";\n              case \
\"AssignmentExpression\":\n                return this.getType(e2.left);\n    \
          case \"CallExpression\":\n                if \
(this.isAstMathFunction(e2)) return \"Number\";\n                if \
(!e2.callee || !e2.callee.name) {\n                  if \
(\"SequenceExpression\" === e2.callee.type && \
e2.callee.expressions[e2.callee.expressions.length - 1].property.name) {\n    \
                const t3 = e2.callee.expressions[e2.callee.expressions.length \
- 1].property.name;\n                    return \
this.inferArgumentTypesIfNeeded(t3, e2.arguments), this.lookupReturnType(t3, \
e2, this);\n                  }\n                  if (\"this.color\" === \
this.getVariableSignature(e2.callee, true)) return null;\n                  \
if (\"MemberExpression\" === e2.callee.type && e2.callee.object && \
e2.callee.property && e2.callee.property.name && e2.arguments) {\n            \
        const t3 = e2.callee.property.name;\n                    return \
this.inferArgumentTypesIfNeeded(t3, e2.arguments), this.lookupReturnType(t3, \
e2, this);\n                  }\n                  throw \
this.astErrorOutput(\"Unknown call expression\", e2);\n                }\n    \
            if (e2.callee && e2.callee.name) {\n                  const t3 = \
e2.callee.name;\n                  return this.inferArgumentTypesIfNeeded(t3, \
e2.arguments), this.lookupReturnType(t3, e2, this);\n                }\n      \
          throw this.astErrorOutput(`Unhandled getType Type \"${e2.type}\"`, \
e2);\n              case \"LogicalExpression\":\n                return \
\"Boolean\";\n              case \"BinaryExpression\":\n                \
switch (e2.operator) {\n                  case \"%\":\n                  case \
\"/\":\n                    if (this.fixIntegerDivisionAccuracy) return \
\"Number\";\n                    break;\n                  case \">\":\n      \
            case \"<\":\n                    return \"Boolean\";\n            \
      case \"&\":\n                  case \"|\":\n                  case \
\"^\":\n                  case \"<<\":\n                  case \">>\":\n      \
            case \">>>\":\n                    return \"Integer\";\n          \
      }\n                const r2 = this.getType(e2.left);\n                \
if (this.isState(\"skip-literal-correction\")) return r2;\n                if \
(\"LiteralInteger\" === r2) {\n                  const t3 = \
this.getType(e2.right);\n                  return \"LiteralInteger\" === t3 ? \
e2.left.value % 1 == 0 ? \"Integer\" : \"Float\" : t3;\n                }\n   \
             return a[r2] || r2;\n              case \"UpdateExpression\":\n  \
            case \"ReturnStatement\":\n                return \
this.getType(e2.argument);\n              case \"UnaryExpression\":\n         \
       return \"~\" === e2.operator ? \"Integer\" : \
this.getType(e2.argument);\n              case \"VariableDeclaration\": {\n   \
             const t3 = e2.declarations;\n                let r3;\n           \
     for (let e3 = 0; e3 < t3.length; e3++) {\n                  const n3 = \
t3[e3];\n                  r3 = this.getType(n3);\n                }\n        \
        if (!r3) throw this.astErrorOutput(\"Unable to find type for \
declaration\", e2);\n                return r3;\n              }\n            \
  case \"VariableDeclarator\":\n                const n2 = \
this.getDeclaration(e2.id);\n                if (!n2) throw \
this.astErrorOutput(\"Unable to find declarator\", e2);\n                if \
(!n2.valueType) throw this.astErrorOutput(\"Unable to find declarator \
valueType\", e2);\n                return n2.valueType;\n              case \
\"Identifier\":\n                if (\"Infinity\" === e2.name) return \
\"Number\";\n                if (this.isAstVariable(e2)) {\n                  \
if (\"value\" === this.getVariableSignature(e2)) return \
this.getCheckVariableType(e2);\n                }\n                const i2 = \
this.findIdentifierOrigin(e2);\n                return i2 && i2.init ? \
this.getType(i2.init) : null;\n              case \"MemberExpression\":\n     \
           if (this.isAstMathFunction(e2)) {\n                  switch \
(e2.property.name) {\n                    case \"ceil\":\n                    \
case \"floor\":\n                    case \"round\":\n                      \
return \"Integer\";\n                  }\n                  return \
\"Number\";\n                }\n                if (this.isAstVariable(e2)) \
{\n                  switch (this.getVariableSignature(e2)) {\n               \
     case \"value[]\":\n                      return \
this.getLookupType(this.getCheckVariableType(e2.object));\n                   \
 case \"value[][]\":\n                      return \
this.getLookupType(this.getCheckVariableType(e2.object.object));\n            \
        case \"value[][][]\":\n                      return \
this.getLookupType(this.getCheckVariableType(e2.object.object.object));\n     \
               case \"value[][][][]\":\n                      return \
this.getLookupType(this.getCheckVariableType(e2.object.object.object.object))\
;\n                    case \"value.thread.value\":\n                    case \
\"this.thread.value\":\n                      return \"Integer\";\n           \
         case \"this.output.value\":\n                      return \
this.dynamicOutput ? \"Integer\" : \"LiteralInteger\";\n                    \
case \"this.constants.value\":\n                      return \
this.getConstantType(e2.property.name);\n                    case \
\"this.constants.value[]\":\n                      return \
this.getLookupType(this.getConstantType(e2.object.property.name));\n          \
          case \"this.constants.value[][]\":\n                      return \
this.getLookupType(this.getConstantType(e2.object.object.property.name));\n   \
                 case \"this.constants.value[][][]\":\n                      \
return \
this.getLookupType(this.getConstantType(e2.object.object.object.property.name\
));\n                    case \"this.constants.value[][][][]\":\n             \
         return \
this.getLookupType(this.getConstantType(e2.object.object.object.object.proper\
ty.name));\n                    case \"fn()[]\":\n                    case \
\"fn()[][]\":\n                    case \"fn()[][][]\":\n                     \
 return this.getLookupType(this.getType(e2.object));\n                    \
case \"value.value\":\n                      if (this.isAstMathVariable(e2)) \
return \"Number\";\n                      switch (e2.property.name) {\n       \
                 case \"r\":\n                        case \"g\":\n           \
             case \"b\":\n                        case \"a\":\n               \
           return this.getLookupType(this.getCheckVariableType(e2.object));\n \
                     }\n                    case \"[][]\":\n                  \
    return \"Number\";\n                  }\n                  throw \
this.astErrorOutput(\"Unhandled getType MemberExpression\", e2);\n            \
    }\n                throw this.astErrorOutput(\"Unhandled getType \
MemberExpression\", e2);\n              case \"ConditionalExpression\":\n     \
         case \"IfStatement\":\n                return \
this.getType(e2.consequent);\n              case \"FunctionDeclaration\":\n   \
           case \"FunctionExpression\":\n                const s2 = \
this.findLastReturn(e2.body);\n                return s2 ? this.getType(s2) : \
null;\n              case \"SequenceExpression\":\n                return \
this.getType(e2.expressions[e2.expressions.length - 1]);\n              \
default:\n                throw this.astErrorOutput(`Unhandled getType Type \
\"${e2.type}\"`, e2);\n            }\n          }\n          \
getCheckVariableType(e2) {\n            const t2 = \
this.getVariableType(e2);\n            if (!t2) throw \
this.astErrorOutput(`${e2.type} is not defined`, e2);\n            return \
t2;\n          }\n          inferArgumentTypesIfNeeded(e2, t2) {\n            \
for (let r2 = 0; r2 < t2.length; r2++) {\n              if \
(!this.needsArgumentType(e2, r2)) continue;\n              const n2 = \
this.getType(t2[r2]);\n              if (!n2) throw \
this.astErrorOutput(`Unable to infer argument ${r2}`, t2[r2]);\n              \
this.assignArgumentType(e2, r2, n2);\n            }\n          }\n          \
isAstMathVariable(e2) {\n            return \"MemberExpression\" === e2.type \
&& e2.object && \"Identifier\" === e2.object.type && \"Math\" === \
e2.object.name && e2.property && \"Identifier\" === e2.property.type && \
[\"E\", \"PI\", \"SQRT2\", \"SQRT1_2\", \"LN2\", \"LN10\", \"LOG2E\", \
\"LOG10E\"].indexOf(e2.property.name) > -1;\n          }\n          \
isAstMathFunction(e2) {\n            return \"CallExpression\" === e2.type && \
e2.callee && \"MemberExpression\" === e2.callee.type && e2.callee.object && \
\"Identifier\" === e2.callee.object.type && \"Math\" === \
e2.callee.object.name && e2.callee.property && \"Identifier\" === \
e2.callee.property.type && [\"abs\", \"acos\", \"acosh\", \"asin\", \
\"asinh\", \"atan\", \"atan2\", \"atanh\", \"cbrt\", \"ceil\", \"clz32\", \
\"cos\", \"cosh\", \"expm1\", \"exp\", \"floor\", \"fround\", \"imul\", \
\"log\", \"log2\", \"log10\", \"log1p\", \"max\", \"min\", \"pow\", \
\"random\", \"round\", \"sign\", \"sin\", \"sinh\", \"sqrt\", \"tan\", \
\"tanh\", \"trunc\"].indexOf(e2.callee.property.name) > -1;\n          }\n    \
      isAstVariable(e2) {\n            return \"Identifier\" === e2.type || \
\"MemberExpression\" === e2.type;\n          }\n          isSafe(e2) {\n      \
      return this.isSafeDependencies(this.getDependencies(e2));\n          \
}\n          isSafeDependencies(e2) {\n            return !e2 || !e2.every || \
e2.every((e3) => e3.isSafe);\n          }\n          getDependencies(e2, t2, \
r2) {\n            if (t2 || (t2 = []), !e2) return null;\n            if \
(Array.isArray(e2)) {\n              for (let n2 = 0; n2 < e2.length; n2++) \
this.getDependencies(e2[n2], t2, r2);\n              return t2;\n            \
}\n            switch (e2.type) {\n              case \
\"AssignmentExpression\":\n                return \
this.getDependencies(e2.left, t2, r2), this.getDependencies(e2.right, t2, \
r2), t2;\n              case \"ConditionalExpression\":\n                \
return this.getDependencies(e2.test, t2, r2), \
this.getDependencies(e2.alternate, t2, r2), \
this.getDependencies(e2.consequent, t2, r2), t2;\n              case \
\"Literal\":\n                t2.push({ origin: \"literal\", value: e2.value, \
isSafe: true !== r2 && (e2.value > -1 / 0 && e2.value < 1 / 0 && \
!isNaN(e2.value)) });\n                break;\n              case \
\"VariableDeclarator\":\n                return this.getDependencies(e2.init, \
t2, r2);\n              case \"Identifier\":\n                const n2 = \
this.getDeclaration(e2);\n                if (n2) t2.push({ name: e2.name, \
origin: \"declaration\", isSafe: !r2 && \
this.isSafeDependencies(n2.dependencies) });\n                else if \
(this.argumentNames.indexOf(e2.name) > -1) t2.push({ name: e2.name, origin: \
\"argument\", isSafe: false });\n                else if \
(this.strictTypingChecking) throw new Error(`Cannot find identifier origin \
\"${e2.name}\"`);\n                break;\n              case \
\"FunctionDeclaration\":\n                return \
this.getDependencies(e2.body.body[e2.body.body.length - 1], t2, r2);\n        \
      case \"ReturnStatement\":\n                return \
this.getDependencies(e2.argument, t2);\n              case \
\"BinaryExpression\":\n              case \"LogicalExpression\":\n            \
    return r2 = \"/\" === e2.operator || \"*\" === e2.operator, \
this.getDependencies(e2.left, t2, r2), this.getDependencies(e2.right, t2, \
r2), t2;\n              case \"UnaryExpression\":\n              case \
\"UpdateExpression\":\n                return \
this.getDependencies(e2.argument, t2, r2);\n              case \
\"VariableDeclaration\":\n                return \
this.getDependencies(e2.declarations, t2, r2);\n              case \
\"ArrayExpression\":\n                return t2.push({ origin: \
\"declaration\", isSafe: true }), t2;\n              case \
\"CallExpression\":\n                return t2.push({ origin: \"function\", \
isSafe: true }), t2;\n              case \"MemberExpression\":\n              \
  const i2 = this.getMemberExpressionDetails(e2);\n                switch \
(i2.signature) {\n                  case \"value[]\":\n                    \
this.getDependencies(e2.object, t2, r2);\n                    break;\n        \
          case \"value[][]\":\n                    \
this.getDependencies(e2.object.object, t2, r2);\n                    break;\n \
                 case \"value[][][]\":\n                    \
this.getDependencies(e2.object.object.object, t2, r2);\n                    \
break;\n                  case \"this.output.value\":\n                    \
this.dynamicOutput && t2.push({ name: i2.name, origin: \"output\", isSafe: \
false });\n                }\n                if (i2) return i2.property && \
this.getDependencies(i2.property, t2, r2), i2.xProperty && \
this.getDependencies(i2.xProperty, t2, r2), i2.yProperty && \
this.getDependencies(i2.yProperty, t2, r2), i2.zProperty && \
this.getDependencies(i2.zProperty, t2, r2), t2;\n              case \
\"SequenceExpression\":\n                return \
this.getDependencies(e2.expressions, t2, r2);\n              default:\n       \
         throw this.astErrorOutput(`Unhandled type ${e2.type} in \
getDependencies`, e2);\n            }\n            return t2;\n          }\n  \
        getVariableSignature(e2, t2) {\n            if \
(!this.isAstVariable(e2)) throw new Error(`ast of type \"${e2.type}\" is not \
a variable signature`);\n            if (\"Identifier\" === e2.type) return \
\"value\";\n            const r2 = [];\n            for (; e2; ) e2.computed \
? r2.push(\"[]\") : \"ThisExpression\" === e2.type ? r2.unshift(\"this\") : \
e2.property && e2.property.name ? \"x\" === e2.property.name || \"y\" === \
e2.property.name || \"z\" === e2.property.name ? r2.unshift(t2 ? \".\" + \
e2.property.name : \".value\") : \"constants\" === e2.property.name || \
\"thread\" === e2.property.name || \"output\" === e2.property.name ? \
r2.unshift(\".\" + e2.property.name) : r2.unshift(t2 ? \".\" + \
e2.property.name : \".value\") : e2.name ? r2.unshift(t2 ? e2.name : \
\"value\") : e2.callee && e2.callee.name ? r2.unshift(t2 ? e2.callee.name + \
\"()\" : \"fn()\") : e2.elements ? r2.unshift(\"[]\") : \
r2.unshift(\"unknown\"), e2 = e2.object;\n            const n2 = \
r2.join(\"\");\n            if (t2) return n2;\n            return \
[\"value\", \"value[]\", \"value[][]\", \"value[][][]\", \"value[][][][]\", \
\"value.value\", \"value.thread.value\", \"this.thread.value\", \
\"this.output.value\", \"this.constants.value\", \"this.constants.value[]\", \
\"this.constants.value[][]\", \"this.constants.value[][][]\", \
\"this.constants.value[][][][]\", \"fn()[]\", \"fn()[][]\", \"fn()[][][]\", \
\"[][]\"].indexOf(n2) > -1 ? n2 : null;\n          }\n          build() {\n   \
         return this.toString().length > 0;\n          }\n          \
astGeneric(e2, t2) {\n            if (null === e2) throw \
this.astErrorOutput(\"NULL ast\", e2);\n            if (Array.isArray(e2)) \
{\n              for (let r2 = 0; r2 < e2.length; r2++) \
this.astGeneric(e2[r2], t2);\n              return t2;\n            }\n       \
     switch (e2.type) {\n              case \"FunctionDeclaration\":\n        \
        return this.astFunctionDeclaration(e2, t2);\n              case \
\"FunctionExpression\":\n                return \
this.astFunctionExpression(e2, t2);\n              case \
\"ReturnStatement\":\n                return this.astReturnStatement(e2, \
t2);\n              case \"Literal\":\n                return \
this.astLiteral(e2, t2);\n              case \"BinaryExpression\":\n          \
      return this.astBinaryExpression(e2, t2);\n              case \
\"Identifier\":\n                return this.astIdentifierExpression(e2, \
t2);\n              case \"AssignmentExpression\":\n                return \
this.astAssignmentExpression(e2, t2);\n              case \
\"ExpressionStatement\":\n                return \
this.astExpressionStatement(e2, t2);\n              case \
\"EmptyStatement\":\n                return this.astEmptyStatement(e2, t2);\n \
             case \"BlockStatement\":\n                return \
this.astBlockStatement(e2, t2);\n              case \"IfStatement\":\n        \
        return this.astIfStatement(e2, t2);\n              case \
\"SwitchStatement\":\n                return this.astSwitchStatement(e2, \
t2);\n              case \"BreakStatement\":\n                return \
this.astBreakStatement(e2, t2);\n              case \"ContinueStatement\":\n  \
              return this.astContinueStatement(e2, t2);\n              case \
\"ForStatement\":\n                return this.astForStatement(e2, t2);\n     \
         case \"WhileStatement\":\n                return \
this.astWhileStatement(e2, t2);\n              case \"DoWhileStatement\":\n   \
             return this.astDoWhileStatement(e2, t2);\n              case \
\"VariableDeclaration\":\n                return \
this.astVariableDeclaration(e2, t2);\n              case \
\"VariableDeclarator\":\n                return \
this.astVariableDeclarator(e2, t2);\n              case \"ThisExpression\":\n \
               return this.astThisExpression(e2, t2);\n              case \
\"SequenceExpression\":\n                return \
this.astSequenceExpression(e2, t2);\n              case \
\"UnaryExpression\":\n                return this.astUnaryExpression(e2, \
t2);\n              case \"UpdateExpression\":\n                return \
this.astUpdateExpression(e2, t2);\n              case \
\"LogicalExpression\":\n                return this.astLogicalExpression(e2, \
t2);\n              case \"MemberExpression\":\n                return \
this.astMemberExpression(e2, t2);\n              case \"CallExpression\":\n   \
             return this.astCallExpression(e2, t2);\n              case \
\"ArrayExpression\":\n                return this.astArrayExpression(e2, \
t2);\n              case \"DebuggerStatement\":\n                return \
this.astDebuggerStatement(e2, t2);\n              case \
\"ConditionalExpression\":\n                return \
this.astConditionalExpression(e2, t2);\n            }\n            throw \
this.astErrorOutput(\"Unknown ast type : \" + e2.type, e2);\n          }\n    \
      astErrorOutput(e2, t2) {\n            if (\"string\" != typeof \
this.source) return new Error(e2);\n            const r2 = \
i.getAstString(this.source, t2), n2 = \
this.source.substr(t2.start).split(/\\n/), s2 = n2.length > 0 ? n2[n2.length \
- 1] : 0;\n            return new Error(`${e2} on line ${n2.length}, position \
${s2.length}:\n ${r2}`);\n          }\n          astDebuggerStatement(e2, t2) \
{\n            return t2;\n          }\n          \
astConditionalExpression(e2, t2) {\n            if (\"ConditionalExpression\" \
!== e2.type) throw this.astErrorOutput(\"Not a conditional expression\", \
e2);\n            return t2.push(\"(\"), this.astGeneric(e2.test, t2), \
t2.push(\"?\"), this.astGeneric(e2.consequent, t2), t2.push(\":\"), \
this.astGeneric(e2.alternate, t2), t2.push(\")\"), t2;\n          }\n         \
 astFunction(e2, t2) {\n            throw new Error(`\"astFunction\" not \
defined on ${this.constructor.name}`);\n          }\n          \
astFunctionDeclaration(e2, t2) {\n            return this.isChildFunction(e2) \
? t2 : this.astFunction(e2, t2);\n          }\n          \
astFunctionExpression(e2, t2) {\n            return this.isChildFunction(e2) \
? t2 : this.astFunction(e2, t2);\n          }\n          isChildFunction(e2) \
{\n            for (let t2 = 0; t2 < this.functions.length; t2++) if \
(this.functions[t2] === e2) return true;\n            return false;\n         \
 }\n          astReturnStatement(e2, t2) {\n            return t2;\n          \
}\n          astLiteral(e2, t2) {\n            return \
this.literalTypes[this.astKey(e2)] = \"Number\", t2;\n          }\n          \
astBinaryExpression(e2, t2) {\n            return t2;\n          }\n          \
astIdentifierExpression(e2, t2) {\n            return t2;\n          }\n      \
    astAssignmentExpression(e2, t2) {\n            return t2;\n          }\n  \
        astExpressionStatement(e2, t2) {\n            return \
this.astGeneric(e2.expression, t2), t2.push(\";\"), t2;\n          }\n        \
  astEmptyStatement(e2, t2) {\n            return t2;\n          }\n          \
astBlockStatement(e2, t2) {\n            return t2;\n          }\n          \
astIfStatement(e2, t2) {\n            return t2;\n          }\n          \
astSwitchStatement(e2, t2) {\n            return t2;\n          }\n          \
astBreakStatement(e2, t2) {\n            return t2.push(\"break;\"), t2;\n    \
      }\n          astContinueStatement(e2, t2) {\n            return \
t2.push(\"continue;\\n\"), t2;\n          }\n          astForStatement(e2, \
t2) {\n            return t2;\n          }\n          astWhileStatement(e2, \
t2) {\n            return t2;\n          }\n          astDoWhileStatement(e2, \
t2) {\n            return t2;\n          }\n          \
astVariableDeclarator(e2, t2) {\n            return this.astGeneric(e2.id, \
t2), null !== e2.init && (t2.push(\"=\"), this.astGeneric(e2.init, t2)), \
t2;\n          }\n          astThisExpression(e2, t2) {\n            return \
t2;\n          }\n          astSequenceExpression(e2, t2) {\n            \
const { expressions: r2 } = e2, n2 = [];\n            for (let e3 = 0; e3 < \
r2.length; e3++) {\n              const t3 = r2[e3], i2 = [];\n              \
this.astGeneric(t3, i2), n2.push(i2.join(\"\"));\n            }\n            \
return n2.length > 1 ? t2.push(\"(\", n2.join(\",\"), \")\") : \
t2.push(n2[0]), t2;\n          }\n          astUnaryExpression(e2, t2) {\n    \
        return this.checkAndUpconvertBitwiseUnary(e2, t2) || (e2.prefix ? \
(t2.push(e2.operator), this.astGeneric(e2.argument, t2)) : \
(this.astGeneric(e2.argument, t2), t2.push(e2.operator))), t2;\n          }\n \
         checkAndUpconvertBitwiseUnary(e2, t2) {\n          }\n          \
astUpdateExpression(e2, t2) {\n            return e2.prefix ? \
(t2.push(e2.operator), this.astGeneric(e2.argument, t2)) : \
(this.astGeneric(e2.argument, t2), t2.push(e2.operator)), t2;\n          }\n  \
        astLogicalExpression(e2, t2) {\n            return t2.push(\"(\"), \
this.astGeneric(e2.left, t2), t2.push(e2.operator), this.astGeneric(e2.right, \
t2), t2.push(\")\"), t2;\n          }\n          astMemberExpression(e2, t2) \
{\n            return t2;\n          }\n          astCallExpression(e2, t2) \
{\n            return t2;\n          }\n          astArrayExpression(e2, t2) \
{\n            return t2;\n          }\n          \
getMemberExpressionDetails(e2) {\n            if (\"MemberExpression\" !== \
e2.type) throw this.astErrorOutput(`Expression ${e2.type} not a \
MemberExpression`, e2);\n            let t2 = null, r2 = null;\n            \
const n2 = this.getVariableSignature(e2);\n            switch (n2) {\n        \
      case \"value\":\n                return null;\n              case \
\"value.thread.value\":\n              case \"this.thread.value\":\n          \
    case \"this.output.value\":\n                return { signature: n2, \
type: \"Integer\", name: e2.property.name };\n              case \
\"value[]\":\n                if (\"string\" != typeof e2.object.name) throw \
this.astErrorOutput(\"Unexpected expression\", e2);\n                return \
t2 = e2.object.name, { name: t2, origin: \"user\", signature: n2, type: \
this.getVariableType(e2.object), xProperty: e2.property };\n              \
case \"value[][]\":\n                if (\"string\" != typeof \
e2.object.object.name) throw this.astErrorOutput(\"Unexpected expression\", \
e2);\n                return t2 = e2.object.object.name, { name: t2, origin: \
\"user\", signature: n2, type: this.getVariableType(e2.object.object), \
yProperty: e2.object.property, xProperty: e2.property };\n              case \
\"value[][][]\":\n                if (\"string\" != typeof \
e2.object.object.object.name) throw this.astErrorOutput(\"Unexpected \
expression\", e2);\n                return t2 = e2.object.object.object.name, \
{ name: t2, origin: \"user\", signature: n2, type: \
this.getVariableType(e2.object.object.object), zProperty: \
e2.object.object.property, yProperty: e2.object.property, xProperty: \
e2.property };\n              case \"value[][][][]\":\n                if \
(\"string\" != typeof e2.object.object.object.object.name) throw \
this.astErrorOutput(\"Unexpected expression\", e2);\n                return \
t2 = e2.object.object.object.object.name, { name: t2, origin: \"user\", \
signature: n2, type: this.getVariableType(e2.object.object.object.object), \
zProperty: e2.object.object.property, yProperty: e2.object.property, \
xProperty: e2.property };\n              case \"value.value\":\n              \
  if (\"string\" != typeof e2.property.name) throw \
this.astErrorOutput(\"Unexpected expression\", e2);\n                if \
(this.isAstMathVariable(e2)) return t2 = e2.property.name, { name: t2, \
origin: \"Math\", type: \"Number\", signature: n2 };\n                switch \
(e2.property.name) {\n                  case \"r\":\n                  case \
\"g\":\n                  case \"b\":\n                  case \"a\":\n        \
            return t2 = e2.object.name, { name: t2, property: \
e2.property.name, origin: \"user\", signature: n2, type: \"Number\" };\n      \
            default:\n                    throw \
this.astErrorOutput(\"Unexpected expression\", e2);\n                }\n      \
        case \"this.constants.value\":\n                if (\"string\" != \
typeof e2.property.name) throw this.astErrorOutput(\"Unexpected expression\", \
e2);\n                if (t2 = e2.property.name, r2 = \
this.getConstantType(t2), !r2) throw this.astErrorOutput(\"Constant has no \
type\", e2);\n                return { name: t2, type: r2, origin: \
\"constants\", signature: n2 };\n              case \
\"this.constants.value[]\":\n                if (\"string\" != typeof \
e2.object.property.name) throw this.astErrorOutput(\"Unexpected expression\", \
e2);\n                if (t2 = e2.object.property.name, r2 = \
this.getConstantType(t2), !r2) throw this.astErrorOutput(\"Constant has no \
type\", e2);\n                return { name: t2, type: r2, origin: \
\"constants\", signature: n2, xProperty: e2.property };\n              case \
\"this.constants.value[][]\":\n                if (\"string\" != typeof \
e2.object.object.property.name) throw this.astErrorOutput(\"Unexpected \
expression\", e2);\n                if (t2 = e2.object.object.property.name, \
r2 = this.getConstantType(t2), !r2) throw this.astErrorOutput(\"Constant has \
no type\", e2);\n                return { name: t2, type: r2, origin: \
\"constants\", signature: n2, yProperty: e2.object.property, xProperty: \
e2.property };\n              case \"this.constants.value[][][]\":\n          \
      if (\"string\" != typeof e2.object.object.object.property.name) throw \
this.astErrorOutput(\"Unexpected expression\", e2);\n                if (t2 = \
e2.object.object.object.property.name, r2 = this.getConstantType(t2), !r2) \
throw this.astErrorOutput(\"Constant has no type\", e2);\n                \
return { name: t2, type: r2, origin: \"constants\", signature: n2, zProperty: \
e2.object.object.property, yProperty: e2.object.property, xProperty: \
e2.property };\n              case \"fn()[]\":\n              case \
\"fn()[][]\":\n              case \"[][]\":\n                return { \
signature: n2, property: e2.property };\n              default:\n             \
   throw this.astErrorOutput(\"Unexpected expression\", e2);\n            }\n \
         }\n          findIdentifierOrigin(e2) {\n            const t2 = \
[this.ast];\n            for (; t2.length > 0; ) {\n              const r2 = \
t2[0];\n              if (\"VariableDeclarator\" === r2.type && r2.id && \
r2.id.name && r2.id.name === e2.name) return r2;\n              if \
(t2.shift(), r2.argument) t2.push(r2.argument);\n              else if \
(r2.body) t2.push(r2.body);\n              else if (r2.declarations) \
t2.push(r2.declarations);\n              else if (Array.isArray(r2)) for (let \
e3 = 0; e3 < r2.length; e3++) t2.push(r2[e3]);\n            }\n            \
return null;\n          }\n          findLastReturn(e2) {\n            const \
t2 = [e2 || this.ast];\n            for (; t2.length > 0; ) {\n              \
const e3 = t2.pop();\n              if (\"ReturnStatement\" === e3.type) \
return e3;\n              if (\"FunctionDeclaration\" !== e3.type) if \
(e3.argument) t2.push(e3.argument);\n              else if (e3.body) \
t2.push(e3.body);\n              else if (e3.declarations) \
t2.push(e3.declarations);\n              else if (Array.isArray(e3)) for (let \
r2 = 0; r2 < e3.length; r2++) t2.push(e3[r2]);\n              else \
e3.consequent ? t2.push(e3.consequent) : e3.cases && t2.push(e3.cases);\n     \
       }\n            return null;\n          }\n          \
getInternalVariableName(e2) {\n            return \
this._internalVariableNames.hasOwnProperty(e2) || \
(this._internalVariableNames[e2] = 0), this._internalVariableNames[e2]++, 1 \
=== this._internalVariableNames[e2] ? e2 : e2 + \
this._internalVariableNames[e2];\n          }\n          astKey(e2, t2 = \
\",\") {\n            if (!e2.start || !e2.end) throw new Error(\"AST start \
and end needed\");\n            return `${e2.start}${t2}${e2.end}`;\n         \
 }\n        } };\n      }, { \"../utils\": 114, \"./function-tracer\": 11, \
acorn: 1 }], 11: [function(e, t, r) {\n        const { utils: n } = \
e(\"../utils\");\n        function i(e2) {\n          return e2.length > 0 ? \
e2[e2.length - 1] : null;\n        }\n        const s = \"trackIdentifiers\", \
a = \"memberExpression\", o = \"inForLoopInit\";\n        t.exports = { \
FunctionTracer: class {\n          constructor(e2) {\n            \
this.runningContexts = [], this.functionContexts = [], this.contexts = [], \
this.functionCalls = [], this.declarations = [], this.identifiers = [], \
this.functions = [], this.returnStatements = [], this.trackedIdentifiers = \
null, this.states = [], this.newFunctionContext(), this.scan(e2);\n          \
}\n          isState(e2) {\n            return this.states[this.states.length \
- 1] === e2;\n          }\n          hasState(e2) {\n            return \
this.states.indexOf(e2) > -1;\n          }\n          pushState(e2) {\n       \
     this.states.push(e2);\n          }\n          popState(e2) {\n           \
 if (!this.isState(e2)) throw new Error(`Cannot pop the non-active state \
\"${e2}\"`);\n            this.states.pop();\n          }\n          get \
currentFunctionContext() {\n            return i(this.functionContexts);\n    \
      }\n          get currentContext() {\n            return \
i(this.runningContexts);\n          }\n          newFunctionContext() {\n     \
       const e2 = { \"@contextType\": \"function\" };\n            \
this.contexts.push(e2), this.functionContexts.push(e2);\n          }\n        \
  newContext(e2) {\n            const t2 = Object.assign({ \"@contextType\": \
\"const/let\" }, this.currentContext);\n            this.contexts.push(t2), \
this.runningContexts.push(t2), e2();\n            const { \
currentFunctionContext: r2 } = this;\n            for (const e3 in r2) \
r2.hasOwnProperty(e3) && !t2.hasOwnProperty(e3) && (t2[e3] = r2[e3]);\n       \
     return this.runningContexts.pop(), t2;\n          }\n          \
useFunctionContext(e2) {\n            const t2 = i(this.functionContexts);\n  \
          this.runningContexts.push(t2), e2(), this.runningContexts.pop();\n  \
        }\n          getIdentifiers(e2) {\n            const t2 = \
this.trackedIdentifiers = [];\n            return this.pushState(s), e2(), \
this.trackedIdentifiers = null, this.popState(s), t2;\n          }\n          \
getDeclaration(e2) {\n            const { currentContext: t2, \
currentFunctionContext: r2, runningContexts: n2 } = this, i2 = t2[e2] || \
r2[e2] || null;\n            if (!i2 && t2 === r2 && n2.length > 0) {\n       \
       const t3 = n2[n2.length - 2];\n              if (t3[e2]) return \
t3[e2];\n            }\n            return i2;\n          }\n          \
scan(e2) {\n            if (e2) if (Array.isArray(e2)) for (let t2 = 0; t2 < \
e2.length; t2++) this.scan(e2[t2]);\n            else switch (e2.type) {\n    \
          case \"Program\":\n                this.useFunctionContext(() => \
{\n                  this.scan(e2.body);\n                });\n               \
 break;\n              case \"BlockStatement\":\n                \
this.newContext(() => {\n                  this.scan(e2.body);\n              \
  });\n                break;\n              case \"AssignmentExpression\":\n \
             case \"LogicalExpression\":\n              case \
\"BinaryExpression\":\n                this.scan(e2.left), \
this.scan(e2.right);\n                break;\n              case \
\"UpdateExpression\":\n                if (\"++\" === e2.operator) {\n        \
          const t2 = this.getDeclaration(e2.argument.name);\n                 \
 t2 && (t2.suggestedType = \"Integer\");\n                }\n                \
this.scan(e2.argument);\n                break;\n              case \
\"UnaryExpression\":\n                this.scan(e2.argument);\n               \
 break;\n              case \"VariableDeclaration\":\n                \"var\" \
=== e2.kind ? this.useFunctionContext(() => {\n                  \
e2.declarations = n.normalizeDeclarations(e2), this.scan(e2.declarations);\n  \
              }) : (e2.declarations = n.normalizeDeclarations(e2), \
this.scan(e2.declarations));\n                break;\n              case \
\"VariableDeclarator\": {\n                const { currentContext: t2 } = \
this, r2 = this.hasState(o), n2 = { ast: e2, context: t2, name: e2.id.name, \
origin: \"declaration\", inForLoopInit: r2, inForLoopTest: null, assignable: \
t2 === this.currentFunctionContext || !r2 && !t2.hasOwnProperty(e2.id.name), \
suggestedType: null, valueType: null, dependencies: null, isSafe: null };\n   \
             t2[e2.id.name] || (t2[e2.id.name] = n2), \
this.declarations.push(n2), this.scan(e2.id), this.scan(e2.init);\n           \
     break;\n              }\n              case \"FunctionExpression\":\n    \
          case \"FunctionDeclaration\":\n                0 === \
this.runningContexts.length ? this.scan(e2.body) : this.functions.push(e2);\n \
               break;\n              case \"IfStatement\":\n                \
this.scan(e2.test), this.scan(e2.consequent), e2.alternate && \
this.scan(e2.alternate);\n                break;\n              case \
\"ForStatement\": {\n                let t2;\n                const r2 = \
this.newContext(() => {\n                  this.pushState(o), \
this.scan(e2.init), this.popState(o), t2 = this.getIdentifiers(() => {\n      \
              this.scan(e2.test);\n                  }), \
this.scan(e2.update), this.newContext(() => {\n                    \
this.scan(e2.body);\n                  });\n                });\n             \
   if (t2) for (const e3 in r2) \"@contextType\" !== e3 && t2.indexOf(e3) > \
-1 && (r2[e3].inForLoopTest = true);\n                break;\n              \
}\n              case \"DoWhileStatement\":\n              case \
\"WhileStatement\":\n                this.newContext(() => {\n                \
  this.scan(e2.body), this.scan(e2.test);\n                });\n              \
  break;\n              case \"Identifier\":\n                this.isState(s) \
&& this.trackedIdentifiers.push(e2.name), this.identifiers.push({ context: \
this.currentContext, declaration: this.getDeclaration(e2.name), ast: e2 });\n \
               break;\n              case \"ReturnStatement\":\n              \
  this.returnStatements.push(e2), this.scan(e2.argument);\n                \
break;\n              case \"MemberExpression\":\n                \
this.pushState(a), this.scan(e2.object), this.scan(e2.property), \
this.popState(a);\n                break;\n              case \
\"ExpressionStatement\":\n                this.scan(e2.expression);\n         \
       break;\n              case \"SequenceExpression\":\n                \
this.scan(e2.expressions);\n                break;\n              case \
\"CallExpression\":\n                this.functionCalls.push({ context: \
this.currentContext, ast: e2 }), this.scan(e2.arguments);\n                \
break;\n              case \"ArrayExpression\":\n                \
this.scan(e2.elements);\n                break;\n              case \
\"ConditionalExpression\":\n                this.scan(e2.test), \
this.scan(e2.alternate), this.scan(e2.consequent);\n                break;\n  \
            case \"SwitchStatement\":\n                \
this.scan(e2.discriminant), this.scan(e2.cases);\n                break;\n    \
          case \"SwitchCase\":\n                this.scan(e2.test), \
this.scan(e2.consequent);\n                break;\n              case \
\"ThisExpression\":\n              case \"Literal\":\n              case \
\"DebuggerStatement\":\n              case \"EmptyStatement\":\n              \
case \"BreakStatement\":\n              case \"ContinueStatement\":\n         \
       break;\n              default:\n                throw new \
Error(`unhandled type \"${e2.type}\"`);\n            }\n          }\n        \
} };\n      }, { \"../utils\": 114 }], 12: [function(e, t, r) {\n        \
const { glWiretap: n } = e(\"gl-wiretap\"), { utils: i } = \
e(\"../../utils\");\n        function s(e2) {\n          return \
e2.toString().replace(\"=>\", \"\").replace(/^function /, \
\"\").replace(/utils[.]/g, \"/*utils.*/\");\n        }\n        function \
a(e2, t2) {\n          const r2 = \"single\" === t2.precision ? e2 : `new \
Float32Array(${e2}.buffer)`;\n          return t2.output[2] ? \
`renderOutput(${r2}, ${t2.output[0]}, ${t2.output[1]}, ${t2.output[2]})` : \
t2.output[1] ? `renderOutput(${r2}, ${t2.output[0]}, ${t2.output[1]})` : \
`renderOutput(${r2}, ${t2.output[0]})`;\n        }\n        function o(e2, \
t2, r2) {\n          const n2 = e2.toArray.toString(), s2 = \
!/^function/.test(n2);\n          return `() => {\n  function framebuffer() { \
return ${r2}; };\n  ${i.flattenFunctionToString(`${s2 ? \"function \" : \
\"\"}${n2}`, { findDependency: (t3, r3) => {\n            if (\"utils\" === \
t3) return `const ${r3} = ${i[r3].toString()};`;\n            if (\"this\" \
=== t3) return \"framebuffer\" === r3 ? \"\" : `${s2 ? \"function \" : \
\"\"}${e2[r3].toString()}`;\n            throw new Error(\"unhandled \
fromObject\");\n          }, thisLookup: (r3, n3) => {\n            if \
(\"texture\" === r3) return t2;\n            if (\"context\" === r3) return \
n3 ? null : \"gl\";\n            if (e2.hasOwnProperty(r3)) return \
JSON.stringify(e2[r3]);\n            throw new Error(`unhandled thisLookup \
${r3}`);\n          } })}\n  return toArray();\n  }`;\n        }\n        \
function u(e2, t2, r2, n2, i2) {\n          if (null === e2) return null;\n   \
       if (null === t2) return null;\n          switch (typeof e2) {\n        \
    case \"boolean\":\n            case \"number\":\n              return \
null;\n          }\n          if (\"undefined\" != typeof HTMLImageElement && \
e2 instanceof HTMLImageElement) for (let i3 = 0; i3 < t2.length; i3++) {\n    \
        const s2 = t2[i3];\n            if (\"HTMLImageArray\" !== s2.type && \
s2) continue;\n            if (s2.uploadValue !== e2) continue;\n            \
const a2 = r2[i3].indexOf(e2);\n            if (-1 === a2) continue;\n        \
    const o2 = `uploadValue_${s2.name}[${a2}]`;\n            return \
n2.insertVariable(o2, e2), o2;\n          }\n          for (let r3 = 0; r3 < \
t2.length; r3++) {\n            const i3 = t2[r3];\n            if (e2 !== \
i3.uploadValue) continue;\n            const s2 = `uploadValue_${i3.name}`;\n \
           return n2.insertVariable(s2, i3), s2;\n          }\n          \
return null;\n        }\n        t.exports = { glKernelString: function(e2, \
t2, r2, l, h) {\n          r2.built || r2.build.apply(r2, t2), t2 = t2 ? \
Array.from(t2).map((e3) => {\n            switch (typeof e3) {\n              \
case \"boolean\":\n                return new Boolean(e3);\n              \
case \"number\":\n                return new Number(e3);\n              \
default:\n                return e3;\n            }\n          }) : null;\n   \
       const c = [], p = [], d = n(r2.context, { useTrackablePrimitives: \
true, onReadPixels: (e3) => {\n            if (N.subKernels) {\n              \
if (m) {\n                const t3 = N.subKernels[f++].property;\n            \
    p.push(`    result${isNaN(t3) ? \".\" + t3 : `[${t3}]`} = ${a(e3, \
N)};`);\n              } else p.push(`    const result = { result: ${a(e3, \
N)} };`), m = true;\n              f === N.subKernels.length && p.push(\"    \
return result;\");\n            } else e3 ? p.push(`    return ${a(e3, N)};`) \
: p.push(\"    return null;\");\n          }, onUnrecognizedArgumentLookup: \
(e3) => {\n            const t3 = u(e3, N.kernelArguments, [], d, c);\n       \
     if (t3) return t3;\n            const r3 = u(e3, N.kernelConstants, S ? \
Object.keys(S).map((e4) => S[e4]) : [], d, c);\n            return r3 || \
null;\n          } });\n          let m = false, f = 0;\n          const { \
source: g, canvas: x, output: y, pipeline: b, graphical: T, \
loopMaxIterations: v, constants: S, optimizeFloatMemory: A, precision: _, \
fixIntegerDivisionAccuracy: E, functions: w, nativeFunctions: k, subKernels: \
I, immutable: D, argumentTypes: C, constantTypes: $, kernelArguments: L, \
kernelConstants: R, tactic: F } = r2, N = new e2(g, { canvas: x, context: d, \
checkContext: false, output: y, pipeline: b, graphical: T, loopMaxIterations: \
v, constants: S, optimizeFloatMemory: A, precision: _, \
fixIntegerDivisionAccuracy: E, functions: w, nativeFunctions: k, subKernels: \
I, immutable: D, argumentTypes: C, constantTypes: $, tactic: F });\n          \
let V = [];\n          if (d.setIndent(2), N.build.apply(N, t2), \
V.push(d.toString()), d.reset(), N.kernelArguments.forEach((e3, r3) => {\n    \
        switch (e3.type) {\n              case \"Integer\":\n              \
case \"Boolean\":\n              case \"Number\":\n              case \
\"Float\":\n              case \"Array\":\n              case \"Array(2)\":\n \
             case \"Array(3)\":\n              case \"Array(4)\":\n           \
   case \"HTMLCanvas\":\n              case \"HTMLImage\":\n              \
case \"HTMLVideo\":\n              case \"Input\":\n                \
d.insertVariable(`uploadValue_${e3.name}`, e3.uploadValue);\n                \
break;\n              case \"HTMLImageArray\":\n                for (let n2 = \
0; n2 < t2[r3].length; n2++) {\n                  const i2 = t2[r3];\n        \
          d.insertVariable(`uploadValue_${e3.name}[${n2}]`, i2[n2]);\n        \
        }\n                break;\n              case \
\"MemoryOptimizedNumberTexture\":\n              case \"NumberTexture\":\n    \
          case \"Array1D(2)\":\n              case \"Array1D(3)\":\n          \
    case \"Array1D(4)\":\n              case \"Array2D(2)\":\n              \
case \"Array2D(3)\":\n              case \"Array2D(4)\":\n              case \
\"Array3D(2)\":\n              case \"Array3D(3)\":\n              case \
\"Array3D(4)\":\n              case \"ArrayTexture(1)\":\n              case \
\"ArrayTexture(2)\":\n              case \"ArrayTexture(3)\":\n              \
case \"ArrayTexture(4)\":\n                \
d.insertVariable(`uploadValue_${e3.name}`, t2[r3].texture);\n                \
break;\n              default:\n                throw new Error(`unhandled \
kernelArgumentType insertion for glWiretap of type ${e3.type}`);\n            \
}\n          }), V.push(\"/** start of injected functions **/\"), \
V.push(`function ${s(i.flattenTo)}`), V.push(`function \
${s(i.flatten2dArrayTo)}`), V.push(`function ${s(i.flatten3dArrayTo)}`), \
V.push(`function ${s(i.flatten4dArrayTo)}`), V.push(`function \
${s(i.isArray)}`), N.renderOutput !== N.renderTexture && N.formatValues && \
V.push(`  const renderOutput = function ${s(N.formatValues)};`), V.push(\"/** \
end of injected functions **/\"), V.push(`  const innerKernel = function \
(${N.kernelArguments.map((e3) => e3.varName).join(\", \")}) {`), \
d.setIndent(4), N.run.apply(N, t2), N.renderKernels ? N.renderKernels() : \
N.renderOutput && N.renderOutput(), V.push(\"    /** start setup uploads for \
kernel values **/\"), N.kernelArguments.forEach((e3) => {\n            \
V.push(\"    \" + e3.getStringValueHandler().split(\"\\n\").join(\"\\n    \
\"));\n          }), V.push(\"    /** end setup uploads for kernel values \
**/\"), V.push(d.toString()), N.renderOutput === N.renderTexture) {\n         \
   d.reset();\n            const e3 = \
d.getContextVariableName(N.framebuffer);\n            if (N.renderKernels) \
{\n              const t3 = N.renderKernels(), r3 = \
d.getContextVariableName(N.texture.texture);\n              V.push(`    \
return {\n      result: {\n        texture: ${r3},\n        type: \
'${t3.result.type}',\n        toArray: ${o(t3.result, r3, e3)}\n      },`);\n \
             const { subKernels: n2, mappedTextures: i2 } = N;\n              \
for (let r4 = 0; r4 < n2.length; r4++) {\n                const s2 = i2[r4], \
a2 = n2[r4], u2 = t3[a2.property], l2 = \
d.getContextVariableName(s2.texture);\n                V.push(`\n      \
${a2.property}: {\n        texture: ${l2},\n        type: '${u2.type}',\n     \
   toArray: ${o(u2, l2, e3)}\n      },`);\n              }\n              \
V.push(\"    };\");\n            } else {\n              const t3 = \
N.renderOutput(), r3 = d.getContextVariableName(N.texture.texture);\n         \
     V.push(`    return {\n        texture: ${r3},\n        type: \
'${t3.type}',\n        toArray: ${o(t3, r3, e3)}\n      };`);\n            \
}\n          }\n          V.push(\"    \" + (h ? \"\\n\" + h + \"    \" : \
\"\")), V.push(p.join(\"\\n\")), V.push(\"  };\"), N.graphical && \
(V.push(function(e3) {\n            const t3 = e3.getPixels.toString(), r3 = \
!/^function/.test(t3);\n            return i.flattenFunctionToString(`${r3 ? \
\"function \" : \"\"}${t3}`, { findDependency: (e4, t4) => \"utils\" === e4 ? \
`const ${t4} = ${i[t4].toString()};` : null, thisLookup: (t4) => {\n          \
    if (\"context\" === t4) return null;\n              if \
(e3.hasOwnProperty(t4)) return JSON.stringify(e3[t4]);\n              throw \
new Error(`unhandled thisLookup ${t4}`);\n            } });\n          }(N)), \
V.push(\"  innerKernel.getPixels = getPixels;\")), V.push(\"  return \
innerKernel;\");\n          let M = [];\n          return R.forEach((e3) => \
{\n            M.push(`${e3.getStringValueHandler()}`);\n          }), \
`function kernel(settings) {\n  const { context, constants } = settings;\n  \
${M.join(\"\")}\n  ${l || \"\"}\n${V.join(\"\\n\")}\n}`;\n        } };\n      \
}, { \"../../utils\": 114, \"gl-wiretap\": 3 }], 13: [function(e, t, r) {\n   \
     const { Kernel: n } = e(\"../kernel\"), { utils: i } = \
e(\"../../utils\"), { GLTextureArray2Float: s } = \
e(\"./texture/array-2-float\"), { GLTextureArray2Float2D: a } = \
e(\"./texture/array-2-float-2d\"), { GLTextureArray2Float3D: o } = \
e(\"./texture/array-2-float-3d\"), { GLTextureArray3Float: u } = \
e(\"./texture/array-3-float\"), { GLTextureArray3Float2D: l } = \
e(\"./texture/array-3-float-2d\"), { GLTextureArray3Float3D: h } = \
e(\"./texture/array-3-float-3d\"), { GLTextureArray4Float: c } = \
e(\"./texture/array-4-float\"), { GLTextureArray4Float2D: p } = \
e(\"./texture/array-4-float-2d\"), { GLTextureArray4Float3D: d } = \
e(\"./texture/array-4-float-3d\"), { GLTextureFloat: m } = \
e(\"./texture/float\"), { GLTextureFloat2D: f } = e(\"./texture/float-2d\"), \
{ GLTextureFloat3D: g } = e(\"./texture/float-3d\"), { \
GLTextureMemoryOptimized: x } = e(\"./texture/memory-optimized\"), { \
GLTextureMemoryOptimized2D: y } = e(\"./texture/memory-optimized-2d\"), { \
GLTextureMemoryOptimized3D: b } = e(\"./texture/memory-optimized-3d\"), { \
GLTextureUnsigned: T } = e(\"./texture/unsigned\"), { GLTextureUnsigned2D: v \
} = e(\"./texture/unsigned-2d\"), { GLTextureUnsigned3D: S } = \
e(\"./texture/unsigned-3d\"), { GLTextureGraphical: A } = \
e(\"./texture/graphical\");\n        const _ = { int: \"Integer\", float: \
\"Number\", vec2: \"Array(2)\", vec3: \"Array(3)\", vec4: \"Array(4)\" };\n   \
     t.exports = { GLKernel: class extends n {\n          static get mode() \
{\n            return \"gpu\";\n          }\n          static \
getIsFloatRead() {\n            const e2 = new this(\"function \
kernelFunction() {\\n      return 1;\\n    }\", { context: this.testContext, \
canvas: this.testCanvas, validate: false, output: [1], precision: \"single\", \
returnType: \"Number\", tactic: \"speed\" });\n            e2.build(), \
e2.run();\n            const t2 = e2.renderOutput();\n            return \
e2.destroy(true), 1 === t2[0];\n          }\n          static \
getIsIntegerDivisionAccurate() {\n            const e2 = new \
this(function(e3, t3) {\n              return e3[this.thread.x] / \
t3[this.thread.x];\n            }.toString(), { context: this.testContext, \
canvas: this.testCanvas, validate: false, output: [2], returnType: \
\"Number\", precision: \"unsigned\", tactic: \"speed\" }), t2 = [[6, \
6030401], [3, 3991]];\n            e2.build.apply(e2, t2), e2.run.apply(e2, \
t2);\n            const r2 = e2.renderOutput();\n            return \
e2.destroy(true), 2 === r2[0] && 1511 === r2[1];\n          }\n          \
static getIsSpeedTacticSupported() {\n            const e2 = new \
this(function(e3) {\n              return e3[this.thread.x];\n            \
}.toString(), { context: this.testContext, canvas: this.testCanvas, validate: \
false, output: [4], returnType: \"Number\", precision: \"unsigned\", tactic: \
\"speed\" }), t2 = [[0, 1, 2, 3]];\n            e2.build.apply(e2, t2), \
e2.run.apply(e2, t2);\n            const r2 = e2.renderOutput();\n            \
return e2.destroy(true), 0 === Math.round(r2[0]) && 1 === Math.round(r2[1]) \
&& 2 === Math.round(r2[2]) && 3 === Math.round(r2[3]);\n          }\n         \
 static get testCanvas() {\n            throw new Error(`\"testCanvas\" not \
defined on ${this.name}`);\n          }\n          static get testContext() \
{\n            throw new Error(`\"testContext\" not defined on \
${this.name}`);\n          }\n          static getFeatures() {\n            \
const e2 = this.testContext, t2 = this.getIsDrawBuffers();\n            \
return Object.freeze({ isFloatRead: this.getIsFloatRead(), \
isIntegerDivisionAccurate: this.getIsIntegerDivisionAccurate(), \
isSpeedTacticSupported: this.getIsSpeedTacticSupported(), isTextureFloat: \
this.getIsTextureFloat(), isDrawBuffers: t2, kernelMap: t2, channelCount: \
this.getChannelCount(), maxTextureSize: this.getMaxTextureSize(), \
lowIntPrecision: e2.getShaderPrecisionFormat(e2.FRAGMENT_SHADER, e2.LOW_INT), \
lowFloatPrecision: e2.getShaderPrecisionFormat(e2.FRAGMENT_SHADER, \
e2.LOW_FLOAT), mediumIntPrecision: \
e2.getShaderPrecisionFormat(e2.FRAGMENT_SHADER, e2.MEDIUM_INT), \
mediumFloatPrecision: e2.getShaderPrecisionFormat(e2.FRAGMENT_SHADER, \
e2.MEDIUM_FLOAT), highIntPrecision: \
e2.getShaderPrecisionFormat(e2.FRAGMENT_SHADER, e2.HIGH_INT), \
highFloatPrecision: e2.getShaderPrecisionFormat(e2.FRAGMENT_SHADER, \
e2.HIGH_FLOAT) });\n          }\n          static setupFeatureChecks() {\n    \
        throw new Error(`\"setupFeatureChecks\" not defined on \
${this.name}`);\n          }\n          static getSignature(e2, t2) {\n       \
     return e2.getVariablePrecisionString() + (t2.length > 0 ? \":\" + \
t2.join(\",\") : \"\");\n          }\n          \
setFixIntegerDivisionAccuracy(e2) {\n            return \
this.fixIntegerDivisionAccuracy = e2, this;\n          }\n          \
setPrecision(e2) {\n            return this.precision = e2, this;\n          \
}\n          setFloatTextures(e2) {\n            return \
i.warnDeprecated(\"method\", \"setFloatTextures\", \
\"setOptimizeFloatMemory\"), this.floatTextures = e2, this;\n          }\n    \
      static nativeFunctionArguments(e2) {\n            const t2 = [], r2 = \
[], n2 = [], i2 = /^[a-zA-Z_]/, s2 = /[a-zA-Z_0-9]/;\n            let a2 = 0, \
o2 = null, u2 = null;\n            for (; a2 < e2.length; ) {\n              \
const l2 = e2[a2], h2 = e2[a2 + 1], c2 = n2.length > 0 ? n2[n2.length - 1] : \
null;\n              if (\"FUNCTION_ARGUMENTS\" !== c2 || \"/\" !== l2 || \
\"*\" !== h2) if (\"MULTI_LINE_COMMENT\" !== c2 || \"*\" !== l2 || \"/\" !== \
h2) if (\"FUNCTION_ARGUMENTS\" !== c2 || \"/\" !== l2 || \"/\" !== h2) if \
(\"COMMENT\" !== c2 || \"\\n\" !== l2) if (null !== c2 || \"(\" !== l2) {\n   \
             if (\"FUNCTION_ARGUMENTS\" === c2) {\n                  if \
(\")\" === l2) {\n                    n2.pop();\n                    break;\n \
                 }\n                  if (\"f\" === l2 && \"l\" === h2 && \
\"o\" === e2[a2 + 2] && \"a\" === e2[a2 + 3] && \"t\" === e2[a2 + 4] && \" \" \
=== e2[a2 + 5]) {\n                    n2.push(\"DECLARE_VARIABLE\"), u2 = \
\"float\", o2 = \"\", a2 += 6;\n                    continue;\n               \
   }\n                  if (\"i\" === l2 && \"n\" === h2 && \"t\" === e2[a2 + \
2] && \" \" === e2[a2 + 3]) {\n                    \
n2.push(\"DECLARE_VARIABLE\"), u2 = \"int\", o2 = \"\", a2 += 4;\n            \
        continue;\n                  }\n                  if (\"v\" === l2 && \
\"e\" === h2 && \"c\" === e2[a2 + 2] && \"2\" === e2[a2 + 3] && \" \" === \
e2[a2 + 4]) {\n                    n2.push(\"DECLARE_VARIABLE\"), u2 = \
\"vec2\", o2 = \"\", a2 += 5;\n                    continue;\n                \
  }\n                  if (\"v\" === l2 && \"e\" === h2 && \"c\" === e2[a2 + \
2] && \"3\" === e2[a2 + 3] && \" \" === e2[a2 + 4]) {\n                    \
n2.push(\"DECLARE_VARIABLE\"), u2 = \"vec3\", o2 = \"\", a2 += 5;\n           \
         continue;\n                  }\n                  if (\"v\" === l2 \
&& \"e\" === h2 && \"c\" === e2[a2 + 2] && \"4\" === e2[a2 + 3] && \" \" === \
e2[a2 + 4]) {\n                    n2.push(\"DECLARE_VARIABLE\"), u2 = \
\"vec4\", o2 = \"\", a2 += 5;\n                    continue;\n                \
  }\n                } else if (\"DECLARE_VARIABLE\" === c2) {\n              \
    if (\"\" === o2) {\n                    if (\" \" === l2) {\n             \
         a2++;\n                      continue;\n                    }\n      \
              if (!i2.test(l2)) throw new Error(\"variable name is not \
expected string\");\n                  }\n                  o2 += l2, \
s2.test(h2) || (n2.pop(), r2.push(o2), t2.push(_[u2]));\n                }\n  \
              a2++;\n              } else n2.push(\"FUNCTION_ARGUMENTS\"), \
a2++;\n              else n2.pop(), a2++;\n              else \
n2.push(\"COMMENT\"), a2 += 2;\n              else n2.pop(), a2 += 2;\n       \
       else n2.push(\"MULTI_LINE_COMMENT\"), a2 += 2;\n            }\n        \
    if (n2.length > 0) throw new Error(\"GLSL function was not parsable\");\n \
           return { argumentNames: r2, argumentTypes: t2 };\n          }\n    \
      static nativeFunctionReturnType(e2) {\n            return \
_[e2.match(/int|float|vec[2-4]/)[0]];\n          }\n          static \
combineKernels(e2, t2) {\n            e2.apply(null, arguments);\n            \
const { texSize: r2, context: n2, threadDim: s2 } = t2.texSize;\n            \
let a2;\n            if (\"single\" === t2.precision) {\n              const \
e3 = r2[0], t3 = Math.ceil(r2[1] / 4);\n              a2 = new \
Float32Array(e3 * t3 * 4 * 4), n2.readPixels(0, 0, e3, 4 * t3, n2.RGBA, \
n2.FLOAT, a2);\n            } else {\n              const e3 = new \
Uint8Array(r2[0] * r2[1] * 4);\n              n2.readPixels(0, 0, r2[0], \
r2[1], n2.RGBA, n2.UNSIGNED_BYTE, e3), a2 = new Float32Array(e3.buffer);\n    \
        }\n            if (a2 = a2.subarray(0, s2[0] * s2[1] * s2[2]), 1 === \
t2.output.length) return a2;\n            if (2 === t2.output.length) return \
i.splitArray(a2, t2.output[0]);\n            if (3 === t2.output.length) {\n  \
            return i.splitArray(a2, t2.output[0] * \
t2.output[1]).map(function(e3) {\n                return i.splitArray(e3, \
t2.output[0]);\n              });\n            }\n          }\n          \
constructor(e2, t2) {\n            super(e2, t2), this.transferValues = null, \
this.formatValues = null, this.TextureConstructor = null, this.renderOutput = \
null, this.renderRawOutput = null, this.texSize = null, this.translatedSource \
= null, this.compiledFragmentShader = null, this.compiledVertexShader = null, \
this.switchingKernels = null, this._textureSwitched = null, \
this._mappedTextureSwitched = null;\n          }\n          \
checkTextureSize() {\n            const { features: e2 } = \
this.constructor;\n            if (this.texSize[0] > e2.maxTextureSize || \
this.texSize[1] > e2.maxTextureSize) throw new Error(`Texture size \
[${this.texSize[0]},${this.texSize[1]}] generated by kernel is larger than \
supported size [${e2.maxTextureSize},${e2.maxTextureSize}]`);\n          }\n  \
        translateSource() {\n            throw new Error(`\"translateSource\" \
not defined on ${this.constructor.name}`);\n          }\n          \
pickRenderStrategy(e2) {\n            if (this.graphical) return \
this.renderRawOutput = this.readPackedPixelsToUint8Array, this.transferValues \
= (e3) => e3, this.TextureConstructor = A, null;\n            if \
(\"unsigned\" === this.precision) if (this.renderRawOutput = \
this.readPackedPixelsToUint8Array, this.transferValues = \
this.readPackedPixelsToFloat32Array, this.pipeline) switch (this.renderOutput \
= this.renderTexture, null !== this.subKernels && (this.renderKernels = \
this.renderKernelsToTextures), this.returnType) {\n              case \
\"LiteralInteger\":\n              case \"Float\":\n              case \
\"Number\":\n              case \"Integer\":\n                return \
this.output[2] > 0 ? (this.TextureConstructor = S, null) : this.output[1] > 0 \
? (this.TextureConstructor = v, null) : (this.TextureConstructor = T, \
null);\n              case \"Array(2)\":\n              case \"Array(3)\":\n  \
            case \"Array(4)\":\n                return \
this.requestFallback(e2);\n            }\n            else switch (null !== \
this.subKernels && (this.renderKernels = this.renderKernelsToArrays), \
this.returnType) {\n              case \"LiteralInteger\":\n              \
case \"Float\":\n              case \"Number\":\n              case \
\"Integer\":\n                return this.renderOutput = this.renderValues, \
this.output[2] > 0 ? (this.TextureConstructor = S, this.formatValues = \
i.erect3DPackedFloat, null) : this.output[1] > 0 ? (this.TextureConstructor = \
v, this.formatValues = i.erect2DPackedFloat, null) : (this.TextureConstructor \
= T, this.formatValues = i.erectPackedFloat, null);\n              case \
\"Array(2)\":\n              case \"Array(3)\":\n              case \
\"Array(4)\":\n                return this.requestFallback(e2);\n            \
}\n            else {\n              if (\"single\" !== this.precision) throw \
new Error(`unhandled precision of \"${this.precision}\"`);\n              if \
(this.renderRawOutput = this.readFloatPixelsToFloat32Array, \
this.transferValues = this.readFloatPixelsToFloat32Array, this.pipeline) \
switch (this.renderOutput = this.renderTexture, null !== this.subKernels && \
(this.renderKernels = this.renderKernelsToTextures), this.returnType) {\n     \
           case \"LiteralInteger\":\n                case \"Float\":\n        \
        case \"Number\":\n                case \"Integer\":\n                 \
 return this.optimizeFloatMemory ? this.output[2] > 0 ? \
(this.TextureConstructor = b, null) : this.output[1] > 0 ? \
(this.TextureConstructor = y, null) : (this.TextureConstructor = x, null) : \
this.output[2] > 0 ? (this.TextureConstructor = g, null) : this.output[1] > 0 \
? (this.TextureConstructor = f, null) : (this.TextureConstructor = m, \
null);\n                case \"Array(2)\":\n                  return \
this.output[2] > 0 ? (this.TextureConstructor = o, null) : this.output[1] > 0 \
? (this.TextureConstructor = a, null) : (this.TextureConstructor = s, \
null);\n                case \"Array(3)\":\n                  return \
this.output[2] > 0 ? (this.TextureConstructor = h, null) : this.output[1] > 0 \
? (this.TextureConstructor = l, null) : (this.TextureConstructor = u, \
null);\n                case \"Array(4)\":\n                  return \
this.output[2] > 0 ? (this.TextureConstructor = d, null) : this.output[1] > 0 \
? (this.TextureConstructor = p, null) : (this.TextureConstructor = c, \
null);\n              }\n              if (this.renderOutput = \
this.renderValues, null !== this.subKernels && (this.renderKernels = \
this.renderKernelsToArrays), this.optimizeFloatMemory) switch \
(this.returnType) {\n                case \"LiteralInteger\":\n               \
 case \"Float\":\n                case \"Number\":\n                case \
\"Integer\":\n                  return this.output[2] > 0 ? \
(this.TextureConstructor = b, this.formatValues = \
i.erectMemoryOptimized3DFloat, null) : this.output[1] > 0 ? \
(this.TextureConstructor = y, this.formatValues = \
i.erectMemoryOptimized2DFloat, null) : (this.TextureConstructor = x, \
this.formatValues = i.erectMemoryOptimizedFloat, null);\n                case \
\"Array(2)\":\n                  return this.output[2] > 0 ? \
(this.TextureConstructor = o, this.formatValues = i.erect3DArray2, null) : \
this.output[1] > 0 ? (this.TextureConstructor = a, this.formatValues = \
i.erect2DArray2, null) : (this.TextureConstructor = s, this.formatValues = \
i.erectArray2, null);\n                case \"Array(3)\":\n                  \
return this.output[2] > 0 ? (this.TextureConstructor = h, this.formatValues = \
i.erect3DArray3, null) : this.output[1] > 0 ? (this.TextureConstructor = l, \
this.formatValues = i.erect2DArray3, null) : (this.TextureConstructor = u, \
this.formatValues = i.erectArray3, null);\n                case \
\"Array(4)\":\n                  return this.output[2] > 0 ? \
(this.TextureConstructor = d, this.formatValues = i.erect3DArray4, null) : \
this.output[1] > 0 ? (this.TextureConstructor = p, this.formatValues = \
i.erect2DArray4, null) : (this.TextureConstructor = c, this.formatValues = \
i.erectArray4, null);\n              }\n              else switch \
(this.returnType) {\n                case \"LiteralInteger\":\n               \
 case \"Float\":\n                case \"Number\":\n                case \
\"Integer\":\n                  return this.output[2] > 0 ? \
(this.TextureConstructor = g, this.formatValues = i.erect3DFloat, null) : \
this.output[1] > 0 ? (this.TextureConstructor = f, this.formatValues = \
i.erect2DFloat, null) : (this.TextureConstructor = m, this.formatValues = \
i.erectFloat, null);\n                case \"Array(2)\":\n                  \
return this.output[2] > 0 ? (this.TextureConstructor = o, this.formatValues = \
i.erect3DArray2, null) : this.output[1] > 0 ? (this.TextureConstructor = a, \
this.formatValues = i.erect2DArray2, null) : (this.TextureConstructor = s, \
this.formatValues = i.erectArray2, null);\n                case \
\"Array(3)\":\n                  return this.output[2] > 0 ? \
(this.TextureConstructor = h, this.formatValues = i.erect3DArray3, null) : \
this.output[1] > 0 ? (this.TextureConstructor = l, this.formatValues = \
i.erect2DArray3, null) : (this.TextureConstructor = u, this.formatValues = \
i.erectArray3, null);\n                case \"Array(4)\":\n                  \
return this.output[2] > 0 ? (this.TextureConstructor = d, this.formatValues = \
i.erect3DArray4, null) : this.output[1] > 0 ? (this.TextureConstructor = p, \
this.formatValues = i.erect2DArray4, null) : (this.TextureConstructor = c, \
this.formatValues = i.erectArray4, null);\n              }\n            }\n   \
         throw new Error(`unhandled return type \"${this.returnType}\"`);\n   \
       }\n          getKernelString() {\n            throw new \
Error(\"abstract method call\");\n          }\n          \
getMainResultTexture() {\n            switch (this.returnType) {\n            \
  case \"LiteralInteger\":\n              case \"Float\":\n              case \
\"Integer\":\n              case \"Number\":\n                return \
this.getMainResultNumberTexture();\n              case \"Array(2)\":\n        \
        return this.getMainResultArray2Texture();\n              case \
\"Array(3)\":\n                return this.getMainResultArray3Texture();\n    \
          case \"Array(4)\":\n                return \
this.getMainResultArray4Texture();\n              default:\n                \
throw new Error(`unhandled returnType type ${this.returnType}`);\n            \
}\n          }\n          getMainResultKernelNumberTexture() {\n            \
throw new Error(\"abstract method call\");\n          }\n          \
getMainResultSubKernelNumberTexture() {\n            throw new \
Error(\"abstract method call\");\n          }\n          \
getMainResultKernelArray2Texture() {\n            throw new Error(\"abstract \
method call\");\n          }\n          getMainResultSubKernelArray2Texture() \
{\n            throw new Error(\"abstract method call\");\n          }\n      \
    getMainResultKernelArray3Texture() {\n            throw new \
Error(\"abstract method call\");\n          }\n          \
getMainResultSubKernelArray3Texture() {\n            throw new \
Error(\"abstract method call\");\n          }\n          \
getMainResultKernelArray4Texture() {\n            throw new Error(\"abstract \
method call\");\n          }\n          getMainResultSubKernelArray4Texture() \
{\n            throw new Error(\"abstract method call\");\n          }\n      \
    getMainResultGraphical() {\n            throw new Error(\"abstract method \
call\");\n          }\n          getMainResultMemoryOptimizedFloats() {\n     \
       throw new Error(\"abstract method call\");\n          }\n          \
getMainResultPackedPixels() {\n            throw new Error(\"abstract method \
call\");\n          }\n          getMainResultString() {\n            return \
this.graphical ? this.getMainResultGraphical() : \"single\" === \
this.precision ? this.optimizeFloatMemory ? \
this.getMainResultMemoryOptimizedFloats() : this.getMainResultTexture() : \
this.getMainResultPackedPixels();\n          }\n          \
getMainResultNumberTexture() {\n            return \
i.linesToString(this.getMainResultKernelNumberTexture()) + \
i.linesToString(this.getMainResultSubKernelNumberTexture());\n          }\n   \
       getMainResultArray2Texture() {\n            return \
i.linesToString(this.getMainResultKernelArray2Texture()) + \
i.linesToString(this.getMainResultSubKernelArray2Texture());\n          }\n   \
       getMainResultArray3Texture() {\n            return \
i.linesToString(this.getMainResultKernelArray3Texture()) + \
i.linesToString(this.getMainResultSubKernelArray3Texture());\n          }\n   \
       getMainResultArray4Texture() {\n            return \
i.linesToString(this.getMainResultKernelArray4Texture()) + \
i.linesToString(this.getMainResultSubKernelArray4Texture());\n          }\n   \
       getFloatTacticDeclaration() {\n            return `precision \
${this.getVariablePrecisionString(this.texSize, this.tactic)} float;\n`;\n    \
      }\n          getIntTacticDeclaration() {\n            return `precision \
${this.getVariablePrecisionString(this.texSize, this.tactic, true)} \
int;\n`;\n          }\n          getSampler2DTacticDeclaration() {\n          \
  return `precision ${this.getVariablePrecisionString(this.texSize, \
this.tactic)} sampler2D;\n`;\n          }\n          \
getSampler2DArrayTacticDeclaration() {\n            return `precision \
${this.getVariablePrecisionString(this.texSize, this.tactic)} \
sampler2DArray;\n`;\n          }\n          renderTexture() {\n            \
return this.immutable ? this.texture.clone() : this.texture;\n          }\n   \
       readPackedPixelsToUint8Array() {\n            if (\"unsigned\" !== \
this.precision) throw new Error('Requires this.precision to be \
\"unsigned\"');\n            const { texSize: e2, context: t2 } = this, r2 = \
new Uint8Array(e2[0] * e2[1] * 4);\n            return t2.readPixels(0, 0, \
e2[0], e2[1], t2.RGBA, t2.UNSIGNED_BYTE, r2), r2;\n          }\n          \
readPackedPixelsToFloat32Array() {\n            return new \
Float32Array(this.readPackedPixelsToUint8Array().buffer);\n          }\n      \
    readFloatPixelsToFloat32Array() {\n            if (\"single\" !== \
this.precision) throw new Error('Requires this.precision to be \
\"single\"');\n            const { texSize: e2, context: t2 } = this, r2 = \
e2[0], n2 = e2[1], i2 = new Float32Array(r2 * n2 * 4);\n            return \
t2.readPixels(0, 0, r2, n2, t2.RGBA, t2.FLOAT, i2), i2;\n          }\n        \
  getPixels(e2) {\n            const { context: t2, output: r2 } = this, [n2, \
s2] = r2, a2 = new Uint8Array(n2 * s2 * 4);\n            return \
t2.readPixels(0, 0, n2, s2, t2.RGBA, t2.UNSIGNED_BYTE, a2), new \
Uint8ClampedArray((e2 ? a2 : i.flipPixels(a2, n2, s2)).buffer);\n          \
}\n          renderKernelsToArrays() {\n            const e2 = { result: \
this.renderOutput() };\n            for (let t2 = 0; t2 < \
this.subKernels.length; t2++) e2[this.subKernels[t2].property] = \
this.mappedTextures[t2].toArray();\n            return e2;\n          }\n     \
     renderKernelsToTextures() {\n            const e2 = { result: \
this.renderOutput() };\n            if (this.immutable) for (let t2 = 0; t2 < \
this.subKernels.length; t2++) e2[this.subKernels[t2].property] = \
this.mappedTextures[t2].clone();\n            else for (let t2 = 0; t2 < \
this.subKernels.length; t2++) e2[this.subKernels[t2].property] = \
this.mappedTextures[t2];\n            return e2;\n          }\n          \
resetSwitchingKernels() {\n            const e2 = this.switchingKernels;\n    \
        return this.switchingKernels = null, e2;\n          }\n          \
setOutput(e2) {\n            const t2 = this.toKernelOutput(e2);\n            \
if (this.program) {\n              if (!this.dynamicOutput) throw new \
Error(\"Resizing a kernel with dynamicOutput: false is not possible\");\n     \
         const r2 = [t2[0], t2[1] || 1, t2[2] || 1], n2 = \
i.getKernelTextureSize({ optimizeFloatMemory: this.optimizeFloatMemory, \
precision: this.precision }, r2), s2 = this.texSize;\n              if (s2) \
{\n                const t3 = this.getVariablePrecisionString(s2, \
this.tactic), r3 = this.getVariablePrecisionString(n2, this.tactic);\n        \
        if (t3 !== r3) return this.debug && console.warn(\"Precision \
requirement changed, asking GPU instance to recompile\"), void \
this.switchKernels({ type: \"outputPrecisionMismatch\", precision: r3, \
needed: e2 });\n              }\n              this.output = t2, \
this.threadDim = r2, this.texSize = n2;\n              const { context: a2 } \
= this;\n              if (a2.bindFramebuffer(a2.FRAMEBUFFER, \
this.framebuffer), this.updateMaxTexSize(), this.framebuffer.width = \
this.texSize[0], this.framebuffer.height = this.texSize[1], a2.viewport(0, 0, \
this.maxTexSize[0], this.maxTexSize[1]), this.canvas.width = \
this.maxTexSize[0], this.canvas.height = this.maxTexSize[1], this.texture && \
this.texture.delete(), this.texture = null, this._setupOutputTexture(), \
this.mappedTextures && this.mappedTextures.length > 0) {\n                for \
(let e3 = 0; e3 < this.mappedTextures.length; e3++) \
this.mappedTextures[e3].delete();\n                this.mappedTextures = \
null, this._setupSubOutputTextures();\n              }\n            } else \
this.output = t2;\n            return this;\n          }\n          \
renderValues() {\n            return this.formatValues(this.transferValues(), \
this.output[0], this.output[1], this.output[2]);\n          }\n          \
switchKernels(e2) {\n            this.switchingKernels ? \
this.switchingKernels.push(e2) : this.switchingKernels = [e2];\n          }\n \
         getVariablePrecisionString(e2 = this.texSize, t2 = this.tactic, r2 = \
false) {\n            if (!t2) {\n              if \
(!this.constructor.features.isSpeedTacticSupported) return \"highp\";\n       \
       const t3 = this.constructor.features[r2 ? \"lowIntPrecision\" : \
\"lowFloatPrecision\"], n2 = this.constructor.features[r2 ? \
\"mediumIntPrecision\" : \"mediumFloatPrecision\"], i2 = \
this.constructor.features[r2 ? \"highIntPrecision\" : \
\"highFloatPrecision\"], s2 = Math.log2(e2[0] * e2[1]);\n              if (s2 \
<= t3.rangeMax) return \"lowp\";\n              if (s2 <= n2.rangeMax) return \
\"mediump\";\n              if (s2 <= i2.rangeMax) return \"highp\";\n        \
      throw new Error(\"The required size exceeds that of the ability of your \
system\");\n            }\n            switch (t2) {\n              case \
\"speed\":\n                return \"lowp\";\n              case \
\"balanced\":\n                return \"mediump\";\n              case \
\"precision\":\n                return \"highp\";\n              default:\n   \
             throw new Error(`Unknown tactic \"${t2}\" use \"speed\", \
\"balanced\", \"precision\", or empty for auto`);\n            }\n          \
}\n          updateTextureArgumentRefs(e2, t2) {\n            if \
(this.immutable) {\n              if (this.texture.texture === t2.texture) \
{\n                const { prevArg: r2 } = e2;\n                r2 && (1 === \
r2.texture._refs && (this.texture.delete(), this.texture = r2.clone(), \
this._textureSwitched = true), r2.delete()), e2.prevArg = t2.clone();\n       \
       } else if (this.mappedTextures && this.mappedTextures.length > 0) {\n  \
              const { mappedTextures: r2 } = this;\n                for (let \
n2 = 0; n2 < r2.length; n2++) {\n                  const i2 = r2[n2];\n       \
           if (i2.texture === t2.texture) {\n                    const { \
prevArg: s2 } = e2;\n                    return s2 && (1 === s2.texture._refs \
&& (i2.delete(), r2[n2] = s2.clone(), this._mappedTextureSwitched[n2] = \
true), s2.delete()), void (e2.prevArg = t2.clone());\n                  }\n   \
             }\n              }\n            }\n          }\n          \
onActivate(e2) {\n            if (this._textureSwitched = true, this.texture \
= e2.texture, this.mappedTextures) {\n              for (let e3 = 0; e3 < \
this.mappedTextures.length; e3++) this._mappedTextureSwitched[e3] = true;\n   \
           this.mappedTextures = e2.mappedTextures;\n            }\n          \
}\n          initCanvas() {\n          }\n        } };\n      }, { \
\"../../utils\": 114, \"../kernel\": 36, \"./texture/array-2-float\": 16, \
\"./texture/array-2-float-2d\": 14, \"./texture/array-2-float-3d\": 15, \
\"./texture/array-3-float\": 19, \"./texture/array-3-float-2d\": 17, \
\"./texture/array-3-float-3d\": 18, \"./texture/array-4-float\": 22, \
\"./texture/array-4-float-2d\": 20, \"./texture/array-4-float-3d\": 21, \
\"./texture/float\": 25, \"./texture/float-2d\": 23, \"./texture/float-3d\": \
24, \"./texture/graphical\": 26, \"./texture/memory-optimized\": 30, \
\"./texture/memory-optimized-2d\": 28, \"./texture/memory-optimized-3d\": 29, \
\"./texture/unsigned\": 33, \"./texture/unsigned-2d\": 31, \
\"./texture/unsigned-3d\": 32 }], 14: [function(e, t, r) {\n        const { \
utils: n } = e(\"../../../utils\"), { GLTextureFloat: i } = e(\"./float\");\n \
       t.exports = { GLTextureArray2Float2D: class extends i {\n          \
constructor(e2) {\n            super(e2), this.type = \"ArrayTexture(2)\";\n  \
        }\n          toArray() {\n            return \
n.erect2DArray2(this.renderValues(), this.output[0], this.output[1]);\n       \
   }\n        } };\n      }, { \"../../../utils\": 114, \"./float\": 25 }], \
15: [function(e, t, r) {\n        const { utils: n } = e(\"../../../utils\"), \
{ GLTextureFloat: i } = e(\"./float\");\n        t.exports = { \
GLTextureArray2Float3D: class extends i {\n          constructor(e2) {\n      \
      super(e2), this.type = \"ArrayTexture(2)\";\n          }\n          \
toArray() {\n            return n.erect3DArray2(this.renderValues(), \
this.output[0], this.output[1], this.output[2]);\n          }\n        } };\n \
     }, { \"../../../utils\": 114, \"./float\": 25 }], 16: [function(e, t, r) \
{\n        const { utils: n } = e(\"../../../utils\"), { GLTextureFloat: i } \
= e(\"./float\");\n        t.exports = { GLTextureArray2Float: class extends \
i {\n          constructor(e2) {\n            super(e2), this.type = \
\"ArrayTexture(2)\";\n          }\n          toArray() {\n            return \
n.erectArray2(this.renderValues(), this.output[0], this.output[1]);\n         \
 }\n        } };\n      }, { \"../../../utils\": 114, \"./float\": 25 }], 17: \
[function(e, t, r) {\n        const { utils: n } = e(\"../../../utils\"), { \
GLTextureFloat: i } = e(\"./float\");\n        t.exports = { \
GLTextureArray3Float2D: class extends i {\n          constructor(e2) {\n      \
      super(e2), this.type = \"ArrayTexture(3)\";\n          }\n          \
toArray() {\n            return n.erect2DArray3(this.renderValues(), \
this.output[0], this.output[1]);\n          }\n        } };\n      }, { \
\"../../../utils\": 114, \"./float\": 25 }], 18: [function(e, t, r) {\n       \
 const { utils: n } = e(\"../../../utils\"), { GLTextureFloat: i } = \
e(\"./float\");\n        t.exports = { GLTextureArray3Float3D: class extends \
i {\n          constructor(e2) {\n            super(e2), this.type = \
\"ArrayTexture(3)\";\n          }\n          toArray() {\n            return \
n.erect3DArray3(this.renderValues(), this.output[0], this.output[1], \
this.output[2]);\n          }\n        } };\n      }, { \"../../../utils\": \
114, \"./float\": 25 }], 19: [function(e, t, r) {\n        const { utils: n } \
= e(\"../../../utils\"), { GLTextureFloat: i } = e(\"./float\");\n        \
t.exports = { GLTextureArray3Float: class extends i {\n          \
constructor(e2) {\n            super(e2), this.type = \"ArrayTexture(3)\";\n  \
        }\n          toArray() {\n            return \
n.erectArray3(this.renderValues(), this.output[0]);\n          }\n        } \
};\n      }, { \"../../../utils\": 114, \"./float\": 25 }], 20: [function(e, \
t, r) {\n        const { utils: n } = e(\"../../../utils\"), { \
GLTextureFloat: i } = e(\"./float\");\n        t.exports = { \
GLTextureArray4Float2D: class extends i {\n          constructor(e2) {\n      \
      super(e2), this.type = \"ArrayTexture(4)\";\n          }\n          \
toArray() {\n            return n.erect2DArray4(this.renderValues(), \
this.output[0], this.output[1]);\n          }\n        } };\n      }, { \
\"../../../utils\": 114, \"./float\": 25 }], 21: [function(e, t, r) {\n       \
 const { utils: n } = e(\"../../../utils\"), { GLTextureFloat: i } = \
e(\"./float\");\n        t.exports = { GLTextureArray4Float3D: class extends \
i {\n          constructor(e2) {\n            super(e2), this.type = \
\"ArrayTexture(4)\";\n          }\n          toArray() {\n            return \
n.erect3DArray4(this.renderValues(), this.output[0], this.output[1], \
this.output[2]);\n          }\n        } };\n      }, { \"../../../utils\": \
114, \"./float\": 25 }], 22: [function(e, t, r) {\n        const { utils: n } \
= e(\"../../../utils\"), { GLTextureFloat: i } = e(\"./float\");\n        \
t.exports = { GLTextureArray4Float: class extends i {\n          \
constructor(e2) {\n            super(e2), this.type = \"ArrayTexture(4)\";\n  \
        }\n          toArray() {\n            return \
n.erectArray4(this.renderValues(), this.output[0]);\n          }\n        } \
};\n      }, { \"../../../utils\": 114, \"./float\": 25 }], 23: [function(e, \
t, r) {\n        const { utils: n } = e(\"../../../utils\"), { \
GLTextureFloat: i } = e(\"./float\");\n        t.exports = { \
GLTextureFloat2D: class extends i {\n          constructor(e2) {\n            \
super(e2), this.type = \"ArrayTexture(1)\";\n          }\n          toArray() \
{\n            return n.erect2DFloat(this.renderValues(), this.output[0], \
this.output[1]);\n          }\n        } };\n      }, { \"../../../utils\": \
114, \"./float\": 25 }], 24: [function(e, t, r) {\n        const { utils: n } \
= e(\"../../../utils\"), { GLTextureFloat: i } = e(\"./float\");\n        \
t.exports = { GLTextureFloat3D: class extends i {\n          constructor(e2) \
{\n            super(e2), this.type = \"ArrayTexture(1)\";\n          }\n     \
     toArray() {\n            return n.erect3DFloat(this.renderValues(), \
this.output[0], this.output[1], this.output[2]);\n          }\n        } };\n \
     }, { \"../../../utils\": 114, \"./float\": 25 }], 25: [function(e, t, r) \
{\n        const { utils: n } = e(\"../../../utils\"), { GLTexture: i } = \
e(\"./index\");\n        t.exports = { GLTextureFloat: class extends i {\n    \
      get textureType() {\n            return this.context.FLOAT;\n          \
}\n          constructor(e2) {\n            super(e2), this.type = \
\"ArrayTexture(1)\";\n          }\n          renderRawOutput() {\n            \
const e2 = this.context, t2 = this.size;\n            \
e2.bindFramebuffer(e2.FRAMEBUFFER, this.framebuffer()), \
e2.framebufferTexture2D(e2.FRAMEBUFFER, e2.COLOR_ATTACHMENT0, e2.TEXTURE_2D, \
this.texture, 0);\n            const r2 = new Float32Array(t2[0] * t2[1] * \
4);\n            return e2.readPixels(0, 0, t2[0], t2[1], e2.RGBA, e2.FLOAT, \
r2), r2;\n          }\n          renderValues() {\n            return \
this._deleted ? null : this.renderRawOutput();\n          }\n          \
toArray() {\n            return n.erectFloat(this.renderValues(), \
this.output[0]);\n          }\n        } };\n      }, { \"../../../utils\": \
114, \"./index\": 27 }], 26: [function(e, t, r) {\n        const { \
GLTextureUnsigned: n } = e(\"./unsigned\");\n        t.exports = { \
GLTextureGraphical: class extends n {\n          constructor(e2) {\n          \
  super(e2), this.type = \"ArrayTexture(4)\";\n          }\n          \
toArray() {\n            return this.renderValues();\n          }\n        } \
};\n      }, { \"./unsigned\": 33 }], 27: [function(e, t, r) {\n        const \
{ Texture: n } = e(\"../../../texture\");\n        function i(e2, t2) {\n     \
     e2.activeTexture(e2.TEXTURE15), e2.bindTexture(e2.TEXTURE_2D, t2), \
e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_S, e2.CLAMP_TO_EDGE), \
e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_T, e2.CLAMP_TO_EDGE), \
e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MIN_FILTER, e2.NEAREST), \
e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MAG_FILTER, e2.NEAREST);\n        \
}\n        t.exports = { GLTexture: class extends n {\n          get \
textureType() {\n            throw new Error(`\"textureType\" not implemented \
on ${this.name}`);\n          }\n          clone() {\n            return new \
this.constructor(this);\n          }\n          beforeMutate() {\n            \
return this.texture._refs > 1 && (this.newTexture(), true);\n          }\n    \
      cloneTexture() {\n            this.texture._refs--;\n            const \
{ context: e2, size: t2, texture: r2, kernel: n2 } = this;\n            \
n2.debug && console.warn(\"cloning internal texture\"), \
e2.bindFramebuffer(e2.FRAMEBUFFER, this.framebuffer()), i(e2, r2), \
e2.framebufferTexture2D(e2.FRAMEBUFFER, e2.COLOR_ATTACHMENT0, e2.TEXTURE_2D, \
r2, 0);\n            const s = e2.createTexture();\n            i(e2, s), \
e2.texImage2D(e2.TEXTURE_2D, 0, this.internalFormat, t2[0], t2[1], 0, \
this.textureFormat, this.textureType, null), \
e2.copyTexSubImage2D(e2.TEXTURE_2D, 0, 0, 0, 0, 0, t2[0], t2[1]), s._refs = \
1, this.texture = s;\n          }\n          newTexture() {\n            \
this.texture._refs--;\n            const e2 = this.context, t2 = this.size;\n \
           this.kernel.debug && console.warn(\"new internal texture\");\n     \
       const r2 = e2.createTexture();\n            i(e2, r2), \
e2.texImage2D(e2.TEXTURE_2D, 0, this.internalFormat, t2[0], t2[1], 0, \
this.textureFormat, this.textureType, null), r2._refs = 1, this.texture = \
r2;\n          }\n          clear() {\n            if (this.texture._refs) \
{\n              this.texture._refs--;\n              const e3 = \
this.context, t3 = this.texture = e3.createTexture();\n              i(e3, \
t3);\n              const r2 = this.size;\n              t3._refs = 1, \
e3.texImage2D(e3.TEXTURE_2D, 0, this.internalFormat, r2[0], r2[1], 0, \
this.textureFormat, this.textureType, null);\n            }\n            \
const { context: e2, texture: t2 } = this;\n            \
e2.bindFramebuffer(e2.FRAMEBUFFER, this.framebuffer()), \
e2.bindTexture(e2.TEXTURE_2D, t2), i(e2, t2), \
e2.framebufferTexture2D(e2.FRAMEBUFFER, e2.COLOR_ATTACHMENT0, e2.TEXTURE_2D, \
t2, 0), e2.clearColor(0, 0, 0, 0), e2.clear(e2.COLOR_BUFFER_BIT | \
e2.DEPTH_BUFFER_BIT);\n          }\n          delete() {\n            \
this._deleted || (this._deleted = true, this.texture._refs && \
(this.texture._refs--, this.texture._refs) || \
this.context.deleteTexture(this.texture));\n          }\n          \
framebuffer() {\n            return this._framebuffer || (this._framebuffer = \
this.kernel.getRawValueFramebuffer(this.size[0], this.size[1])), \
this._framebuffer;\n          }\n        } };\n      }, { \
\"../../../texture\": 113 }], 28: [function(e, t, r) {\n        const { \
utils: n } = e(\"../../../utils\"), { GLTextureFloat: i } = e(\"./float\");\n \
       t.exports = { GLTextureMemoryOptimized2D: class extends i {\n          \
constructor(e2) {\n            super(e2), this.type = \
\"MemoryOptimizedNumberTexture\";\n          }\n          toArray() {\n       \
     return n.erectMemoryOptimized2DFloat(this.renderValues(), \
this.output[0], this.output[1]);\n          }\n        } };\n      }, { \
\"../../../utils\": 114, \"./float\": 25 }], 29: [function(e, t, r) {\n       \
 const { utils: n } = e(\"../../../utils\"), { GLTextureFloat: i } = \
e(\"./float\");\n        t.exports = { GLTextureMemoryOptimized3D: class \
extends i {\n          constructor(e2) {\n            super(e2), this.type = \
\"MemoryOptimizedNumberTexture\";\n          }\n          toArray() {\n       \
     return n.erectMemoryOptimized3DFloat(this.renderValues(), \
this.output[0], this.output[1], this.output[2]);\n          }\n        } };\n \
     }, { \"../../../utils\": 114, \"./float\": 25 }], 30: [function(e, t, r) \
{\n        const { utils: n } = e(\"../../../utils\"), { GLTextureFloat: i } \
= e(\"./float\");\n        t.exports = { GLTextureMemoryOptimized: class \
extends i {\n          constructor(e2) {\n            super(e2), this.type = \
\"MemoryOptimizedNumberTexture\";\n          }\n          toArray() {\n       \
     return n.erectMemoryOptimizedFloat(this.renderValues(), \
this.output[0]);\n          }\n        } };\n      }, { \"../../../utils\": \
114, \"./float\": 25 }], 31: [function(e, t, r) {\n        const { utils: n } \
= e(\"../../../utils\"), { GLTextureUnsigned: i } = e(\"./unsigned\");\n      \
  t.exports = { GLTextureUnsigned2D: class extends i {\n          \
constructor(e2) {\n            super(e2), this.type = \"NumberTexture\";\n    \
      }\n          toArray() {\n            return \
n.erect2DPackedFloat(this.renderValues(), this.output[0], this.output[1]);\n  \
        }\n        } };\n      }, { \"../../../utils\": 114, \"./unsigned\": \
33 }], 32: [function(e, t, r) {\n        const { utils: n } = \
e(\"../../../utils\"), { GLTextureUnsigned: i } = e(\"./unsigned\");\n        \
t.exports = { GLTextureUnsigned3D: class extends i {\n          \
constructor(e2) {\n            super(e2), this.type = \"NumberTexture\";\n    \
      }\n          toArray() {\n            return \
n.erect3DPackedFloat(this.renderValues(), this.output[0], this.output[1], \
this.output[2]);\n          }\n        } };\n      }, { \"../../../utils\": \
114, \"./unsigned\": 33 }], 33: [function(e, t, r) {\n        const { utils: \
n } = e(\"../../../utils\"), { GLTexture: i } = e(\"./index\");\n        \
t.exports = { GLTextureUnsigned: class extends i {\n          get \
textureType() {\n            return this.context.UNSIGNED_BYTE;\n          \
}\n          constructor(e2) {\n            super(e2), this.type = \
\"NumberTexture\";\n          }\n          renderRawOutput() {\n            \
const { context: e2 } = this;\n            e2.bindFramebuffer(e2.FRAMEBUFFER, \
this.framebuffer()), e2.framebufferTexture2D(e2.FRAMEBUFFER, \
e2.COLOR_ATTACHMENT0, e2.TEXTURE_2D, this.texture, 0);\n            const t2 \
= new Uint8Array(this.size[0] * this.size[1] * 4);\n            return \
e2.readPixels(0, 0, this.size[0], this.size[1], e2.RGBA, e2.UNSIGNED_BYTE, \
t2), t2;\n          }\n          renderValues() {\n            return \
this._deleted ? null : new Float32Array(this.renderRawOutput().buffer);\n     \
     }\n          toArray() {\n            return \
n.erectPackedFloat(this.renderValues(), this.output[0]);\n          }\n       \
 } };\n      }, { \"../../../utils\": 114, \"./index\": 27 }], 34: \
[function(e, t, r) {\n        const n = e(\"gl\"), { WebGLKernel: i } = \
e(\"../web-gl/kernel\"), { glKernelString: s } = \
e(\"../gl/kernel-string\");\n        let a = null, o = null, u = null, l = \
null, h = null;\n        t.exports = { HeadlessGLKernel: class extends i {\n  \
        static get isSupported() {\n            return null !== a || \
(this.setupFeatureChecks(), a = null !== u), a;\n          }\n          \
static setupFeatureChecks() {\n            if (o = null, l = null, \
\"function\" == typeof n) try {\n              if (u = n(2, 2, { \
preserveDrawingBuffer: true }), !u || !u.getExtension) return;\n              \
l = { STACKGL_resize_drawingbuffer: \
u.getExtension(\"STACKGL_resize_drawingbuffer\"), STACKGL_destroy_context: \
u.getExtension(\"STACKGL_destroy_context\"), OES_texture_float: \
u.getExtension(\"OES_texture_float\"), OES_texture_float_linear: \
u.getExtension(\"OES_texture_float_linear\"), OES_element_index_uint: \
u.getExtension(\"OES_element_index_uint\"), WEBGL_draw_buffers: \
u.getExtension(\"WEBGL_draw_buffers\"), WEBGL_color_buffer_float: \
u.getExtension(\"WEBGL_color_buffer_float\") }, h = this.getFeatures();\n     \
       } catch (e2) {\n              console.warn(e2);\n            }\n       \
   }\n          static isContextMatch(e2) {\n            try {\n              \
return \"ANGLE\" === e2.getParameter(e2.RENDERER);\n            } catch (e3) \
{\n              return false;\n            }\n          }\n          static \
getIsTextureFloat() {\n            return Boolean(l.OES_texture_float);\n     \
     }\n          static getIsDrawBuffers() {\n            return \
Boolean(l.WEBGL_draw_buffers);\n          }\n          static \
getChannelCount() {\n            return l.WEBGL_draw_buffers ? \
u.getParameter(l.WEBGL_draw_buffers.MAX_DRAW_BUFFERS_WEBGL) : 1;\n          \
}\n          static getMaxTextureSize() {\n            return \
u.getParameter(u.MAX_TEXTURE_SIZE);\n          }\n          static get \
testCanvas() {\n            return o;\n          }\n          static get \
testContext() {\n            return u;\n          }\n          static get \
features() {\n            return h;\n          }\n          initCanvas() {\n  \
          return {};\n          }\n          initContext() {\n            \
return n(2, 2, { preserveDrawingBuffer: true });\n          }\n          \
initExtensions() {\n            this.extensions = { \
STACKGL_resize_drawingbuffer: \
this.context.getExtension(\"STACKGL_resize_drawingbuffer\"), \
STACKGL_destroy_context: \
this.context.getExtension(\"STACKGL_destroy_context\"), OES_texture_float: \
this.context.getExtension(\"OES_texture_float\"), OES_texture_float_linear: \
this.context.getExtension(\"OES_texture_float_linear\"), \
OES_element_index_uint: \
this.context.getExtension(\"OES_element_index_uint\"), WEBGL_draw_buffers: \
this.context.getExtension(\"WEBGL_draw_buffers\") };\n          }\n          \
build() {\n            super.build.apply(this, arguments), \
this.fallbackRequested || \
this.extensions.STACKGL_resize_drawingbuffer.resize(this.maxTexSize[0], \
this.maxTexSize[1]);\n          }\n          destroyExtensions() {\n          \
  this.extensions.STACKGL_resize_drawingbuffer = null, \
this.extensions.STACKGL_destroy_context = null, \
this.extensions.OES_texture_float = null, \
this.extensions.OES_texture_float_linear = null, \
this.extensions.OES_element_index_uint = null, \
this.extensions.WEBGL_draw_buffers = null;\n          }\n          static \
destroyContext(e2) {\n            const t2 = \
e2.getExtension(\"STACKGL_destroy_context\");\n            t2 && t2.destroy \
&& t2.destroy();\n          }\n          toString() {\n            return \
s(this.constructor, arguments, this, \"const gl = context || require('gl')(1, \
1);\\n\", \"    if (!context) { \
gl.getExtension('STACKGL_destroy_context').destroy(); }\\n\");\n          }\n \
         setOutput(e2) {\n            return super.setOutput(e2), \
this.graphical && this.extensions.STACKGL_resize_drawingbuffer && \
this.extensions.STACKGL_resize_drawingbuffer.resize(this.maxTexSize[0], \
this.maxTexSize[1]), this;\n          }\n        } };\n      }, { \
\"../gl/kernel-string\": 12, \"../web-gl/kernel\": 70, gl: 2 }], 35: \
[function(e, t, r) {\n        t.exports = { KernelValue: class {\n          \
constructor(e2, t2) {\n            const { name: r2, kernel: n, context: i, \
checkContext: s, onRequestContextHandle: a, onUpdateValueMismatch: o, origin: \
u, strictIntegers: l, type: h, tactic: c } = t2;\n            if (!r2) throw \
new Error(\"name not set\");\n            if (!h) throw new Error(\"type not \
set\");\n            if (!u) throw new Error(\"origin not set\");\n           \
 if (\"user\" !== u && \"constants\" !== u) throw new Error(`origin must be \
\"user\" or \"constants\" value is \"${u}\"`);\n            if (!a) throw new \
Error(\"onRequestContextHandle is not set\");\n            this.name = r2, \
this.origin = u, this.tactic = c, this.varName = \"constants\" === u ? \
`constants.${r2}` : r2, this.kernel = n, this.strictIntegers = l, this.type = \
e2.type || h, this.size = e2.size || null, this.index = null, this.context = \
i, this.checkContext = null == s || s, this.contextHandle = null, \
this.onRequestContextHandle = a, this.onUpdateValueMismatch = o, \
this.forceUploadEachRun = null;\n          }\n          get id() {\n          \
  return `${this.origin}_${name}`;\n          }\n          getSource() {\n    \
        throw new Error(`\"getSource\" not defined on \
${this.constructor.name}`);\n          }\n          updateValue(e2) {\n       \
     throw new Error(`\"updateValue\" not defined on \
${this.constructor.name}`);\n          }\n        } };\n      }, {}], 36: \
[function(e, t, r) {\n        const { utils: n } = e(\"../utils\"), { Input: \
i } = e(\"../input\");\n        t.exports = { Kernel: class {\n          \
static get isSupported() {\n            throw new Error(`\"isSupported\" not \
implemented on ${this.name}`);\n          }\n          static \
isContextMatch(e2) {\n            throw new Error(`\"isContextMatch\" not \
implemented on ${this.name}`);\n          }\n          static getFeatures() \
{\n            throw new Error(`\"getFeatures\" not implemented on \
${this.name}`);\n          }\n          static destroyContext(e2) {\n         \
   throw new Error(`\"destroyContext\" called on ${this.name}`);\n          \
}\n          static nativeFunctionArguments() {\n            throw new \
Error(`\"nativeFunctionArguments\" called on ${this.name}`);\n          }\n   \
       static nativeFunctionReturnType() {\n            throw new \
Error(`\"nativeFunctionReturnType\" called on ${this.name}`);\n          }\n  \
        static combineKernels() {\n            throw new \
Error(`\"combineKernels\" called on ${this.name}`);\n          }\n          \
constructor(e2, t2) {\n            if (\"object\" != typeof e2) {\n           \
   if (\"string\" != typeof e2) throw new Error(\"source not a string\");\n   \
           if (!n.isFunctionString(e2)) throw new Error(\"source not a \
function string\");\n            }\n            this.useLegacyEncoder = \
false, this.fallbackRequested = false, this.onRequestFallback = null, \
this.argumentNames = \"string\" == typeof e2 ? \
n.getArgumentNamesFromString(e2) : null, this.argumentTypes = null, \
this.argumentSizes = null, this.argumentBitRatios = null, \
this.kernelArguments = null, this.kernelConstants = null, \
this.forceUploadKernelConstants = null, this.source = e2, this.output = null, \
this.debug = false, this.graphical = false, this.loopMaxIterations = 0, \
this.constants = null, this.constantTypes = null, this.constantBitRatios = \
null, this.dynamicArguments = false, this.dynamicOutput = false, this.canvas \
= null, this.context = null, this.checkContext = null, this.gpu = null, \
this.functions = null, this.nativeFunctions = null, this.injectedNative = \
null, this.subKernels = null, this.validate = true, this.immutable = false, \
this.pipeline = false, this.precision = null, this.tactic = null, \
this.plugins = null, this.returnType = null, this.leadingReturnStatement = \
null, this.followingReturnStatement = null, this.optimizeFloatMemory = null, \
this.strictIntegers = false, this.fixIntegerDivisionAccuracy = null, \
this.built = false, this.signature = null;\n          }\n          \
mergeSettings(e2) {\n            for (let t2 in e2) if (e2.hasOwnProperty(t2) \
&& this.hasOwnProperty(t2)) {\n              switch (t2) {\n                \
case \"output\":\n                  if (!Array.isArray(e2.output)) {\n        \
            this.setOutput(e2.output);\n                    continue;\n       \
           }\n                  break;\n                case \"functions\":\n \
                 this.functions = [];\n                  for (let t3 = 0; t3 \
< e2.functions.length; t3++) this.addFunction(e2.functions[t3]);\n            \
      continue;\n                case \"graphical\":\n                  \
e2[t2] && !e2.hasOwnProperty(\"precision\") && (this.precision = \
\"unsigned\"), this[t2] = e2[t2];\n                  continue;\n              \
  case \"nativeFunctions\":\n                  if (!e2.nativeFunctions) \
continue;\n                  this.nativeFunctions = [];\n                  \
for (let t3 = 0; t3 < e2.nativeFunctions.length; t3++) {\n                    \
const r2 = e2.nativeFunctions[t3], { name: n2, source: i2 } = r2;\n           \
         this.addNativeFunction(n2, i2, r2);\n                  }\n           \
       continue;\n              }\n              this[t2] = e2[t2];\n         \
   }\n            this.canvas || (this.canvas = this.initCanvas()), \
this.context || (this.context = this.initContext()), this.plugins || \
(this.plugins = this.initPlugins(e2));\n          }\n          build() {\n    \
        throw new Error(`\"build\" not defined on \
${this.constructor.name}`);\n          }\n          run() {\n            \
throw new Error(`\"run\" not defined on ${this.constructor.name}`);\n         \
 }\n          initCanvas() {\n            throw new Error(`\"initCanvas\" not \
defined on ${this.constructor.name}`);\n          }\n          initContext() \
{\n            throw new Error(`\"initContext\" not defined on \
${this.constructor.name}`);\n          }\n          initPlugins(e2) {\n       \
     throw new Error(`\"initPlugins\" not defined on \
${this.constructor.name}`);\n          }\n          addFunction(e2, t2 = {}) \
{\n            if (e2.name && e2.source && e2.argumentTypes && \"returnType\" \
in e2) this.functions.push(e2);\n            else if (\"settings\" in e2 && \
\"source\" in e2) this.functions.push(this.functionToIGPUFunction(e2.source, \
e2.settings));\n            else {\n              if (\"string\" != typeof e2 \
&& \"function\" != typeof e2) throw new Error(\"function not properly \
defined\");\n              \
this.functions.push(this.functionToIGPUFunction(e2, t2));\n            }\n    \
        return this;\n          }\n          addNativeFunction(e2, t2, r2 = \
{}) {\n            const { argumentTypes: n2, argumentNames: i2 } = \
r2.argumentTypes ? function(e3) {\n              const t3 = Object.keys(e3), \
r3 = [];\n              for (let n3 = 0; n3 < t3.length; n3++) {\n            \
    const i3 = t3[n3];\n                r3.push(e3[i3]);\n              }\n   \
           return { argumentTypes: r3, argumentNames: t3 };\n            \
}(r2.argumentTypes) : this.constructor.nativeFunctionArguments(t2) || {};\n   \
         return this.nativeFunctions.push({ name: e2, source: t2, settings: \
r2, argumentTypes: n2, argumentNames: i2, returnType: r2.returnType || \
this.constructor.nativeFunctionReturnType(t2) }), this;\n          }\n        \
  setupArguments(e2) {\n            if (this.kernelArguments = [], \
this.argumentTypes) for (let e3 = 0; e3 < this.argumentTypes.length; e3++) \
this.kernelArguments.push({ type: this.argumentTypes[e3] });\n            \
else if (!this.argumentTypes) {\n              this.argumentTypes = [];\n     \
         for (let t2 = 0; t2 < e2.length; t2++) {\n                const r2 = \
n.getVariableType(e2[t2], this.strictIntegers), i2 = \"Integer\" === r2 ? \
\"Number\" : r2;\n                this.argumentTypes.push(i2), \
this.kernelArguments.push({ type: i2 });\n              }\n            }\n    \
        this.argumentSizes = new Array(e2.length), this.argumentBitRatios = \
new Int32Array(e2.length);\n            for (let t2 = 0; t2 < e2.length; \
t2++) {\n              const r2 = e2[t2];\n              \
this.argumentSizes[t2] = r2.constructor === i ? r2.size : null, \
this.argumentBitRatios[t2] = this.getBitRatio(r2);\n            }\n           \
 if (this.argumentNames.length !== e2.length) throw new Error(\"arguments are \
miss-aligned\");\n          }\n          setupConstants() {\n            \
this.kernelConstants = [];\n            let e2 = null === \
this.constantTypes;\n            if (e2 && (this.constantTypes = {}), \
this.constantBitRatios = {}, this.constants) for (let t2 in this.constants) \
{\n              if (e2) {\n                const e3 = \
n.getVariableType(this.constants[t2], this.strictIntegers);\n                \
this.constantTypes[t2] = e3, this.kernelConstants.push({ name: t2, type: e3 \
});\n              } else this.kernelConstants.push({ name: t2, type: \
this.constantTypes[t2] });\n              this.constantBitRatios[t2] = \
this.getBitRatio(this.constants[t2]);\n            }\n          }\n          \
setOptimizeFloatMemory(e2) {\n            return this.optimizeFloatMemory = \
e2, this;\n          }\n          toKernelOutput(e2) {\n            return \
e2.hasOwnProperty(\"x\") ? e2.hasOwnProperty(\"y\") ? \
e2.hasOwnProperty(\"z\") ? [e2.x, e2.y, e2.z] : [e2.x, e2.y] : [e2.x] : e2;\n \
         }\n          setOutput(e2) {\n            return this.output = \
this.toKernelOutput(e2), this;\n          }\n          setDebug(e2) {\n       \
     return this.debug = e2, this;\n          }\n          setGraphical(e2) \
{\n            return this.graphical = e2, this.precision = \"unsigned\", \
this;\n          }\n          setLoopMaxIterations(e2) {\n            return \
this.loopMaxIterations = e2, this;\n          }\n          setConstants(e2) \
{\n            return this.constants = e2, this;\n          }\n          \
setConstantTypes(e2) {\n            return this.constantTypes = e2, this;\n   \
       }\n          setFunctions(e2) {\n            for (let t2 = 0; t2 < \
e2.length; t2++) this.addFunction(e2[t2]);\n            return this;\n        \
  }\n          setNativeFunctions(e2) {\n            for (let t2 = 0; t2 < \
e2.length; t2++) {\n              const r2 = e2[t2], { name: n2, source: i2 } \
= r2;\n              this.addNativeFunction(n2, i2, r2);\n            }\n     \
       return this;\n          }\n          setInjectedNative(e2) {\n         \
   return this.injectedNative = e2, this;\n          }\n          \
setPipeline(e2) {\n            return this.pipeline = e2, this;\n          \
}\n          setPrecision(e2) {\n            return this.precision = e2, \
this;\n          }\n          setDimensions(e2) {\n            return \
n.warnDeprecated(\"method\", \"setDimensions\", \"setOutput\"), this.output = \
e2, this;\n          }\n          setOutputToTexture(e2) {\n            \
return n.warnDeprecated(\"method\", \"setOutputToTexture\", \"setPipeline\"), \
this.pipeline = e2, this;\n          }\n          setImmutable(e2) {\n        \
    return this.immutable = e2, this;\n          }\n          setCanvas(e2) \
{\n            return this.canvas = e2, this;\n          }\n          \
setStrictIntegers(e2) {\n            return this.strictIntegers = e2, this;\n \
         }\n          setDynamicOutput(e2) {\n            return \
this.dynamicOutput = e2, this;\n          }\n          \
setHardcodeConstants(e2) {\n            return n.warnDeprecated(\"method\", \
\"setHardcodeConstants\"), this.setDynamicOutput(e2), \
this.setDynamicArguments(e2), this;\n          }\n          \
setDynamicArguments(e2) {\n            return this.dynamicArguments = e2, \
this;\n          }\n          setUseLegacyEncoder(e2) {\n            return \
this.useLegacyEncoder = e2, this;\n          }\n          setWarnVarUsage(e2) \
{\n            return n.warnDeprecated(\"method\", \"setWarnVarUsage\"), \
this;\n          }\n          getCanvas() {\n            return \
n.warnDeprecated(\"method\", \"getCanvas\"), this.canvas;\n          }\n      \
    getWebGl() {\n            return n.warnDeprecated(\"method\", \
\"getWebGl\"), this.context;\n          }\n          setContext(e2) {\n       \
     return this.context = e2, this;\n          }\n          \
setArgumentTypes(e2) {\n            if (Array.isArray(e2)) this.argumentTypes \
= e2;\n            else {\n              this.argumentTypes = [];\n           \
   for (const t2 in e2) {\n                if (!e2.hasOwnProperty(t2)) \
continue;\n                const r2 = this.argumentNames.indexOf(t2);\n       \
         if (-1 === r2) throw new Error(`unable to find argument ${t2}`);\n   \
             this.argumentTypes[r2] = e2[t2];\n              }\n            \
}\n            return this;\n          }\n          setTactic(e2) {\n         \
   return this.tactic = e2, this;\n          }\n          requestFallback(e2) \
{\n            if (!this.onRequestFallback) throw new \
Error(`\"onRequestFallback\" not defined on ${this.constructor.name}`);\n     \
       return this.fallbackRequested = true, this.onRequestFallback(e2);\n    \
      }\n          validateSettings() {\n            throw new \
Error(`\"validateSettings\" not defined on ${this.constructor.name}`);\n      \
    }\n          addSubKernel(e2) {\n            if (null === this.subKernels \
&& (this.subKernels = []), !e2.source) throw new Error('subKernel missing \
\"source\" property');\n            if (!e2.property && isNaN(e2.property)) \
throw new Error('subKernel missing \"property\" property');\n            if \
(!e2.name) throw new Error('subKernel missing \"name\" property');\n          \
  return this.subKernels.push(e2), this;\n          }\n          destroy(e2) \
{\n            throw new Error(`\"destroy\" called on \
${this.constructor.name}`);\n          }\n          getBitRatio(e2) {\n       \
     if (\"single\" === this.precision) return 4;\n            if \
(Array.isArray(e2[0])) return this.getBitRatio(e2[0]);\n            if \
(e2.constructor === i) return this.getBitRatio(e2.value);\n            switch \
(e2.constructor) {\n              case Uint8ClampedArray:\n              case \
Uint8Array:\n              case Int8Array:\n                return 1;\n       \
       case Uint16Array:\n              case Int16Array:\n                \
return 2;\n              case Float32Array:\n              case Int32Array:\n \
             default:\n                return 4;\n            }\n          \
}\n          getPixels(e2) {\n            throw new Error(`\"getPixels\" \
called on ${this.constructor.name}`);\n          }\n          checkOutput() \
{\n            if (!this.output || !n.isArray(this.output)) throw new \
Error(\"kernel.output not an array\");\n            if (this.output.length < \
1) throw new Error(\"kernel.output is empty, needs at least 1 value\");\n     \
       for (let e2 = 0; e2 < this.output.length; e2++) if \
(isNaN(this.output[e2]) || this.output[e2] < 1) throw new \
Error(`${this.constructor.name}.output[${e2}] incorrectly defined as \
\\`${this.output[e2]}\\`, needs to be numeric, and greater than 0`);\n        \
  }\n          prependString(e2) {\n            throw new \
Error(`\"prependString\" called on ${this.constructor.name}`);\n          }\n \
         hasPrependString(e2) {\n            throw new \
Error(`\"hasPrependString\" called on ${this.constructor.name}`);\n          \
}\n          toJSON() {\n            return { settings: { output: \
this.output, pipeline: this.pipeline, argumentNames: this.argumentNames, \
argumentsTypes: this.argumentTypes, constants: this.constants, pluginNames: \
this.plugins ? this.plugins.map((e2) => e2.name) : null, returnType: \
this.returnType } };\n          }\n          buildSignature(e2) {\n           \
 const t2 = this.constructor;\n            this.signature = \
t2.getSignature(this, t2.getArgumentTypes(this, e2));\n          }\n          \
static getArgumentTypes(e2, t2) {\n            const r2 = new \
Array(t2.length);\n            for (let i2 = 0; i2 < t2.length; i2++) {\n     \
         const s = t2[i2], a = e2.argumentTypes[i2];\n              if \
(s.type) r2[i2] = s.type;\n              else switch (a) {\n                \
case \"Number\":\n                case \"Integer\":\n                case \
\"Float\":\n                case \"ArrayTexture(1)\":\n                  \
r2[i2] = n.getVariableType(s);\n                  break;\n                \
default:\n                  r2[i2] = a;\n              }\n            }\n     \
       return r2;\n          }\n          static getSignature(e2, t2) {\n     \
       throw new Error(`\"getSignature\" not implemented on ${this.name}`);\n \
         }\n          functionToIGPUFunction(e2, t2 = {}) {\n            if \
(\"string\" != typeof e2 && \"function\" != typeof e2) throw new \
Error(\"source not a string or function\");\n            const r2 = \
\"string\" == typeof e2 ? e2 : e2.toString();\n            let i2 = [];\n     \
       return i2 = Array.isArray(t2.argumentTypes) ? t2.argumentTypes : \
\"object\" == typeof t2.argumentTypes ? \
n.getArgumentNamesFromString(r2).map((e3) => t2.argumentTypes[e3]) || [] : \
t2.argumentTypes || [], { name: n.getFunctionNameFromString(r2) || null, \
source: r2, argumentTypes: i2, returnType: t2.returnType || null };\n         \
 }\n          onActivate(e2) {\n          }\n        } };\n      }, { \
\"../input\": 110, \"../utils\": 114 }], 37: [function(e, t, r) {\n        \
const n = \
`__HEADER__;\n__FLOAT_TACTIC_DECLARATION__;\n__INT_TACTIC_DECLARATION__;\n__S\
AMPLER_2D_TACTIC_DECLARATION__;\n\nconst int LOOP_MAX = \
__LOOP_MAX__;\n\n__PLUGINS__;\n__CONSTANTS__;\n\nvarying vec2 \
vTexCoord;\n\nfloat acosh(float x) {\n  return log(x + sqrt(x * x - \
1.0));\n}\n\nfloat sinh(float x) {\n  return (pow(${Math.E}, x) - \
pow(${Math.E}, -x)) / 2.0;\n}\n\nfloat asinh(float x) {\n  return log(x + \
sqrt(x * x + 1.0));\n}\n\nfloat atan2(float v1, float v2) {\n  if (v1 == 0.0 \
|| v2 == 0.0) return 0.0;\n  return atan(v1 / v2);\n}\n\nfloat atanh(float x) \
{\n  x = (x + 1.0) / (x - 1.0);\n  if (x < 0.0) {\n    return 0.5 * \
log(-x);\n  }\n  return 0.5 * log(x);\n}\n\nfloat cbrt(float x) {\n  if (x >= \
0.0) {\n    return pow(x, 1.0 / 3.0);\n  } else {\n    return -pow(x, 1.0 / \
3.0);\n  }\n}\n\nfloat cosh(float x) {\n  return (pow(${Math.E}, x) + \
pow(${Math.E}, -x)) / 2.0; \n}\n\nfloat expm1(float x) {\n  return \
pow(${Math.E}, x) - 1.0; \n}\n\nfloat fround(highp float x) {\n  return \
x;\n}\n\nfloat imul(float v1, float v2) {\n  return float(int(v1) * \
int(v2));\n}\n\nfloat log10(float x) {\n  return log2(x) * (1.0 / \
log2(10.0));\n}\n\nfloat log1p(float x) {\n  return log(1.0 + x);\n}\n\nfloat \
_pow(float v1, float v2) {\n  if (v2 == 0.0) return 1.0;\n  return pow(v1, \
v2);\n}\n\nfloat tanh(float x) {\n  float e = exp(2.0 * x);\n  return (e - \
1.0) / (e + 1.0);\n}\n\nfloat trunc(float x) {\n  if (x >= 0.0) {\n    return \
floor(x); \n  } else {\n    return ceil(x);\n  }\n}\n\nvec4 _round(vec4 x) \
{\n  return floor(x + 0.5);\n}\n\nfloat _round(float x) {\n  return floor(x + \
0.5);\n}\n\nconst int BIT_COUNT = 32;\nint modi(int x, int y) {\n  return x - \
y * (x / y);\n}\n\nint bitwiseOr(int a, int b) {\n  int result = 0;\n  int n \
= 1;\n  \n  for (int i = 0; i < BIT_COUNT; i++) {\n    if ((modi(a, 2) == 1) \
|| (modi(b, 2) == 1)) {\n      result += n;\n    }\n    a = a / 2;\n    b = b \
/ 2;\n    n = n * 2;\n    if(!(a > 0 || b > 0)) {\n      break;\n    }\n  }\n \
 return result;\n}\nint bitwiseXOR(int a, int b) {\n  int result = 0;\n  int \
n = 1;\n  \n  for (int i = 0; i < BIT_COUNT; i++) {\n    if ((modi(a, 2) == \
1) != (modi(b, 2) == 1)) {\n      result += n;\n    }\n    a = a / 2;\n    b \
= b / 2;\n    n = n * 2;\n    if(!(a > 0 || b > 0)) {\n      break;\n    }\n  \
}\n  return result;\n}\nint bitwiseAnd(int a, int b) {\n  int result = 0;\n  \
int n = 1;\n  for (int i = 0; i < BIT_COUNT; i++) {\n    if ((modi(a, 2) == \
1) && (modi(b, 2) == 1)) {\n      result += n;\n    }\n    a = a / 2;\n    b \
= b / 2;\n    n = n * 2;\n    if(!(a > 0 && b > 0)) {\n      break;\n    }\n  \
}\n  return result;\n}\nint bitwiseNot(int a) {\n  int result = 0;\n  int n = \
1;\n  \n  for (int i = 0; i < BIT_COUNT; i++) {\n    if (modi(a, 2) == 0) {\n \
     result += n;    \n    }\n    a = a / 2;\n    n = n * 2;\n  }\n  return \
result;\n}\nint bitwiseZeroFillLeftShift(int n, int shift) {\n  int maxBytes \
= BIT_COUNT;\n  for (int i = 0; i < BIT_COUNT; i++) {\n    if (maxBytes >= n) \
{\n      break;\n    }\n    maxBytes *= 2;\n  }\n  for (int i = 0; i < \
BIT_COUNT; i++) {\n    if (i >= shift) {\n      break;\n    }\n    n *= 2;\n  \
}\n\n  int result = 0;\n  int byteVal = 1;\n  for (int i = 0; i < BIT_COUNT; \
i++) {\n    if (i >= maxBytes) break;\n    if (modi(n, 2) > 0) { result += \
byteVal; }\n    n = int(n / 2);\n    byteVal *= 2;\n  }\n  return \
result;\n}\n\nint bitwiseSignedRightShift(int num, int shifts) {\n  return \
int(floor(float(num) / pow(2.0, float(shifts))));\n}\n\nint \
bitwiseZeroFillRightShift(int n, int shift) {\n  int maxBytes = BIT_COUNT;\n  \
for (int i = 0; i < BIT_COUNT; i++) {\n    if (maxBytes >= n) {\n      \
break;\n    }\n    maxBytes *= 2;\n  }\n  for (int i = 0; i < BIT_COUNT; i++) \
{\n    if (i >= shift) {\n      break;\n    }\n    n /= 2;\n  }\n  int result \
= 0;\n  int byteVal = 1;\n  for (int i = 0; i < BIT_COUNT; i++) {\n    if (i \
>= maxBytes) break;\n    if (modi(n, 2) > 0) { result += byteVal; }\n    n = \
int(n / 2);\n    byteVal *= 2;\n  }\n  return result;\n}\n\nvec2 \
integerMod(vec2 x, float y) {\n  vec2 res = floor(mod(x, y));\n  return res * \
step(1.0 - floor(y), -res);\n}\n\nvec3 integerMod(vec3 x, float y) {\n  vec3 \
res = floor(mod(x, y));\n  return res * step(1.0 - floor(y), \
-res);\n}\n\nvec4 integerMod(vec4 x, vec4 y) {\n  vec4 res = floor(mod(x, \
y));\n  return res * step(1.0 - floor(y), -res);\n}\n\nfloat integerMod(float \
x, float y) {\n  float res = floor(mod(x, y));\n  return res * (res > \
floor(y) - 1.0 ? 0.0 : 1.0);\n}\n\nint integerMod(int x, int y) {\n  return x \
- (y * int(x / y));\n}\n\n__DIVIDE_WITH_INTEGER_CHECK__;\n\n// Here be \
dragons!\n// DO NOT OPTIMIZE THIS CODE\n// YOU WILL BREAK SOMETHING ON \
SOMEBODY'S MACHINE\n// LEAVE IT AS IT IS, LEST YOU WASTE YOUR OWN TIME\nconst \
vec2 MAGIC_VEC = vec2(1.0, -256.0);\nconst vec4 SCALE_FACTOR = vec4(1.0, \
256.0, 65536.0, 0.0);\nconst vec4 SCALE_FACTOR_INV = vec4(1.0, 0.00390625, \
0.0000152587890625, 0.0); // 1, 1/256, 1/65536\nfloat decode32(vec4 texel) \
{\n  __DECODE32_ENDIANNESS__;\n  texel *= 255.0;\n  vec2 gte128;\n  gte128.x \
= texel.b >= 128.0 ? 1.0 : 0.0;\n  gte128.y = texel.a >= 128.0 ? 1.0 : 0.0;\n \
 float exponent = 2.0 * texel.a - 127.0 + dot(gte128, MAGIC_VEC);\n  float \
res = exp2(_round(exponent));\n  texel.b = texel.b - 128.0 * gte128.x;\n  res \
= dot(texel, SCALE_FACTOR) * exp2(_round(exponent-23.0)) + res;\n  res *= \
gte128.y * -2.0 + 1.0;\n  return res;\n}\n\nfloat decode16(vec4 texel, int \
index) {\n  int channel = integerMod(index, 2);\n  if (channel == 0) return \
texel.r * 255.0 + texel.g * 65280.0;\n  if (channel == 1) return texel.b * \
255.0 + texel.a * 65280.0;\n  return 0.0;\n}\n\nfloat decode8(vec4 texel, int \
index) {\n  int channel = integerMod(index, 4);\n  if (channel == 0) return \
texel.r * 255.0;\n  if (channel == 1) return texel.g * 255.0;\n  if (channel \
== 2) return texel.b * 255.0;\n  if (channel == 3) return texel.a * 255.0;\n  \
return 0.0;\n}\n\nvec4 legacyEncode32(float f) {\n  float F = abs(f);\n  \
float sign = f < 0.0 ? 1.0 : 0.0;\n  float exponent = floor(log2(F));\n  \
float mantissa = (exp2(-exponent) * F);\n  // exponent += \
floor(log2(mantissa));\n  vec4 texel = vec4(F * exp2(23.0-exponent)) * \
SCALE_FACTOR_INV;\n  texel.rg = integerMod(texel.rg, 256.0);\n  texel.b = \
integerMod(texel.b, 128.0);\n  texel.a = exponent*0.5 + 63.5;\n  texel.ba += \
vec2(integerMod(exponent+127.0, 2.0), sign) * 128.0;\n  texel = \
floor(texel);\n  texel *= 0.003921569; // 1/255\n  __ENCODE32_ENDIANNESS__;\n \
 return texel;\n}\n\n// \
https://github.com/gpujs/gpu.js/wiki/Encoder-details\nvec4 encode32(float \
value) {\n  if (value == 0.0) return vec4(0, 0, 0, 0);\n\n  float exponent;\n \
 float mantissa;\n  vec4  result;\n  float sgn;\n\n  sgn = step(0.0, \
-value);\n  value = abs(value);\n\n  exponent = floor(log2(value));\n\n  \
mantissa = value*pow(2.0, -exponent)-1.0;\n  exponent = exponent+127.0;\n  \
result   = vec4(0,0,0,0);\n\n  result.a = floor(exponent/2.0);\n  exponent = \
exponent - result.a*2.0;\n  result.a = result.a + 128.0*sgn;\n\n  result.b = \
floor(mantissa * 128.0);\n  mantissa = mantissa - result.b / 128.0;\n  \
result.b = result.b + exponent*128.0;\n\n  result.g = \
floor(mantissa*32768.0);\n  mantissa = mantissa - result.g/32768.0;\n\n  \
result.r = floor(mantissa*8388608.0);\n  return result/255.0;\n}\n// Dragons \
end here\n\nint index;\nivec3 threadId;\n\nivec3 indexTo3D(int idx, ivec3 \
texDim) {\n  int z = int(idx / (texDim.x * texDim.y));\n  idx -= z * \
int(texDim.x * texDim.y);\n  int y = int(idx / texDim.x);\n  int x = \
int(integerMod(idx, texDim.x));\n  return ivec3(x, y, z);\n}\n\nfloat \
get32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  \
int index = x + texDim.x * (y + texDim.y * z);\n  int w = texSize.x;\n  vec2 \
st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\n  vec4 texel \
= texture2D(tex, st / vec2(texSize));\n  return decode32(texel);\n}\n\nfloat \
get16(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  \
int index = x + texDim.x * (y + texDim.y * z);\n  int w = texSize.x * 2;\n  \
vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\n  vec4 \
texel = texture2D(tex, st / vec2(texSize.x * 2, texSize.y));\n  return \
decode16(texel, index);\n}\n\nfloat get8(sampler2D tex, ivec2 texSize, ivec3 \
texDim, int z, int y, int x) {\n  int index = x + texDim.x * (y + texDim.y * \
z);\n  int w = texSize.x * 4;\n  vec2 st = vec2(float(integerMod(index, w)), \
float(index / w)) + 0.5;\n  vec4 texel = texture2D(tex, st / vec2(texSize.x * \
4, texSize.y));\n  return decode8(texel, index);\n}\n\nfloat \
getMemoryOptimized32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int \
y, int x) {\n  int index = x + texDim.x * (y + texDim.y * z);\n  int channel \
= integerMod(index, 4);\n  index = index / 4;\n  int w = texSize.x;\n  vec2 \
st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\n  vec4 texel \
= texture2D(tex, st / vec2(texSize));\n  if (channel == 0) return texel.r;\n  \
if (channel == 1) return texel.g;\n  if (channel == 2) return texel.b;\n  if \
(channel == 3) return texel.a;\n  return 0.0;\n}\n\nvec4 getImage2D(sampler2D \
tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  int index = x + \
texDim.x * (y + texDim.y * z);\n  int w = texSize.x;\n  vec2 st = \
vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\n  return \
texture2D(tex, st / vec2(texSize));\n}\n\nfloat \
getFloatFromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int \
y, int x) {\n  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);\n  \
return result[0];\n}\n\nvec2 getVec2FromSampler2D(sampler2D tex, ivec2 \
texSize, ivec3 texDim, int z, int y, int x) {\n  vec4 result = \
getImage2D(tex, texSize, texDim, z, y, x);\n  return vec2(result[0], \
result[1]);\n}\n\nvec2 getMemoryOptimizedVec2(sampler2D tex, ivec2 texSize, \
ivec3 texDim, int z, int y, int x) {\n  int index = x + (texDim.x * (y + \
(texDim.y * z)));\n  int channel = integerMod(index, 2);\n  index = index / \
2;\n  int w = texSize.x;\n  vec2 st = vec2(float(integerMod(index, w)), \
float(index / w)) + 0.5;\n  vec4 texel = texture2D(tex, st / \
vec2(texSize));\n  if (channel == 0) return vec2(texel.r, texel.g);\n  if \
(channel == 1) return vec2(texel.b, texel.a);\n  return vec2(0.0, \
0.0);\n}\n\nvec3 getVec3FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 \
texDim, int z, int y, int x) {\n  vec4 result = getImage2D(tex, texSize, \
texDim, z, y, x);\n  return vec3(result[0], result[1], result[2]);\n}\n\nvec3 \
getMemoryOptimizedVec3(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int \
y, int x) {\n  int fieldIndex = 3 * (x + texDim.x * (y + texDim.y * z));\n  \
int vectorIndex = fieldIndex / 4;\n  int vectorOffset = fieldIndex - \
vectorIndex * 4;\n  int readY = vectorIndex / texSize.x;\n  int readX = \
vectorIndex - readY * texSize.x;\n  vec4 tex1 = texture2D(tex, (vec2(readX, \
readY) + 0.5) / vec2(texSize));\n  \n  if (vectorOffset == 0) {\n    return \
tex1.xyz;\n  } else if (vectorOffset == 1) {\n    return tex1.yzw;\n  } else \
{\n    readX++;\n    if (readX >= texSize.x) {\n      readX = 0;\n      \
readY++;\n    }\n    vec4 tex2 = texture2D(tex, vec2(readX, readY) / \
vec2(texSize));\n    if (vectorOffset == 2) {\n      return vec3(tex1.z, \
tex1.w, tex2.x);\n    } else {\n      return vec3(tex1.w, tex2.x, tex2.y);\n  \
  }\n  }\n}\n\nvec4 getVec4FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 \
texDim, int z, int y, int x) {\n  return getImage2D(tex, texSize, texDim, z, \
y, x);\n}\n\nvec4 getMemoryOptimizedVec4(sampler2D tex, ivec2 texSize, ivec3 \
texDim, int z, int y, int x) {\n  int index = x + texDim.x * (y + texDim.y * \
z);\n  int channel = integerMod(index, 2);\n  int w = texSize.x;\n  vec2 st = \
vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\n  vec4 texel = \
texture2D(tex, st / vec2(texSize));\n  return vec4(texel.r, texel.g, texel.b, \
texel.a);\n}\n\nvec4 actualColor;\nvoid color(float r, float g, float b, \
float a) {\n  actualColor = vec4(r,g,b,a);\n}\n\nvoid color(float r, float g, \
float b) {\n  color(r,g,b,1.0);\n}\n\nvoid color(sampler2D image) {\n  \
actualColor = texture2D(image, vTexCoord);\n}\n\nfloat modulo(float number, \
float divisor) {\n  if (number < 0.0) {\n    number = abs(number);\n    if \
(divisor < 0.0) {\n      divisor = abs(divisor);\n    }\n    return \
-mod(number, divisor);\n  }\n  if (divisor < 0.0) {\n    divisor = \
abs(divisor);\n  }\n  return mod(number, \
divisor);\n}\n\n__INJECTED_NATIVE__;\n__MAIN_CONSTANTS__;\n__MAIN_ARGUMENTS__\
;\n__KERNEL__;\n\nvoid main(void) {\n  index = int(vTexCoord.s * \
float(uTexSize.x)) + int(vTexCoord.t * float(uTexSize.y)) * uTexSize.x;\n  \
__MAIN_RESULT__;\n}`;\n        t.exports = { fragmentShader: n };\n      }, \
{}], 38: [function(e, t, r) {\n        const { utils: n } = \
e(\"../../utils\"), { FunctionNode: i } = e(\"../function-node\");\n        \
const s = { Array: \"sampler2D\", \"Array(2)\": \"vec2\", \"Array(3)\": \
\"vec3\", \"Array(4)\": \"vec4\", \"Matrix(2)\": \"mat2\", \"Matrix(3)\": \
\"mat3\", \"Matrix(4)\": \"mat4\", Array2D: \"sampler2D\", Array3D: \
\"sampler2D\", Boolean: \"bool\", Float: \"float\", Input: \"sampler2D\", \
Integer: \"int\", Number: \"float\", LiteralInteger: \"float\", \
NumberTexture: \"sampler2D\", MemoryOptimizedNumberTexture: \"sampler2D\", \
\"ArrayTexture(1)\": \"sampler2D\", \"ArrayTexture(2)\": \"sampler2D\", \
\"ArrayTexture(3)\": \"sampler2D\", \"ArrayTexture(4)\": \"sampler2D\", \
HTMLVideo: \"sampler2D\", HTMLCanvas: \"sampler2D\", OffscreenCanvas: \
\"sampler2D\", HTMLImage: \"sampler2D\", ImageBitmap: \"sampler2D\", \
ImageData: \"sampler2D\", HTMLImageArray: \"sampler2DArray\" }, a = { \
\"===\": \"==\", \"!==\": \"!=\" };\n        t.exports = { WebGLFunctionNode: \
class extends i {\n          constructor(e2, t2) {\n            super(e2, \
t2), t2 && t2.hasOwnProperty(\"fixIntegerDivisionAccuracy\") && \
(this.fixIntegerDivisionAccuracy = t2.fixIntegerDivisionAccuracy);\n          \
}\n          astConditionalExpression(e2, t2) {\n            if \
(\"ConditionalExpression\" !== e2.type) throw this.astErrorOutput(\"Not a \
conditional expression\", e2);\n            const r2 = \
this.getType(e2.consequent), n2 = this.getType(e2.alternate);\n            \
return null === r2 && null === n2 ? (t2.push(\"if (\"), \
this.astGeneric(e2.test, t2), t2.push(\") {\"), \
this.astGeneric(e2.consequent, t2), t2.push(\";\"), t2.push(\"} else {\"), \
this.astGeneric(e2.alternate, t2), t2.push(\";\"), t2.push(\"}\"), t2) : \
(t2.push(\"(\"), this.astGeneric(e2.test, t2), t2.push(\"?\"), \
this.astGeneric(e2.consequent, t2), t2.push(\":\"), \
this.astGeneric(e2.alternate, t2), t2.push(\")\"), t2);\n          }\n        \
  astFunction(e2, t2) {\n            if (this.isRootKernel) \
t2.push(\"void\");\n            else {\n              if (!this.returnType) \
{\n                this.findLastReturn() && (this.returnType = \
this.getType(e2.body), \"LiteralInteger\" === this.returnType && \
(this.returnType = \"Number\"));\n              }\n              const { \
returnType: r2 } = this;\n              if (r2) {\n                const e3 = \
s[r2];\n                if (!e3) throw new Error(`unknown type ${r2}`);\n     \
           t2.push(e3);\n              } else t2.push(\"void\");\n            \
}\n            if (t2.push(\" \"), t2.push(this.name), t2.push(\"(\"), \
!this.isRootKernel) for (let r2 = 0; r2 < this.argumentNames.length; ++r2) \
{\n              const i2 = this.argumentNames[r2];\n              r2 > 0 && \
t2.push(\", \");\n              let a2 = \
this.argumentTypes[this.argumentNames.indexOf(i2)];\n              if (!a2) \
throw this.astErrorOutput(`Unknown argument ${i2} type`, e2);\n              \
\"LiteralInteger\" === a2 && (this.argumentTypes[r2] = a2 = \"Number\");\n    \
          const o = s[a2];\n              if (!o) throw \
this.astErrorOutput(\"Unexpected expression\", e2);\n              const u = \
n.sanitizeName(i2);\n              \"sampler2D\" === o || \"sampler2DArray\" \
=== o ? t2.push(`${o} user_${u},ivec2 user_${u}Size,ivec3 user_${u}Dim`) : \
t2.push(`${o} user_${u}`);\n            }\n            t2.push(\") {\\n\");\n \
           for (let r2 = 0; r2 < e2.body.body.length; ++r2) \
this.astGeneric(e2.body.body[r2], t2), t2.push(\"\\n\");\n            return \
t2.push(\"}\\n\"), t2;\n          }\n          astReturnStatement(e2, t2) {\n \
           if (!e2.argument) throw this.astErrorOutput(\"Unexpected return \
statement\", e2);\n            this.pushState(\"skip-literal-correction\");\n \
           const r2 = this.getType(e2.argument);\n            \
this.popState(\"skip-literal-correction\");\n            const n2 = [];\n     \
       switch (this.returnType || (this.returnType = \"LiteralInteger\" === \
r2 || \"Integer\" === r2 ? \"Number\" : r2), this.returnType) {\n             \
 case \"LiteralInteger\":\n              case \"Number\":\n              case \
\"Float\":\n                switch (r2) {\n                  case \
\"Integer\":\n                    n2.push(\"float(\"), \
this.astGeneric(e2.argument, n2), n2.push(\")\");\n                    \
break;\n                  case \"LiteralInteger\":\n                    \
this.castLiteralToFloat(e2.argument, n2), \"Integer\" === this.getType(e2) && \
(n2.unshift(\"float(\"), n2.push(\")\"));\n                    break;\n       \
           default:\n                    this.astGeneric(e2.argument, n2);\n  \
              }\n                break;\n              case \"Integer\":\n    \
            switch (r2) {\n                  case \"Float\":\n                \
  case \"Number\":\n                    this.castValueToInteger(e2.argument, \
n2);\n                    break;\n                  case \
\"LiteralInteger\":\n                    \
this.castLiteralToInteger(e2.argument, n2);\n                    break;\n     \
             default:\n                    this.astGeneric(e2.argument, \
n2);\n                }\n                break;\n              case \
\"Array(4)\":\n              case \"Array(3)\":\n              case \
\"Array(2)\":\n              case \"Matrix(2)\":\n              case \
\"Matrix(3)\":\n              case \"Matrix(4)\":\n              case \
\"Input\":\n                this.astGeneric(e2.argument, n2);\n               \
 break;\n              default:\n                throw \
this.astErrorOutput(`unhandled return type ${this.returnType}`, e2);\n        \
    }\n            return this.isRootKernel ? (t2.push(`kernelResult = \
${n2.join(\"\")};`), t2.push(\"return;\")) : this.isSubKernel ? \
(t2.push(`subKernelResult_${this.name} = ${n2.join(\"\")};`), t2.push(`return \
subKernelResult_${this.name};`)) : t2.push(`return ${n2.join(\"\")};`), t2;\n \
         }\n          astLiteral(e2, t2) {\n            if (isNaN(e2.value)) \
throw this.astErrorOutput(\"Non-numeric literal not supported : \" + \
e2.value, e2);\n            const r2 = this.astKey(e2);\n            return \
Number.isInteger(e2.value) ? this.isState(\"casting-to-integer\") || \
this.isState(\"building-integer\") ? (this.literalTypes[r2] = \"Integer\", \
t2.push(`${e2.value}`)) : (this.isState(\"casting-to-float\") || \
this.isState(\"building-float\"), this.literalTypes[r2] = \"Number\", \
t2.push(`${e2.value}.0`)) : this.isState(\"casting-to-integer\") || \
this.isState(\"building-integer\") ? (this.literalTypes[r2] = \"Integer\", \
t2.push(Math.round(e2.value))) : (this.literalTypes[r2] = \"Number\", \
t2.push(`${e2.value}`)), t2;\n          }\n          astBinaryExpression(e2, \
t2) {\n            if (this.checkAndUpconvertOperator(e2, t2)) return t2;\n   \
         if (this.fixIntegerDivisionAccuracy && \"/\" === e2.operator) {\n    \
          switch (t2.push(\"divWithIntCheck(\"), \
this.pushState(\"building-float\"), this.getType(e2.left)) {\n                \
case \"Integer\":\n                  this.castValueToFloat(e2.left, t2);\n    \
              break;\n                case \"LiteralInteger\":\n              \
    this.castLiteralToFloat(e2.left, t2);\n                  break;\n         \
       default:\n                  this.astGeneric(e2.left, t2);\n            \
  }\n              switch (t2.push(\", \"), this.getType(e2.right)) {\n       \
         case \"Integer\":\n                  this.castValueToFloat(e2.right, \
t2);\n                  break;\n                case \"LiteralInteger\":\n    \
              this.castLiteralToFloat(e2.right, t2);\n                  \
break;\n                default:\n                  this.astGeneric(e2.right, \
t2);\n              }\n              return \
this.popState(\"building-float\"), t2.push(\")\"), t2;\n            }\n       \
     t2.push(\"(\");\n            const r2 = this.getType(e2.left) || \
\"Number\", n2 = this.getType(e2.right) || \"Number\";\n            if (!r2 \
|| !n2) throw this.astErrorOutput(\"Unhandled binary expression\", e2);\n     \
       const i2 = r2 + \" & \" + n2;\n            switch (i2) {\n             \
 case \"Integer & Integer\":\n                \
this.pushState(\"building-integer\"), this.astGeneric(e2.left, t2), \
t2.push(a[e2.operator] || e2.operator), this.astGeneric(e2.right, t2), \
this.popState(\"building-integer\");\n                break;\n              \
case \"Number & Float\":\n              case \"Float & Number\":\n            \
  case \"Float & Float\":\n              case \"Number & Number\":\n          \
      this.pushState(\"building-float\"), this.astGeneric(e2.left, t2), \
t2.push(a[e2.operator] || e2.operator), this.astGeneric(e2.right, t2), \
this.popState(\"building-float\");\n                break;\n              \
case \"LiteralInteger & LiteralInteger\":\n                \
this.isState(\"casting-to-integer\") || this.isState(\"building-integer\") ? \
(this.pushState(\"building-integer\"), this.astGeneric(e2.left, t2), \
t2.push(a[e2.operator] || e2.operator), this.astGeneric(e2.right, t2), \
this.popState(\"building-integer\")) : (this.pushState(\"building-float\"), \
this.castLiteralToFloat(e2.left, t2), t2.push(a[e2.operator] || e2.operator), \
this.castLiteralToFloat(e2.right, t2), this.popState(\"building-float\"));\n  \
              break;\n              case \"Integer & Float\":\n              \
case \"Integer & Number\":\n                if ((\">\" === e2.operator || \
\"<\" === e2.operator && \"Literal\" === e2.right.type) && \
!Number.isInteger(e2.right.value)) {\n                  \
this.pushState(\"building-float\"), this.castValueToFloat(e2.left, t2), \
t2.push(a[e2.operator] || e2.operator), this.astGeneric(e2.right, t2), \
this.popState(\"building-float\");\n                  break;\n                \
}\n                if (this.pushState(\"building-integer\"), \
this.astGeneric(e2.left, t2), t2.push(a[e2.operator] || e2.operator), \
this.pushState(\"casting-to-integer\"), \"Literal\" === e2.right.type) {\n    \
              const r3 = [];\n                  this.astGeneric(e2.right, \
r3);\n                  if (\"Integer\" !== this.getType(e2.right)) throw \
this.astErrorOutput(\"Unhandled binary expression with literal\", e2);\n      \
            t2.push(r3.join(\"\"));\n                } else \
t2.push(\"int(\"), this.astGeneric(e2.right, t2), t2.push(\")\");\n           \
     this.popState(\"casting-to-integer\"), \
this.popState(\"building-integer\");\n                break;\n              \
case \"Integer & LiteralInteger\":\n                \
this.pushState(\"building-integer\"), this.astGeneric(e2.left, t2), \
t2.push(a[e2.operator] || e2.operator), this.castLiteralToInteger(e2.right, \
t2), this.popState(\"building-integer\");\n                break;\n           \
   case \"Number & Integer\":\n              case \"Float & Integer\":\n      \
          this.pushState(\"building-float\"), this.astGeneric(e2.left, t2), \
t2.push(a[e2.operator] || e2.operator), this.castValueToFloat(e2.right, t2), \
this.popState(\"building-float\");\n                break;\n              \
case \"Float & LiteralInteger\":\n              case \"Number & \
LiteralInteger\":\n                this.pushState(\"building-float\"), \
this.astGeneric(e2.left, t2), t2.push(a[e2.operator] || e2.operator), \
this.castLiteralToFloat(e2.right, t2), this.popState(\"building-float\");\n   \
             break;\n              case \"LiteralInteger & Float\":\n         \
     case \"LiteralInteger & Number\":\n                \
this.isState(\"casting-to-integer\") ? (this.pushState(\"building-integer\"), \
this.castLiteralToInteger(e2.left, t2), t2.push(a[e2.operator] || \
e2.operator), this.castValueToInteger(e2.right, t2), \
this.popState(\"building-integer\")) : (this.pushState(\"building-float\"), \
this.astGeneric(e2.left, t2), t2.push(a[e2.operator] || e2.operator), \
this.pushState(\"casting-to-float\"), this.astGeneric(e2.right, t2), \
this.popState(\"casting-to-float\"), this.popState(\"building-float\"));\n    \
            break;\n              case \"LiteralInteger & Integer\":\n        \
        this.pushState(\"building-integer\"), \
this.castLiteralToInteger(e2.left, t2), t2.push(a[e2.operator] || \
e2.operator), this.astGeneric(e2.right, t2), \
this.popState(\"building-integer\");\n                break;\n              \
case \"Boolean & Boolean\":\n                \
this.pushState(\"building-boolean\"), this.astGeneric(e2.left, t2), \
t2.push(a[e2.operator] || e2.operator), this.astGeneric(e2.right, t2), \
this.popState(\"building-boolean\");\n                break;\n              \
default:\n                throw this.astErrorOutput(`Unhandled binary \
expression between ${i2}`, e2);\n            }\n            return \
t2.push(\")\"), t2;\n          }\n          checkAndUpconvertOperator(e2, t2) \
{\n            const r2 = this.checkAndUpconvertBitwiseOperators(e2, t2);\n   \
         if (r2) return r2;\n            const n2 = { \"%\": \
this.fixIntegerDivisionAccuracy ? \"integerCorrectionModulo\" : \"modulo\", \
\"**\": \"pow\" }[e2.operator];\n            if (!n2) return null;\n          \
  switch (t2.push(n2), t2.push(\"(\"), this.getType(e2.left)) {\n             \
 case \"Integer\":\n                this.castValueToFloat(e2.left, t2);\n     \
           break;\n              case \"LiteralInteger\":\n                \
this.castLiteralToFloat(e2.left, t2);\n                break;\n              \
default:\n                this.astGeneric(e2.left, t2);\n            }\n      \
      switch (t2.push(\",\"), this.getType(e2.right)) {\n              case \
\"Integer\":\n                this.castValueToFloat(e2.right, t2);\n          \
      break;\n              case \"LiteralInteger\":\n                \
this.castLiteralToFloat(e2.right, t2);\n                break;\n              \
default:\n                this.astGeneric(e2.right, t2);\n            }\n     \
       return t2.push(\")\"), t2;\n          }\n          \
checkAndUpconvertBitwiseOperators(e2, t2) {\n            const r2 = { \"&\": \
\"bitwiseAnd\", \"|\": \"bitwiseOr\", \"^\": \"bitwiseXOR\", \"<<\": \
\"bitwiseZeroFillLeftShift\", \">>\": \"bitwiseSignedRightShift\", \">>>\": \
\"bitwiseZeroFillRightShift\" }[e2.operator];\n            if (!r2) return \
null;\n            t2.push(r2), t2.push(\"(\");\n            switch \
(this.getType(e2.left)) {\n              case \"Number\":\n              case \
\"Float\":\n                this.castValueToInteger(e2.left, t2);\n           \
     break;\n              case \"LiteralInteger\":\n                \
this.castLiteralToInteger(e2.left, t2);\n                break;\n             \
 default:\n                this.astGeneric(e2.left, t2);\n            }\n     \
       t2.push(\",\");\n            switch (this.getType(e2.right)) {\n       \
       case \"Number\":\n              case \"Float\":\n                \
this.castValueToInteger(e2.right, t2);\n                break;\n              \
case \"LiteralInteger\":\n                this.castLiteralToInteger(e2.right, \
t2);\n                break;\n              default:\n                \
this.astGeneric(e2.right, t2);\n            }\n            return \
t2.push(\")\"), t2;\n          }\n          checkAndUpconvertBitwiseUnary(e2, \
t2) {\n            const r2 = { \"~\": \"bitwiseNot\" }[e2.operator];\n       \
     if (!r2) return null;\n            switch (t2.push(r2), t2.push(\"(\"), \
this.getType(e2.argument)) {\n              case \"Number\":\n              \
case \"Float\":\n                this.castValueToInteger(e2.argument, t2);\n  \
              break;\n              case \"LiteralInteger\":\n                \
this.castLiteralToInteger(e2.argument, t2);\n                break;\n         \
     default:\n                this.astGeneric(e2.argument, t2);\n            \
}\n            return t2.push(\")\"), t2;\n          }\n          \
castLiteralToInteger(e2, t2) {\n            return \
this.pushState(\"casting-to-integer\"), this.astGeneric(e2, t2), \
this.popState(\"casting-to-integer\"), t2;\n          }\n          \
castLiteralToFloat(e2, t2) {\n            return \
this.pushState(\"casting-to-float\"), this.astGeneric(e2, t2), \
this.popState(\"casting-to-float\"), t2;\n          }\n          \
castValueToInteger(e2, t2) {\n            return \
this.pushState(\"casting-to-integer\"), t2.push(\"int(\"), \
this.astGeneric(e2, t2), t2.push(\")\"), \
this.popState(\"casting-to-integer\"), t2;\n          }\n          \
castValueToFloat(e2, t2) {\n            return \
this.pushState(\"casting-to-float\"), t2.push(\"float(\"), \
this.astGeneric(e2, t2), t2.push(\")\"), this.popState(\"casting-to-float\"), \
t2;\n          }\n          astIdentifierExpression(e2, t2) {\n            if \
(\"Identifier\" !== e2.type) throw this.astErrorOutput(\"IdentifierExpression \
- not an Identifier\", e2);\n            const r2 = this.getType(e2), i2 = \
n.sanitizeName(e2.name);\n            return \"Infinity\" === e2.name ? \
t2.push(\"3.402823466e+38\") : \"Boolean\" === r2 && \
this.argumentNames.indexOf(i2) > -1 ? t2.push(`bool(user_${i2})`) : \
t2.push(`user_${i2}`), t2;\n          }\n          astForStatement(e2, t2) \
{\n            if (\"ForStatement\" !== e2.type) throw \
this.astErrorOutput(\"Invalid for statement\", e2);\n            const r2 = \
[], n2 = [], i2 = [], s2 = [];\n            let a2 = null;\n            if \
(e2.init) {\n              const { declarations: t3 } = e2.init;\n            \
  t3.length > 1 && (a2 = false), this.astGeneric(e2.init, r2);\n              \
for (let e3 = 0; e3 < t3.length; e3++) t3[e3].init && \"Literal\" !== \
t3[e3].init.type && (a2 = false);\n            } else a2 = false;\n           \
 if (e2.test ? this.astGeneric(e2.test, n2) : a2 = false, e2.update ? \
this.astGeneric(e2.update, i2) : a2 = false, e2.body && \
(this.pushState(\"loop-body\"), this.astGeneric(e2.body, s2), \
this.popState(\"loop-body\")), null === a2 && (a2 = this.isSafe(e2.init) && \
this.isSafe(e2.test)), a2) {\n              const e3 = r2.join(\"\"), a3 = \
\";\" !== e3[e3.length - 1];\n              t2.push(`for (${e3}${a3 ? \";\" : \
\"\"}${n2.join(\"\")};${i2.join(\"\")}){\n`), t2.push(s2.join(\"\")), \
t2.push(\"}\\n\");\n            } else {\n              const e3 = \
this.getInternalVariableName(\"safeI\");\n              r2.length > 0 && \
t2.push(r2.join(\"\"), \"\\n\"), t2.push(`for (int \
${e3}=0;${e3}<LOOP_MAX;${e3}++){\n`), n2.length > 0 && t2.push(`if \
(!${n2.join(\"\")}) break;\n`), t2.push(s2.join(\"\")), \
t2.push(`\n${i2.join(\"\")};`), t2.push(\"}\\n\");\n            }\n           \
 return t2;\n          }\n          astWhileStatement(e2, t2) {\n            \
if (\"WhileStatement\" !== e2.type) throw this.astErrorOutput(\"Invalid while \
statement\", e2);\n            const r2 = \
this.getInternalVariableName(\"safeI\");\n            return t2.push(`for \
(int ${r2}=0;${r2}<LOOP_MAX;${r2}++){\n`), t2.push(\"if (!\"), \
this.astGeneric(e2.test, t2), t2.push(\") break;\\n\"), \
this.astGeneric(e2.body, t2), t2.push(\"}\\n\"), t2;\n          }\n          \
astDoWhileStatement(e2, t2) {\n            if (\"DoWhileStatement\" !== \
e2.type) throw this.astErrorOutput(\"Invalid while statement\", e2);\n        \
    const r2 = this.getInternalVariableName(\"safeI\");\n            return \
t2.push(`for (int ${r2}=0;${r2}<LOOP_MAX;${r2}++){\n`), \
this.astGeneric(e2.body, t2), t2.push(\"if (!\"), this.astGeneric(e2.test, \
t2), t2.push(\") break;\\n\"), t2.push(\"}\\n\"), t2;\n          }\n          \
astAssignmentExpression(e2, t2) {\n            if (\"%=\" === e2.operator) \
this.astGeneric(e2.left, t2), t2.push(\"=\"), t2.push(\"mod(\"), \
this.astGeneric(e2.left, t2), t2.push(\",\"), this.astGeneric(e2.right, t2), \
t2.push(\")\");\n            else {\n              if (\"**=\" !== \
e2.operator) {\n                const r2 = this.getType(e2.left), n2 = \
this.getType(e2.right);\n                return this.astGeneric(e2.left, t2), \
t2.push(e2.operator), \"Integer\" !== r2 && \"Integer\" === n2 ? \
(t2.push(\"float(\"), this.astGeneric(e2.right, t2), t2.push(\")\")) : \
this.astGeneric(e2.right, t2), t2;\n              }\n              \
this.astGeneric(e2.left, t2), t2.push(\"=\"), t2.push(\"pow(\"), \
this.astGeneric(e2.left, t2), t2.push(\",\"), this.astGeneric(e2.right, t2), \
t2.push(\")\");\n            }\n          }\n          astBlockStatement(e2, \
t2) {\n            if (this.isState(\"loop-body\")) {\n              \
this.pushState(\"block-body\");\n              for (let r2 = 0; r2 < \
e2.body.length; r2++) this.astGeneric(e2.body[r2], t2);\n              \
this.popState(\"block-body\");\n            } else {\n              \
t2.push(\"{\\n\");\n              for (let r2 = 0; r2 < e2.body.length; r2++) \
this.astGeneric(e2.body[r2], t2);\n              t2.push(\"}\\n\");\n         \
   }\n            return t2;\n          }\n          \
astVariableDeclaration(e2, t2) {\n            const r2 = e2.declarations;\n   \
         if (!r2 || !r2[0] || !r2[0].init) throw \
this.astErrorOutput(\"Unexpected expression\", e2);\n            const i2 = \
[];\n            let a2 = null;\n            const o = [];\n            let u \
= [];\n            for (let t3 = 0; t3 < r2.length; t3++) {\n              \
const i3 = r2[t3], l = i3.init, h = this.getDeclaration(i3.id), c = \
this.getType(i3.init);\n              let p = c;\n              \
\"LiteralInteger\" === p && (p = \"Integer\" === h.suggestedType ? \
\"Integer\" : \"Number\");\n              const d = s[p];\n              if \
(!d) throw this.astErrorOutput(`Markup type ${p} not handled`, e2);\n         \
     const m = [];\n              if (\"Integer\" === c && \"Integer\" === p) \
{\n                if (h.valueType = \"Number\", 0 === t3 || null === a2) \
m.push(\"float \");\n                else if (p !== a2) throw new \
Error(\"Unhandled declaration\");\n                a2 = p, \
m.push(`user_${n.sanitizeName(i3.id.name)}=`), m.push(\"float(\"), \
this.astGeneric(l, m), m.push(\")\");\n              } else h.valueType = p, \
0 === t3 || null === a2 ? m.push(`${d} `) : p !== a2 && \
(o.push(u.join(\",\")), u = [], m.push(`${d} `)), a2 = p, \
m.push(`user_${n.sanitizeName(i3.id.name)}=`), \"Number\" === c && \
\"Integer\" === p ? l.left && \"Literal\" === l.left.type ? \
this.astGeneric(l, m) : (m.push(\"int(\"), this.astGeneric(l, m), \
m.push(\")\")) : \"LiteralInteger\" === c && \"Integer\" === p ? \
this.castLiteralToInteger(l, m) : this.astGeneric(l, m);\n              \
u.push(m.join(\"\"));\n            }\n            return u.length > 0 && \
o.push(u.join(\",\")), i2.push(o.join(\";\")), t2.push(i2.join(\"\")), \
t2.push(\";\"), t2;\n          }\n          astIfStatement(e2, t2) {\n        \
    return t2.push(\"if (\"), this.astGeneric(e2.test, t2), t2.push(\")\"), \
\"BlockStatement\" === e2.consequent.type ? this.astGeneric(e2.consequent, \
t2) : (t2.push(\" {\\n\"), this.astGeneric(e2.consequent, t2), \
t2.push(\"\\n}\\n\")), e2.alternate && (t2.push(\"else \"), \
\"BlockStatement\" === e2.alternate.type || \"IfStatement\" === \
e2.alternate.type ? this.astGeneric(e2.alternate, t2) : (t2.push(\" {\\n\"), \
this.astGeneric(e2.alternate, t2), t2.push(\"\\n}\\n\"))), t2;\n          }\n \
         astSwitchStatement(e2, t2) {\n            if (\"SwitchStatement\" \
!== e2.type) throw this.astErrorOutput(\"Invalid switch statement\", e2);\n   \
         const { discriminant: r2, cases: n2 } = e2, i2 = this.getType(r2), \
s2 = `switchDiscriminant${this.astKey(e2, \"_\")}`;\n            switch (i2) \
{\n              case \"Float\":\n              case \"Number\":\n            \
    t2.push(`float ${s2} = `), this.astGeneric(r2, t2), t2.push(\";\\n\");\n  \
              break;\n              case \"Integer\":\n                \
t2.push(`int ${s2} = `), this.astGeneric(r2, t2), t2.push(\";\\n\");\n        \
    }\n            if (1 === n2.length && !n2[0].test) return \
this.astGeneric(n2[0].consequent, t2), t2;\n            let a2 = false, o = \
[], u = false, l = false;\n            for (let e3 = 0; e3 < n2.length; e3++) \
{\n              if (n2[e3].test) {\n                if (0 !== e3 && l ? a2 ? \
(t2.push(`${s2} == `), a2 = false) : t2.push(` else if (${s2} == `) : (l = \
true, t2.push(`if (${s2} == `)), \"Integer\" === i2) {\n                  \
switch (this.getType(n2[e3].test)) {\n                    case \"Number\":\n  \
                  case \"Float\":\n                      \
this.castValueToInteger(n2[e3].test, t2);\n                      break;\n     \
               case \"LiteralInteger\":\n                      \
this.castLiteralToInteger(n2[e3].test, t2);\n                  }\n            \
    } else {\n                  if (\"Float\" !== i2) throw new \
Error(\"unhanlded\");\n                  switch (this.getType(n2[e3].test)) \
{\n                    case \"LiteralInteger\":\n                      \
this.castLiteralToFloat(n2[e3].test, t2);\n                      break;\n     \
               case \"Integer\":\n                      \
this.castValueToFloat(n2[e3].test, t2);\n                  }\n                \
}\n                if (!n2[e3].consequent || 0 === n2[e3].consequent.length) \
{\n                  a2 = true, t2.push(\" || \");\n                  \
continue;\n                }\n                t2.push(\") {\\n\");\n          \
    } else {\n                if (n2.length > e3 + 1) {\n                  u \
= true, this.astGeneric(n2[e3].consequent, o);\n                  continue;\n \
               }\n                t2.push(\" else {\\n\");\n              }\n \
             this.astGeneric(n2[e3].consequent, t2), t2.push(\"\\n}\");\n     \
       }\n            return u && (t2.push(\" else {\"), \
t2.push(o.join(\"\")), t2.push(\"}\")), t2;\n          }\n          \
astThisExpression(e2, t2) {\n            return t2.push(\"this\"), t2;\n      \
    }\n          astMemberExpression(e2, t2) {\n            const { property: \
r2, name: i2, signature: s2, origin: a2, type: o, xProperty: u, yProperty: l, \
zProperty: h } = this.getMemberExpressionDetails(e2);\n            switch \
(s2) {\n              case \"value.thread.value\":\n              case \
\"this.thread.value\":\n                if (\"x\" !== i2 && \"y\" !== i2 && \
\"z\" !== i2) throw this.astErrorOutput(\"Unexpected expression, expected \
`this.thread.x`, `this.thread.y`, or `this.thread.z`\", e2);\n                \
return t2.push(`threadId.${i2}`), t2;\n              case \
\"this.output.value\":\n                if (this.dynamicOutput) switch (i2) \
{\n                  case \"x\":\n                    \
this.isState(\"casting-to-float\") ? t2.push(\"float(uOutputDim.x)\") : \
t2.push(\"uOutputDim.x\");\n                    break;\n                  \
case \"y\":\n                    this.isState(\"casting-to-float\") ? \
t2.push(\"float(uOutputDim.y)\") : t2.push(\"uOutputDim.y\");\n               \
     break;\n                  case \"z\":\n                    \
this.isState(\"casting-to-float\") ? t2.push(\"float(uOutputDim.z)\") : \
t2.push(\"uOutputDim.z\");\n                    break;\n                  \
default:\n                    throw this.astErrorOutput(\"Unexpected \
expression\", e2);\n                }\n                else switch (i2) {\n   \
               case \"x\":\n                    \
this.isState(\"casting-to-integer\") ? t2.push(this.output[0]) : \
t2.push(this.output[0], \".0\");\n                    break;\n                \
  case \"y\":\n                    this.isState(\"casting-to-integer\") ? \
t2.push(this.output[1]) : t2.push(this.output[1], \".0\");\n                  \
  break;\n                  case \"z\":\n                    \
this.isState(\"casting-to-integer\") ? t2.push(this.output[2]) : \
t2.push(this.output[2], \".0\");\n                    break;\n                \
  default:\n                    throw this.astErrorOutput(\"Unexpected \
expression\", e2);\n                }\n                return t2;\n           \
   case \"value\":\n                throw this.astErrorOutput(\"Unexpected \
expression\", e2);\n              case \"value[]\":\n              case \
\"value[][]\":\n              case \"value[][][]\":\n              case \
\"value[][][][]\":\n              case \"value.value\":\n                if \
(\"Math\" === a2) return t2.push(Math[i2]), t2;\n                const s3 = \
n.sanitizeName(i2);\n                switch (r2) {\n                  case \
\"r\":\n                    return t2.push(`user_${s3}.r`), t2;\n             \
     case \"g\":\n                    return t2.push(`user_${s3}.g`), t2;\n   \
               case \"b\":\n                    return \
t2.push(`user_${s3}.b`), t2;\n                  case \"a\":\n                 \
   return t2.push(`user_${s3}.a`), t2;\n                }\n                \
break;\n              case \"this.constants.value\":\n                if \
(void 0 === u) switch (o) {\n                  case \"Array(2)\":\n           \
       case \"Array(3)\":\n                  case \"Array(4)\":\n             \
       return t2.push(`constants_${n.sanitizeName(i2)}`), t2;\n               \
 }\n              case \"this.constants.value[]\":\n              case \
\"this.constants.value[][]\":\n              case \
\"this.constants.value[][][]\":\n              case \
\"this.constants.value[][][][]\":\n                break;\n              case \
\"fn()[]\":\n                return this.astCallExpression(e2.object, t2), \
t2.push(\"[\"), t2.push(this.memberExpressionPropertyMarkup(r2)), \
t2.push(\"]\"), t2;\n              case \"fn()[][]\":\n                return \
this.astCallExpression(e2.object.object, t2), t2.push(\"[\"), \
t2.push(this.memberExpressionPropertyMarkup(e2.object.property)), \
t2.push(\"]\"), t2.push(\"[\"), \
t2.push(this.memberExpressionPropertyMarkup(e2.property)), t2.push(\"]\"), \
t2;\n              case \"[][]\":\n                return \
this.astArrayExpression(e2.object, t2), t2.push(\"[\"), \
t2.push(this.memberExpressionPropertyMarkup(r2)), t2.push(\"]\"), t2;\n       \
       default:\n                throw this.astErrorOutput(\"Unexpected \
expression\", e2);\n            }\n            if (false === e2.computed) \
switch (o) {\n              case \"Number\":\n              case \
\"Integer\":\n              case \"Float\":\n              case \
\"Boolean\":\n                return t2.push(`${a2}_${n.sanitizeName(i2)}`), \
t2;\n            }\n            const c = `${a2}_${n.sanitizeName(i2)}`;\n    \
        switch (o) {\n              case \"Array(2)\":\n              case \
\"Array(3)\":\n              case \"Array(4)\":\n                \
this.astGeneric(e2.object, t2), t2.push(\"[\"), \
t2.push(this.memberExpressionPropertyMarkup(u)), t2.push(\"]\");\n            \
    break;\n              case \"HTMLImageArray\":\n                \
t2.push(`getImage3D(${c}, ${c}Size, ${c}Dim, `), this.memberExpressionXYZ(u, \
l, h, t2), t2.push(\")\");\n                break;\n              case \
\"ArrayTexture(1)\":\n                t2.push(`getFloatFromSampler2D(${c}, \
${c}Size, ${c}Dim, `), this.memberExpressionXYZ(u, l, h, t2), \
t2.push(\")\");\n                break;\n              case \"Array1D(2)\":\n \
             case \"Array2D(2)\":\n              case \"Array3D(2)\":\n       \
         t2.push(`getMemoryOptimizedVec2(${c}, ${c}Size, ${c}Dim, `), \
this.memberExpressionXYZ(u, l, h, t2), t2.push(\")\");\n                \
break;\n              case \"ArrayTexture(2)\":\n                \
t2.push(`getVec2FromSampler2D(${c}, ${c}Size, ${c}Dim, `), \
this.memberExpressionXYZ(u, l, h, t2), t2.push(\")\");\n                \
break;\n              case \"Array1D(3)\":\n              case \
\"Array2D(3)\":\n              case \"Array3D(3)\":\n                \
t2.push(`getMemoryOptimizedVec3(${c}, ${c}Size, ${c}Dim, `), \
this.memberExpressionXYZ(u, l, h, t2), t2.push(\")\");\n                \
break;\n              case \"ArrayTexture(3)\":\n                \
t2.push(`getVec3FromSampler2D(${c}, ${c}Size, ${c}Dim, `), \
this.memberExpressionXYZ(u, l, h, t2), t2.push(\")\");\n                \
break;\n              case \"Array1D(4)\":\n              case \
\"Array2D(4)\":\n              case \"Array3D(4)\":\n                \
t2.push(`getMemoryOptimizedVec4(${c}, ${c}Size, ${c}Dim, `), \
this.memberExpressionXYZ(u, l, h, t2), t2.push(\")\");\n                \
break;\n              case \"ArrayTexture(4)\":\n              case \
\"HTMLCanvas\":\n              case \"OffscreenCanvas\":\n              case \
\"HTMLImage\":\n              case \"ImageBitmap\":\n              case \
\"ImageData\":\n              case \"HTMLVideo\":\n                \
t2.push(`getVec4FromSampler2D(${c}, ${c}Size, ${c}Dim, `), \
this.memberExpressionXYZ(u, l, h, t2), t2.push(\")\");\n                \
break;\n              case \"NumberTexture\":\n              case \
\"Array\":\n              case \"Array2D\":\n              case \
\"Array3D\":\n              case \"Array4D\":\n              case \
\"Input\":\n              case \"Number\":\n              case \"Float\":\n   \
           case \"Integer\":\n                if (\"single\" === \
this.precision) t2.push(`getMemoryOptimized32(${c}, ${c}Size, ${c}Dim, `), \
this.memberExpressionXYZ(u, l, h, t2), t2.push(\")\");\n                else \
{\n                  const e3 = \"user\" === a2 ? \
this.lookupFunctionArgumentBitRatio(this.name, i2) : \
this.constantBitRatios[i2];\n                  switch (e3) {\n                \
    case 1:\n                      t2.push(`get8(${c}, ${c}Size, ${c}Dim, \
`);\n                      break;\n                    case 2:\n              \
        t2.push(`get16(${c}, ${c}Size, ${c}Dim, `);\n                      \
break;\n                    case 4:\n                    case 0:\n            \
          t2.push(`get32(${c}, ${c}Size, ${c}Dim, `);\n                      \
break;\n                    default:\n                      throw new \
Error(`unhandled bit ratio of ${e3}`);\n                  }\n                 \
 this.memberExpressionXYZ(u, l, h, t2), t2.push(\")\");\n                }\n  \
              break;\n              case \"MemoryOptimizedNumberTexture\":\n  \
              t2.push(`getMemoryOptimized32(${c}, ${c}Size, ${c}Dim, `), \
this.memberExpressionXYZ(u, l, h, t2), t2.push(\")\");\n                \
break;\n              case \"Matrix(2)\":\n              case \
\"Matrix(3)\":\n              case \"Matrix(4)\":\n                \
t2.push(`${c}[${this.memberExpressionPropertyMarkup(l)}]`), l && \
t2.push(`[${this.memberExpressionPropertyMarkup(u)}]`);\n                \
break;\n              default:\n                throw new Error(`unhandled \
member expression \"${o}\"`);\n            }\n            return t2;\n        \
  }\n          astCallExpression(e2, t2) {\n            if (!e2.callee) throw \
this.astErrorOutput(\"Unknown CallExpression\", e2);\n            let r2 = \
null;\n            const i2 = this.isAstMathFunction(e2);\n            if (r2 \
= i2 || e2.callee.object && \"ThisExpression\" === e2.callee.object.type ? \
e2.callee.property.name : \"SequenceExpression\" !== e2.callee.type || \
\"Literal\" !== e2.callee.expressions[0].type || \
isNaN(e2.callee.expressions[0].raw) ? e2.callee.name : \
e2.callee.expressions[1].property.name, !r2) throw \
this.astErrorOutput(\"Unhandled function, couldn't find name\", e2);\n        \
    switch (r2) {\n              case \"pow\":\n                r2 = \
\"_pow\";\n                break;\n              case \"round\":\n            \
    r2 = \"_round\";\n            }\n            if \
(this.calledFunctions.indexOf(r2) < 0 && this.calledFunctions.push(r2), \
\"random\" === r2 && this.plugins && this.plugins.length > 0) for (let e3 = \
0; e3 < this.plugins.length; e3++) {\n              const r3 = \
this.plugins[e3];\n              if (\"Math.random()\" === r3.functionMatch \
&& r3.functionReplace) return t2.push(r3.functionReplace), t2;\n            \
}\n            if (this.onFunctionCall && this.onFunctionCall(this.name, r2, \
e2.arguments), t2.push(r2), t2.push(\"(\"), i2) for (let r3 = 0; r3 < \
e2.arguments.length; ++r3) {\n              const n2 = e2.arguments[r3], i3 = \
this.getType(n2);\n              if (r3 > 0 && t2.push(\", \"), \"Integer\" \
=== i3) this.castValueToFloat(n2, t2);\n              else \
this.astGeneric(n2, t2);\n            }\n            else {\n              \
const i3 = this.lookupFunctionArgumentTypes(r2) || [];\n              for \
(let s2 = 0; s2 < e2.arguments.length; ++s2) {\n                const a2 = \
e2.arguments[s2];\n                let o = i3[s2];\n                s2 > 0 && \
t2.push(\", \");\n                const u = this.getType(a2);\n               \
 switch (o || (this.triggerImplyArgumentType(r2, s2, u, this), o = u), u) {\n \
                 case \"Boolean\":\n                    this.astGeneric(a2, \
t2);\n                    continue;\n                  case \"Number\":\n     \
             case \"Float\":\n                    if (\"Integer\" === o) {\n  \
                    t2.push(\"int(\"), this.astGeneric(a2, t2), \
t2.push(\")\");\n                      continue;\n                    }\n     \
               if (\"Number\" === o || \"Float\" === o) {\n                   \
   this.astGeneric(a2, t2);\n                      continue;\n                \
    }\n                    if (\"LiteralInteger\" === o) {\n                  \
    this.castLiteralToFloat(a2, t2);\n                      continue;\n       \
             }\n                    break;\n                  case \
\"Integer\":\n                    if (\"Number\" === o || \"Float\" === o) \
{\n                      t2.push(\"float(\"), this.astGeneric(a2, t2), \
t2.push(\")\");\n                      continue;\n                    }\n     \
               if (\"Integer\" === o) {\n                      \
this.astGeneric(a2, t2);\n                      continue;\n                   \
 }\n                    break;\n                  case \"LiteralInteger\":\n  \
                  if (\"Integer\" === o) {\n                      \
this.castLiteralToInteger(a2, t2);\n                      continue;\n         \
           }\n                    if (\"Number\" === o || \"Float\" === o) \
{\n                      this.castLiteralToFloat(a2, t2);\n                   \
   continue;\n                    }\n                    if \
(\"LiteralInteger\" === o) {\n                      this.astGeneric(a2, \
t2);\n                      continue;\n                    }\n                \
    break;\n                  case \"Array(2)\":\n                  case \
\"Array(3)\":\n                  case \"Array(4)\":\n                    if \
(o === u) {\n                      if (\"Identifier\" === a2.type) \
t2.push(`user_${n.sanitizeName(a2.name)}`);\n                      else {\n   \
                     if (\"ArrayExpression\" !== a2.type && \
\"MemberExpression\" !== a2.type && \"CallExpression\" !== a2.type) throw \
this.astErrorOutput(`Unhandled argument type ${a2.type}`, e2);\n              \
          this.astGeneric(a2, t2);\n                      }\n                 \
     continue;\n                    }\n                    break;\n           \
       case \"HTMLCanvas\":\n                  case \"OffscreenCanvas\":\n    \
              case \"HTMLImage\":\n                  case \"ImageBitmap\":\n  \
                case \"ImageData\":\n                  case \
\"HTMLImageArray\":\n                  case \"HTMLVideo\":\n                  \
case \"ArrayTexture(1)\":\n                  case \"ArrayTexture(2)\":\n      \
            case \"ArrayTexture(3)\":\n                  case \
\"ArrayTexture(4)\":\n                  case \"Array\":\n                  \
case \"Input\":\n                    if (o === u) {\n                      if \
(\"Identifier\" !== a2.type) throw this.astErrorOutput(`Unhandled argument \
type ${a2.type}`, e2);\n                      \
this.triggerImplyArgumentBitRatio(this.name, a2.name, r2, s2);\n              \
        const i4 = n.sanitizeName(a2.name);\n                      \
t2.push(`user_${i4},user_${i4}Size,user_${i4}Dim`);\n                      \
continue;\n                    }\n                }\n                throw \
this.astErrorOutput(`Unhandled argument combination of ${u} and ${o} for \
argument named \"${a2.name}\"`, e2);\n              }\n            }\n        \
    return t2.push(\")\"), t2;\n          }\n          astArrayExpression(e2, \
t2) {\n            const r2 = this.getType(e2), n2 = e2.elements.length;\n    \
        switch (r2) {\n              case \"Matrix(2)\":\n              case \
\"Matrix(3)\":\n              case \"Matrix(4)\":\n                \
t2.push(`mat${n2}(`);\n                break;\n              default:\n       \
         t2.push(`vec${n2}(`);\n            }\n            for (let r3 = 0; \
r3 < n2; ++r3) {\n              r3 > 0 && t2.push(\", \");\n              \
const n3 = e2.elements[r3];\n              this.astGeneric(n3, t2);\n         \
   }\n            return t2.push(\")\"), t2;\n          }\n          \
memberExpressionXYZ(e2, t2, r2, n2) {\n            return r2 ? \
n2.push(this.memberExpressionPropertyMarkup(r2), \", \") : n2.push(\"0, \"), \
t2 ? n2.push(this.memberExpressionPropertyMarkup(t2), \", \") : n2.push(\"0, \
\"), n2.push(this.memberExpressionPropertyMarkup(e2)), n2;\n          }\n     \
     memberExpressionPropertyMarkup(e2) {\n            if (!e2) throw new \
Error(\"Property not set\");\n            const t2 = [];\n            switch \
(this.getType(e2)) {\n              case \"Number\":\n              case \
\"Float\":\n                this.castValueToInteger(e2, t2);\n                \
break;\n              case \"LiteralInteger\":\n                \
this.castLiteralToInteger(e2, t2);\n                break;\n              \
default:\n                this.astGeneric(e2, t2);\n            }\n           \
 return t2.join(\"\");\n          }\n        } };\n      }, { \
\"../../utils\": 114, \"../function-node\": 10 }], 39: [function(e, t, r) {\n \
       const { WebGLKernelValueBoolean: n } = e(\"./kernel-value/boolean\"), \
{ WebGLKernelValueFloat: i } = e(\"./kernel-value/float\"), { \
WebGLKernelValueInteger: s } = e(\"./kernel-value/integer\"), { \
WebGLKernelValueHTMLImage: a } = e(\"./kernel-value/html-image\"), { \
WebGLKernelValueDynamicHTMLImage: o } = \
e(\"./kernel-value/dynamic-html-image\"), { WebGLKernelValueHTMLVideo: u } = \
e(\"./kernel-value/html-video\"), { WebGLKernelValueDynamicHTMLVideo: l } = \
e(\"./kernel-value/dynamic-html-video\"), { WebGLKernelValueSingleInput: h } \
= e(\"./kernel-value/single-input\"), { WebGLKernelValueDynamicSingleInput: c \
} = e(\"./kernel-value/dynamic-single-input\"), { \
WebGLKernelValueUnsignedInput: p } = e(\"./kernel-value/unsigned-input\"), { \
WebGLKernelValueDynamicUnsignedInput: d } = \
e(\"./kernel-value/dynamic-unsigned-input\"), { \
WebGLKernelValueMemoryOptimizedNumberTexture: m } = \
e(\"./kernel-value/memory-optimized-number-texture\"), { \
WebGLKernelValueDynamicMemoryOptimizedNumberTexture: f } = \
e(\"./kernel-value/dynamic-memory-optimized-number-texture\"), { \
WebGLKernelValueNumberTexture: g } = e(\"./kernel-value/number-texture\"), { \
WebGLKernelValueDynamicNumberTexture: x } = \
e(\"./kernel-value/dynamic-number-texture\"), { WebGLKernelValueSingleArray: \
y } = e(\"./kernel-value/single-array\"), { \
WebGLKernelValueDynamicSingleArray: b } = \
e(\"./kernel-value/dynamic-single-array\"), { WebGLKernelValueSingleArray1DI: \
T } = e(\"./kernel-value/single-array1d-i\"), { \
WebGLKernelValueDynamicSingleArray1DI: v } = \
e(\"./kernel-value/dynamic-single-array1d-i\"), { \
WebGLKernelValueSingleArray2DI: S } = e(\"./kernel-value/single-array2d-i\"), \
{ WebGLKernelValueDynamicSingleArray2DI: A } = \
e(\"./kernel-value/dynamic-single-array2d-i\"), { \
WebGLKernelValueSingleArray3DI: _ } = e(\"./kernel-value/single-array3d-i\"), \
{ WebGLKernelValueDynamicSingleArray3DI: E } = \
e(\"./kernel-value/dynamic-single-array3d-i\"), { WebGLKernelValueArray2: w } \
= e(\"./kernel-value/array2\"), { WebGLKernelValueArray3: k } = \
e(\"./kernel-value/array3\"), { WebGLKernelValueArray4: I } = \
e(\"./kernel-value/array4\"), { WebGLKernelValueUnsignedArray: D } = \
e(\"./kernel-value/unsigned-array\"), { WebGLKernelValueDynamicUnsignedArray: \
C } = e(\"./kernel-value/dynamic-unsigned-array\"), $ = { unsigned: { \
dynamic: { Boolean: n, Integer: s, Float: i, Array: C, \"Array(2)\": w, \
\"Array(3)\": k, \"Array(4)\": I, \"Array1D(2)\": false, \"Array1D(3)\": \
false, \"Array1D(4)\": false, \"Array2D(2)\": false, \"Array2D(3)\": false, \
\"Array2D(4)\": false, \"Array3D(2)\": false, \"Array3D(3)\": false, \
\"Array3D(4)\": false, Input: d, NumberTexture: x, \"ArrayTexture(1)\": x, \
\"ArrayTexture(2)\": x, \"ArrayTexture(3)\": x, \"ArrayTexture(4)\": x, \
MemoryOptimizedNumberTexture: f, HTMLCanvas: o, OffscreenCanvas: o, \
HTMLImage: o, ImageBitmap: o, ImageData: o, HTMLImageArray: false, HTMLVideo: \
l }, static: { Boolean: n, Float: i, Integer: s, Array: D, \"Array(2)\": w, \
\"Array(3)\": k, \"Array(4)\": I, \"Array1D(2)\": false, \"Array1D(3)\": \
false, \"Array1D(4)\": false, \"Array2D(2)\": false, \"Array2D(3)\": false, \
\"Array2D(4)\": false, \"Array3D(2)\": false, \"Array3D(3)\": false, \
\"Array3D(4)\": false, Input: p, NumberTexture: g, \"ArrayTexture(1)\": g, \
\"ArrayTexture(2)\": g, \"ArrayTexture(3)\": g, \"ArrayTexture(4)\": g, \
MemoryOptimizedNumberTexture: m, HTMLCanvas: a, OffscreenCanvas: a, \
HTMLImage: a, ImageBitmap: a, ImageData: a, HTMLImageArray: false, HTMLVideo: \
u } }, single: { dynamic: { Boolean: n, Integer: s, Float: i, Array: b, \
\"Array(2)\": w, \"Array(3)\": k, \"Array(4)\": I, \"Array1D(2)\": v, \
\"Array1D(3)\": v, \"Array1D(4)\": v, \"Array2D(2)\": A, \"Array2D(3)\": A, \
\"Array2D(4)\": A, \"Array3D(2)\": E, \"Array3D(3)\": E, \"Array3D(4)\": E, \
Input: c, NumberTexture: x, \"ArrayTexture(1)\": x, \"ArrayTexture(2)\": x, \
\"ArrayTexture(3)\": x, \"ArrayTexture(4)\": x, MemoryOptimizedNumberTexture: \
f, HTMLCanvas: o, OffscreenCanvas: o, HTMLImage: o, ImageBitmap: o, \
ImageData: o, HTMLImageArray: false, HTMLVideo: l }, static: { Boolean: n, \
Float: i, Integer: s, Array: y, \"Array(2)\": w, \"Array(3)\": k, \
\"Array(4)\": I, \"Array1D(2)\": T, \"Array1D(3)\": T, \"Array1D(4)\": T, \
\"Array2D(2)\": S, \"Array2D(3)\": S, \"Array2D(4)\": S, \"Array3D(2)\": _, \
\"Array3D(3)\": _, \"Array3D(4)\": _, Input: h, NumberTexture: g, \
\"ArrayTexture(1)\": g, \"ArrayTexture(2)\": g, \"ArrayTexture(3)\": g, \
\"ArrayTexture(4)\": g, MemoryOptimizedNumberTexture: m, HTMLCanvas: a, \
OffscreenCanvas: a, HTMLImage: a, ImageBitmap: a, ImageData: a, \
HTMLImageArray: false, HTMLVideo: u } } };\n        t.exports = { \
lookupKernelValueType: function(e2, t2, r2, n2) {\n          if (!e2) throw \
new Error(\"type missing\");\n          if (!t2) throw new Error(\"dynamic \
missing\");\n          if (!r2) throw new Error(\"precision missing\");\n     \
     n2.type && (e2 = n2.type);\n          const i2 = $[r2][t2];\n          \
if (false === i2[e2]) return null;\n          if (void 0 === i2[e2]) throw \
new Error(`Could not find a KernelValue for ${e2}`);\n          return \
i2[e2];\n        }, kernelValueMaps: $ };\n      }, { \
\"./kernel-value/array2\": 41, \"./kernel-value/array3\": 42, \
\"./kernel-value/array4\": 43, \"./kernel-value/boolean\": 44, \
\"./kernel-value/dynamic-html-image\": 45, \
\"./kernel-value/dynamic-html-video\": 46, \
\"./kernel-value/dynamic-memory-optimized-number-texture\": 47, \
\"./kernel-value/dynamic-number-texture\": 48, \
\"./kernel-value/dynamic-single-array\": 49, \
\"./kernel-value/dynamic-single-array1d-i\": 50, \
\"./kernel-value/dynamic-single-array2d-i\": 51, \
\"./kernel-value/dynamic-single-array3d-i\": 52, \
\"./kernel-value/dynamic-single-input\": 53, \
\"./kernel-value/dynamic-unsigned-array\": 54, \
\"./kernel-value/dynamic-unsigned-input\": 55, \"./kernel-value/float\": 56, \
\"./kernel-value/html-image\": 57, \"./kernel-value/html-video\": 58, \
\"./kernel-value/integer\": 60, \
\"./kernel-value/memory-optimized-number-texture\": 61, \
\"./kernel-value/number-texture\": 62, \"./kernel-value/single-array\": 63, \
\"./kernel-value/single-array1d-i\": 64, \"./kernel-value/single-array2d-i\": \
65, \"./kernel-value/single-array3d-i\": 66, \"./kernel-value/single-input\": \
67, \"./kernel-value/unsigned-array\": 68, \"./kernel-value/unsigned-input\": \
69 }], 40: [function(e, t, r) {\n        const { WebGLKernelValue: n } = \
e(\"./index\"), { Input: i } = e(\"../../../input\");\n        t.exports = { \
WebGLKernelArray: class extends n {\n          checkSize(e2, t2) {\n          \
  if (!this.kernel.validate) return;\n            const { maxTextureSize: r2 \
} = this.kernel.constructor.features;\n            if (e2 > r2 || t2 > r2) \
throw e2 > t2 ? new Error(`Argument texture width of ${e2} larger than \
maximum size of ${r2} for your GPU`) : e2 < t2 ? new Error(`Argument texture \
height of ${t2} larger than maximum size of ${r2} for your GPU`) : new \
Error(`Argument texture height and width of ${t2} larger than maximum size of \
${r2} for your GPU`);\n          }\n          setup() {\n            \
this.requestTexture(), this.setupTexture(), this.defineTexture();\n          \
}\n          requestTexture() {\n            this.texture = \
this.onRequestTexture();\n          }\n          defineTexture() {\n          \
  const { context: e2 } = this;\n            \
e2.activeTexture(this.contextHandle), e2.bindTexture(e2.TEXTURE_2D, \
this.texture), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_S, \
e2.CLAMP_TO_EDGE), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_T, \
e2.CLAMP_TO_EDGE), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MIN_FILTER, \
e2.NEAREST), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MAG_FILTER, \
e2.NEAREST);\n          }\n          setupTexture() {\n            \
this.contextHandle = this.onRequestContextHandle(), this.index = \
this.onRequestIndex(), this.dimensionsId = this.id + \"Dim\", this.sizeId = \
this.id + \"Size\";\n          }\n          getBitRatio(e2) {\n            if \
(Array.isArray(e2[0])) return this.getBitRatio(e2[0]);\n            if \
(e2.constructor === i) return this.getBitRatio(e2.value);\n            switch \
(e2.constructor) {\n              case Uint8ClampedArray:\n              case \
Uint8Array:\n              case Int8Array:\n                return 1;\n       \
       case Uint16Array:\n              case Int16Array:\n                \
return 2;\n              case Float32Array:\n              case Int32Array:\n \
             default:\n                return 4;\n            }\n          \
}\n          destroy() {\n            this.prevArg && this.prevArg.delete(), \
this.context.deleteTexture(this.texture);\n          }\n        } };\n      \
}, { \"../../../input\": 110, \"./index\": 59 }], 41: [function(e, t, r) {\n  \
      const { WebGLKernelValue: n } = e(\"./index\");\n        t.exports = { \
WebGLKernelValueArray2: class extends n {\n          constructor(e2, t2) {\n  \
          super(e2, t2), this.uploadValue = e2;\n          }\n          \
getSource(e2) {\n            return \"constants\" === this.origin ? `const \
vec2 ${this.id} = vec2(${e2[0]},${e2[1]});\n` : `uniform vec2 \
${this.id};\n`;\n          }\n          getStringValueHandler() {\n           \
 return \"constants\" === this.origin ? \"\" : `const \
uploadValue_${this.name} = ${this.varName};\n`;\n          }\n          \
updateValue(e2) {\n            \"constants\" !== this.origin && \
this.kernel.setUniform2fv(this.id, this.uploadValue = e2);\n          }\n     \
   } };\n      }, { \"./index\": 59 }], 42: [function(e, t, r) {\n        \
const { WebGLKernelValue: n } = e(\"./index\");\n        t.exports = { \
WebGLKernelValueArray3: class extends n {\n          constructor(e2, t2) {\n  \
          super(e2, t2), this.uploadValue = e2;\n          }\n          \
getSource(e2) {\n            return \"constants\" === this.origin ? `const \
vec3 ${this.id} = vec3(${e2[0]},${e2[1]},${e2[2]});\n` : `uniform vec3 \
${this.id};\n`;\n          }\n          getStringValueHandler() {\n           \
 return \"constants\" === this.origin ? \"\" : `const \
uploadValue_${this.name} = ${this.varName};\n`;\n          }\n          \
updateValue(e2) {\n            \"constants\" !== this.origin && \
this.kernel.setUniform3fv(this.id, this.uploadValue = e2);\n          }\n     \
   } };\n      }, { \"./index\": 59 }], 43: [function(e, t, r) {\n        \
const { WebGLKernelValue: n } = e(\"./index\");\n        t.exports = { \
WebGLKernelValueArray4: class extends n {\n          constructor(e2, t2) {\n  \
          super(e2, t2), this.uploadValue = e2;\n          }\n          \
getSource(e2) {\n            return \"constants\" === this.origin ? `const \
vec4 ${this.id} = vec4(${e2[0]},${e2[1]},${e2[2]},${e2[3]});\n` : `uniform \
vec4 ${this.id};\n`;\n          }\n          getStringValueHandler() {\n      \
      return \"constants\" === this.origin ? \"\" : `const \
uploadValue_${this.name} = ${this.varName};\n`;\n          }\n          \
updateValue(e2) {\n            \"constants\" !== this.origin && \
this.kernel.setUniform4fv(this.id, this.uploadValue = e2);\n          }\n     \
   } };\n      }, { \"./index\": 59 }], 44: [function(e, t, r) {\n        \
const { utils: n } = e(\"../../../utils\"), { WebGLKernelValue: i } = \
e(\"./index\");\n        t.exports = { WebGLKernelValueBoolean: class extends \
i {\n          constructor(e2, t2) {\n            super(e2, t2), \
this.uploadValue = e2;\n          }\n          getSource(e2) {\n            \
return \"constants\" === this.origin ? `const bool ${this.id} = ${e2};\n` : \
`uniform bool ${this.id};\n`;\n          }\n          getStringValueHandler() \
{\n            return `const uploadValue_${this.name} = \
${this.varName};\n`;\n          }\n          updateValue(e2) {\n            \
\"constants\" !== this.origin && this.kernel.setUniform1i(this.id, \
this.uploadValue = e2);\n          }\n        } };\n      }, { \
\"../../../utils\": 114, \"./index\": 59 }], 45: [function(e, t, r) {\n       \
 const { utils: n } = e(\"../../../utils\"), { WebGLKernelValueHTMLImage: i } \
= e(\"./html-image\");\n        t.exports = { \
WebGLKernelValueDynamicHTMLImage: class extends i {\n          getSource() \
{\n            return n.linesToString([`uniform sampler2D ${this.id}`, \
`uniform ivec2 ${this.sizeId}`, `uniform ivec3 ${this.dimensionsId}`]);\n     \
     }\n          updateValue(e2) {\n            const { width: t2, height: \
r2 } = e2;\n            this.checkSize(t2, r2), this.dimensions = [t2, r2, \
1], this.textureSize = [t2, r2], this.kernel.setUniform3iv(this.dimensionsId, \
this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), \
super.updateValue(e2);\n          }\n        } };\n      }, { \
\"../../../utils\": 114, \"./html-image\": 57 }], 46: [function(e, t, r) {\n  \
      const { WebGLKernelValueDynamicHTMLImage: n } = \
e(\"./dynamic-html-image\");\n        t.exports = { \
WebGLKernelValueDynamicHTMLVideo: class extends n {\n        } };\n      }, { \
\"./dynamic-html-image\": 45 }], 47: [function(e, t, r) {\n        const { \
utils: n } = e(\"../../../utils\"), { \
WebGLKernelValueMemoryOptimizedNumberTexture: i } = \
e(\"./memory-optimized-number-texture\");\n        t.exports = { \
WebGLKernelValueDynamicMemoryOptimizedNumberTexture: class extends i {\n      \
    getSource() {\n            return n.linesToString([`uniform sampler2D \
${this.id}`, `uniform ivec2 ${this.sizeId}`, `uniform ivec3 \
${this.dimensionsId}`]);\n          }\n          updateValue(e2) {\n          \
  this.dimensions = e2.dimensions, this.checkSize(e2.size[0], e2.size[1]), \
this.textureSize = e2.size, this.kernel.setUniform3iv(this.dimensionsId, \
this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), \
super.updateValue(e2);\n          }\n        } };\n      }, { \
\"../../../utils\": 114, \"./memory-optimized-number-texture\": 61 }], 48: \
[function(e, t, r) {\n        const { utils: n } = e(\"../../../utils\"), { \
WebGLKernelValueNumberTexture: i } = e(\"./number-texture\");\n        \
t.exports = { WebGLKernelValueDynamicNumberTexture: class extends i {\n       \
   getSource() {\n            return n.linesToString([`uniform sampler2D \
${this.id}`, `uniform ivec2 ${this.sizeId}`, `uniform ivec3 \
${this.dimensionsId}`]);\n          }\n          updateValue(e2) {\n          \
  this.dimensions = e2.dimensions, this.checkSize(e2.size[0], e2.size[1]), \
this.textureSize = e2.size, this.kernel.setUniform3iv(this.dimensionsId, \
this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), \
super.updateValue(e2);\n          }\n        } };\n      }, { \
\"../../../utils\": 114, \"./number-texture\": 62 }], 49: [function(e, t, r) \
{\n        const { utils: n } = e(\"../../../utils\"), { \
WebGLKernelValueSingleArray: i } = e(\"./single-array\");\n        t.exports \
= { WebGLKernelValueDynamicSingleArray: class extends i {\n          \
getSource() {\n            return n.linesToString([`uniform sampler2D \
${this.id}`, `uniform ivec2 ${this.sizeId}`, `uniform ivec3 \
${this.dimensionsId}`]);\n          }\n          updateValue(e2) {\n          \
  this.dimensions = n.getDimensions(e2, true), this.textureSize = \
n.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio), \
this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * \
this.bitRatio, this.checkSize(this.textureSize[0], this.textureSize[1]), \
this.uploadValue = new Float32Array(this.uploadArrayLength), \
this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), \
this.kernel.setUniform2iv(this.sizeId, this.textureSize), \
super.updateValue(e2);\n          }\n        } };\n      }, { \
\"../../../utils\": 114, \"./single-array\": 63 }], 50: [function(e, t, r) \
{\n        const { utils: n } = e(\"../../../utils\"), { \
WebGLKernelValueSingleArray1DI: i } = e(\"./single-array1d-i\");\n        \
t.exports = { WebGLKernelValueDynamicSingleArray1DI: class extends i {\n      \
    getSource() {\n            return n.linesToString([`uniform sampler2D \
${this.id}`, `uniform ivec2 ${this.sizeId}`, `uniform ivec3 \
${this.dimensionsId}`]);\n          }\n          updateValue(e2) {\n          \
  this.setShape(e2), this.kernel.setUniform3iv(this.dimensionsId, \
this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), \
super.updateValue(e2);\n          }\n        } };\n      }, { \
\"../../../utils\": 114, \"./single-array1d-i\": 64 }], 51: [function(e, t, \
r) {\n        const { utils: n } = e(\"../../../utils\"), { \
WebGLKernelValueSingleArray2DI: i } = e(\"./single-array2d-i\");\n        \
t.exports = { WebGLKernelValueDynamicSingleArray2DI: class extends i {\n      \
    getSource() {\n            return n.linesToString([`uniform sampler2D \
${this.id}`, `uniform ivec2 ${this.sizeId}`, `uniform ivec3 \
${this.dimensionsId}`]);\n          }\n          updateValue(e2) {\n          \
  this.setShape(e2), this.kernel.setUniform3iv(this.dimensionsId, \
this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), \
super.updateValue(e2);\n          }\n        } };\n      }, { \
\"../../../utils\": 114, \"./single-array2d-i\": 65 }], 52: [function(e, t, \
r) {\n        const { utils: n } = e(\"../../../utils\"), { \
WebGLKernelValueSingleArray3DI: i } = e(\"./single-array3d-i\");\n        \
t.exports = { WebGLKernelValueDynamicSingleArray3DI: class extends i {\n      \
    getSource() {\n            return n.linesToString([`uniform sampler2D \
${this.id}`, `uniform ivec2 ${this.sizeId}`, `uniform ivec3 \
${this.dimensionsId}`]);\n          }\n          updateValue(e2) {\n          \
  this.setShape(e2), this.kernel.setUniform3iv(this.dimensionsId, \
this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), \
super.updateValue(e2);\n          }\n        } };\n      }, { \
\"../../../utils\": 114, \"./single-array3d-i\": 66 }], 53: [function(e, t, \
r) {\n        const { utils: n } = e(\"../../../utils\"), { \
WebGLKernelValueSingleInput: i } = e(\"./single-input\");\n        t.exports \
= { WebGLKernelValueDynamicSingleInput: class extends i {\n          \
getSource() {\n            return n.linesToString([`uniform sampler2D \
${this.id}`, `uniform ivec2 ${this.sizeId}`, `uniform ivec3 \
${this.dimensionsId}`]);\n          }\n          updateValue(e2) {\n          \
  let [t2, r2, i2] = e2.size;\n            this.dimensions = new \
Int32Array([t2 || 1, r2 || 1, i2 || 1]), this.textureSize = \
n.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio), \
this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * \
this.bitRatio, this.checkSize(this.textureSize[0], this.textureSize[1]), \
this.uploadValue = new Float32Array(this.uploadArrayLength), \
this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), \
this.kernel.setUniform2iv(this.sizeId, this.textureSize), \
super.updateValue(e2);\n          }\n        } };\n      }, { \
\"../../../utils\": 114, \"./single-input\": 67 }], 54: [function(e, t, r) \
{\n        const { utils: n } = e(\"../../../utils\"), { \
WebGLKernelValueUnsignedArray: i } = e(\"./unsigned-array\");\n        \
t.exports = { WebGLKernelValueDynamicUnsignedArray: class extends i {\n       \
   getSource() {\n            return n.linesToString([`uniform sampler2D \
${this.id}`, `uniform ivec2 ${this.sizeId}`, `uniform ivec3 \
${this.dimensionsId}`]);\n          }\n          updateValue(e2) {\n          \
  this.dimensions = n.getDimensions(e2, true), this.textureSize = \
n.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio), \
this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / \
this.bitRatio), this.checkSize(this.textureSize[0], this.textureSize[1]);\n   \
         const t2 = this.getTransferArrayType(e2);\n            \
this.preUploadValue = new t2(this.uploadArrayLength), this.uploadValue = new \
Uint8Array(this.preUploadValue.buffer), \
this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), \
this.kernel.setUniform2iv(this.sizeId, this.textureSize), \
super.updateValue(e2);\n          }\n        } };\n      }, { \
\"../../../utils\": 114, \"./unsigned-array\": 68 }], 55: [function(e, t, r) \
{\n        const { utils: n } = e(\"../../../utils\"), { \
WebGLKernelValueUnsignedInput: i } = e(\"./unsigned-input\");\n        \
t.exports = { WebGLKernelValueDynamicUnsignedInput: class extends i {\n       \
   getSource() {\n            return n.linesToString([`uniform sampler2D \
${this.id}`, `uniform ivec2 ${this.sizeId}`, `uniform ivec3 \
${this.dimensionsId}`]);\n          }\n          updateValue(e2) {\n          \
  let [t2, r2, i2] = e2.size;\n            this.dimensions = new \
Int32Array([t2 || 1, r2 || 1, i2 || 1]), this.textureSize = \
n.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio), \
this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / \
this.bitRatio), this.checkSize(this.textureSize[0], this.textureSize[1]);\n   \
         const s = this.getTransferArrayType(e2.value);\n            \
this.preUploadValue = new s(this.uploadArrayLength), this.uploadValue = new \
Uint8Array(this.preUploadValue.buffer), \
this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), \
this.kernel.setUniform2iv(this.sizeId, this.textureSize), \
super.updateValue(e2);\n          }\n        } };\n      }, { \
\"../../../utils\": 114, \"./unsigned-input\": 69 }], 56: [function(e, t, r) \
{\n        const { utils: n } = e(\"../../../utils\"), { WebGLKernelValue: i \
} = e(\"./index\");\n        t.exports = { WebGLKernelValueFloat: class \
extends i {\n          constructor(e2, t2) {\n            super(e2, t2), \
this.uploadValue = e2;\n          }\n          getStringValueHandler() {\n    \
        return `const uploadValue_${this.name} = ${this.varName};\n`;\n       \
   }\n          getSource(e2) {\n            return \"constants\" === \
this.origin ? Number.isInteger(e2) ? `const float ${this.id} = ${e2}.0;\n` : \
`const float ${this.id} = ${e2};\n` : `uniform float ${this.id};\n`;\n        \
  }\n          updateValue(e2) {\n            \"constants\" !== this.origin \
&& this.kernel.setUniform1f(this.id, this.uploadValue = e2);\n          }\n   \
     } };\n      }, { \"../../../utils\": 114, \"./index\": 59 }], 57: \
[function(e, t, r) {\n        const { utils: n } = e(\"../../../utils\"), { \
WebGLKernelArray: i } = e(\"./array\");\n        t.exports = { \
WebGLKernelValueHTMLImage: class extends i {\n          constructor(e2, t2) \
{\n            super(e2, t2);\n            const { width: r2, height: n2 } = \
e2;\n            this.checkSize(r2, n2), this.dimensions = [r2, n2, 1], \
this.textureSize = [r2, n2], this.uploadValue = e2;\n          }\n          \
getStringValueHandler() {\n            return `const uploadValue_${this.name} \
= ${this.varName};\n`;\n          }\n          getSource() {\n            \
return n.linesToString([`uniform sampler2D ${this.id}`, `ivec2 ${this.sizeId} \
= ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`, `ivec3 \
${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, \
${this.dimensions[2]})`]);\n          }\n          updateValue(e2) {\n        \
    if (e2.constructor !== this.initialValueConstructor) return void \
this.onUpdateValueMismatch(e2.constructor);\n            const { context: t2 \
} = this;\n            t2.activeTexture(this.contextHandle), \
t2.bindTexture(t2.TEXTURE_2D, this.texture), \
t2.pixelStorei(t2.UNPACK_FLIP_Y_WEBGL, true), t2.texImage2D(t2.TEXTURE_2D, 0, \
t2.RGBA, t2.RGBA, t2.UNSIGNED_BYTE, this.uploadValue = e2), \
this.kernel.setUniform1i(this.id, this.index);\n          }\n        } };\n   \
   }, { \"../../../utils\": 114, \"./array\": 40 }], 58: [function(e, t, r) \
{\n        const { WebGLKernelValueHTMLImage: n } = e(\"./html-image\");\n    \
    t.exports = { WebGLKernelValueHTMLVideo: class extends n {\n        } \
};\n      }, { \"./html-image\": 57 }], 59: [function(e, t, r) {\n        \
const { utils: n } = e(\"../../../utils\"), { KernelValue: i } = \
e(\"../../kernel-value\");\n        t.exports = { WebGLKernelValue: class \
extends i {\n          constructor(e2, t2) {\n            super(e2, t2), \
this.dimensionsId = null, this.sizeId = null, this.initialValueConstructor = \
e2.constructor, this.onRequestTexture = t2.onRequestTexture, \
this.onRequestIndex = t2.onRequestIndex, this.uploadValue = null, \
this.textureSize = null, this.bitRatio = null, this.prevArg = null;\n         \
 }\n          get id() {\n            return \
`${this.origin}_${n.sanitizeName(this.name)}`;\n          }\n          \
setup() {\n          }\n          getTransferArrayType(e2) {\n            if \
(Array.isArray(e2[0])) return this.getTransferArrayType(e2[0]);\n            \
switch (e2.constructor) {\n              case Array:\n              case \
Int32Array:\n              case Int16Array:\n              case Int8Array:\n  \
              return Float32Array;\n              case Uint8ClampedArray:\n   \
           case Uint8Array:\n              case Uint16Array:\n              \
case Uint32Array:\n              case Float32Array:\n              case \
Float64Array:\n                return e2.constructor;\n            }\n        \
    return console.warn(\"Unfamiliar constructor type.  Will go ahead and \
use, but likley this may result in a transfer of zeros\"), e2.constructor;\n  \
        }\n          getStringValueHandler() {\n            throw new \
Error(`\"getStringValueHandler\" not implemented on \
${this.constructor.name}`);\n          }\n          \
getVariablePrecisionString() {\n            return \
this.kernel.getVariablePrecisionString(this.textureSize || void 0, \
this.tactic || void 0);\n          }\n          destroy() {\n          }\n    \
    } };\n      }, { \"../../../utils\": 114, \"../../kernel-value\": 35 }], \
60: [function(e, t, r) {\n        const { utils: n } = e(\"../../../utils\"), \
{ WebGLKernelValue: i } = e(\"./index\");\n        t.exports = { \
WebGLKernelValueInteger: class extends i {\n          constructor(e2, t2) {\n \
           super(e2, t2), this.uploadValue = e2;\n          }\n          \
getStringValueHandler() {\n            return `const uploadValue_${this.name} \
= ${this.varName};\n`;\n          }\n          getSource(e2) {\n            \
return \"constants\" === this.origin ? `const int ${this.id} = \
${parseInt(e2)};\n` : `uniform int ${this.id};\n`;\n          }\n          \
updateValue(e2) {\n            \"constants\" !== this.origin && \
this.kernel.setUniform1i(this.id, this.uploadValue = e2);\n          }\n      \
  } };\n      }, { \"../../../utils\": 114, \"./index\": 59 }], 61: \
[function(e, t, r) {\n        const { utils: n } = e(\"../../../utils\"), { \
WebGLKernelArray: i } = e(\"./array\"), s = \"Source and destination textures \
are the same.  Use immutable = true and manually cleanup kernel output \
texture memory with texture.delete()\";\n        t.exports = { \
WebGLKernelValueMemoryOptimizedNumberTexture: class extends i {\n          \
constructor(e2, t2) {\n            super(e2, t2);\n            const [r2, n2] \
= e2.size;\n            this.checkSize(r2, n2), this.dimensions = \
e2.dimensions, this.textureSize = e2.size, this.uploadValue = e2.texture, \
this.forceUploadEachRun = true;\n          }\n          setup() {\n           \
 this.setupTexture();\n          }\n          getStringValueHandler() {\n     \
       return `const uploadValue_${this.name} = \
${this.varName}.texture;\n`;\n          }\n          getSource() {\n          \
  return n.linesToString([`uniform sampler2D ${this.id}`, `ivec2 \
${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`, \
`ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, \
${this.dimensions[1]}, ${this.dimensions[2]})`]);\n          }\n          \
updateValue(e2) {\n            if (e2.constructor !== \
this.initialValueConstructor) return void \
this.onUpdateValueMismatch(e2.constructor);\n            if \
(this.checkContext && e2.context !== this.context) throw new Error(`Value \
${this.name} (${this.type}) must be from same context`);\n            const { \
kernel: t2, context: r2 } = this;\n            if (t2.pipeline) if \
(t2.immutable) t2.updateTextureArgumentRefs(this, e2);\n            else {\n  \
            if (t2.texture && t2.texture.texture === e2.texture) throw new \
Error(s);\n              if (t2.mappedTextures) {\n                const { \
mappedTextures: r3 } = t2;\n                for (let t3 = 0; t3 < r3.length; \
t3++) if (r3[t3].texture === e2.texture) throw new Error(s);\n              \
}\n            }\n            r2.activeTexture(this.contextHandle), \
r2.bindTexture(r2.TEXTURE_2D, this.uploadValue = e2.texture), \
this.kernel.setUniform1i(this.id, this.index);\n          }\n        }, \
sameError: s };\n      }, { \"../../../utils\": 114, \"./array\": 40 }], 62: \
[function(e, t, r) {\n        const { utils: n } = e(\"../../../utils\"), { \
WebGLKernelArray: i } = e(\"./array\"), { sameError: s } = \
e(\"./memory-optimized-number-texture\");\n        t.exports = { \
WebGLKernelValueNumberTexture: class extends i {\n          constructor(e2, \
t2) {\n            super(e2, t2);\n            const [r2, n2] = e2.size;\n    \
        this.checkSize(r2, n2);\n            const { size: i2, dimensions: s2 \
} = e2;\n            this.bitRatio = this.getBitRatio(e2), this.dimensions = \
s2, this.textureSize = i2, this.uploadValue = e2.texture, \
this.forceUploadEachRun = true;\n          }\n          setup() {\n           \
 this.setupTexture();\n          }\n          getStringValueHandler() {\n     \
       return `const uploadValue_${this.name} = \
${this.varName}.texture;\n`;\n          }\n          getSource() {\n          \
  return n.linesToString([`uniform sampler2D ${this.id}`, `ivec2 \
${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`, \
`ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, \
${this.dimensions[1]}, ${this.dimensions[2]})`]);\n          }\n          \
updateValue(e2) {\n            if (e2.constructor !== \
this.initialValueConstructor) return void \
this.onUpdateValueMismatch(e2.constructor);\n            if \
(this.checkContext && e2.context !== this.context) throw new Error(`Value \
${this.name} (${this.type}) must be from same context`);\n            const { \
kernel: t2, context: r2 } = this;\n            if (t2.pipeline) if \
(t2.immutable) t2.updateTextureArgumentRefs(this, e2);\n            else {\n  \
            if (t2.texture && t2.texture.texture === e2.texture) throw new \
Error(s);\n              if (t2.mappedTextures) {\n                const { \
mappedTextures: r3 } = t2;\n                for (let t3 = 0; t3 < r3.length; \
t3++) if (r3[t3].texture === e2.texture) throw new Error(s);\n              \
}\n            }\n            r2.activeTexture(this.contextHandle), \
r2.bindTexture(r2.TEXTURE_2D, this.uploadValue = e2.texture), \
this.kernel.setUniform1i(this.id, this.index);\n          }\n        } };\n   \
   }, { \"../../../utils\": 114, \"./array\": 40, \
\"./memory-optimized-number-texture\": 61 }], 63: [function(e, t, r) {\n      \
  const { utils: n } = e(\"../../../utils\"), { WebGLKernelArray: i } = \
e(\"./array\");\n        t.exports = { WebGLKernelValueSingleArray: class \
extends i {\n          constructor(e2, t2) {\n            super(e2, t2), \
this.bitRatio = 4, this.dimensions = n.getDimensions(e2, true), \
this.textureSize = n.getMemoryOptimizedFloatTextureSize(this.dimensions, \
this.bitRatio), this.uploadArrayLength = this.textureSize[0] * \
this.textureSize[1] * this.bitRatio, this.checkSize(this.textureSize[0], \
this.textureSize[1]), this.uploadValue = new \
Float32Array(this.uploadArrayLength);\n          }\n          \
getStringValueHandler() {\n            return n.linesToString([`const \
uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`, \
`flattenTo(${this.varName}, uploadValue_${this.name})`]);\n          }\n      \
    getSource() {\n            return n.linesToString([`uniform sampler2D \
${this.id}`, `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, \
${this.textureSize[1]})`, `ivec3 ${this.dimensionsId} = \
ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, \
${this.dimensions[2]})`]);\n          }\n          updateValue(e2) {\n        \
    if (e2.constructor !== this.initialValueConstructor) return void \
this.onUpdateValueMismatch(e2.constructor);\n            const { context: t2 \
} = this;\n            n.flattenTo(e2, this.uploadValue), \
t2.activeTexture(this.contextHandle), t2.bindTexture(t2.TEXTURE_2D, \
this.texture), t2.pixelStorei(t2.UNPACK_FLIP_Y_WEBGL, false), \
t2.texImage2D(t2.TEXTURE_2D, 0, t2.RGBA, this.textureSize[0], \
this.textureSize[1], 0, t2.RGBA, t2.FLOAT, this.uploadValue), \
this.kernel.setUniform1i(this.id, this.index);\n          }\n        } };\n   \
   }, { \"../../../utils\": 114, \"./array\": 40 }], 64: [function(e, t, r) \
{\n        const { utils: n } = e(\"../../../utils\"), { WebGLKernelArray: i \
} = e(\"./array\");\n        t.exports = { WebGLKernelValueSingleArray1DI: \
class extends i {\n          constructor(e2, t2) {\n            super(e2, \
t2), this.bitRatio = 4, this.setShape(e2);\n          }\n          \
setShape(e2) {\n            const t2 = n.getDimensions(e2, true);\n           \
 this.textureSize = n.getMemoryOptimizedFloatTextureSize(t2, this.bitRatio), \
this.dimensions = new Int32Array([t2[1], 1, 1]), this.uploadArrayLength = \
this.textureSize[0] * this.textureSize[1] * this.bitRatio, \
this.checkSize(this.textureSize[0], this.textureSize[1]), this.uploadValue = \
new Float32Array(this.uploadArrayLength);\n          }\n          \
getStringValueHandler() {\n            return n.linesToString([`const \
uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`, \
`flattenTo(${this.varName}, uploadValue_${this.name})`]);\n          }\n      \
    getSource() {\n            return n.linesToString([`uniform sampler2D \
${this.id}`, `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, \
${this.textureSize[1]})`, `ivec3 ${this.dimensionsId} = \
ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, \
${this.dimensions[2]})`]);\n          }\n          updateValue(e2) {\n        \
    if (e2.constructor !== this.initialValueConstructor) return void \
this.onUpdateValueMismatch(e2.constructor);\n            const { context: t2 \
} = this;\n            n.flatten2dArrayTo(e2, this.uploadValue), \
t2.activeTexture(this.contextHandle), t2.bindTexture(t2.TEXTURE_2D, \
this.texture), t2.pixelStorei(t2.UNPACK_FLIP_Y_WEBGL, false), \
t2.texImage2D(t2.TEXTURE_2D, 0, t2.RGBA, this.textureSize[0], \
this.textureSize[1], 0, t2.RGBA, t2.FLOAT, this.uploadValue), \
this.kernel.setUniform1i(this.id, this.index);\n          }\n        } };\n   \
   }, { \"../../../utils\": 114, \"./array\": 40 }], 65: [function(e, t, r) \
{\n        const { utils: n } = e(\"../../../utils\"), { WebGLKernelArray: i \
} = e(\"./array\");\n        t.exports = { WebGLKernelValueSingleArray2DI: \
class extends i {\n          constructor(e2, t2) {\n            super(e2, \
t2), this.bitRatio = 4, this.setShape(e2);\n          }\n          \
setShape(e2) {\n            const t2 = n.getDimensions(e2, true);\n           \
 this.textureSize = n.getMemoryOptimizedFloatTextureSize(t2, this.bitRatio), \
this.dimensions = new Int32Array([t2[1], t2[2], 1]), this.uploadArrayLength = \
this.textureSize[0] * this.textureSize[1] * this.bitRatio, \
this.checkSize(this.textureSize[0], this.textureSize[1]), this.uploadValue = \
new Float32Array(this.uploadArrayLength);\n          }\n          \
getStringValueHandler() {\n            return n.linesToString([`const \
uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`, \
`flattenTo(${this.varName}, uploadValue_${this.name})`]);\n          }\n      \
    getSource() {\n            return n.linesToString([`uniform sampler2D \
${this.id}`, `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, \
${this.textureSize[1]})`, `ivec3 ${this.dimensionsId} = \
ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, \
${this.dimensions[2]})`]);\n          }\n          updateValue(e2) {\n        \
    if (e2.constructor !== this.initialValueConstructor) return void \
this.onUpdateValueMismatch(e2.constructor);\n            const { context: t2 \
} = this;\n            n.flatten3dArrayTo(e2, this.uploadValue), \
t2.activeTexture(this.contextHandle), t2.bindTexture(t2.TEXTURE_2D, \
this.texture), t2.pixelStorei(t2.UNPACK_FLIP_Y_WEBGL, false), \
t2.texImage2D(t2.TEXTURE_2D, 0, t2.RGBA, this.textureSize[0], \
this.textureSize[1], 0, t2.RGBA, t2.FLOAT, this.uploadValue), \
this.kernel.setUniform1i(this.id, this.index);\n          }\n        } };\n   \
   }, { \"../../../utils\": 114, \"./array\": 40 }], 66: [function(e, t, r) \
{\n        const { utils: n } = e(\"../../../utils\"), { WebGLKernelArray: i \
} = e(\"./array\");\n        t.exports = { WebGLKernelValueSingleArray3DI: \
class extends i {\n          constructor(e2, t2) {\n            super(e2, \
t2), this.bitRatio = 4, this.setShape(e2);\n          }\n          \
setShape(e2) {\n            const t2 = n.getDimensions(e2, true);\n           \
 this.textureSize = n.getMemoryOptimizedFloatTextureSize(t2, this.bitRatio), \
this.dimensions = new Int32Array([t2[1], t2[2], t2[3]]), \
this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * \
this.bitRatio, this.checkSize(this.textureSize[0], this.textureSize[1]), \
this.uploadValue = new Float32Array(this.uploadArrayLength);\n          }\n   \
       getStringValueHandler() {\n            return n.linesToString([`const \
uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`, \
`flattenTo(${this.varName}, uploadValue_${this.name})`]);\n          }\n      \
    getSource() {\n            return n.linesToString([`uniform sampler2D \
${this.id}`, `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, \
${this.textureSize[1]})`, `ivec3 ${this.dimensionsId} = \
ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, \
${this.dimensions[2]})`]);\n          }\n          updateValue(e2) {\n        \
    if (e2.constructor !== this.initialValueConstructor) return void \
this.onUpdateValueMismatch(e2.constructor);\n            const { context: t2 \
} = this;\n            n.flatten4dArrayTo(e2, this.uploadValue), \
t2.activeTexture(this.contextHandle), t2.bindTexture(t2.TEXTURE_2D, \
this.texture), t2.pixelStorei(t2.UNPACK_FLIP_Y_WEBGL, false), \
t2.texImage2D(t2.TEXTURE_2D, 0, t2.RGBA, this.textureSize[0], \
this.textureSize[1], 0, t2.RGBA, t2.FLOAT, this.uploadValue), \
this.kernel.setUniform1i(this.id, this.index);\n          }\n        } };\n   \
   }, { \"../../../utils\": 114, \"./array\": 40 }], 67: [function(e, t, r) \
{\n        const { utils: n } = e(\"../../../utils\"), { WebGLKernelArray: i \
} = e(\"./array\");\n        t.exports = { WebGLKernelValueSingleInput: class \
extends i {\n          constructor(e2, t2) {\n            super(e2, t2), \
this.bitRatio = 4;\n            let [r2, i2, s] = e2.size;\n            \
this.dimensions = new Int32Array([r2 || 1, i2 || 1, s || 1]), \
this.textureSize = n.getMemoryOptimizedFloatTextureSize(this.dimensions, \
this.bitRatio), this.uploadArrayLength = this.textureSize[0] * \
this.textureSize[1] * this.bitRatio, this.checkSize(this.textureSize[0], \
this.textureSize[1]), this.uploadValue = new \
Float32Array(this.uploadArrayLength);\n          }\n          \
getStringValueHandler() {\n            return n.linesToString([`const \
uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`, \
`flattenTo(${this.varName}.value, uploadValue_${this.name})`]);\n          \
}\n          getSource() {\n            return n.linesToString([`uniform \
sampler2D ${this.id}`, `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, \
${this.textureSize[1]})`, `ivec3 ${this.dimensionsId} = \
ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, \
${this.dimensions[2]})`]);\n          }\n          updateValue(e2) {\n        \
    if (e2.constructor !== this.initialValueConstructor) return void \
this.onUpdateValueMismatch(e2.constructor);\n            const { context: t2 \
} = this;\n            n.flattenTo(e2.value, this.uploadValue), \
t2.activeTexture(this.contextHandle), t2.bindTexture(t2.TEXTURE_2D, \
this.texture), t2.pixelStorei(t2.UNPACK_FLIP_Y_WEBGL, false), \
t2.texImage2D(t2.TEXTURE_2D, 0, t2.RGBA, this.textureSize[0], \
this.textureSize[1], 0, t2.RGBA, t2.FLOAT, this.uploadValue), \
this.kernel.setUniform1i(this.id, this.index);\n          }\n        } };\n   \
   }, { \"../../../utils\": 114, \"./array\": 40 }], 68: [function(e, t, r) \
{\n        const { utils: n } = e(\"../../../utils\"), { WebGLKernelArray: i \
} = e(\"./array\");\n        t.exports = { WebGLKernelValueUnsignedArray: \
class extends i {\n          constructor(e2, t2) {\n            super(e2, \
t2), this.bitRatio = this.getBitRatio(e2), this.dimensions = \
n.getDimensions(e2, true), this.textureSize = \
n.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio), \
this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / \
this.bitRatio), this.checkSize(this.textureSize[0], this.textureSize[1]), \
this.TranserArrayType = this.getTransferArrayType(e2), this.preUploadValue = \
new this.TranserArrayType(this.uploadArrayLength), this.uploadValue = new \
Uint8Array(this.preUploadValue.buffer);\n          }\n          \
getStringValueHandler() {\n            return n.linesToString([`const \
preUploadValue_${this.name} = new \
${this.TranserArrayType.name}(${this.uploadArrayLength})`, `const \
uploadValue_${this.name} = new \
Uint8Array(preUploadValue_${this.name}.buffer)`, `flattenTo(${this.varName}, \
preUploadValue_${this.name})`]);\n          }\n          getSource() {\n      \
      return n.linesToString([`uniform sampler2D ${this.id}`, `ivec2 \
${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`, \
`ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, \
${this.dimensions[1]}, ${this.dimensions[2]})`]);\n          }\n          \
updateValue(e2) {\n            if (e2.constructor !== \
this.initialValueConstructor) return void \
this.onUpdateValueMismatch(e2.constructor);\n            const { context: t2 \
} = this;\n            n.flattenTo(e2, this.preUploadValue), \
t2.activeTexture(this.contextHandle), t2.bindTexture(t2.TEXTURE_2D, \
this.texture), t2.pixelStorei(t2.UNPACK_FLIP_Y_WEBGL, false), \
t2.texImage2D(t2.TEXTURE_2D, 0, t2.RGBA, this.textureSize[0], \
this.textureSize[1], 0, t2.RGBA, t2.UNSIGNED_BYTE, this.uploadValue), \
this.kernel.setUniform1i(this.id, this.index);\n          }\n        } };\n   \
   }, { \"../../../utils\": 114, \"./array\": 40 }], 69: [function(e, t, r) \
{\n        const { utils: n } = e(\"../../../utils\"), { WebGLKernelArray: i \
} = e(\"./array\");\n        t.exports = { WebGLKernelValueUnsignedInput: \
class extends i {\n          constructor(e2, t2) {\n            super(e2, \
t2), this.bitRatio = this.getBitRatio(e2);\n            const [r2, i2, s] = \
e2.size;\n            this.dimensions = new Int32Array([r2 || 1, i2 || 1, s \
|| 1]), this.textureSize = \
n.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio), \
this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / \
this.bitRatio), this.checkSize(this.textureSize[0], this.textureSize[1]), \
this.TranserArrayType = this.getTransferArrayType(e2.value), \
this.preUploadValue = new this.TranserArrayType(this.uploadArrayLength), \
this.uploadValue = new Uint8Array(this.preUploadValue.buffer);\n          }\n \
         getStringValueHandler() {\n            return \
n.linesToString([`const preUploadValue_${this.name} = new \
${this.TranserArrayType.name}(${this.uploadArrayLength})`, `const \
uploadValue_${this.name} = new \
Uint8Array(preUploadValue_${this.name}.buffer)`, \
`flattenTo(${this.varName}.value, preUploadValue_${this.name})`]);\n          \
}\n          getSource() {\n            return n.linesToString([`uniform \
sampler2D ${this.id}`, `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, \
${this.textureSize[1]})`, `ivec3 ${this.dimensionsId} = \
ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, \
${this.dimensions[2]})`]);\n          }\n          updateValue(e2) {\n        \
    if (e2.constructor !== this.initialValueConstructor) return void \
this.onUpdateValueMismatch(value.constructor);\n            const { context: \
t2 } = this;\n            n.flattenTo(e2.value, this.preUploadValue), \
t2.activeTexture(this.contextHandle), t2.bindTexture(t2.TEXTURE_2D, \
this.texture), t2.pixelStorei(t2.UNPACK_FLIP_Y_WEBGL, false), \
t2.texImage2D(t2.TEXTURE_2D, 0, t2.RGBA, this.textureSize[0], \
this.textureSize[1], 0, t2.RGBA, t2.UNSIGNED_BYTE, this.uploadValue), \
this.kernel.setUniform1i(this.id, this.index);\n          }\n        } };\n   \
   }, { \"../../../utils\": 114, \"./array\": 40 }], 70: [function(e, t, r) \
{\n        const { GLKernel: n } = e(\"../gl/kernel\"), { FunctionBuilder: i \
} = e(\"../function-builder\"), { WebGLFunctionNode: s } = \
e(\"./function-node\"), { utils: a } = e(\"../../utils\"), o = \
e(\"../../plugins/math-random-uniformly-distributed\"), { fragmentShader: u } \
= e(\"./fragment-shader\"), { vertexShader: l } = e(\"./vertex-shader\"), { \
glKernelString: h } = e(\"../gl/kernel-string\"), { lookupKernelValueType: c \
} = e(\"./kernel-value-maps\");\n        let p = null, d = null, m = null, f \
= null, g = null;\n        const x = [o], y = [], b = {};\n        t.exports \
= { WebGLKernel: class extends n {\n          static get isSupported() {\n    \
        return null !== p || (this.setupFeatureChecks(), p = \
this.isContextMatch(m)), p;\n          }\n          static \
setupFeatureChecks() {\n            \"undefined\" != typeof document ? d = \
document.createElement(\"canvas\") : \"undefined\" != typeof OffscreenCanvas \
&& (d = new OffscreenCanvas(0, 0)), d && (m = d.getContext(\"webgl\") || \
d.getContext(\"experimental-webgl\"), m && m.getExtension && (f = { \
OES_texture_float: m.getExtension(\"OES_texture_float\"), \
OES_texture_float_linear: m.getExtension(\"OES_texture_float_linear\"), \
OES_element_index_uint: m.getExtension(\"OES_element_index_uint\"), \
WEBGL_draw_buffers: m.getExtension(\"WEBGL_draw_buffers\") }, g = \
this.getFeatures()));\n          }\n          static isContextMatch(e2) {\n   \
         return \"undefined\" != typeof WebGLRenderingContext && e2 \
instanceof WebGLRenderingContext;\n          }\n          static \
getIsTextureFloat() {\n            return Boolean(f.OES_texture_float);\n     \
     }\n          static getIsDrawBuffers() {\n            return \
Boolean(f.WEBGL_draw_buffers);\n          }\n          static \
getChannelCount() {\n            return f.WEBGL_draw_buffers ? \
m.getParameter(f.WEBGL_draw_buffers.MAX_DRAW_BUFFERS_WEBGL) : 1;\n          \
}\n          static getMaxTextureSize() {\n            return \
m.getParameter(m.MAX_TEXTURE_SIZE);\n          }\n          static \
lookupKernelValueType(e2, t2, r2, n2) {\n            return c(e2, t2, r2, \
n2);\n          }\n          static get testCanvas() {\n            return \
d;\n          }\n          static get testContext() {\n            return \
m;\n          }\n          static get features() {\n            return g;\n   \
       }\n          static get fragmentShader() {\n            return u;\n    \
      }\n          static get vertexShader() {\n            return l;\n       \
   }\n          constructor(e2, t2) {\n            super(e2, t2), \
this.program = null, this.pipeline = t2.pipeline, this.endianness = \
a.systemEndianness(), this.extensions = {}, this.argumentTextureCount = 0, \
this.constantTextureCount = 0, this.fragShader = null, this.vertShader = \
null, this.drawBuffersMap = null, this.maxTexSize = null, \
this.onRequestSwitchKernel = null, this.texture = null, this.mappedTextures = \
null, this.mergeSettings(e2.settings || t2), this.threadDim = null, \
this.framebuffer = null, this.buffer = null, this.textureCache = [], \
this.programUniformLocationCache = {}, this.uniform1fCache = {}, \
this.uniform1iCache = {}, this.uniform2fCache = {}, this.uniform2fvCache = \
{}, this.uniform2ivCache = {}, this.uniform3fvCache = {}, \
this.uniform3ivCache = {}, this.uniform4fvCache = {}, this.uniform4ivCache = \
{};\n          }\n          initCanvas() {\n            if (\"undefined\" != \
typeof document) {\n              const e2 = \
document.createElement(\"canvas\");\n              return e2.width = 2, \
e2.height = 2, e2;\n            }\n            if (\"undefined\" != typeof \
OffscreenCanvas) return new OffscreenCanvas(0, 0);\n          }\n          \
initContext() {\n            const e2 = { alpha: false, depth: false, \
antialias: false };\n            return this.canvas.getContext(\"webgl\", e2) \
|| this.canvas.getContext(\"experimental-webgl\", e2);\n          }\n         \
 initPlugins(e2) {\n            const t2 = [], { source: r2 } = this;\n       \
     if (\"string\" == typeof r2) for (let e3 = 0; e3 < x.length; e3++) {\n   \
           const n2 = x[e3];\n              r2.match(n2.functionMatch) && \
t2.push(n2);\n            }\n            else if (\"object\" == typeof r2 && \
e2.pluginNames) for (let r3 = 0; r3 < x.length; r3++) {\n              const \
n2 = x[r3];\n              e2.pluginNames.some((e3) => e3 === n2.name) && \
t2.push(n2);\n            }\n            return t2;\n          }\n          \
initExtensions() {\n            this.extensions = { OES_texture_float: \
this.context.getExtension(\"OES_texture_float\"), OES_texture_float_linear: \
this.context.getExtension(\"OES_texture_float_linear\"), \
OES_element_index_uint: \
this.context.getExtension(\"OES_element_index_uint\"), WEBGL_draw_buffers: \
this.context.getExtension(\"WEBGL_draw_buffers\"), WEBGL_color_buffer_float: \
this.context.getExtension(\"WEBGL_color_buffer_float\") };\n          }\n     \
     validateSettings(e2) {\n            if (!this.validate) return void \
(this.texSize = a.getKernelTextureSize({ optimizeFloatMemory: \
this.optimizeFloatMemory, precision: this.precision }, this.output));\n       \
     const { features: t2 } = this.constructor;\n            if (true === \
this.optimizeFloatMemory && !t2.isTextureFloat) throw new Error(\"Float \
textures are not supported\");\n            if (\"single\" === this.precision \
&& !t2.isFloatRead) throw new Error(\"Single precision not supported\");\n    \
        if (!this.graphical && null === this.precision && t2.isTextureFloat \
&& (this.precision = t2.isFloatRead ? \"single\" : \"unsigned\"), \
this.subKernels && this.subKernels.length > 0 && \
!this.extensions.WEBGL_draw_buffers) throw new Error(\"could not instantiate \
draw buffers extension\");\n            if (null === \
this.fixIntegerDivisionAccuracy ? this.fixIntegerDivisionAccuracy = \
!t2.isIntegerDivisionAccurate : this.fixIntegerDivisionAccuracy && \
t2.isIntegerDivisionAccurate && (this.fixIntegerDivisionAccuracy = false), \
this.checkOutput(), !this.output || 0 === this.output.length) {\n             \
 if (1 !== e2.length) throw new Error(\"Auto output only supported for \
kernels with only one input\");\n              const t3 = \
a.getVariableType(e2[0], this.strictIntegers);\n              switch (t3) {\n \
               case \"Array\":\n                  this.output = \
a.getDimensions(t3);\n                  break;\n                case \
\"NumberTexture\":\n                case \"MemoryOptimizedNumberTexture\":\n  \
              case \"ArrayTexture(1)\":\n                case \
\"ArrayTexture(2)\":\n                case \"ArrayTexture(3)\":\n             \
   case \"ArrayTexture(4)\":\n                  this.output = e2[0].output;\n \
                 break;\n                default:\n                  throw \
new Error(\"Auto output not supported for input type: \" + t3);\n             \
 }\n            }\n            if (this.graphical) {\n              if (2 !== \
this.output.length) throw new Error(\"Output must have 2 dimensions on \
graphical mode\");\n              return \"precision\" === this.precision && \
(this.precision = \"unsigned\", console.warn(\"Cannot use graphical mode and \
single precision at the same time\")), void (this.texSize = \
a.clone(this.output));\n            }\n            null === this.precision && \
t2.isTextureFloat && (this.precision = \"single\"), this.texSize = \
a.getKernelTextureSize({ optimizeFloatMemory: this.optimizeFloatMemory, \
precision: this.precision }, this.output), this.checkTextureSize();\n         \
 }\n          updateMaxTexSize() {\n            const { texSize: e2, canvas: \
t2 } = this;\n            if (null === this.maxTexSize) {\n              let \
r2 = y.indexOf(t2);\n              -1 === r2 && (r2 = y.length, y.push(t2), \
b[r2] = [e2[0], e2[1]]), this.maxTexSize = b[r2];\n            }\n            \
this.maxTexSize[0] < e2[0] && (this.maxTexSize[0] = e2[0]), \
this.maxTexSize[1] < e2[1] && (this.maxTexSize[1] = e2[1]);\n          }\n    \
      setupArguments(e2) {\n            this.kernelArguments = [], \
this.argumentTextureCount = 0;\n            const t2 = null === \
this.argumentTypes;\n            if (t2 && (this.argumentTypes = []), \
this.argumentSizes = [], this.argumentBitRatios = [], e2.length < \
this.argumentNames.length) throw new Error(\"not enough arguments for \
kernel\");\n            if (e2.length > this.argumentNames.length) throw new \
Error(\"too many arguments for kernel\");\n            const { context: r2 } \
= this;\n            let n2 = 0;\n            const i2 = () => \
this.createTexture(), s2 = () => this.constantTextureCount + n2++, o2 = (e3) \
=> {\n              this.switchKernels({ type: \"argumentMismatch\", needed: \
e3 });\n            }, u2 = () => r2.TEXTURE0 + this.constantTextureCount + \
this.argumentTextureCount++;\n            for (let n3 = 0; n3 < e2.length; \
n3++) {\n              const l2 = e2[n3], h2 = this.argumentNames[n3];\n      \
        let c2;\n              t2 ? (c2 = a.getVariableType(l2, \
this.strictIntegers), this.argumentTypes.push(c2)) : c2 = \
this.argumentTypes[n3];\n              const p2 = \
this.constructor.lookupKernelValueType(c2, this.dynamicArguments ? \
\"dynamic\" : \"static\", this.precision, e2[n3]);\n              if (null \
=== p2) return this.requestFallback(e2);\n              const d2 = new p2(l2, \
{ name: h2, type: c2, tactic: this.tactic, origin: \"user\", context: r2, \
checkContext: this.checkContext, kernel: this, strictIntegers: \
this.strictIntegers, onRequestTexture: i2, onRequestIndex: s2, \
onUpdateValueMismatch: o2, onRequestContextHandle: u2 });\n              \
this.kernelArguments.push(d2), d2.setup(), \
this.argumentSizes.push(d2.textureSize), this.argumentBitRatios[n3] = \
d2.bitRatio;\n            }\n          }\n          createTexture() {\n       \
     const e2 = this.context.createTexture();\n            return \
this.textureCache.push(e2), e2;\n          }\n          setupConstants(e2) \
{\n            const { context: t2 } = this;\n            \
this.kernelConstants = [], this.forceUploadKernelConstants = [];\n            \
let r2 = null === this.constantTypes;\n            r2 && (this.constantTypes \
= {}), this.constantBitRatios = {};\n            let n2 = 0;\n            for \
(const i2 in this.constants) {\n              const s2 = \
this.constants[i2];\n              let o2;\n              r2 ? (o2 = \
a.getVariableType(s2, this.strictIntegers), this.constantTypes[i2] = o2) : o2 \
= this.constantTypes[i2];\n              const u2 = \
this.constructor.lookupKernelValueType(o2, \"static\", this.precision, s2);\n \
             if (null === u2) return this.requestFallback(e2);\n              \
const l2 = new u2(s2, { name: i2, type: o2, tactic: this.tactic, origin: \
\"constants\", context: this.context, checkContext: this.checkContext, \
kernel: this, strictIntegers: this.strictIntegers, onRequestTexture: () => \
this.createTexture(), onRequestIndex: () => n2++, onRequestContextHandle: () \
=> t2.TEXTURE0 + this.constantTextureCount++ });\n              \
this.constantBitRatios[i2] = l2.bitRatio, this.kernelConstants.push(l2), \
l2.setup(), l2.forceUploadEachRun && \
this.forceUploadKernelConstants.push(l2);\n            }\n          }\n       \
   build() {\n            if (this.built) return;\n            if \
(this.initExtensions(), this.validateSettings(arguments), \
this.setupConstants(arguments), this.fallbackRequested) return;\n            \
if (this.setupArguments(arguments), this.fallbackRequested) return;\n         \
   this.updateMaxTexSize(), this.translateSource();\n            const e2 = \
this.pickRenderStrategy(arguments);\n            if (e2) return e2;\n         \
   const { texSize: t2, context: r2, canvas: n2 } = this;\n            \
r2.enable(r2.SCISSOR_TEST), this.pipeline && this.precision, r2.viewport(0, \
0, this.maxTexSize[0], this.maxTexSize[1]), n2.width = this.maxTexSize[0], \
n2.height = this.maxTexSize[1];\n            const i2 = this.threadDim = \
Array.from(this.output);\n            for (; i2.length < 3; ) i2.push(1);\n   \
         const s2 = this.getVertexShader(arguments), a2 = \
r2.createShader(r2.VERTEX_SHADER);\n            r2.shaderSource(a2, s2), \
r2.compileShader(a2), this.vertShader = a2;\n            const o2 = \
this.getFragmentShader(arguments), u2 = \
r2.createShader(r2.FRAGMENT_SHADER);\n            if (r2.shaderSource(u2, \
o2), r2.compileShader(u2), this.fragShader = u2, this.debug && \
(console.log(\"GLSL Shader Output:\"), console.log(o2)), \
!r2.getShaderParameter(a2, r2.COMPILE_STATUS)) throw new Error(\"Error \
compiling vertex shader: \" + r2.getShaderInfoLog(a2));\n            if \
(!r2.getShaderParameter(u2, r2.COMPILE_STATUS)) throw new Error(\"Error \
compiling fragment shader: \" + r2.getShaderInfoLog(u2));\n            const \
l2 = this.program = r2.createProgram();\n            r2.attachShader(l2, a2), \
r2.attachShader(l2, u2), r2.linkProgram(l2), this.framebuffer = \
r2.createFramebuffer(), this.framebuffer.width = t2[0], \
this.framebuffer.height = t2[1], this.rawValueFramebuffers = {};\n            \
const h2 = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]), c2 = new \
Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), p2 = h2.byteLength;\n            let \
d2 = this.buffer;\n            d2 ? r2.bindBuffer(r2.ARRAY_BUFFER, d2) : (d2 \
= this.buffer = r2.createBuffer(), r2.bindBuffer(r2.ARRAY_BUFFER, d2), \
r2.bufferData(r2.ARRAY_BUFFER, h2.byteLength + c2.byteLength, \
r2.STATIC_DRAW)), r2.bufferSubData(r2.ARRAY_BUFFER, 0, h2), \
r2.bufferSubData(r2.ARRAY_BUFFER, p2, c2);\n            const m2 = \
r2.getAttribLocation(this.program, \"aPos\");\n            \
r2.enableVertexAttribArray(m2), r2.vertexAttribPointer(m2, 2, r2.FLOAT, \
false, 0, 0);\n            const f2 = r2.getAttribLocation(this.program, \
\"aTexCoord\");\n            r2.enableVertexAttribArray(f2), \
r2.vertexAttribPointer(f2, 2, r2.FLOAT, false, 0, p2), \
r2.bindFramebuffer(r2.FRAMEBUFFER, this.framebuffer);\n            let g2 = \
0;\n            r2.useProgram(this.program);\n            for (let e3 in \
this.constants) this.kernelConstants[g2++].updateValue(this.constants[e3]);\n \
           this._setupOutputTexture(), null !== this.subKernels && \
this.subKernels.length > 0 && (this._mappedTextureSwitched = {}, \
this._setupSubOutputTextures()), this.buildSignature(arguments), this.built = \
true;\n          }\n          translateSource() {\n            const e2 = \
i.fromKernel(this, s, { fixIntegerDivisionAccuracy: \
this.fixIntegerDivisionAccuracy });\n            this.translatedSource = \
e2.getPrototypeString(\"kernel\"), this.setupReturnTypes(e2);\n          }\n  \
        setupReturnTypes(e2) {\n            if (this.graphical || \
this.returnType || (this.returnType = e2.getKernelResultType()), \
this.subKernels && this.subKernels.length > 0) for (let t2 = 0; t2 < \
this.subKernels.length; t2++) {\n              const r2 = \
this.subKernels[t2];\n              r2.returnType || (r2.returnType = \
e2.getSubKernelResultType(t2));\n            }\n          }\n          run() \
{\n            const { kernelArguments: e2, texSize: t2, \
forceUploadKernelConstants: r2, context: n2 } = this;\n            \
n2.useProgram(this.program), n2.scissor(0, 0, t2[0], t2[1]), \
this.dynamicOutput && (this.setUniform3iv(\"uOutputDim\", new \
Int32Array(this.threadDim)), this.setUniform2iv(\"uTexSize\", t2)), \
this.setUniform2f(\"ratio\", t2[0] / this.maxTexSize[0], t2[1] / \
this.maxTexSize[1]);\n            for (let e3 = 0; e3 < r2.length; e3++) {\n  \
            const t3 = r2[e3];\n              if \
(t3.updateValue(this.constants[t3.name]), this.switchingKernels) return;\n    \
        }\n            for (let t3 = 0; t3 < e2.length; t3++) if \
(e2[t3].updateValue(arguments[t3]), this.switchingKernels) return;\n          \
  if (this.plugins) for (let e3 = 0; e3 < this.plugins.length; e3++) {\n      \
        const t3 = this.plugins[e3];\n              t3.onBeforeRun && \
t3.onBeforeRun(this);\n            }\n            if (this.graphical) return \
this.pipeline ? (n2.bindRenderbuffer(n2.RENDERBUFFER, null), \
n2.bindFramebuffer(n2.FRAMEBUFFER, this.framebuffer), this.immutable && \
this._replaceOutputTexture(), n2.drawArrays(n2.TRIANGLE_STRIP, 0, 4), \
this.immutable ? this.texture.clone() : this.texture) : \
(n2.bindRenderbuffer(n2.RENDERBUFFER, null), \
n2.bindFramebuffer(n2.FRAMEBUFFER, null), void \
n2.drawArrays(n2.TRIANGLE_STRIP, 0, 4));\n            \
n2.bindFramebuffer(n2.FRAMEBUFFER, this.framebuffer), this.immutable && \
this._replaceOutputTexture(), null !== this.subKernels && (this.immutable && \
this._replaceSubOutputTextures(), this.drawBuffers()), \
n2.drawArrays(n2.TRIANGLE_STRIP, 0, 4);\n          }\n          drawBuffers() \
{\n            \
this.extensions.WEBGL_draw_buffers.drawBuffersWEBGL(this.drawBuffersMap);\n   \
       }\n          getInternalFormat() {\n            return \
this.context.RGBA;\n          }\n          getTextureFormat() {\n            \
const { context: e2 } = this;\n            if (this.getInternalFormat() === \
e2.RGBA) return e2.RGBA;\n            throw new Error(\"Unknown internal \
format\");\n          }\n          _replaceOutputTexture() {\n            if \
(this.texture.beforeMutate() || this._textureSwitched) {\n              const \
e2 = this.context;\n              e2.framebufferTexture2D(e2.FRAMEBUFFER, \
e2.COLOR_ATTACHMENT0, e2.TEXTURE_2D, this.texture.texture, 0), \
this._textureSwitched = false;\n            }\n          }\n          \
_setupOutputTexture() {\n            const e2 = this.context, t2 = \
this.texSize;\n            if (this.texture) return void \
e2.framebufferTexture2D(e2.FRAMEBUFFER, e2.COLOR_ATTACHMENT0, e2.TEXTURE_2D, \
this.texture.texture, 0);\n            const r2 = this.createTexture();\n     \
       e2.activeTexture(e2.TEXTURE0 + this.constantTextureCount + \
this.argumentTextureCount), e2.bindTexture(e2.TEXTURE_2D, r2), \
e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_S, e2.CLAMP_TO_EDGE), \
e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_T, e2.CLAMP_TO_EDGE), \
e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MIN_FILTER, e2.NEAREST), \
e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MAG_FILTER, e2.NEAREST);\n         \
   const n2 = this.getInternalFormat();\n            \"single\" === \
this.precision ? e2.texImage2D(e2.TEXTURE_2D, 0, n2, t2[0], t2[1], 0, \
e2.RGBA, e2.FLOAT, null) : e2.texImage2D(e2.TEXTURE_2D, 0, n2, t2[0], t2[1], \
0, n2, e2.UNSIGNED_BYTE, null), e2.framebufferTexture2D(e2.FRAMEBUFFER, \
e2.COLOR_ATTACHMENT0, e2.TEXTURE_2D, r2, 0), this.texture = new \
this.TextureConstructor({ texture: r2, size: t2, dimensions: this.threadDim, \
output: this.output, context: this.context, internalFormat: \
this.getInternalFormat(), textureFormat: this.getTextureFormat(), kernel: \
this });\n          }\n          _replaceSubOutputTextures() {\n            \
const e2 = this.context;\n            for (let t2 = 0; t2 < \
this.mappedTextures.length; t2++) {\n              const r2 = \
this.mappedTextures[t2];\n              (r2.beforeMutate() || \
this._mappedTextureSwitched[t2]) && (e2.framebufferTexture2D(e2.FRAMEBUFFER, \
e2.COLOR_ATTACHMENT0 + t2 + 1, e2.TEXTURE_2D, r2.texture, 0), \
this._mappedTextureSwitched[t2] = false);\n            }\n          }\n       \
   _setupSubOutputTextures() {\n            const e2 = this.context;\n        \
    if (this.mappedTextures) {\n              for (let t3 = 0; t3 < \
this.subKernels.length; t3++) e2.framebufferTexture2D(e2.FRAMEBUFFER, \
e2.COLOR_ATTACHMENT0 + t3 + 1, e2.TEXTURE_2D, \
this.mappedTextures[t3].texture, 0);\n              return;\n            }\n  \
          const t2 = this.texSize;\n            this.drawBuffersMap = \
[e2.COLOR_ATTACHMENT0], this.mappedTextures = [];\n            for (let r2 = \
0; r2 < this.subKernels.length; r2++) {\n              const n2 = \
this.createTexture();\n              \
this.drawBuffersMap.push(e2.COLOR_ATTACHMENT0 + r2 + 1), \
e2.activeTexture(e2.TEXTURE0 + this.constantTextureCount + \
this.argumentTextureCount + r2), e2.bindTexture(e2.TEXTURE_2D, n2), \
e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_S, e2.CLAMP_TO_EDGE), \
e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_T, e2.CLAMP_TO_EDGE), \
e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MIN_FILTER, e2.NEAREST), \
e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MAG_FILTER, e2.NEAREST), \
\"single\" === this.precision ? e2.texImage2D(e2.TEXTURE_2D, 0, e2.RGBA, \
t2[0], t2[1], 0, e2.RGBA, e2.FLOAT, null) : e2.texImage2D(e2.TEXTURE_2D, 0, \
e2.RGBA, t2[0], t2[1], 0, e2.RGBA, e2.UNSIGNED_BYTE, null), \
e2.framebufferTexture2D(e2.FRAMEBUFFER, e2.COLOR_ATTACHMENT0 + r2 + 1, \
e2.TEXTURE_2D, n2, 0), this.mappedTextures.push(new this.TextureConstructor({ \
texture: n2, size: t2, dimensions: this.threadDim, output: this.output, \
context: this.context, internalFormat: this.getInternalFormat(), \
textureFormat: this.getTextureFormat(), kernel: this }));\n            }\n    \
      }\n          setUniform1f(e2, t2) {\n            if \
(this.uniform1fCache.hasOwnProperty(e2)) {\n              if (t2 === \
this.uniform1fCache[e2]) return;\n            }\n            \
this.uniform1fCache[e2] = t2;\n            const r2 = \
this.getUniformLocation(e2);\n            this.context.uniform1f(r2, t2);\n   \
       }\n          setUniform1i(e2, t2) {\n            if \
(this.uniform1iCache.hasOwnProperty(e2)) {\n              if (t2 === \
this.uniform1iCache[e2]) return;\n            }\n            \
this.uniform1iCache[e2] = t2;\n            const r2 = \
this.getUniformLocation(e2);\n            this.context.uniform1i(r2, t2);\n   \
       }\n          setUniform2f(e2, t2, r2) {\n            if \
(this.uniform2fCache.hasOwnProperty(e2)) {\n              const n3 = \
this.uniform2fCache[e2];\n              if (t2 === n3[0] && r2 === n3[1]) \
return;\n            }\n            this.uniform2fCache[e2] = [t2, r2];\n     \
       const n2 = this.getUniformLocation(e2);\n            \
this.context.uniform2f(n2, t2, r2);\n          }\n          setUniform2fv(e2, \
t2) {\n            if (this.uniform2fvCache.hasOwnProperty(e2)) {\n           \
   const r3 = this.uniform2fvCache[e2];\n              if (t2[0] === r3[0] && \
t2[1] === r3[1]) return;\n            }\n            this.uniform2fvCache[e2] \
= t2;\n            const r2 = this.getUniformLocation(e2);\n            \
this.context.uniform2fv(r2, t2);\n          }\n          setUniform2iv(e2, \
t2) {\n            if (this.uniform2ivCache.hasOwnProperty(e2)) {\n           \
   const r3 = this.uniform2ivCache[e2];\n              if (t2[0] === r3[0] && \
t2[1] === r3[1]) return;\n            }\n            this.uniform2ivCache[e2] \
= t2;\n            const r2 = this.getUniformLocation(e2);\n            \
this.context.uniform2iv(r2, t2);\n          }\n          setUniform3fv(e2, \
t2) {\n            if (this.uniform3fvCache.hasOwnProperty(e2)) {\n           \
   const r3 = this.uniform3fvCache[e2];\n              if (t2[0] === r3[0] && \
t2[1] === r3[1] && t2[2] === r3[2]) return;\n            }\n            \
this.uniform3fvCache[e2] = t2;\n            const r2 = \
this.getUniformLocation(e2);\n            this.context.uniform3fv(r2, t2);\n  \
        }\n          setUniform3iv(e2, t2) {\n            if \
(this.uniform3ivCache.hasOwnProperty(e2)) {\n              const r3 = \
this.uniform3ivCache[e2];\n              if (t2[0] === r3[0] && t2[1] === \
r3[1] && t2[2] === r3[2]) return;\n            }\n            \
this.uniform3ivCache[e2] = t2;\n            const r2 = \
this.getUniformLocation(e2);\n            this.context.uniform3iv(r2, t2);\n  \
        }\n          setUniform4fv(e2, t2) {\n            if \
(this.uniform4fvCache.hasOwnProperty(e2)) {\n              const r3 = \
this.uniform4fvCache[e2];\n              if (t2[0] === r3[0] && t2[1] === \
r3[1] && t2[2] === r3[2] && t2[3] === r3[3]) return;\n            }\n         \
   this.uniform4fvCache[e2] = t2;\n            const r2 = \
this.getUniformLocation(e2);\n            this.context.uniform4fv(r2, t2);\n  \
        }\n          setUniform4iv(e2, t2) {\n            if \
(this.uniform4ivCache.hasOwnProperty(e2)) {\n              const r3 = \
this.uniform4ivCache[e2];\n              if (t2[0] === r3[0] && t2[1] === \
r3[1] && t2[2] === r3[2] && t2[3] === r3[3]) return;\n            }\n         \
   this.uniform4ivCache[e2] = t2;\n            const r2 = \
this.getUniformLocation(e2);\n            this.context.uniform4iv(r2, t2);\n  \
        }\n          getUniformLocation(e2) {\n            return \
this.programUniformLocationCache.hasOwnProperty(e2) ? \
this.programUniformLocationCache[e2] : this.programUniformLocationCache[e2] = \
this.context.getUniformLocation(this.program, e2);\n          }\n          \
_getFragShaderArtifactMap(e2) {\n            return { HEADER: \
this._getHeaderString(), LOOP_MAX: this._getLoopMaxString(), PLUGINS: \
this._getPluginsString(), CONSTANTS: this._getConstantsString(), \
DECODE32_ENDIANNESS: this._getDecode32EndiannessString(), \
ENCODE32_ENDIANNESS: this._getEncode32EndiannessString(), \
DIVIDE_WITH_INTEGER_CHECK: this._getDivideWithIntegerCheckString(), \
INJECTED_NATIVE: this._getInjectedNative(), MAIN_CONSTANTS: \
this._getMainConstantsString(), MAIN_ARGUMENTS: \
this._getMainArgumentsString(e2), KERNEL: this.getKernelString(), \
MAIN_RESULT: this.getMainResultString(), FLOAT_TACTIC_DECLARATION: \
this.getFloatTacticDeclaration(), INT_TACTIC_DECLARATION: \
this.getIntTacticDeclaration(), SAMPLER_2D_TACTIC_DECLARATION: \
this.getSampler2DTacticDeclaration(), SAMPLER_2D_ARRAY_TACTIC_DECLARATION: \
this.getSampler2DArrayTacticDeclaration() };\n          }\n          \
_getVertShaderArtifactMap(e2) {\n            return { \
FLOAT_TACTIC_DECLARATION: this.getFloatTacticDeclaration(), \
INT_TACTIC_DECLARATION: this.getIntTacticDeclaration(), \
SAMPLER_2D_TACTIC_DECLARATION: this.getSampler2DTacticDeclaration(), \
SAMPLER_2D_ARRAY_TACTIC_DECLARATION: \
this.getSampler2DArrayTacticDeclaration() };\n          }\n          \
_getHeaderString() {\n            return null !== this.subKernels ? \
\"#extension GL_EXT_draw_buffers : require\\n\" : \"\";\n          }\n        \
  _getLoopMaxString() {\n            return this.loopMaxIterations ? ` \
${parseInt(this.loopMaxIterations)};\n` : \" 1000;\\n\";\n          }\n       \
   _getPluginsString() {\n            return this.plugins ? \
this.plugins.map((e2) => e2.source && this.source.match(e2.functionMatch) ? \
e2.source : \"\").join(\"\\n\") : \"\\n\";\n          }\n          \
_getConstantsString() {\n            const e2 = [], { threadDim: t2, texSize: \
r2 } = this;\n            return this.dynamicOutput ? e2.push(\"uniform ivec3 \
uOutputDim\", \"uniform ivec2 uTexSize\") : e2.push(`ivec3 uOutputDim = \
ivec3(${t2[0]}, ${t2[1]}, ${t2[2]})`, `ivec2 uTexSize = ivec2(${r2[0]}, \
${r2[1]})`), a.linesToString(e2);\n          }\n          \
_getTextureCoordinate() {\n            const e2 = this.subKernels;\n          \
  return null === e2 || e2.length < 1 ? \"varying vec2 vTexCoord;\\n\" : \
\"out vec2 vTexCoord;\\n\";\n          }\n          \
_getDecode32EndiannessString() {\n            return \"LE\" === \
this.endianness ? \"\" : \"  texel.rgba = texel.abgr;\\n\";\n          }\n    \
      _getEncode32EndiannessString() {\n            return \"LE\" === \
this.endianness ? \"\" : \"  texel.rgba = texel.abgr;\\n\";\n          }\n    \
      _getDivideWithIntegerCheckString() {\n            return \
this.fixIntegerDivisionAccuracy ? \"float divWithIntCheck(float x, float y) \
{\\n  if (floor(x) == x && floor(y) == y && integerMod(x, y) == 0.0) {\\n    \
return float(int(x) / int(y));\\n  }\\n  return x / y;\\n}\\n\\nfloat \
integerCorrectionModulo(float number, float divisor) {\\n  if (number < 0.0) \
{\\n    number = abs(number);\\n    if (divisor < 0.0) {\\n      divisor = \
abs(divisor);\\n    }\\n    return -(number - (divisor * \
floor(divWithIntCheck(number, divisor))));\\n  }\\n  if (divisor < 0.0) {\\n  \
  divisor = abs(divisor);\\n  }\\n  return number - (divisor * \
floor(divWithIntCheck(number, divisor)));\\n}\" : \"\";\n          }\n        \
  _getMainArgumentsString(e2) {\n            const t2 = [], { argumentNames: \
r2 } = this;\n            for (let n2 = 0; n2 < r2.length; n2++) \
t2.push(this.kernelArguments[n2].getSource(e2[n2]));\n            return \
t2.join(\"\");\n          }\n          _getInjectedNative() {\n            \
return this.injectedNative || \"\";\n          }\n          \
_getMainConstantsString() {\n            const e2 = [], { constants: t2 } = \
this;\n            if (t2) {\n              let r2 = 0;\n              for \
(const n2 in t2) this.constants.hasOwnProperty(n2) && \
e2.push(this.kernelConstants[r2++].getSource(this.constants[n2]));\n          \
  }\n            return e2.join(\"\");\n          }\n          \
getRawValueFramebuffer(e2, t2) {\n            if \
(this.rawValueFramebuffers[e2] || (this.rawValueFramebuffers[e2] = {}), \
!this.rawValueFramebuffers[e2][t2]) {\n              const r2 = \
this.context.createFramebuffer();\n              r2.width = e2, r2.height = \
t2, this.rawValueFramebuffers[e2][t2] = r2;\n            }\n            \
return this.rawValueFramebuffers[e2][t2];\n          }\n          \
getKernelResultDeclaration() {\n            switch (this.returnType) {\n      \
        case \"Array(2)\":\n                return \"vec2 kernelResult\";\n   \
           case \"Array(3)\":\n                return \"vec3 \
kernelResult\";\n              case \"Array(4)\":\n                return \
\"vec4 kernelResult\";\n              case \"LiteralInteger\":\n              \
case \"Float\":\n              case \"Number\":\n              case \
\"Integer\":\n                return \"float kernelResult\";\n              \
default:\n                if (this.graphical) return \"float \
kernelResult\";\n                throw new Error(`unrecognized output type \
\"${this.returnType}\"`);\n            }\n          }\n          \
getKernelString() {\n            const e2 = \
[this.getKernelResultDeclaration()], { subKernels: t2 } = this;\n            \
if (null !== t2) switch (this.returnType) {\n              case \"Number\":\n \
             case \"Float\":\n              case \"Integer\":\n               \
 for (let r2 = 0; r2 < t2.length; r2++) {\n                  const n2 = \
t2[r2];\n                  e2.push(\"Integer\" === n2.returnType ? `int \
subKernelResult_${n2.name} = 0` : `float subKernelResult_${n2.name} = \
0.0`);\n                }\n                break;\n              case \
\"Array(2)\":\n                for (let r2 = 0; r2 < t2.length; r2++) \
e2.push(`vec2 subKernelResult_${t2[r2].name}`);\n                break;\n     \
         case \"Array(3)\":\n                for (let r2 = 0; r2 < t2.length; \
r2++) e2.push(`vec3 subKernelResult_${t2[r2].name}`);\n                \
break;\n              case \"Array(4)\":\n                for (let r2 = 0; r2 \
< t2.length; r2++) e2.push(`vec4 subKernelResult_${t2[r2].name}`);\n          \
  }\n            return a.linesToString(e2) + this.translatedSource;\n        \
  }\n          getMainResultGraphical() {\n            return \
a.linesToString([\"  threadId = indexTo3D(index, uOutputDim)\", \"  \
kernel()\", \"  gl_FragColor = actualColor\"]);\n          }\n          \
getMainResultPackedPixels() {\n            switch (this.returnType) {\n       \
       case \"LiteralInteger\":\n              case \"Number\":\n             \
 case \"Integer\":\n              case \"Float\":\n                return \
this.getMainResultKernelPackedPixels() + \
this.getMainResultSubKernelPackedPixels();\n              default:\n          \
      throw new Error(`packed output only usable with Numbers, \
\"${this.returnType}\" specified`);\n            }\n          }\n          \
getMainResultKernelPackedPixels() {\n            return a.linesToString([\"  \
threadId = indexTo3D(index, uOutputDim)\", \"  kernel()\", `  gl_FragData[0] \
= ${this.useLegacyEncoder ? \"legacyEncode32\" : \
\"encode32\"}(kernelResult)`]);\n          }\n          \
getMainResultSubKernelPackedPixels() {\n            const e2 = [];\n          \
  if (!this.subKernels) return \"\";\n            for (let t2 = 0; t2 < \
this.subKernels.length; t2++) {\n              \"Integer\" === \
this.subKernels[t2].returnType ? e2.push(`  gl_FragData[${t2 + 1}] = \
${this.useLegacyEncoder ? \"legacyEncode32\" : \
\"encode32\"}(float(subKernelResult_${this.subKernels[t2].name}))`) : \
e2.push(`  gl_FragData[${t2 + 1}] = ${this.useLegacyEncoder ? \
\"legacyEncode32\" : \
\"encode32\"}(subKernelResult_${this.subKernels[t2].name})`);\n            \
}\n            return a.linesToString(e2);\n          }\n          \
getMainResultMemoryOptimizedFloats() {\n            const e2 = [\"  index *= \
4\"];\n            switch (this.returnType) {\n              case \
\"Number\":\n              case \"Integer\":\n              case \"Float\":\n \
               const t2 = [\"r\", \"g\", \"b\", \"a\"];\n                for \
(let r2 = 0; r2 < t2.length; r2++) {\n                  const n2 = t2[r2];\n  \
                this.getMainResultKernelMemoryOptimizedFloats(e2, n2), \
this.getMainResultSubKernelMemoryOptimizedFloats(e2, n2), r2 + 1 < t2.length \
&& e2.push(\"  index += 1\");\n                }\n                break;\n    \
          default:\n                throw new Error(`optimized output only \
usable with Numbers, ${this.returnType} specified`);\n            }\n         \
   return a.linesToString(e2);\n          }\n          \
getMainResultKernelMemoryOptimizedFloats(e2, t2) {\n            e2.push(\"  \
threadId = indexTo3D(index, uOutputDim)\", \"  kernel()\", `  \
gl_FragData[0].${t2} = kernelResult`);\n          }\n          \
getMainResultSubKernelMemoryOptimizedFloats(e2, t2) {\n            if \
(!this.subKernels) return e2;\n            for (let r2 = 0; r2 < \
this.subKernels.length; r2++) {\n              \"Integer\" === \
this.subKernels[r2].returnType ? e2.push(`  gl_FragData[${r2 + 1}].${t2} = \
float(subKernelResult_${this.subKernels[r2].name})`) : e2.push(`  \
gl_FragData[${r2 + 1}].${t2} = \
subKernelResult_${this.subKernels[r2].name}`);\n            }\n          }\n  \
        getMainResultKernelNumberTexture() {\n            return [\"  \
threadId = indexTo3D(index, uOutputDim)\", \"  kernel()\", \"  \
gl_FragData[0][0] = kernelResult\"];\n          }\n          \
getMainResultSubKernelNumberTexture() {\n            const e2 = [];\n         \
   if (!this.subKernels) return e2;\n            for (let t2 = 0; t2 < \
this.subKernels.length; ++t2) {\n              const r2 = \
this.subKernels[t2];\n              \"Integer\" === r2.returnType ? e2.push(` \
 gl_FragData[${t2 + 1}][0] = float(subKernelResult_${r2.name})`) : e2.push(`  \
gl_FragData[${t2 + 1}][0] = subKernelResult_${r2.name}`);\n            }\n    \
        return e2;\n          }\n          getMainResultKernelArray2Texture() \
{\n            return [\"  threadId = indexTo3D(index, uOutputDim)\", \"  \
kernel()\", \"  gl_FragData[0][0] = kernelResult[0]\", \"  gl_FragData[0][1] \
= kernelResult[1]\"];\n          }\n          \
getMainResultSubKernelArray2Texture() {\n            const e2 = [];\n         \
   if (!this.subKernels) return e2;\n            for (let t2 = 0; t2 < \
this.subKernels.length; ++t2) e2.push(`  gl_FragData[${t2 + 1}][0] = \
subKernelResult_${this.subKernels[t2].name}[0]`, `  gl_FragData[${t2 + 1}][1] \
= subKernelResult_${this.subKernels[t2].name}[1]`);\n            return e2;\n \
         }\n          getMainResultKernelArray3Texture() {\n            \
return [\"  threadId = indexTo3D(index, uOutputDim)\", \"  kernel()\", \"  \
gl_FragData[0][0] = kernelResult[0]\", \"  gl_FragData[0][1] = \
kernelResult[1]\", \"  gl_FragData[0][2] = kernelResult[2]\"];\n          }\n \
         getMainResultSubKernelArray3Texture() {\n            const e2 = \
[];\n            if (!this.subKernels) return e2;\n            for (let t2 = \
0; t2 < this.subKernels.length; ++t2) e2.push(`  gl_FragData[${t2 + 1}][0] = \
subKernelResult_${this.subKernels[t2].name}[0]`, `  gl_FragData[${t2 + 1}][1] \
= subKernelResult_${this.subKernels[t2].name}[1]`, `  gl_FragData[${t2 + \
1}][2] = subKernelResult_${this.subKernels[t2].name}[2]`);\n            \
return e2;\n          }\n          getMainResultKernelArray4Texture() {\n     \
       return [\"  threadId = indexTo3D(index, uOutputDim)\", \"  kernel()\", \
\"  gl_FragData[0] = kernelResult\"];\n          }\n          \
getMainResultSubKernelArray4Texture() {\n            const e2 = [];\n         \
   if (!this.subKernels) return e2;\n            switch (this.returnType) {\n \
             case \"Number\":\n              case \"Float\":\n              \
case \"Integer\":\n                for (let t2 = 0; t2 < \
this.subKernels.length; ++t2) {\n                  \"Integer\" === \
this.subKernels[t2].returnType ? e2.push(`  gl_FragData[${t2 + 1}] = \
float(subKernelResult_${this.subKernels[t2].name})`) : e2.push(`  \
gl_FragData[${t2 + 1}] = subKernelResult_${this.subKernels[t2].name}`);\n     \
           }\n                break;\n              case \"Array(2)\":\n      \
          for (let t2 = 0; t2 < this.subKernels.length; ++t2) e2.push(`  \
gl_FragData[${t2 + 1}][0] = subKernelResult_${this.subKernels[t2].name}[0]`, \
`  gl_FragData[${t2 + 1}][1] = \
subKernelResult_${this.subKernels[t2].name}[1]`);\n                break;\n   \
           case \"Array(3)\":\n                for (let t2 = 0; t2 < \
this.subKernels.length; ++t2) e2.push(`  gl_FragData[${t2 + 1}][0] = \
subKernelResult_${this.subKernels[t2].name}[0]`, `  gl_FragData[${t2 + 1}][1] \
= subKernelResult_${this.subKernels[t2].name}[1]`, `  gl_FragData[${t2 + \
1}][2] = subKernelResult_${this.subKernels[t2].name}[2]`);\n                \
break;\n              case \"Array(4)\":\n                for (let t2 = 0; t2 \
< this.subKernels.length; ++t2) e2.push(`  gl_FragData[${t2 + 1}][0] = \
subKernelResult_${this.subKernels[t2].name}[0]`, `  gl_FragData[${t2 + 1}][1] \
= subKernelResult_${this.subKernels[t2].name}[1]`, `  gl_FragData[${t2 + \
1}][2] = subKernelResult_${this.subKernels[t2].name}[2]`, `  gl_FragData[${t2 \
+ 1}][3] = subKernelResult_${this.subKernels[t2].name}[3]`);\n            }\n \
           return e2;\n          }\n          replaceArtifacts(e2, t2) {\n    \
        return e2.replace(/[ ]*__([A-Z]+[0-9]*([_]?[A-Z]*[0-9]?)*)__;\\n/g, \
(e3, r2) => {\n              if (t2.hasOwnProperty(r2)) return t2[r2];\n      \
        throw `unhandled artifact ${r2}`;\n            });\n          }\n     \
     getFragmentShader(e2) {\n            return null !== \
this.compiledFragmentShader ? this.compiledFragmentShader : \
this.compiledFragmentShader = \
this.replaceArtifacts(this.constructor.fragmentShader, \
this._getFragShaderArtifactMap(e2));\n          }\n          \
getVertexShader(e2) {\n            return null !== this.compiledVertexShader \
? this.compiledVertexShader : this.compiledVertexShader = \
this.replaceArtifacts(this.constructor.vertexShader, \
this._getVertShaderArtifactMap(e2));\n          }\n          toString() {\n   \
         const e2 = a.linesToString([\"const gl = context\"]);\n            \
return h(this.constructor, arguments, this, e2);\n          }\n          \
destroy(e2) {\n            if (!this.context) return;\n            \
this.buffer && this.context.deleteBuffer(this.buffer), this.framebuffer && \
this.context.deleteFramebuffer(this.framebuffer);\n            for (const e3 \
in this.rawValueFramebuffers) {\n              for (const t3 in \
this.rawValueFramebuffers[e3]) \
this.context.deleteFramebuffer(this.rawValueFramebuffers[e3][t3]), delete \
this.rawValueFramebuffers[e3][t3];\n              delete \
this.rawValueFramebuffers[e3];\n            }\n            if \
(this.vertShader && this.context.deleteShader(this.vertShader), \
this.fragShader && this.context.deleteShader(this.fragShader), this.program \
&& this.context.deleteProgram(this.program), this.texture) {\n              \
this.texture.delete();\n              const e3 = \
this.textureCache.indexOf(this.texture.texture);\n              e3 > -1 && \
this.textureCache.splice(e3, 1), this.texture = null;\n            }\n        \
    if (this.mappedTextures && this.mappedTextures.length) {\n              \
for (let e3 = 0; e3 < this.mappedTextures.length; e3++) {\n                \
const t3 = this.mappedTextures[e3];\n                t3.delete();\n           \
     const r2 = this.textureCache.indexOf(t3.texture);\n                r2 > \
-1 && this.textureCache.splice(r2, 1);\n              }\n              \
this.mappedTextures = null;\n            }\n            if \
(this.kernelArguments) for (let e3 = 0; e3 < this.kernelArguments.length; \
e3++) this.kernelArguments[e3].destroy();\n            if \
(this.kernelConstants) for (let e3 = 0; e3 < this.kernelConstants.length; \
e3++) this.kernelConstants[e3].destroy();\n            for (; \
this.textureCache.length > 0; ) {\n              const e3 = \
this.textureCache.pop();\n              this.context.deleteTexture(e3);\n     \
       }\n            if (e2) {\n              const e3 = \
y.indexOf(this.canvas);\n              e3 >= 0 && (y[e3] = null, b[e3] = \
null);\n            }\n            if (this.destroyExtensions(), delete \
this.context, delete this.canvas, !this.gpu) return;\n            const t2 = \
this.gpu.kernels.indexOf(this);\n            -1 !== t2 && \
this.gpu.kernels.splice(t2, 1);\n          }\n          destroyExtensions() \
{\n            this.extensions.OES_texture_float = null, \
this.extensions.OES_texture_float_linear = null, \
this.extensions.OES_element_index_uint = null, \
this.extensions.WEBGL_draw_buffers = null;\n          }\n          static \
destroyContext(e2) {\n            const t2 = \
e2.getExtension(\"WEBGL_lose_context\");\n            t2 && \
t2.loseContext();\n          }\n          toJSON() {\n            const e2 = \
super.toJSON();\n            return e2.functionNodes = i.fromKernel(this, \
s).toJSON(), e2.settings.threadDim = this.threadDim, e2;\n          }\n       \
 } };\n      }, { \"../../plugins/math-random-uniformly-distributed\": 112, \
\"../../utils\": 114, \"../function-builder\": 9, \"../gl/kernel\": 13, \
\"../gl/kernel-string\": 12, \"./fragment-shader\": 37, \"./function-node\": \
38, \"./kernel-value-maps\": 39, \"./vertex-shader\": 71 }], 71: [function(e, \
t, r) {\n        t.exports = { vertexShader: \
\"__FLOAT_TACTIC_DECLARATION__;\\n__INT_TACTIC_DECLARATION__;\\n__SAMPLER_2D_\
TACTIC_DECLARATION__;\\n\\nattribute vec2 aPos;\\nattribute vec2 \
aTexCoord;\\n\\nvarying vec2 vTexCoord;\\nuniform vec2 ratio;\\n\\nvoid \
main(void) {\\n  gl_Position = vec4((aPos + vec2(1)) * ratio + vec2(-1), 0, \
1);\\n  vTexCoord = aTexCoord;\\n}\" };\n      }, {}], 72: [function(e, t, r) \
{\n        const n = `#version 300 \
es\n__HEADER__;\n__FLOAT_TACTIC_DECLARATION__;\n__INT_TACTIC_DECLARATION__;\n\
__SAMPLER_2D_TACTIC_DECLARATION__;\n__SAMPLER_2D_ARRAY_TACTIC_DECLARATION__;\
\n\nconst int LOOP_MAX = __LOOP_MAX__;\n\n__PLUGINS__;\n__CONSTANTS__;\n\nin \
vec2 vTexCoord;\n\nfloat atan2(float v1, float v2) {\n  if (v1 == 0.0 || v2 \
== 0.0) return 0.0;\n  return atan(v1 / v2);\n}\n\nfloat cbrt(float x) {\n  \
if (x >= 0.0) {\n    return pow(x, 1.0 / 3.0);\n  } else {\n    return \
-pow(x, 1.0 / 3.0);\n  }\n}\n\nfloat expm1(float x) {\n  return \
pow(${Math.E}, x) - 1.0; \n}\n\nfloat fround(highp float x) {\n  return \
x;\n}\n\nfloat imul(float v1, float v2) {\n  return float(int(v1) * \
int(v2));\n}\n\nfloat log10(float x) {\n  return log2(x) * (1.0 / \
log2(10.0));\n}\n\nfloat log1p(float x) {\n  return log(1.0 + x);\n}\n\nfloat \
_pow(float v1, float v2) {\n  if (v2 == 0.0) return 1.0;\n  return pow(v1, \
v2);\n}\n\nfloat _round(float x) {\n  return floor(x + 0.5);\n}\n\n\nconst \
int BIT_COUNT = 32;\nint modi(int x, int y) {\n  return x - y * (x / \
y);\n}\n\nint bitwiseOr(int a, int b) {\n  int result = 0;\n  int n = 1;\n  \
\n  for (int i = 0; i < BIT_COUNT; i++) {\n    if ((modi(a, 2) == 1) || \
(modi(b, 2) == 1)) {\n      result += n;\n    }\n    a = a / 2;\n    b = b / \
2;\n    n = n * 2;\n    if(!(a > 0 || b > 0)) {\n      break;\n    }\n  }\n  \
return result;\n}\nint bitwiseXOR(int a, int b) {\n  int result = 0;\n  int n \
= 1;\n  \n  for (int i = 0; i < BIT_COUNT; i++) {\n    if ((modi(a, 2) == 1) \
!= (modi(b, 2) == 1)) {\n      result += n;\n    }\n    a = a / 2;\n    b = b \
/ 2;\n    n = n * 2;\n    if(!(a > 0 || b > 0)) {\n      break;\n    }\n  }\n \
 return result;\n}\nint bitwiseAnd(int a, int b) {\n  int result = 0;\n  int \
n = 1;\n  for (int i = 0; i < BIT_COUNT; i++) {\n    if ((modi(a, 2) == 1) && \
(modi(b, 2) == 1)) {\n      result += n;\n    }\n    a = a / 2;\n    b = b / \
2;\n    n = n * 2;\n    if(!(a > 0 && b > 0)) {\n      break;\n    }\n  }\n  \
return result;\n}\nint bitwiseNot(int a) {\n  int result = 0;\n  int n = 1;\n \
 \n  for (int i = 0; i < BIT_COUNT; i++) {\n    if (modi(a, 2) == 0) {\n      \
result += n;    \n    }\n    a = a / 2;\n    n = n * 2;\n  }\n  return \
result;\n}\nint bitwiseZeroFillLeftShift(int n, int shift) {\n  int maxBytes \
= BIT_COUNT;\n  for (int i = 0; i < BIT_COUNT; i++) {\n    if (maxBytes >= n) \
{\n      break;\n    }\n    maxBytes *= 2;\n  }\n  for (int i = 0; i < \
BIT_COUNT; i++) {\n    if (i >= shift) {\n      break;\n    }\n    n *= 2;\n  \
}\n\n  int result = 0;\n  int byteVal = 1;\n  for (int i = 0; i < BIT_COUNT; \
i++) {\n    if (i >= maxBytes) break;\n    if (modi(n, 2) > 0) { result += \
byteVal; }\n    n = int(n / 2);\n    byteVal *= 2;\n  }\n  return \
result;\n}\n\nint bitwiseSignedRightShift(int num, int shifts) {\n  return \
int(floor(float(num) / pow(2.0, float(shifts))));\n}\n\nint \
bitwiseZeroFillRightShift(int n, int shift) {\n  int maxBytes = BIT_COUNT;\n  \
for (int i = 0; i < BIT_COUNT; i++) {\n    if (maxBytes >= n) {\n      \
break;\n    }\n    maxBytes *= 2;\n  }\n  for (int i = 0; i < BIT_COUNT; i++) \
{\n    if (i >= shift) {\n      break;\n    }\n    n /= 2;\n  }\n  int result \
= 0;\n  int byteVal = 1;\n  for (int i = 0; i < BIT_COUNT; i++) {\n    if (i \
>= maxBytes) break;\n    if (modi(n, 2) > 0) { result += byteVal; }\n    n = \
int(n / 2);\n    byteVal *= 2;\n  }\n  return result;\n}\n\nvec2 \
integerMod(vec2 x, float y) {\n  vec2 res = floor(mod(x, y));\n  return res * \
step(1.0 - floor(y), -res);\n}\n\nvec3 integerMod(vec3 x, float y) {\n  vec3 \
res = floor(mod(x, y));\n  return res * step(1.0 - floor(y), \
-res);\n}\n\nvec4 integerMod(vec4 x, vec4 y) {\n  vec4 res = floor(mod(x, \
y));\n  return res * step(1.0 - floor(y), -res);\n}\n\nfloat integerMod(float \
x, float y) {\n  float res = floor(mod(x, y));\n  return res * (res > \
floor(y) - 1.0 ? 0.0 : 1.0);\n}\n\nint integerMod(int x, int y) {\n  return x \
- (y * int(x/y));\n}\n\n__DIVIDE_WITH_INTEGER_CHECK__;\n\n// Here be \
dragons!\n// DO NOT OPTIMIZE THIS CODE\n// YOU WILL BREAK SOMETHING ON \
SOMEBODY'S MACHINE\n// LEAVE IT AS IT IS, LEST YOU WASTE YOUR OWN TIME\nconst \
vec2 MAGIC_VEC = vec2(1.0, -256.0);\nconst vec4 SCALE_FACTOR = vec4(1.0, \
256.0, 65536.0, 0.0);\nconst vec4 SCALE_FACTOR_INV = vec4(1.0, 0.00390625, \
0.0000152587890625, 0.0); // 1, 1/256, 1/65536\nfloat decode32(vec4 texel) \
{\n  __DECODE32_ENDIANNESS__;\n  texel *= 255.0;\n  vec2 gte128;\n  gte128.x \
= texel.b >= 128.0 ? 1.0 : 0.0;\n  gte128.y = texel.a >= 128.0 ? 1.0 : 0.0;\n \
 float exponent = 2.0 * texel.a - 127.0 + dot(gte128, MAGIC_VEC);\n  float \
res = exp2(round(exponent));\n  texel.b = texel.b - 128.0 * gte128.x;\n  res \
= dot(texel, SCALE_FACTOR) * exp2(round(exponent-23.0)) + res;\n  res *= \
gte128.y * -2.0 + 1.0;\n  return res;\n}\n\nfloat decode16(vec4 texel, int \
index) {\n  int channel = integerMod(index, 2);\n  return texel[channel*2] * \
255.0 + texel[channel*2 + 1] * 65280.0;\n}\n\nfloat decode8(vec4 texel, int \
index) {\n  int channel = integerMod(index, 4);\n  return texel[channel] * \
255.0;\n}\n\nvec4 legacyEncode32(float f) {\n  float F = abs(f);\n  float \
sign = f < 0.0 ? 1.0 : 0.0;\n  float exponent = floor(log2(F));\n  float \
mantissa = (exp2(-exponent) * F);\n  // exponent += floor(log2(mantissa));\n  \
vec4 texel = vec4(F * exp2(23.0-exponent)) * SCALE_FACTOR_INV;\n  texel.rg = \
integerMod(texel.rg, 256.0);\n  texel.b = integerMod(texel.b, 128.0);\n  \
texel.a = exponent*0.5 + 63.5;\n  texel.ba += vec2(integerMod(exponent+127.0, \
2.0), sign) * 128.0;\n  texel = floor(texel);\n  texel *= 0.003921569; // \
1/255\n  __ENCODE32_ENDIANNESS__;\n  return texel;\n}\n\n// \
https://github.com/gpujs/gpu.js/wiki/Encoder-details\nvec4 encode32(float \
value) {\n  if (value == 0.0) return vec4(0, 0, 0, 0);\n\n  float exponent;\n \
 float mantissa;\n  vec4  result;\n  float sgn;\n\n  sgn = step(0.0, \
-value);\n  value = abs(value);\n\n  exponent = floor(log2(value));\n\n  \
mantissa = value*pow(2.0, -exponent)-1.0;\n  exponent = exponent+127.0;\n  \
result   = vec4(0,0,0,0);\n\n  result.a = floor(exponent/2.0);\n  exponent = \
exponent - result.a*2.0;\n  result.a = result.a + 128.0*sgn;\n\n  result.b = \
floor(mantissa * 128.0);\n  mantissa = mantissa - result.b / 128.0;\n  \
result.b = result.b + exponent*128.0;\n\n  result.g = \
floor(mantissa*32768.0);\n  mantissa = mantissa - result.g/32768.0;\n\n  \
result.r = floor(mantissa*8388608.0);\n  return result/255.0;\n}\n// Dragons \
end here\n\nint index;\nivec3 threadId;\n\nivec3 indexTo3D(int idx, ivec3 \
texDim) {\n  int z = int(idx / (texDim.x * texDim.y));\n  idx -= z * \
int(texDim.x * texDim.y);\n  int y = int(idx / texDim.x);\n  int x = \
int(integerMod(idx, texDim.x));\n  return ivec3(x, y, z);\n}\n\nfloat \
get32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  \
int index = x + texDim.x * (y + texDim.y * z);\n  int w = texSize.x;\n  vec2 \
st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\n  vec4 texel \
= texture(tex, st / vec2(texSize));\n  return decode32(texel);\n}\n\nfloat \
get16(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  \
int index = x + (texDim.x * (y + (texDim.y * z)));\n  int w = texSize.x * \
2;\n  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\n  \
vec4 texel = texture(tex, st / vec2(texSize.x * 2, texSize.y));\n  return \
decode16(texel, index);\n}\n\nfloat get8(sampler2D tex, ivec2 texSize, ivec3 \
texDim, int z, int y, int x) {\n  int index = x + (texDim.x * (y + (texDim.y \
* z)));\n  int w = texSize.x * 4;\n  vec2 st = vec2(float(integerMod(index, \
w)), float(index / w)) + 0.5;\n  vec4 texel = texture(tex, st / \
vec2(texSize.x * 4, texSize.y));\n  return decode8(texel, index);\n}\n\nfloat \
getMemoryOptimized32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int \
y, int x) {\n  int index = x + (texDim.x * (y + (texDim.y * z)));\n  int \
channel = integerMod(index, 4);\n  index = index / 4;\n  int w = texSize.x;\n \
 vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\n  \
index = index / 4;\n  vec4 texel = texture(tex, st / vec2(texSize));\n  \
return texel[channel];\n}\n\nvec4 getImage2D(sampler2D tex, ivec2 texSize, \
ivec3 texDim, int z, int y, int x) {\n  int index = x + texDim.x * (y + \
texDim.y * z);\n  int w = texSize.x;\n  vec2 st = \
vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\n  return \
texture(tex, st / vec2(texSize));\n}\n\nvec4 getImage3D(sampler2DArray tex, \
ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  int index = x + \
texDim.x * (y + texDim.y * z);\n  int w = texSize.x;\n  vec2 st = \
vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\n  return \
texture(tex, vec3(st / vec2(texSize), z));\n}\n\nfloat \
getFloatFromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int \
y, int x) {\n  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);\n  \
return result[0];\n}\n\nvec2 getVec2FromSampler2D(sampler2D tex, ivec2 \
texSize, ivec3 texDim, int z, int y, int x) {\n  vec4 result = \
getImage2D(tex, texSize, texDim, z, y, x);\n  return vec2(result[0], \
result[1]);\n}\n\nvec2 getMemoryOptimizedVec2(sampler2D tex, ivec2 texSize, \
ivec3 texDim, int z, int y, int x) {\n  int index = x + texDim.x * (y + \
texDim.y * z);\n  int channel = integerMod(index, 2);\n  index = index / 2;\n \
 int w = texSize.x;\n  vec2 st = vec2(float(integerMod(index, w)), \
float(index / w)) + 0.5;\n  vec4 texel = texture(tex, st / vec2(texSize));\n  \
if (channel == 0) return vec2(texel.r, texel.g);\n  if (channel == 1) return \
vec2(texel.b, texel.a);\n  return vec2(0.0, 0.0);\n}\n\nvec3 \
getVec3FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int \
y, int x) {\n  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);\n  \
return vec3(result[0], result[1], result[2]);\n}\n\nvec3 \
getMemoryOptimizedVec3(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int \
y, int x) {\n  int fieldIndex = 3 * (x + texDim.x * (y + texDim.y * z));\n  \
int vectorIndex = fieldIndex / 4;\n  int vectorOffset = fieldIndex - \
vectorIndex * 4;\n  int readY = vectorIndex / texSize.x;\n  int readX = \
vectorIndex - readY * texSize.x;\n  vec4 tex1 = texture(tex, (vec2(readX, \
readY) + 0.5) / vec2(texSize));\n\n  if (vectorOffset == 0) {\n    return \
tex1.xyz;\n  } else if (vectorOffset == 1) {\n    return tex1.yzw;\n  } else \
{\n    readX++;\n    if (readX >= texSize.x) {\n      readX = 0;\n      \
readY++;\n    }\n    vec4 tex2 = texture(tex, vec2(readX, readY) / \
vec2(texSize));\n    if (vectorOffset == 2) {\n      return vec3(tex1.z, \
tex1.w, tex2.x);\n    } else {\n      return vec3(tex1.w, tex2.x, tex2.y);\n  \
  }\n  }\n}\n\nvec4 getVec4FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 \
texDim, int z, int y, int x) {\n  return getImage2D(tex, texSize, texDim, z, \
y, x);\n}\n\nvec4 getMemoryOptimizedVec4(sampler2D tex, ivec2 texSize, ivec3 \
texDim, int z, int y, int x) {\n  int index = x + texDim.x * (y + texDim.y * \
z);\n  int channel = integerMod(index, 2);\n  int w = texSize.x;\n  vec2 st = \
vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\n  vec4 texel = \
texture(tex, st / vec2(texSize));\n  return vec4(texel.r, texel.g, texel.b, \
texel.a);\n}\n\nvec4 actualColor;\nvoid color(float r, float g, float b, \
float a) {\n  actualColor = vec4(r,g,b,a);\n}\n\nvoid color(float r, float g, \
float b) {\n  color(r,g,b,1.0);\n}\n\nfloat modulo(float number, float \
divisor) {\n  if (number < 0.0) {\n    number = abs(number);\n    if (divisor \
< 0.0) {\n      divisor = abs(divisor);\n    }\n    return -mod(number, \
divisor);\n  }\n  if (divisor < 0.0) {\n    divisor = abs(divisor);\n  }\n  \
return mod(number, \
divisor);\n}\n\n__INJECTED_NATIVE__;\n__MAIN_CONSTANTS__;\n__MAIN_ARGUMENTS__\
;\n__KERNEL__;\n\nvoid main(void) {\n  index = int(vTexCoord.s * \
float(uTexSize.x)) + int(vTexCoord.t * float(uTexSize.y)) * uTexSize.x;\n  \
__MAIN_RESULT__;\n}`;\n        t.exports = { fragmentShader: n };\n      }, \
{}], 73: [function(e, t, r) {\n        const { utils: n } = \
e(\"../../utils\"), { WebGLFunctionNode: i } = \
e(\"../web-gl/function-node\");\n        t.exports = { WebGL2FunctionNode: \
class extends i {\n          astIdentifierExpression(e2, t2) {\n            \
if (\"Identifier\" !== e2.type) throw \
this.astErrorOutput(\"IdentifierExpression - not an Identifier\", e2);\n      \
      const r2 = this.getType(e2), i2 = n.sanitizeName(e2.name);\n            \
return \"Infinity\" === e2.name ? t2.push(\"intBitsToFloat(2139095039)\") : \
\"Boolean\" === r2 && this.argumentNames.indexOf(i2) > -1 ? \
t2.push(`bool(user_${i2})`) : t2.push(`user_${i2}`), t2;\n          }\n       \
 } };\n      }, { \"../../utils\": 114, \"../web-gl/function-node\": 38 }], \
74: [function(e, t, r) {\n        const { WebGL2KernelValueBoolean: n } = \
e(\"./kernel-value/boolean\"), { WebGL2KernelValueFloat: i } = \
e(\"./kernel-value/float\"), { WebGL2KernelValueInteger: s } = \
e(\"./kernel-value/integer\"), { WebGL2KernelValueHTMLImage: a } = \
e(\"./kernel-value/html-image\"), { WebGL2KernelValueDynamicHTMLImage: o } = \
e(\"./kernel-value/dynamic-html-image\"), { WebGL2KernelValueHTMLImageArray: \
u } = e(\"./kernel-value/html-image-array\"), { \
WebGL2KernelValueDynamicHTMLImageArray: l } = \
e(\"./kernel-value/dynamic-html-image-array\"), { WebGL2KernelValueHTMLVideo: \
h } = e(\"./kernel-value/html-video\"), { WebGL2KernelValueDynamicHTMLVideo: \
c } = e(\"./kernel-value/dynamic-html-video\"), { \
WebGL2KernelValueSingleInput: p } = e(\"./kernel-value/single-input\"), { \
WebGL2KernelValueDynamicSingleInput: d } = \
e(\"./kernel-value/dynamic-single-input\"), { WebGL2KernelValueUnsignedInput: \
m } = e(\"./kernel-value/unsigned-input\"), { \
WebGL2KernelValueDynamicUnsignedInput: f } = \
e(\"./kernel-value/dynamic-unsigned-input\"), { \
WebGL2KernelValueMemoryOptimizedNumberTexture: g } = \
e(\"./kernel-value/memory-optimized-number-texture\"), { \
WebGL2KernelValueDynamicMemoryOptimizedNumberTexture: x } = \
e(\"./kernel-value/dynamic-memory-optimized-number-texture\"), { \
WebGL2KernelValueNumberTexture: y } = e(\"./kernel-value/number-texture\"), { \
WebGL2KernelValueDynamicNumberTexture: b } = \
e(\"./kernel-value/dynamic-number-texture\"), { WebGL2KernelValueSingleArray: \
T } = e(\"./kernel-value/single-array\"), { \
WebGL2KernelValueDynamicSingleArray: v } = \
e(\"./kernel-value/dynamic-single-array\"), { \
WebGL2KernelValueSingleArray1DI: S } = \
e(\"./kernel-value/single-array1d-i\"), { \
WebGL2KernelValueDynamicSingleArray1DI: A } = \
e(\"./kernel-value/dynamic-single-array1d-i\"), { \
WebGL2KernelValueSingleArray2DI: _ } = \
e(\"./kernel-value/single-array2d-i\"), { \
WebGL2KernelValueDynamicSingleArray2DI: E } = \
e(\"./kernel-value/dynamic-single-array2d-i\"), { \
WebGL2KernelValueSingleArray3DI: w } = \
e(\"./kernel-value/single-array3d-i\"), { \
WebGL2KernelValueDynamicSingleArray3DI: k } = \
e(\"./kernel-value/dynamic-single-array3d-i\"), { WebGL2KernelValueArray2: I \
} = e(\"./kernel-value/array2\"), { WebGL2KernelValueArray3: D } = \
e(\"./kernel-value/array3\"), { WebGL2KernelValueArray4: C } = \
e(\"./kernel-value/array4\"), { WebGL2KernelValueUnsignedArray: $ } = \
e(\"./kernel-value/unsigned-array\"), { \
WebGL2KernelValueDynamicUnsignedArray: L } = \
e(\"./kernel-value/dynamic-unsigned-array\"), R = { unsigned: { dynamic: { \
Boolean: n, Integer: s, Float: i, Array: L, \"Array(2)\": I, \"Array(3)\": D, \
\"Array(4)\": C, \"Array1D(2)\": false, \"Array1D(3)\": false, \
\"Array1D(4)\": false, \"Array2D(2)\": false, \"Array2D(3)\": false, \
\"Array2D(4)\": false, \"Array3D(2)\": false, \"Array3D(3)\": false, \
\"Array3D(4)\": false, Input: f, NumberTexture: b, \"ArrayTexture(1)\": b, \
\"ArrayTexture(2)\": b, \"ArrayTexture(3)\": b, \"ArrayTexture(4)\": b, \
MemoryOptimizedNumberTexture: x, HTMLCanvas: o, OffscreenCanvas: o, \
HTMLImage: o, ImageBitmap: o, ImageData: o, HTMLImageArray: l, HTMLVideo: c \
}, static: { Boolean: n, Float: i, Integer: s, Array: $, \"Array(2)\": I, \
\"Array(3)\": D, \"Array(4)\": C, \"Array1D(2)\": false, \"Array1D(3)\": \
false, \"Array1D(4)\": false, \"Array2D(2)\": false, \"Array2D(3)\": false, \
\"Array2D(4)\": false, \"Array3D(2)\": false, \"Array3D(3)\": false, \
\"Array3D(4)\": false, Input: m, NumberTexture: y, \"ArrayTexture(1)\": y, \
\"ArrayTexture(2)\": y, \"ArrayTexture(3)\": y, \"ArrayTexture(4)\": y, \
MemoryOptimizedNumberTexture: x, HTMLCanvas: a, OffscreenCanvas: a, \
HTMLImage: a, ImageBitmap: a, ImageData: a, HTMLImageArray: u, HTMLVideo: h } \
}, single: { dynamic: { Boolean: n, Integer: s, Float: i, Array: v, \
\"Array(2)\": I, \"Array(3)\": D, \"Array(4)\": C, \"Array1D(2)\": A, \
\"Array1D(3)\": A, \"Array1D(4)\": A, \"Array2D(2)\": E, \"Array2D(3)\": E, \
\"Array2D(4)\": E, \"Array3D(2)\": k, \"Array3D(3)\": k, \"Array3D(4)\": k, \
Input: d, NumberTexture: b, \"ArrayTexture(1)\": b, \"ArrayTexture(2)\": b, \
\"ArrayTexture(3)\": b, \"ArrayTexture(4)\": b, MemoryOptimizedNumberTexture: \
x, HTMLCanvas: o, OffscreenCanvas: o, HTMLImage: o, ImageBitmap: o, \
ImageData: o, HTMLImageArray: l, HTMLVideo: c }, static: { Boolean: n, Float: \
i, Integer: s, Array: T, \"Array(2)\": I, \"Array(3)\": D, \"Array(4)\": C, \
\"Array1D(2)\": S, \"Array1D(3)\": S, \"Array1D(4)\": S, \"Array2D(2)\": _, \
\"Array2D(3)\": _, \"Array2D(4)\": _, \"Array3D(2)\": w, \"Array3D(3)\": w, \
\"Array3D(4)\": w, Input: p, NumberTexture: y, \"ArrayTexture(1)\": y, \
\"ArrayTexture(2)\": y, \"ArrayTexture(3)\": y, \"ArrayTexture(4)\": y, \
MemoryOptimizedNumberTexture: g, HTMLCanvas: a, OffscreenCanvas: a, \
HTMLImage: a, ImageBitmap: a, ImageData: a, HTMLImageArray: u, HTMLVideo: h } \
} };\n        t.exports = { kernelValueMaps: R, lookupKernelValueType: \
function(e2, t2, r2, n2) {\n          if (!e2) throw new Error(\"type \
missing\");\n          if (!t2) throw new Error(\"dynamic missing\");\n       \
   if (!r2) throw new Error(\"precision missing\");\n          n2.type && (e2 \
= n2.type);\n          const i2 = R[r2][t2];\n          if (false === i2[e2]) \
return null;\n          if (void 0 === i2[e2]) throw new Error(`Could not \
find a KernelValue for ${e2}`);\n          return i2[e2];\n        } };\n     \
 }, { \"./kernel-value/array2\": 75, \"./kernel-value/array3\": 76, \
\"./kernel-value/array4\": 77, \"./kernel-value/boolean\": 78, \
\"./kernel-value/dynamic-html-image\": 80, \
\"./kernel-value/dynamic-html-image-array\": 79, \
\"./kernel-value/dynamic-html-video\": 81, \
\"./kernel-value/dynamic-memory-optimized-number-texture\": 82, \
\"./kernel-value/dynamic-number-texture\": 83, \
\"./kernel-value/dynamic-single-array\": 84, \
\"./kernel-value/dynamic-single-array1d-i\": 85, \
\"./kernel-value/dynamic-single-array2d-i\": 86, \
\"./kernel-value/dynamic-single-array3d-i\": 87, \
\"./kernel-value/dynamic-single-input\": 88, \
\"./kernel-value/dynamic-unsigned-array\": 89, \
\"./kernel-value/dynamic-unsigned-input\": 90, \"./kernel-value/float\": 91, \
\"./kernel-value/html-image\": 93, \"./kernel-value/html-image-array\": 92, \
\"./kernel-value/html-video\": 94, \"./kernel-value/integer\": 95, \
\"./kernel-value/memory-optimized-number-texture\": 96, \
\"./kernel-value/number-texture\": 97, \"./kernel-value/single-array\": 98, \
\"./kernel-value/single-array1d-i\": 99, \"./kernel-value/single-array2d-i\": \
100, \"./kernel-value/single-array3d-i\": 101, \
\"./kernel-value/single-input\": 102, \"./kernel-value/unsigned-array\": 103, \
\"./kernel-value/unsigned-input\": 104 }], 75: [function(e, t, r) {\n        \
const { WebGLKernelValueArray2: n } = \
e(\"../../web-gl/kernel-value/array2\");\n        t.exports = { \
WebGL2KernelValueArray2: class extends n {\n        } };\n      }, { \
\"../../web-gl/kernel-value/array2\": 41 }], 76: [function(e, t, r) {\n       \
 const { WebGLKernelValueArray3: n } = \
e(\"../../web-gl/kernel-value/array3\");\n        t.exports = { \
WebGL2KernelValueArray3: class extends n {\n        } };\n      }, { \
\"../../web-gl/kernel-value/array3\": 42 }], 77: [function(e, t, r) {\n       \
 const { WebGLKernelValueArray4: n } = \
e(\"../../web-gl/kernel-value/array4\");\n        t.exports = { \
WebGL2KernelValueArray4: class extends n {\n        } };\n      }, { \
\"../../web-gl/kernel-value/array4\": 43 }], 78: [function(e, t, r) {\n       \
 const { WebGLKernelValueBoolean: n } = \
e(\"../../web-gl/kernel-value/boolean\");\n        t.exports = { \
WebGL2KernelValueBoolean: class extends n {\n        } };\n      }, { \
\"../../web-gl/kernel-value/boolean\": 44 }], 79: [function(e, t, r) {\n      \
  const { utils: n } = e(\"../../../utils\"), { \
WebGL2KernelValueHTMLImageArray: i } = e(\"./html-image-array\");\n        \
t.exports = { WebGL2KernelValueDynamicHTMLImageArray: class extends i {\n     \
     getSource() {\n            const e2 = \
this.getVariablePrecisionString();\n            return \
n.linesToString([`uniform ${e2} sampler2DArray ${this.id}`, `uniform ${e2} \
ivec2 ${this.sizeId}`, `uniform ${e2} ivec3 ${this.dimensionsId}`]);\n        \
  }\n          updateValue(e2) {\n            const { width: t2, height: r2 } \
= e2[0];\n            this.checkSize(t2, r2), this.dimensions = [t2, r2, \
e2.length], this.textureSize = [t2, r2], \
this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), \
this.kernel.setUniform2iv(this.sizeId, this.textureSize), \
super.updateValue(e2);\n          }\n        } };\n      }, { \
\"../../../utils\": 114, \"./html-image-array\": 92 }], 80: [function(e, t, \
r) {\n        const { utils: n } = e(\"../../../utils\"), { \
WebGLKernelValueDynamicHTMLImage: i } = \
e(\"../../web-gl/kernel-value/dynamic-html-image\");\n        t.exports = { \
WebGL2KernelValueDynamicHTMLImage: class extends i {\n          getSource() \
{\n            const e2 = this.getVariablePrecisionString();\n            \
return n.linesToString([`uniform ${e2} sampler2D ${this.id}`, `uniform ${e2} \
ivec2 ${this.sizeId}`, `uniform ${e2} ivec3 ${this.dimensionsId}`]);\n        \
  }\n        } };\n      }, { \"../../../utils\": 114, \
\"../../web-gl/kernel-value/dynamic-html-image\": 45 }], 81: [function(e, t, \
r) {\n        const { utils: n } = e(\"../../../utils\"), { \
WebGL2KernelValueDynamicHTMLImage: i } = e(\"./dynamic-html-image\");\n       \
 t.exports = { WebGL2KernelValueDynamicHTMLVideo: class extends i {\n        \
} };\n      }, { \"../../../utils\": 114, \"./dynamic-html-image\": 80 }], \
82: [function(e, t, r) {\n        const { utils: n } = e(\"../../../utils\"), \
{ WebGLKernelValueDynamicMemoryOptimizedNumberTexture: i } = \
e(\"../../web-gl/kernel-value/dynamic-memory-optimized-number-texture\");\n   \
     t.exports = { WebGL2KernelValueDynamicMemoryOptimizedNumberTexture: \
class extends i {\n          getSource() {\n            return \
n.linesToString([`uniform sampler2D ${this.id}`, `uniform ivec2 \
${this.sizeId}`, `uniform ivec3 ${this.dimensionsId}`]);\n          }\n       \
 } };\n      }, { \"../../../utils\": 114, \
\"../../web-gl/kernel-value/dynamic-memory-optimized-number-texture\": 47 }], \
83: [function(e, t, r) {\n        const { utils: n } = e(\"../../../utils\"), \
{ WebGLKernelValueDynamicNumberTexture: i } = \
e(\"../../web-gl/kernel-value/dynamic-number-texture\");\n        t.exports = \
{ WebGL2KernelValueDynamicNumberTexture: class extends i {\n          \
getSource() {\n            const e2 = this.getVariablePrecisionString();\n    \
        return n.linesToString([`uniform ${e2} sampler2D ${this.id}`, \
`uniform ${e2} ivec2 ${this.sizeId}`, `uniform ${e2} ivec3 \
${this.dimensionsId}`]);\n          }\n        } };\n      }, { \
\"../../../utils\": 114, \
\"../../web-gl/kernel-value/dynamic-number-texture\": 48 }], 84: [function(e, \
t, r) {\n        const { utils: n } = e(\"../../../utils\"), { \
WebGL2KernelValueSingleArray: i } = \
e(\"../../web-gl2/kernel-value/single-array\");\n        t.exports = { \
WebGL2KernelValueDynamicSingleArray: class extends i {\n          getSource() \
{\n            const e2 = this.getVariablePrecisionString();\n            \
return n.linesToString([`uniform ${e2} sampler2D ${this.id}`, `uniform ${e2} \
ivec2 ${this.sizeId}`, `uniform ${e2} ivec3 ${this.dimensionsId}`]);\n        \
  }\n          updateValue(e2) {\n            this.dimensions = \
n.getDimensions(e2, true), this.textureSize = \
n.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio), \
this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * \
this.bitRatio, this.checkSize(this.textureSize[0], this.textureSize[1]), \
this.uploadValue = new Float32Array(this.uploadArrayLength), \
this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), \
this.kernel.setUniform2iv(this.sizeId, this.textureSize), \
super.updateValue(e2);\n          }\n        } };\n      }, { \
\"../../../utils\": 114, \"../../web-gl2/kernel-value/single-array\": 98 }], \
85: [function(e, t, r) {\n        const { utils: n } = e(\"../../../utils\"), \
{ WebGL2KernelValueSingleArray1DI: i } = \
e(\"../../web-gl2/kernel-value/single-array1d-i\");\n        t.exports = { \
WebGL2KernelValueDynamicSingleArray1DI: class extends i {\n          \
getSource() {\n            const e2 = this.getVariablePrecisionString();\n    \
        return n.linesToString([`uniform ${e2} sampler2D ${this.id}`, \
`uniform ${e2} ivec2 ${this.sizeId}`, `uniform ${e2} ivec3 \
${this.dimensionsId}`]);\n          }\n          updateValue(e2) {\n          \
  this.setShape(e2), this.kernel.setUniform3iv(this.dimensionsId, \
this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), \
super.updateValue(e2);\n          }\n        } };\n      }, { \
\"../../../utils\": 114, \"../../web-gl2/kernel-value/single-array1d-i\": 99 \
}], 86: [function(e, t, r) {\n        const { utils: n } = \
e(\"../../../utils\"), { WebGL2KernelValueSingleArray2DI: i } = \
e(\"../../web-gl2/kernel-value/single-array2d-i\");\n        t.exports = { \
WebGL2KernelValueDynamicSingleArray2DI: class extends i {\n          \
getSource() {\n            const e2 = this.getVariablePrecisionString();\n    \
        return n.linesToString([`uniform ${e2} sampler2D ${this.id}`, \
`uniform ${e2} ivec2 ${this.sizeId}`, `uniform ${e2} ivec3 \
${this.dimensionsId}`]);\n          }\n          updateValue(e2) {\n          \
  this.setShape(e2), this.kernel.setUniform3iv(this.dimensionsId, \
this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), \
super.updateValue(e2);\n          }\n        } };\n      }, { \
\"../../../utils\": 114, \"../../web-gl2/kernel-value/single-array2d-i\": 100 \
}], 87: [function(e, t, r) {\n        const { utils: n } = \
e(\"../../../utils\"), { WebGL2KernelValueSingleArray3DI: i } = \
e(\"../../web-gl2/kernel-value/single-array3d-i\");\n        t.exports = { \
WebGL2KernelValueDynamicSingleArray3DI: class extends i {\n          \
getSource() {\n            const e2 = this.getVariablePrecisionString();\n    \
        return n.linesToString([`uniform ${e2} sampler2D ${this.id}`, \
`uniform ${e2} ivec2 ${this.sizeId}`, `uniform ${e2} ivec3 \
${this.dimensionsId}`]);\n          }\n          updateValue(e2) {\n          \
  this.setShape(e2), this.kernel.setUniform3iv(this.dimensionsId, \
this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), \
super.updateValue(e2);\n          }\n        } };\n      }, { \
\"../../../utils\": 114, \"../../web-gl2/kernel-value/single-array3d-i\": 101 \
}], 88: [function(e, t, r) {\n        const { utils: n } = \
e(\"../../../utils\"), { WebGL2KernelValueSingleInput: i } = \
e(\"../../web-gl2/kernel-value/single-input\");\n        t.exports = { \
WebGL2KernelValueDynamicSingleInput: class extends i {\n          getSource() \
{\n            const e2 = this.getVariablePrecisionString();\n            \
return n.linesToString([`uniform ${e2} sampler2D ${this.id}`, `uniform ${e2} \
ivec2 ${this.sizeId}`, `uniform ${e2} ivec3 ${this.dimensionsId}`]);\n        \
  }\n          updateValue(e2) {\n            let [t2, r2, i2] = e2.size;\n   \
         this.dimensions = new Int32Array([t2 || 1, r2 || 1, i2 || 1]), \
this.textureSize = n.getMemoryOptimizedFloatTextureSize(this.dimensions, \
this.bitRatio), this.uploadArrayLength = this.textureSize[0] * \
this.textureSize[1] * this.bitRatio, this.checkSize(this.textureSize[0], \
this.textureSize[1]), this.uploadValue = new \
Float32Array(this.uploadArrayLength), \
this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), \
this.kernel.setUniform2iv(this.sizeId, this.textureSize), \
super.updateValue(e2);\n          }\n        } };\n      }, { \
\"../../../utils\": 114, \"../../web-gl2/kernel-value/single-input\": 102 }], \
89: [function(e, t, r) {\n        const { utils: n } = e(\"../../../utils\"), \
{ WebGLKernelValueDynamicUnsignedArray: i } = \
e(\"../../web-gl/kernel-value/dynamic-unsigned-array\");\n        t.exports = \
{ WebGL2KernelValueDynamicUnsignedArray: class extends i {\n          \
getSource() {\n            const e2 = this.getVariablePrecisionString();\n    \
        return n.linesToString([`uniform ${e2} sampler2D ${this.id}`, \
`uniform ${e2} ivec2 ${this.sizeId}`, `uniform ${e2} ivec3 \
${this.dimensionsId}`]);\n          }\n        } };\n      }, { \
\"../../../utils\": 114, \
\"../../web-gl/kernel-value/dynamic-unsigned-array\": 54 }], 90: [function(e, \
t, r) {\n        const { utils: n } = e(\"../../../utils\"), { \
WebGLKernelValueDynamicUnsignedInput: i } = \
e(\"../../web-gl/kernel-value/dynamic-unsigned-input\");\n        t.exports = \
{ WebGL2KernelValueDynamicUnsignedInput: class extends i {\n          \
getSource() {\n            const e2 = this.getVariablePrecisionString();\n    \
        return n.linesToString([`uniform ${e2} sampler2D ${this.id}`, \
`uniform ${e2} ivec2 ${this.sizeId}`, `uniform ${e2} ivec3 \
${this.dimensionsId}`]);\n          }\n        } };\n      }, { \
\"../../../utils\": 114, \
\"../../web-gl/kernel-value/dynamic-unsigned-input\": 55 }], 91: [function(e, \
t, r) {\n        const { utils: n } = e(\"../../../utils\"), { \
WebGLKernelValueFloat: i } = e(\"../../web-gl/kernel-value/float\");\n        \
t.exports = { WebGL2KernelValueFloat: class extends i {\n        } };\n      \
}, { \"../../../utils\": 114, \"../../web-gl/kernel-value/float\": 56 }], 92: \
[function(e, t, r) {\n        const { utils: n } = e(\"../../../utils\"), { \
WebGLKernelArray: i } = e(\"../../web-gl/kernel-value/array\");\n        \
t.exports = { WebGL2KernelValueHTMLImageArray: class extends i {\n          \
constructor(e2, t2) {\n            super(e2, t2), this.checkSize(e2[0].width, \
e2[0].height), this.dimensions = [e2[0].width, e2[0].height, e2.length], \
this.textureSize = [e2[0].width, e2[0].height];\n          }\n          \
defineTexture() {\n            const { context: e2 } = this;\n            \
e2.activeTexture(this.contextHandle), e2.bindTexture(e2.TEXTURE_2D_ARRAY, \
this.texture), e2.texParameteri(e2.TEXTURE_2D_ARRAY, e2.TEXTURE_MAG_FILTER, \
e2.NEAREST), e2.texParameteri(e2.TEXTURE_2D_ARRAY, e2.TEXTURE_MIN_FILTER, \
e2.NEAREST);\n          }\n          getStringValueHandler() {\n            \
return `const uploadValue_${this.name} = ${this.varName};\n`;\n          }\n  \
        getSource() {\n            const e2 = \
this.getVariablePrecisionString();\n            return \
n.linesToString([`uniform ${e2} sampler2DArray ${this.id}`, `${e2} ivec2 \
${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`, \
`${e2} ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, \
${this.dimensions[1]}, ${this.dimensions[2]})`]);\n          }\n          \
updateValue(e2) {\n            const { context: t2 } = this;\n            \
t2.activeTexture(this.contextHandle), t2.bindTexture(t2.TEXTURE_2D_ARRAY, \
this.texture), t2.pixelStorei(t2.UNPACK_FLIP_Y_WEBGL, true), \
t2.texImage3D(t2.TEXTURE_2D_ARRAY, 0, t2.RGBA, e2[0].width, e2[0].height, \
e2.length, 0, t2.RGBA, t2.UNSIGNED_BYTE, null);\n            for (let r2 = 0; \
r2 < e2.length; r2++) {\n              const n2 = 0, i2 = 0, s = 1;\n         \
     t2.texSubImage3D(t2.TEXTURE_2D_ARRAY, 0, n2, i2, r2, e2[r2].width, \
e2[r2].height, s, t2.RGBA, t2.UNSIGNED_BYTE, this.uploadValue = e2[r2]);\n    \
        }\n            this.kernel.setUniform1i(this.id, this.index);\n       \
   }\n        } };\n      }, { \"../../../utils\": 114, \
\"../../web-gl/kernel-value/array\": 40 }], 93: [function(e, t, r) {\n        \
const { utils: n } = e(\"../../../utils\"), { WebGLKernelValueHTMLImage: i } \
= e(\"../../web-gl/kernel-value/html-image\");\n        t.exports = { \
WebGL2KernelValueHTMLImage: class extends i {\n          getSource() {\n      \
      const e2 = this.getVariablePrecisionString();\n            return \
n.linesToString([`uniform ${e2} sampler2D ${this.id}`, `${e2} ivec2 \
${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`, \
`${e2} ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, \
${this.dimensions[1]}, ${this.dimensions[2]})`]);\n          }\n        } \
};\n      }, { \"../../../utils\": 114, \
\"../../web-gl/kernel-value/html-image\": 57 }], 94: [function(e, t, r) {\n   \
     const { utils: n } = e(\"../../../utils\"), { \
WebGL2KernelValueHTMLImage: i } = e(\"./html-image\");\n        t.exports = { \
WebGL2KernelValueHTMLVideo: class extends i {\n        } };\n      }, { \
\"../../../utils\": 114, \"./html-image\": 93 }], 95: [function(e, t, r) {\n  \
      const { WebGLKernelValueInteger: n } = \
e(\"../../web-gl/kernel-value/integer\");\n        t.exports = { \
WebGL2KernelValueInteger: class extends n {\n          getSource(e2) {\n      \
      const t2 = this.getVariablePrecisionString();\n            return \
\"constants\" === this.origin ? `const ${t2} int ${this.id} = \
${parseInt(e2)};\n` : `uniform ${t2} int ${this.id};\n`;\n          }\n       \
   updateValue(e2) {\n            \"constants\" !== this.origin && \
this.kernel.setUniform1i(this.id, this.uploadValue = e2);\n          }\n      \
  } };\n      }, { \"../../web-gl/kernel-value/integer\": 60 }], 96: \
[function(e, t, r) {\n        const { utils: n } = e(\"../../../utils\"), { \
WebGLKernelValueMemoryOptimizedNumberTexture: i } = \
e(\"../../web-gl/kernel-value/memory-optimized-number-texture\");\n        \
t.exports = { WebGL2KernelValueMemoryOptimizedNumberTexture: class extends i \
{\n          getSource() {\n            const { id: e2, sizeId: t2, \
textureSize: r2, dimensionsId: i2, dimensions: s } = this, a = \
this.getVariablePrecisionString();\n            return \
n.linesToString([`uniform sampler2D ${e2}`, `${a} ivec2 ${t2} = \
ivec2(${r2[0]}, ${r2[1]})`, `${a} ivec3 ${i2} = ivec3(${s[0]}, ${s[1]}, \
${s[2]})`]);\n          }\n        } };\n      }, { \"../../../utils\": 114, \
\"../../web-gl/kernel-value/memory-optimized-number-texture\": 61 }], 97: \
[function(e, t, r) {\n        const { utils: n } = e(\"../../../utils\"), { \
WebGLKernelValueNumberTexture: i } = \
e(\"../../web-gl/kernel-value/number-texture\");\n        t.exports = { \
WebGL2KernelValueNumberTexture: class extends i {\n          getSource() {\n  \
          const { id: e2, sizeId: t2, textureSize: r2, dimensionsId: i2, \
dimensions: s } = this, a = this.getVariablePrecisionString();\n            \
return n.linesToString([`uniform ${a} sampler2D ${e2}`, `${a} ivec2 ${t2} = \
ivec2(${r2[0]}, ${r2[1]})`, `${a} ivec3 ${i2} = ivec3(${s[0]}, ${s[1]}, \
${s[2]})`]);\n          }\n        } };\n      }, { \"../../../utils\": 114, \
\"../../web-gl/kernel-value/number-texture\": 62 }], 98: [function(e, t, r) \
{\n        const { utils: n } = e(\"../../../utils\"), { \
WebGLKernelValueSingleArray: i } = \
e(\"../../web-gl/kernel-value/single-array\");\n        t.exports = { \
WebGL2KernelValueSingleArray: class extends i {\n          getSource() {\n    \
        const e2 = this.getVariablePrecisionString();\n            return \
n.linesToString([`uniform ${e2} sampler2D ${this.id}`, `${e2} ivec2 \
${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`, \
`${e2} ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, \
${this.dimensions[1]}, ${this.dimensions[2]})`]);\n          }\n          \
updateValue(e2) {\n            if (e2.constructor !== \
this.initialValueConstructor) return void \
this.onUpdateValueMismatch(e2.constructor);\n            const { context: t2 \
} = this;\n            n.flattenTo(e2, this.uploadValue), \
t2.activeTexture(this.contextHandle), t2.bindTexture(t2.TEXTURE_2D, \
this.texture), t2.pixelStorei(t2.UNPACK_FLIP_Y_WEBGL, false), \
t2.texImage2D(t2.TEXTURE_2D, 0, t2.RGBA32F, this.textureSize[0], \
this.textureSize[1], 0, t2.RGBA, t2.FLOAT, this.uploadValue), \
this.kernel.setUniform1i(this.id, this.index);\n          }\n        } };\n   \
   }, { \"../../../utils\": 114, \"../../web-gl/kernel-value/single-array\": \
63 }], 99: [function(e, t, r) {\n        const { utils: n } = \
e(\"../../../utils\"), { WebGLKernelValueSingleArray1DI: i } = \
e(\"../../web-gl/kernel-value/single-array1d-i\");\n        t.exports = { \
WebGL2KernelValueSingleArray1DI: class extends i {\n          updateValue(e2) \
{\n            if (e2.constructor !== this.initialValueConstructor) return \
void this.onUpdateValueMismatch(e2.constructor);\n            const { \
context: t2 } = this;\n            n.flattenTo(e2, this.uploadValue), \
t2.activeTexture(this.contextHandle), t2.bindTexture(t2.TEXTURE_2D, \
this.texture), t2.pixelStorei(t2.UNPACK_FLIP_Y_WEBGL, false), \
t2.texImage2D(t2.TEXTURE_2D, 0, t2.RGBA32F, this.textureSize[0], \
this.textureSize[1], 0, t2.RGBA, t2.FLOAT, this.uploadValue), \
this.kernel.setUniform1i(this.id, this.index);\n          }\n        } };\n   \
   }, { \"../../../utils\": 114, \
\"../../web-gl/kernel-value/single-array1d-i\": 64 }], 100: [function(e, t, \
r) {\n        const { utils: n } = e(\"../../../utils\"), { \
WebGLKernelValueSingleArray2DI: i } = \
e(\"../../web-gl/kernel-value/single-array2d-i\");\n        t.exports = { \
WebGL2KernelValueSingleArray2DI: class extends i {\n          updateValue(e2) \
{\n            if (e2.constructor !== this.initialValueConstructor) return \
void this.onUpdateValueMismatch(e2.constructor);\n            const { \
context: t2 } = this;\n            n.flattenTo(e2, this.uploadValue), \
t2.activeTexture(this.contextHandle), t2.bindTexture(t2.TEXTURE_2D, \
this.texture), t2.pixelStorei(t2.UNPACK_FLIP_Y_WEBGL, false), \
t2.texImage2D(t2.TEXTURE_2D, 0, t2.RGBA32F, this.textureSize[0], \
this.textureSize[1], 0, t2.RGBA, t2.FLOAT, this.uploadValue), \
this.kernel.setUniform1i(this.id, this.index);\n          }\n        } };\n   \
   }, { \"../../../utils\": 114, \
\"../../web-gl/kernel-value/single-array2d-i\": 65 }], 101: [function(e, t, \
r) {\n        const { utils: n } = e(\"../../../utils\"), { \
WebGLKernelValueSingleArray3DI: i } = \
e(\"../../web-gl/kernel-value/single-array3d-i\");\n        t.exports = { \
WebGL2KernelValueSingleArray3DI: class extends i {\n          updateValue(e2) \
{\n            if (e2.constructor !== this.initialValueConstructor) return \
void this.onUpdateValueMismatch(e2.constructor);\n            const { \
context: t2 } = this;\n            n.flattenTo(e2, this.uploadValue), \
t2.activeTexture(this.contextHandle), t2.bindTexture(t2.TEXTURE_2D, \
this.texture), t2.pixelStorei(t2.UNPACK_FLIP_Y_WEBGL, false), \
t2.texImage2D(t2.TEXTURE_2D, 0, t2.RGBA32F, this.textureSize[0], \
this.textureSize[1], 0, t2.RGBA, t2.FLOAT, this.uploadValue), \
this.kernel.setUniform1i(this.id, this.index);\n          }\n        } };\n   \
   }, { \"../../../utils\": 114, \
\"../../web-gl/kernel-value/single-array3d-i\": 66 }], 102: [function(e, t, \
r) {\n        const { utils: n } = e(\"../../../utils\"), { \
WebGLKernelValueSingleInput: i } = \
e(\"../../web-gl/kernel-value/single-input\");\n        t.exports = { \
WebGL2KernelValueSingleInput: class extends i {\n          getSource() {\n    \
        const e2 = this.getVariablePrecisionString();\n            return \
n.linesToString([`uniform ${e2} sampler2D ${this.id}`, `${e2} ivec2 \
${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`, \
`${e2} ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, \
${this.dimensions[1]}, ${this.dimensions[2]})`]);\n          }\n          \
updateValue(e2) {\n            const { context: t2 } = this;\n            \
n.flattenTo(e2.value, this.uploadValue), \
t2.activeTexture(this.contextHandle), t2.bindTexture(t2.TEXTURE_2D, \
this.texture), t2.pixelStorei(t2.UNPACK_FLIP_Y_WEBGL, false), \
t2.texImage2D(t2.TEXTURE_2D, 0, t2.RGBA32F, this.textureSize[0], \
this.textureSize[1], 0, t2.RGBA, t2.FLOAT, this.uploadValue), \
this.kernel.setUniform1i(this.id, this.index);\n          }\n        } };\n   \
   }, { \"../../../utils\": 114, \"../../web-gl/kernel-value/single-input\": \
67 }], 103: [function(e, t, r) {\n        const { utils: n } = \
e(\"../../../utils\"), { WebGLKernelValueUnsignedArray: i } = \
e(\"../../web-gl/kernel-value/unsigned-array\");\n        t.exports = { \
WebGL2KernelValueUnsignedArray: class extends i {\n          getSource() {\n  \
          const e2 = this.getVariablePrecisionString();\n            return \
n.linesToString([`uniform ${e2} sampler2D ${this.id}`, `${e2} ivec2 \
${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`, \
`${e2} ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, \
${this.dimensions[1]}, ${this.dimensions[2]})`]);\n          }\n        } \
};\n      }, { \"../../../utils\": 114, \
\"../../web-gl/kernel-value/unsigned-array\": 68 }], 104: [function(e, t, r) \
{\n        const { utils: n } = e(\"../../../utils\"), { \
WebGLKernelValueUnsignedInput: i } = \
e(\"../../web-gl/kernel-value/unsigned-input\");\n        t.exports = { \
WebGL2KernelValueUnsignedInput: class extends i {\n          getSource() {\n  \
          const e2 = this.getVariablePrecisionString();\n            return \
n.linesToString([`uniform ${e2} sampler2D ${this.id}`, `${e2} ivec2 \
${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`, \
`${e2} ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, \
${this.dimensions[1]}, ${this.dimensions[2]})`]);\n          }\n        } \
};\n      }, { \"../../../utils\": 114, \
\"../../web-gl/kernel-value/unsigned-input\": 69 }], 105: [function(e, t, r) \
{\n        const { WebGLKernel: n } = e(\"../web-gl/kernel\"), { \
WebGL2FunctionNode: i } = e(\"./function-node\"), { FunctionBuilder: s } = \
e(\"../function-builder\"), { utils: a } = e(\"../../utils\"), { \
fragmentShader: o } = e(\"./fragment-shader\"), { vertexShader: u } = \
e(\"./vertex-shader\"), { lookupKernelValueType: l } = \
e(\"./kernel-value-maps\");\n        let h = null, c = null, p = null, d = \
null, m = null;\n        t.exports = { WebGL2Kernel: class extends n {\n      \
    static get isSupported() {\n            return null !== h || \
(this.setupFeatureChecks(), h = this.isContextMatch(p)), h;\n          }\n    \
      static setupFeatureChecks() {\n            \"undefined\" != typeof \
document ? c = document.createElement(\"canvas\") : \"undefined\" != typeof \
OffscreenCanvas && (c = new OffscreenCanvas(0, 0)), c && (p = \
c.getContext(\"webgl2\"), p && p.getExtension && (d = { \
EXT_color_buffer_float: p.getExtension(\"EXT_color_buffer_float\"), \
OES_texture_float_linear: p.getExtension(\"OES_texture_float_linear\") }, m = \
this.getFeatures()));\n          }\n          static isContextMatch(e2) {\n   \
         return \"undefined\" != typeof WebGL2RenderingContext && e2 \
instanceof WebGL2RenderingContext;\n          }\n          static \
getFeatures() {\n            const e2 = this.testContext;\n            return \
Object.freeze({ isFloatRead: this.getIsFloatRead(), \
isIntegerDivisionAccurate: this.getIsIntegerDivisionAccurate(), \
isSpeedTacticSupported: this.getIsSpeedTacticSupported(), kernelMap: true, \
isTextureFloat: true, isDrawBuffers: true, channelCount: \
this.getChannelCount(), maxTextureSize: this.getMaxTextureSize(), \
lowIntPrecision: e2.getShaderPrecisionFormat(e2.FRAGMENT_SHADER, e2.LOW_INT), \
lowFloatPrecision: e2.getShaderPrecisionFormat(e2.FRAGMENT_SHADER, \
e2.LOW_FLOAT), mediumIntPrecision: \
e2.getShaderPrecisionFormat(e2.FRAGMENT_SHADER, e2.MEDIUM_INT), \
mediumFloatPrecision: e2.getShaderPrecisionFormat(e2.FRAGMENT_SHADER, \
e2.MEDIUM_FLOAT), highIntPrecision: \
e2.getShaderPrecisionFormat(e2.FRAGMENT_SHADER, e2.HIGH_INT), \
highFloatPrecision: e2.getShaderPrecisionFormat(e2.FRAGMENT_SHADER, \
e2.HIGH_FLOAT) });\n          }\n          static getIsTextureFloat() {\n     \
       return true;\n          }\n          static getChannelCount() {\n      \
      return p.getParameter(p.MAX_DRAW_BUFFERS);\n          }\n          \
static getMaxTextureSize() {\n            return \
p.getParameter(p.MAX_TEXTURE_SIZE);\n          }\n          static \
lookupKernelValueType(e2, t2, r2, n2) {\n            return l(e2, t2, r2, \
n2);\n          }\n          static get testCanvas() {\n            return \
c;\n          }\n          static get testContext() {\n            return \
p;\n          }\n          static get features() {\n            return m;\n   \
       }\n          static get fragmentShader() {\n            return o;\n    \
      }\n          static get vertexShader() {\n            return u;\n       \
   }\n          initContext() {\n            return \
this.canvas.getContext(\"webgl2\", { alpha: false, depth: false, antialias: \
false });\n          }\n          initExtensions() {\n            \
this.extensions = { EXT_color_buffer_float: \
this.context.getExtension(\"EXT_color_buffer_float\"), \
OES_texture_float_linear: \
this.context.getExtension(\"OES_texture_float_linear\") };\n          }\n     \
     validateSettings(e2) {\n            if (!this.validate) return void \
(this.texSize = a.getKernelTextureSize({ optimizeFloatMemory: \
this.optimizeFloatMemory, precision: this.precision }, this.output));\n       \
     const { features: t2 } = this.constructor;\n            if (\"single\" \
=== this.precision && !t2.isFloatRead) throw new Error(\"Float texture \
outputs are not supported\");\n            if (this.graphical || null !== \
this.precision || (this.precision = t2.isFloatRead ? \"single\" : \
\"unsigned\"), null === this.fixIntegerDivisionAccuracy ? \
this.fixIntegerDivisionAccuracy = !t2.isIntegerDivisionAccurate : \
this.fixIntegerDivisionAccuracy && t2.isIntegerDivisionAccurate && \
(this.fixIntegerDivisionAccuracy = false), this.checkOutput(), !this.output \
|| 0 === this.output.length) {\n              if (1 !== e2.length) throw new \
Error(\"Auto output only supported for kernels with only one input\");\n      \
        const t3 = a.getVariableType(e2[0], this.strictIntegers);\n           \
   switch (t3) {\n                case \"Array\":\n                  \
this.output = a.getDimensions(t3);\n                  break;\n                \
case \"NumberTexture\":\n                case \
\"MemoryOptimizedNumberTexture\":\n                case \
\"ArrayTexture(1)\":\n                case \"ArrayTexture(2)\":\n             \
   case \"ArrayTexture(3)\":\n                case \"ArrayTexture(4)\":\n     \
             this.output = e2[0].output;\n                  break;\n          \
      default:\n                  throw new Error(\"Auto output not supported \
for input type: \" + t3);\n              }\n            }\n            if \
(this.graphical) {\n              if (2 !== this.output.length) throw new \
Error(\"Output must have 2 dimensions on graphical mode\");\n              \
return \"single\" === this.precision && (console.warn(\"Cannot use graphical \
mode and single precision at the same time\"), this.precision = \
\"unsigned\"), void (this.texSize = a.clone(this.output));\n            }\n   \
         !this.graphical && null === this.precision && t2.isTextureFloat && \
(this.precision = \"single\"), this.texSize = a.getKernelTextureSize({ \
optimizeFloatMemory: this.optimizeFloatMemory, precision: this.precision }, \
this.output), this.checkTextureSize();\n          }\n          \
translateSource() {\n            const e2 = s.fromKernel(this, i, { \
fixIntegerDivisionAccuracy: this.fixIntegerDivisionAccuracy });\n            \
this.translatedSource = e2.getPrototypeString(\"kernel\"), \
this.setupReturnTypes(e2);\n          }\n          drawBuffers() {\n          \
  this.context.drawBuffers(this.drawBuffersMap);\n          }\n          \
getTextureFormat() {\n            const { context: e2 } = this;\n            \
switch (this.getInternalFormat()) {\n              case e2.R32F:\n            \
    return e2.RED;\n              case e2.RG32F:\n                return \
e2.RG;\n              case e2.RGBA32F:\n              case e2.RGBA:\n         \
       return e2.RGBA;\n              default:\n                throw new \
Error(\"Unknown internal format\");\n            }\n          }\n          \
getInternalFormat() {\n            const { context: e2 } = this;\n            \
if (\"single\" === this.precision) {\n              if (this.pipeline) switch \
(this.returnType) {\n                case \"Number\":\n                case \
\"Float\":\n                case \"Integer\":\n                  return \
this.optimizeFloatMemory ? e2.RGBA32F : e2.R32F;\n                case \
\"Array(2)\":\n                  return e2.RG32F;\n                case \
\"Array(3)\":\n                case \"Array(4)\":\n                  return \
e2.RGBA32F;\n                default:\n                  throw new \
Error(\"Unhandled return type\");\n              }\n              return \
e2.RGBA32F;\n            }\n            return e2.RGBA;\n          }\n        \
  _setupOutputTexture() {\n            const e2 = this.context;\n            \
if (this.texture) return void e2.framebufferTexture2D(e2.FRAMEBUFFER, \
e2.COLOR_ATTACHMENT0, e2.TEXTURE_2D, this.texture.texture, 0);\n            \
e2.bindFramebuffer(e2.FRAMEBUFFER, this.framebuffer);\n            const t2 = \
e2.createTexture(), r2 = this.texSize;\n            \
e2.activeTexture(e2.TEXTURE0 + this.constantTextureCount + \
this.argumentTextureCount), e2.bindTexture(e2.TEXTURE_2D, t2), \
e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_S, e2.REPEAT), \
e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_T, e2.REPEAT), \
e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MIN_FILTER, e2.NEAREST), \
e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MAG_FILTER, e2.NEAREST);\n         \
   const n2 = this.getInternalFormat();\n            \"single\" === \
this.precision ? e2.texStorage2D(e2.TEXTURE_2D, 1, n2, r2[0], r2[1]) : \
e2.texImage2D(e2.TEXTURE_2D, 0, n2, r2[0], r2[1], 0, n2, e2.UNSIGNED_BYTE, \
null), e2.framebufferTexture2D(e2.FRAMEBUFFER, e2.COLOR_ATTACHMENT0, \
e2.TEXTURE_2D, t2, 0), this.texture = new this.TextureConstructor({ texture: \
t2, size: r2, dimensions: this.threadDim, output: this.output, context: \
this.context, internalFormat: this.getInternalFormat(), textureFormat: \
this.getTextureFormat(), kernel: this });\n          }\n          \
_setupSubOutputTextures() {\n            const e2 = this.context;\n           \
 if (this.mappedTextures) {\n              for (let t3 = 0; t3 < \
this.subKernels.length; t3++) e2.framebufferTexture2D(e2.FRAMEBUFFER, \
e2.COLOR_ATTACHMENT0 + t3 + 1, e2.TEXTURE_2D, \
this.mappedTextures[t3].texture, 0);\n              return;\n            }\n  \
          const t2 = this.texSize;\n            this.drawBuffersMap = \
[e2.COLOR_ATTACHMENT0], this.mappedTextures = [];\n            for (let r2 = \
0; r2 < this.subKernels.length; r2++) {\n              const n2 = \
this.createTexture();\n              \
this.drawBuffersMap.push(e2.COLOR_ATTACHMENT0 + r2 + 1), \
e2.activeTexture(e2.TEXTURE0 + this.constantTextureCount + \
this.argumentTextureCount + r2), e2.bindTexture(e2.TEXTURE_2D, n2), \
e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_S, e2.CLAMP_TO_EDGE), \
e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_T, e2.CLAMP_TO_EDGE), \
e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MIN_FILTER, e2.NEAREST), \
e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MAG_FILTER, e2.NEAREST);\n         \
     const i2 = this.getInternalFormat();\n              \"single\" === \
this.precision ? e2.texStorage2D(e2.TEXTURE_2D, 1, i2, t2[0], t2[1]) : \
e2.texImage2D(e2.TEXTURE_2D, 0, e2.RGBA, t2[0], t2[1], 0, e2.RGBA, \
e2.UNSIGNED_BYTE, null), e2.framebufferTexture2D(e2.FRAMEBUFFER, \
e2.COLOR_ATTACHMENT0 + r2 + 1, e2.TEXTURE_2D, n2, 0), \
this.mappedTextures.push(new this.TextureConstructor({ texture: n2, size: t2, \
dimensions: this.threadDim, output: this.output, context: this.context, \
internalFormat: this.getInternalFormat(), textureFormat: \
this.getTextureFormat(), kernel: this }));\n            }\n          }\n      \
    _getHeaderString() {\n            return \"\";\n          }\n          \
_getTextureCoordinate() {\n            const e2 = this.subKernels, t2 = \
this.getVariablePrecisionString(this.texSize, this.tactic);\n            \
return null === e2 || e2.length < 1 ? `in ${t2} vec2 vTexCoord;\n` : `out \
${t2} vec2 vTexCoord;\n`;\n          }\n          _getMainArgumentsString(e2) \
{\n            const t2 = [], r2 = this.argumentNames;\n            for (let \
n2 = 0; n2 < r2.length; n2++) \
t2.push(this.kernelArguments[n2].getSource(e2[n2]));\n            return \
t2.join(\"\");\n          }\n          getKernelString() {\n            const \
e2 = [this.getKernelResultDeclaration()], t2 = this.subKernels;\n            \
if (null !== t2) switch (e2.push(\"layout(location = 0) out vec4 data0\"), \
this.returnType) {\n              case \"Number\":\n              case \
\"Float\":\n              case \"Integer\":\n                for (let r2 = 0; \
r2 < t2.length; r2++) {\n                  const n2 = t2[r2];\n               \
   e2.push(\"Integer\" === n2.returnType ? `int subKernelResult_${n2.name} = \
0` : `float subKernelResult_${n2.name} = 0.0`, `layout(location = ${r2 + 1}) \
out vec4 data${r2 + 1}`);\n                }\n                break;\n        \
      case \"Array(2)\":\n                for (let r2 = 0; r2 < t2.length; \
r2++) e2.push(`vec2 subKernelResult_${t2[r2].name}`, `layout(location = ${r2 \
+ 1}) out vec4 data${r2 + 1}`);\n                break;\n              case \
\"Array(3)\":\n                for (let r2 = 0; r2 < t2.length; r2++) \
e2.push(`vec3 subKernelResult_${t2[r2].name}`, `layout(location = ${r2 + 1}) \
out vec4 data${r2 + 1}`);\n                break;\n              case \
\"Array(4)\":\n                for (let r2 = 0; r2 < t2.length; r2++) \
e2.push(`vec4 subKernelResult_${t2[r2].name}`, `layout(location = ${r2 + 1}) \
out vec4 data${r2 + 1}`);\n            }\n            else e2.push(\"out vec4 \
data0\");\n            return a.linesToString(e2) + this.translatedSource;\n  \
        }\n          getMainResultGraphical() {\n            return \
a.linesToString([\"  threadId = indexTo3D(index, uOutputDim)\", \"  \
kernel()\", \"  data0 = actualColor\"]);\n          }\n          \
getMainResultPackedPixels() {\n            switch (this.returnType) {\n       \
       case \"LiteralInteger\":\n              case \"Number\":\n             \
 case \"Integer\":\n              case \"Float\":\n                return \
this.getMainResultKernelPackedPixels() + \
this.getMainResultSubKernelPackedPixels();\n              default:\n          \
      throw new Error(`packed output only usable with Numbers, \
\"${this.returnType}\" specified`);\n            }\n          }\n          \
getMainResultKernelPackedPixels() {\n            return a.linesToString([\"  \
threadId = indexTo3D(index, uOutputDim)\", \"  kernel()\", `  data0 = \
${this.useLegacyEncoder ? \"legacyEncode32\" : \
\"encode32\"}(kernelResult)`]);\n          }\n          \
getMainResultSubKernelPackedPixels() {\n            const e2 = [];\n          \
  if (!this.subKernels) return \"\";\n            for (let t2 = 0; t2 < \
this.subKernels.length; t2++) {\n              \"Integer\" === \
this.subKernels[t2].returnType ? e2.push(`  data${t2 + 1} = \
${this.useLegacyEncoder ? \"legacyEncode32\" : \
\"encode32\"}(float(subKernelResult_${this.subKernels[t2].name}))`) : \
e2.push(`  data${t2 + 1} = ${this.useLegacyEncoder ? \"legacyEncode32\" : \
\"encode32\"}(subKernelResult_${this.subKernels[t2].name})`);\n            \
}\n            return a.linesToString(e2);\n          }\n          \
getMainResultKernelMemoryOptimizedFloats(e2, t2) {\n            e2.push(\"  \
threadId = indexTo3D(index, uOutputDim)\", \"  kernel()\", `  data0.${t2} = \
kernelResult`);\n          }\n          \
getMainResultSubKernelMemoryOptimizedFloats(e2, t2) {\n            if \
(!this.subKernels) return e2;\n            for (let r2 = 0; r2 < \
this.subKernels.length; r2++) {\n              const n2 = \
this.subKernels[r2];\n              \"Integer\" === n2.returnType ? e2.push(` \
 data${r2 + 1}.${t2} = float(subKernelResult_${n2.name})`) : e2.push(`  \
data${r2 + 1}.${t2} = subKernelResult_${n2.name}`);\n            }\n          \
}\n          getMainResultKernelNumberTexture() {\n            return [\"  \
threadId = indexTo3D(index, uOutputDim)\", \"  kernel()\", \"  data0[0] = \
kernelResult\"];\n          }\n          \
getMainResultSubKernelNumberTexture() {\n            const e2 = [];\n         \
   if (!this.subKernels) return e2;\n            for (let t2 = 0; t2 < \
this.subKernels.length; ++t2) {\n              const r2 = \
this.subKernels[t2];\n              \"Integer\" === r2.returnType ? e2.push(` \
 data${t2 + 1}[0] = float(subKernelResult_${r2.name})`) : e2.push(`  data${t2 \
+ 1}[0] = subKernelResult_${r2.name}`);\n            }\n            return \
e2;\n          }\n          getMainResultKernelArray2Texture() {\n            \
return [\"  threadId = indexTo3D(index, uOutputDim)\", \"  kernel()\", \"  \
data0[0] = kernelResult[0]\", \"  data0[1] = kernelResult[1]\"];\n          \
}\n          getMainResultSubKernelArray2Texture() {\n            const e2 = \
[];\n            if (!this.subKernels) return e2;\n            for (let t2 = \
0; t2 < this.subKernels.length; ++t2) {\n              const r2 = \
this.subKernels[t2];\n              e2.push(`  data${t2 + 1}[0] = \
subKernelResult_${r2.name}[0]`, `  data${t2 + 1}[1] = \
subKernelResult_${r2.name}[1]`);\n            }\n            return e2;\n     \
     }\n          getMainResultKernelArray3Texture() {\n            return \
[\"  threadId = indexTo3D(index, uOutputDim)\", \"  kernel()\", \"  data0[0] \
= kernelResult[0]\", \"  data0[1] = kernelResult[1]\", \"  data0[2] = \
kernelResult[2]\"];\n          }\n          \
getMainResultSubKernelArray3Texture() {\n            const e2 = [];\n         \
   if (!this.subKernels) return e2;\n            for (let t2 = 0; t2 < \
this.subKernels.length; ++t2) {\n              const r2 = \
this.subKernels[t2];\n              e2.push(`  data${t2 + 1}[0] = \
subKernelResult_${r2.name}[0]`, `  data${t2 + 1}[1] = \
subKernelResult_${r2.name}[1]`, `  data${t2 + 1}[2] = \
subKernelResult_${r2.name}[2]`);\n            }\n            return e2;\n     \
     }\n          getMainResultKernelArray4Texture() {\n            return \
[\"  threadId = indexTo3D(index, uOutputDim)\", \"  kernel()\", \"  data0 = \
kernelResult\"];\n          }\n          \
getMainResultSubKernelArray4Texture() {\n            const e2 = [];\n         \
   if (!this.subKernels) return e2;\n            for (let t2 = 0; t2 < \
this.subKernels.length; ++t2) e2.push(`  data${t2 + 1} = \
subKernelResult_${this.subKernels[t2].name}`);\n            return e2;\n      \
    }\n          destroyExtensions() {\n            \
this.extensions.EXT_color_buffer_float = null, \
this.extensions.OES_texture_float_linear = null;\n          }\n          \
toJSON() {\n            const e2 = super.toJSON();\n            return \
e2.functionNodes = s.fromKernel(this, i).toJSON(), e2.settings.threadDim = \
this.threadDim, e2;\n          }\n        } };\n      }, { \"../../utils\": \
114, \"../function-builder\": 9, \"../web-gl/kernel\": 70, \
\"./fragment-shader\": 72, \"./function-node\": 73, \"./kernel-value-maps\": \
74, \"./vertex-shader\": 106 }], 106: [function(e, t, r) {\n        t.exports \
= { vertexShader: \"#version 300 \
es\\n__FLOAT_TACTIC_DECLARATION__;\\n__INT_TACTIC_DECLARATION__;\\n__SAMPLER_\
2D_TACTIC_DECLARATION__;\\n\\nin vec2 aPos;\\nin vec2 aTexCoord;\\n\\nout \
vec2 vTexCoord;\\nuniform vec2 ratio;\\n\\nvoid main(void) {\\n  gl_Position \
= vec4((aPos + vec2(1)) * ratio + vec2(-1), 0, 1);\\n  vTexCoord = \
aTexCoord;\\n}\" };\n      }, {}], 107: [function(e, t, r) {\n        const n \
= e(\"./index\"), i = n.GPU;\n        for (const e2 in n) \
n.hasOwnProperty(e2) && \"GPU\" !== e2 && (i[e2] = n[e2]);\n        function \
s(e2) {\n          e2.GPU || Object.defineProperty(e2, \"GPU\", { get: () => \
i });\n        }\n        \"undefined\" != typeof window && s(window), \
\"undefined\" != typeof self && s(self), t.exports = n;\n      }, { \
\"./index\": 109 }], 108: [function(e, t, r) {\n        const { gpuMock: n } \
= e(\"gpu-mock.js\"), { utils: i } = e(\"./utils\"), { Kernel: s } = \
e(\"./backend/kernel\"), { CPUKernel: a } = e(\"./backend/cpu/kernel\"), { \
HeadlessGLKernel: o } = e(\"./backend/headless-gl/kernel\"), { WebGL2Kernel: \
u } = e(\"./backend/web-gl2/kernel\"), { WebGLKernel: l } = \
e(\"./backend/web-gl/kernel\"), { kernelRunShortcut: h } = \
e(\"./kernel-run-shortcut\"), c = [o, u, l], p = [\"gpu\", \"cpu\"], d = { \
headlessgl: o, webgl2: u, webgl: l };\n        let m = true;\n        \
function f(e2) {\n          if (!e2) return {};\n          const t2 = \
Object.assign({}, e2);\n          return e2.hasOwnProperty(\"floatOutput\") \
&& (i.warnDeprecated(\"setting\", \"floatOutput\", \"precision\"), \
t2.precision = e2.floatOutput ? \"single\" : \"unsigned\"), \
e2.hasOwnProperty(\"outputToTexture\") && (i.warnDeprecated(\"setting\", \
\"outputToTexture\", \"pipeline\"), t2.pipeline = \
Boolean(e2.outputToTexture)), e2.hasOwnProperty(\"outputImmutable\") && \
(i.warnDeprecated(\"setting\", \"outputImmutable\", \"immutable\"), \
t2.immutable = Boolean(e2.outputImmutable)), \
e2.hasOwnProperty(\"floatTextures\") && (i.warnDeprecated(\"setting\", \
\"floatTextures\", \"optimizeFloatMemory\"), t2.optimizeFloatMemory = \
Boolean(e2.floatTextures)), t2;\n        }\n        t.exports = { GPU: class \
{\n          static disableValidation() {\n            m = false;\n          \
}\n          static enableValidation() {\n            m = true;\n          \
}\n          static get isGPUSupported() {\n            return c.some((e2) => \
e2.isSupported);\n          }\n          static get isKernelMapSupported() \
{\n            return c.some((e2) => e2.isSupported && \
e2.features.kernelMap);\n          }\n          static get \
isOffscreenCanvasSupported() {\n            return \"undefined\" != typeof \
Worker && \"undefined\" != typeof OffscreenCanvas || \"undefined\" != typeof \
importScripts;\n          }\n          static get isWebGLSupported() {\n      \
      return l.isSupported;\n          }\n          static get \
isWebGL2Supported() {\n            return u.isSupported;\n          }\n       \
   static get isHeadlessGLSupported() {\n            return o.isSupported;\n  \
        }\n          static get isCanvasSupported() {\n            return \
\"undefined\" != typeof HTMLCanvasElement;\n          }\n          static get \
isGPUHTMLImageArraySupported() {\n            return u.isSupported;\n         \
 }\n          static get isSinglePrecisionSupported() {\n            return \
c.some((e2) => e2.isSupported && e2.features.isFloatRead && \
e2.features.isTextureFloat);\n          }\n          constructor(e2) {\n      \
      if (e2 = e2 || {}, this.canvas = e2.canvas || null, this.context = \
e2.context || null, this.mode = e2.mode, this.Kernel = null, this.kernels = \
[], this.functions = [], this.nativeFunctions = [], this.injectedNative = \
null, \"dev\" !== this.mode) {\n              if (this.chooseKernel(), \
e2.functions) for (let t2 = 0; t2 < e2.functions.length; t2++) \
this.addFunction(e2.functions[t2]);\n              if (e2.nativeFunctions) \
for (const t2 in e2.nativeFunctions) {\n                if \
(!e2.nativeFunctions.hasOwnProperty(t2)) continue;\n                const r2 \
= e2.nativeFunctions[t2], { name: n2, source: i2 } = r2;\n                \
this.addNativeFunction(n2, i2, r2);\n              }\n            }\n         \
 }\n          chooseKernel() {\n            if (this.Kernel) return;\n        \
    let e2 = null;\n            if (this.context) {\n              for (let \
t2 = 0; t2 < c.length; t2++) {\n                const r2 = c[t2];\n           \
     if (r2.isContextMatch(this.context)) {\n                  if \
(!r2.isSupported) throw new Error(`Kernel type ${r2.name} not supported`);\n  \
                e2 = r2;\n                  break;\n                }\n       \
       }\n              if (null === e2) throw new Error(\"unknown \
Context\");\n            } else if (this.mode) {\n              if (this.mode \
in d) m && !d[this.mode].isSupported || (e2 = d[this.mode]);\n              \
else if (\"gpu\" === this.mode) {\n                for (let t2 = 0; t2 < \
c.length; t2++) if (c[t2].isSupported) {\n                  e2 = c[t2];\n     \
             break;\n                }\n              } else \"cpu\" === \
this.mode && (e2 = a);\n              if (!e2) throw new Error(`A requested \
mode of \"${this.mode}\" and is not supported`);\n            } else {\n      \
        for (let t2 = 0; t2 < c.length; t2++) if (c[t2].isSupported) {\n      \
          e2 = c[t2];\n                break;\n              }\n              \
e2 || (e2 = a);\n            }\n            this.mode || (this.mode = \
e2.mode), this.Kernel = e2;\n          }\n          createKernel(e2, t2) {\n  \
          if (void 0 === e2) throw new Error(\"Missing source parameter\");\n \
           if (\"object\" != typeof e2 && !i.isFunction(e2) && \"string\" != \
typeof e2) throw new Error(\"source parameter not a function\");\n            \
const r2 = this.kernels;\n            if (\"dev\" === this.mode) {\n          \
    const i2 = n(e2, f(t2));\n              return r2.push(i2), i2;\n         \
   }\n            e2 = \"function\" == typeof e2 ? e2.toString() : e2;\n      \
      const s2 = {}, o2 = f(t2) || {};\n            function u2(t3) {\n       \
       console.warn(\"Falling back to CPU\");\n              const r3 = new \
a(e2, { argumentTypes: p2.argumentTypes, constantTypes: p2.constantTypes, \
graphical: p2.graphical, loopMaxIterations: p2.loopMaxIterations, constants: \
p2.constants, dynamicOutput: p2.dynamicOutput, dynamicArgument: \
p2.dynamicArguments, output: p2.output, precision: p2.precision, pipeline: \
p2.pipeline, immutable: p2.immutable, optimizeFloatMemory: \
p2.optimizeFloatMemory, fixIntegerDivisionAccuracy: \
p2.fixIntegerDivisionAccuracy, functions: p2.functions, nativeFunctions: \
p2.nativeFunctions, injectedNative: p2.injectedNative, subKernels: \
p2.subKernels, strictIntegers: p2.strictIntegers, debug: p2.debug });\n       \
       r3.build.apply(r3, t3);\n              const n2 = r3.run.apply(r3, \
t3);\n              return p2.replaceKernel(r3), n2;\n            }\n         \
   t2 && \"object\" == typeof t2.argumentTypes && (o2.argumentTypes = \
Object.keys(t2.argumentTypes).map((e3) => t2.argumentTypes[e3]));\n           \
 const l2 = Object.assign({ context: this.context, canvas: this.canvas, \
functions: this.functions, nativeFunctions: this.nativeFunctions, \
injectedNative: this.injectedNative, gpu: this, validate: m, \
onRequestFallback: u2, onRequestSwitchKernel: function t3(n2, i2, a2) {\n     \
         a2.debug && console.warn(\"Switching kernels\");\n              let \
o3 = null;\n              if (a2.signature && !s2[a2.signature] && \
(s2[a2.signature] = a2), a2.dynamicOutput) for (let e3 = n2.length - 1; e3 >= \
0; e3--) {\n                const t4 = n2[e3];\n                \
\"outputPrecisionMismatch\" === t4.type && (o3 = t4.needed);\n              \
}\n              const l3 = a2.constructor, h2 = l3.getArgumentTypes(a2, i2), \
c3 = l3.getSignature(a2, h2), d2 = s2[c3];\n              if (d2) return \
d2.onActivate(a2), d2;\n              const f2 = s2[c3] = new l3(e2, { \
argumentTypes: h2, constantTypes: a2.constantTypes, graphical: a2.graphical, \
loopMaxIterations: a2.loopMaxIterations, constants: a2.constants, \
dynamicOutput: a2.dynamicOutput, dynamicArgument: a2.dynamicArguments, \
context: a2.context, canvas: a2.canvas, output: o3 || a2.output, precision: \
a2.precision, pipeline: a2.pipeline, immutable: a2.immutable, \
optimizeFloatMemory: a2.optimizeFloatMemory, fixIntegerDivisionAccuracy: \
a2.fixIntegerDivisionAccuracy, functions: a2.functions, nativeFunctions: \
a2.nativeFunctions, injectedNative: a2.injectedNative, subKernels: \
a2.subKernels, strictIntegers: a2.strictIntegers, debug: a2.debug, gpu: \
a2.gpu, validate: m, returnType: a2.returnType, tactic: a2.tactic, \
onRequestFallback: u2, onRequestSwitchKernel: t3, texture: a2.texture, \
mappedTextures: a2.mappedTextures, drawBuffersMap: a2.drawBuffersMap });\n    \
          return f2.build.apply(f2, i2), p2.replaceKernel(f2), r2.push(f2), \
f2;\n            } }, o2), c2 = new this.Kernel(e2, l2), p2 = h(c2);\n        \
    return this.canvas || (this.canvas = c2.canvas), this.context || \
(this.context = c2.context), r2.push(c2), p2;\n          }\n          \
createKernelMap() {\n            let e2, t2;\n            const r2 = typeof \
arguments[arguments.length - 2];\n            if (\"function\" === r2 || \
\"string\" === r2 ? (e2 = arguments[arguments.length - 2], t2 = \
arguments[arguments.length - 1]) : e2 = arguments[arguments.length - 1], \
\"dev\" !== this.mode && (!this.Kernel.isSupported || \
!this.Kernel.features.kernelMap) && this.mode && p.indexOf(this.mode) < 0) \
throw new Error(`kernelMap not supported on ${this.Kernel.name}`);\n          \
  const n2 = f(t2);\n            if (t2 && \"object\" == typeof \
t2.argumentTypes && (n2.argumentTypes = \
Object.keys(t2.argumentTypes).map((e3) => t2.argumentTypes[e3])), \
Array.isArray(arguments[0])) {\n              n2.subKernels = [];\n           \
   const e3 = arguments[0];\n              for (let t3 = 0; t3 < e3.length; \
t3++) {\n                const r3 = e3[t3].toString(), s2 = \
i.getFunctionNameFromString(r3);\n                n2.subKernels.push({ name: \
s2, source: r3, property: t3 });\n              }\n            } else {\n     \
         n2.subKernels = [];\n              const e3 = arguments[0];\n        \
      for (let t3 in e3) {\n                if (!e3.hasOwnProperty(t3)) \
continue;\n                const r3 = e3[t3].toString(), s2 = \
i.getFunctionNameFromString(r3);\n                n2.subKernels.push({ name: \
s2 || t3, source: r3, property: t3 });\n              }\n            }\n      \
      return this.createKernel(e2, n2);\n          }\n          \
combineKernels() {\n            const e2 = arguments[arguments.length - 1];\n \
           if (\"cpu\" === arguments[0].kernel.constructor.mode) return e2;\n \
           const t2 = arguments[0].canvas, r2 = arguments[0].context, n2 = \
arguments.length - 1;\n            for (let e3 = 0; e3 < n2; e3++) \
arguments[e3].setCanvas(t2).setContext(r2).setPipeline(true);\n            \
return function() {\n              const t3 = e2.apply(this, arguments);\n    \
          return t3.toArray ? t3.toArray() : t3;\n            };\n          \
}\n          setFunctions(e2) {\n            return this.functions = e2, \
this;\n          }\n          setNativeFunctions(e2) {\n            return \
this.nativeFunctions = e2, this;\n          }\n          addFunction(e2, t2) \
{\n            return this.functions.push({ source: e2, settings: t2 }), \
this;\n          }\n          addNativeFunction(e2, t2, r2) {\n            if \
(this.kernels.length > 0) throw new Error('Cannot call \"addNativeFunction\" \
after \"createKernels\" has been called.');\n            return \
this.nativeFunctions.push(Object.assign({ name: e2, source: t2 }, r2)), \
this;\n          }\n          injectNative(e2) {\n            return \
this.injectedNative = e2, this;\n          }\n          destroy() {\n         \
   return new Promise((e2, t2) => {\n              this.kernels || e2(), \
setTimeout(() => {\n                try {\n                  for (let e4 = 0; \
e4 < this.kernels.length; e4++) this.kernels[e4].destroy(true);\n             \
     let e3 = this.kernels[0];\n                  e3 && (e3.kernel && (e3 = \
e3.kernel), e3.constructor.destroyContext && \
e3.constructor.destroyContext(this.context));\n                } catch (e3) \
{\n                  t2(e3);\n                }\n                e2();\n      \
        }, 0);\n            });\n          }\n        }, kernelOrder: c, \
kernelTypes: p };\n      }, { \"./backend/cpu/kernel\": 8, \
\"./backend/headless-gl/kernel\": 34, \"./backend/kernel\": 36, \
\"./backend/web-gl/kernel\": 70, \"./backend/web-gl2/kernel\": 105, \
\"./kernel-run-shortcut\": 111, \"./utils\": 114, \"gpu-mock.js\": 4 }], 109: \
[function(e, t, r) {\n        const { GPU: n } = e(\"./gpu\"), { alias: i } = \
e(\"./alias\"), { utils: s } = e(\"./utils\"), { Input: a, input: o } = \
e(\"./input\"), { Texture: u } = e(\"./texture\"), { FunctionBuilder: l } = \
e(\"./backend/function-builder\"), { FunctionNode: h } = \
e(\"./backend/function-node\"), { CPUFunctionNode: c } = \
e(\"./backend/cpu/function-node\"), { CPUKernel: p } = \
e(\"./backend/cpu/kernel\"), { HeadlessGLKernel: d } = \
e(\"./backend/headless-gl/kernel\"), { WebGLFunctionNode: m } = \
e(\"./backend/web-gl/function-node\"), { WebGLKernel: f } = \
e(\"./backend/web-gl/kernel\"), { kernelValueMaps: g } = \
e(\"./backend/web-gl/kernel-value-maps\"), { WebGL2FunctionNode: x } = \
e(\"./backend/web-gl2/function-node\"), { WebGL2Kernel: y } = \
e(\"./backend/web-gl2/kernel\"), { kernelValueMaps: b } = \
e(\"./backend/web-gl2/kernel-value-maps\"), { GLKernel: T } = \
e(\"./backend/gl/kernel\"), { Kernel: v } = e(\"./backend/kernel\"), { \
FunctionTracer: S } = e(\"./backend/function-tracer\"), A = \
e(\"./plugins/math-random-uniformly-distributed\");\n        t.exports = { \
alias: i, CPUFunctionNode: c, CPUKernel: p, GPU: n, FunctionBuilder: l, \
FunctionNode: h, HeadlessGLKernel: d, Input: a, input: o, Texture: u, utils: \
s, WebGL2FunctionNode: x, WebGL2Kernel: y, webGL2KernelValueMaps: b, \
WebGLFunctionNode: m, WebGLKernel: f, webGLKernelValueMaps: g, GLKernel: T, \
Kernel: v, FunctionTracer: S, plugins: { mathRandom: A } };\n      }, { \
\"./alias\": 5, \"./backend/cpu/function-node\": 6, \"./backend/cpu/kernel\": \
8, \"./backend/function-builder\": 9, \"./backend/function-node\": 10, \
\"./backend/function-tracer\": 11, \"./backend/gl/kernel\": 13, \
\"./backend/headless-gl/kernel\": 34, \"./backend/kernel\": 36, \
\"./backend/web-gl/function-node\": 38, \"./backend/web-gl/kernel\": 70, \
\"./backend/web-gl/kernel-value-maps\": 39, \
\"./backend/web-gl2/function-node\": 73, \"./backend/web-gl2/kernel\": 105, \
\"./backend/web-gl2/kernel-value-maps\": 74, \"./gpu\": 108, \"./input\": \
110, \"./plugins/math-random-uniformly-distributed\": 112, \"./texture\": \
113, \"./utils\": 114 }], 110: [function(e, t, r) {\n        class n {\n      \
    constructor(e2, t2) {\n            this.value = e2, Array.isArray(t2) ? \
this.size = t2 : (this.size = new Int32Array(3), t2.z ? this.size = new \
Int32Array([t2.x, t2.y, t2.z]) : t2.y ? this.size = new Int32Array([t2.x, \
t2.y]) : this.size = new Int32Array([t2.x]));\n            const [r2, n2, i] \
= this.size;\n            if (i) {\n              if (this.value.length !== \
r2 * n2 * i) throw new Error(`Input size ${this.value.length} does not match \
${r2} * ${n2} * ${i} = ${n2 * r2 * i}`);\n            } else if (n2) {\n      \
        if (this.value.length !== r2 * n2) throw new Error(`Input size \
${this.value.length} does not match ${r2} * ${n2} = ${n2 * r2}`);\n           \
 } else if (this.value.length !== r2) throw new Error(`Input size \
${this.value.length} does not match ${r2}`);\n          }\n          \
toArray() {\n            const { utils: t2 } = e(\"./utils\"), [r2, n2, i] = \
this.size;\n            return i ? \
t2.erectMemoryOptimized3DFloat(this.value.subarray ? this.value : new \
Float32Array(this.value), r2, n2, i) : n2 ? \
t2.erectMemoryOptimized2DFloat(this.value.subarray ? this.value : new \
Float32Array(this.value), r2, n2) : this.value;\n          }\n        }\n     \
   t.exports = { Input: n, input: function(e2, t2) {\n          return new \
n(e2, t2);\n        } };\n      }, { \"./utils\": 114 }], 111: [function(e, \
t, r) {\n        const { utils: n } = e(\"./utils\");\n        function i(e2, \
t2) {\n          if (t2.kernel) return void (t2.kernel = e2);\n          \
const r2 = n.allPropertiesOf(e2);\n          for (let n2 = 0; n2 < r2.length; \
n2++) {\n            const i2 = r2[n2];\n            \"_\" === i2[0] && \"_\" \
=== i2[1] || (\"function\" == typeof e2[i2] ? \"add\" === i2.substring(0, 3) \
|| \"set\" === i2.substring(0, 3) ? t2[i2] = function() {\n              \
return t2.kernel[i2].apply(t2.kernel, arguments), t2;\n            } : t2[i2] \
= function() {\n              return t2.kernel[i2].apply(t2.kernel, \
arguments);\n            } : (t2.__defineGetter__(i2, () => t2.kernel[i2]), \
t2.__defineSetter__(i2, (e3) => {\n              t2.kernel[i2] = e3;\n        \
    })));\n          }\n          t2.kernel = e2;\n        }\n        \
t.exports = { kernelRunShortcut: function(e2) {\n          let t2 = \
function() {\n            return e2.build.apply(e2, arguments), t2 = \
function() {\n              let t3 = e2.run.apply(e2, arguments);\n           \
   if (e2.switchingKernels) {\n                const n2 = \
e2.resetSwitchingKernels(), i2 = e2.onRequestSwitchKernel(n2, arguments, \
e2);\n                r2.kernel = e2 = i2, t3 = i2.run.apply(i2, \
arguments);\n              }\n              return e2.renderKernels ? \
e2.renderKernels() : e2.renderOutput ? e2.renderOutput() : t3;\n            \
}, t2.apply(e2, arguments);\n          };\n          const r2 = function() \
{\n            return t2.apply(e2, arguments);\n          };\n          \
return r2.exec = function() {\n            return new Promise((e3, r3) => {\n \
             try {\n                e3(t2.apply(this, arguments));\n          \
    } catch (e4) {\n                r3(e4);\n              }\n            \
});\n          }, r2.replaceKernel = function(t3) {\n            i(e2 = t3, \
r2);\n          }, i(e2, r2), r2;\n        } };\n      }, { \"./utils\": 114 \
}], 112: [function(e, t, r) {\n        const n = { name: \
\"math-random-uniformly-distributed\", onBeforeRun: (e2) => {\n          \
e2.setUniform1f(\"randomSeed1\", Math.random()), \
e2.setUniform1f(\"randomSeed2\", Math.random());\n        }, functionMatch: \
\"Math.random()\", functionReplace: \"nrand(vTexCoord)\", functionReturnType: \
\"Number\", source: \"// https://www.shadertoy.com/view/4t2SDh\\n//note: \
uniformly distributed, normalized rand, [0,1]\\nhighp float randomSeedShift = \
1.0;\\nhighp float slide = 1.0;\\nuniform highp float randomSeed1;\\nuniform \
highp float randomSeed2;\\n\\nhighp float nrand(highp vec2 n) {\\n  highp \
float result = fract(sin(dot((n.xy + 1.0) * vec2(randomSeed1 * slide, \
randomSeed2 * randomSeedShift), vec2(12.9898, 78.233))) * 43758.5453);\\n  \
randomSeedShift = result;\\n  if (randomSeedShift > 0.5) {\\n    slide += \
0.00009; \\n  } else {\\n    slide += 0.0009;\\n  }\\n  return result;\\n}\" \
};\n        t.exports = n;\n      }, {}], 113: [function(e, t, r) {\n        \
t.exports = { Texture: class {\n          constructor(e2) {\n            \
const { texture: t2, size: r2, dimensions: n, output: i, context: s, type: a \
= \"NumberTexture\", kernel: o, internalFormat: u, textureFormat: l } = e2;\n \
           if (!i) throw new Error('settings property \"output\" \
required.');\n            if (!s) throw new Error('settings property \
\"context\" required.');\n            if (!t2) throw new Error('settings \
property \"texture\" required.');\n            if (!o) throw new \
Error('settings property \"kernel\" required.');\n            this.texture = \
t2, t2._refs ? t2._refs++ : t2._refs = 1, this.size = r2, this.dimensions = \
n, this.output = i, this.context = s, this.kernel = o, this.type = a, \
this._deleted = false, this.internalFormat = u, this.textureFormat = l;\n     \
     }\n          toArray() {\n            throw new Error(`Not implemented \
on ${this.constructor.name}`);\n          }\n          clone() {\n            \
throw new Error(`Not implemented on ${this.constructor.name}`);\n          \
}\n          delete() {\n            throw new Error(`Not implemented on \
${this.constructor.name}`);\n          }\n          clear() {\n            \
throw new Error(`Not implemented on ${this.constructor.name}`);\n          \
}\n        } };\n      }, {}], 114: [function(e, t, r) {\n        const n = \
e(\"acorn\"), { Input: i } = e(\"./input\"), { Texture: s } = \
e(\"./texture\"), a = /function ([^(]*)/, o = \
/((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/gm, u = /([^\\s,]+)/g, l = { \
systemEndianness: () => d, getSystemEndianness() {\n          const e2 = new \
ArrayBuffer(4), t2 = new Uint32Array(e2), r2 = new Uint8Array(e2);\n          \
if (t2[0] = 3735928559, 239 === r2[0]) return \"LE\";\n          if (222 === \
r2[0]) return \"BE\";\n          throw new Error(\"unknown endianness\");\n   \
     }, isFunction: (e2) => \"function\" == typeof e2, isFunctionString: (e2) \
=> \"string\" == typeof e2 && \"function\" === e2.slice(0, 8).toLowerCase(), \
getFunctionNameFromString(e2) {\n          const t2 = a.exec(e2);\n          \
return t2 && 0 !== t2.length ? t2[1].trim() : null;\n        }, \
getFunctionBodyFromString: (e2) => e2.substring(e2.indexOf(\"{\") + 1, \
e2.lastIndexOf(\"}\")), getArgumentNamesFromString(e2) {\n          const t2 \
= e2.replace(o, \"\");\n          let r2 = t2.slice(t2.indexOf(\"(\") + 1, \
t2.indexOf(\")\")).match(u);\n          return null === r2 && (r2 = []), \
r2;\n        }, clone(e2) {\n          if (null === e2 || \"object\" != \
typeof e2 || e2.hasOwnProperty(\"isActiveClone\")) return e2;\n          \
const t2 = e2.constructor();\n          for (let r2 in e2) \
Object.prototype.hasOwnProperty.call(e2, r2) && (e2.isActiveClone = null, \
t2[r2] = l.clone(e2[r2]), delete e2.isActiveClone);\n          return t2;\n   \
     }, isArray: (e2) => !isNaN(e2.length), getVariableType(e2, t2) {\n       \
   if (l.isArray(e2)) return e2.length > 0 && \"IMG\" === e2[0].nodeName ? \
\"HTMLImageArray\" : \"Array\";\n          switch (e2.constructor) {\n        \
    case Boolean:\n              return \"Boolean\";\n            case \
Number:\n              return t2 && Number.isInteger(e2) ? \"Integer\" : \
\"Float\";\n            case s:\n              return e2.type;\n            \
case i:\n              return \"Input\";\n          }\n          if \
(\"nodeName\" in e2) switch (e2.nodeName) {\n            case \"IMG\":\n      \
      case \"CANVAS\":\n              return \"HTMLImage\";\n            case \
\"VIDEO\":\n              return \"HTMLVideo\";\n          }\n          else \
{\n            if (e2.hasOwnProperty(\"type\")) return e2.type;\n            \
if (\"undefined\" != typeof OffscreenCanvas && e2 instanceof OffscreenCanvas) \
return \"OffscreenCanvas\";\n            if (\"undefined\" != typeof \
ImageBitmap && e2 instanceof ImageBitmap) return \"ImageBitmap\";\n           \
 if (\"undefined\" != typeof ImageData && e2 instanceof ImageData) return \
\"ImageData\";\n          }\n          return \"Unknown\";\n        }, \
getKernelTextureSize(e2, t2) {\n          let [r2, n2, i2] = t2, s2 = (r2 || \
1) * (n2 || 1) * (i2 || 1);\n          return e2.optimizeFloatMemory && \
\"single\" === e2.precision && (r2 = s2 = Math.ceil(s2 / 4)), n2 > 1 && r2 * \
n2 === s2 ? new Int32Array([r2, n2]) : l.closestSquareDimensions(s2);\n       \
 }, closestSquareDimensions(e2) {\n          const t2 = Math.sqrt(e2);\n      \
    let r2 = Math.ceil(t2), n2 = Math.floor(t2);\n          for (; r2 * n2 < \
e2; ) r2--, n2 = Math.ceil(e2 / r2);\n          return new Int32Array([n2, \
Math.ceil(e2 / n2)]);\n        }, getMemoryOptimizedFloatTextureSize(e2, t2) \
{\n          const r2 = l.roundTo((e2[0] || 1) * (e2[1] || 1) * (e2[2] || 1) \
* (e2[3] || 1), 4) / t2;\n          return l.closestSquareDimensions(r2);\n   \
     }, getMemoryOptimizedPackedTextureSize(e2, t2) {\n          const [r2, \
n2, i2] = e2, s2 = l.roundTo((r2 || 1) * (n2 || 1) * (i2 || 1), 4) / (4 / \
t2);\n          return l.closestSquareDimensions(s2);\n        }, roundTo: \
(e2, t2) => Math.floor((e2 + t2 - 1) / t2) * t2, getDimensions(e2, t2) {\n    \
      let r2;\n          if (l.isArray(e2)) {\n            const t3 = [];\n   \
         let n2 = e2;\n            for (; l.isArray(n2); ) \
t3.push(n2.length), n2 = n2[0];\n            r2 = t3.reverse();\n          } \
else if (e2 instanceof s) r2 = e2.output;\n          else {\n            if \
(!(e2 instanceof i)) throw new Error(`Unknown dimensions of ${e2}`);\n        \
    r2 = e2.size;\n          }\n          if (t2) for (r2 = Array.from(r2); \
r2.length < 3; ) r2.push(1);\n          return new Int32Array(r2);\n        \
}, flatten2dArrayTo(e2, t2) {\n          let r2 = 0;\n          for (let n2 = \
0; n2 < e2.length; n2++) t2.set(e2[n2], r2), r2 += e2[n2].length;\n        }, \
flatten3dArrayTo(e2, t2) {\n          let r2 = 0;\n          for (let n2 = 0; \
n2 < e2.length; n2++) for (let i2 = 0; i2 < e2[n2].length; i2++) \
t2.set(e2[n2][i2], r2), r2 += e2[n2][i2].length;\n        }, \
flatten4dArrayTo(e2, t2) {\n          let r2 = 0;\n          for (let n2 = 0; \
n2 < e2.length; n2++) for (let i2 = 0; i2 < e2[n2].length; i2++) for (let s2 \
= 0; s2 < e2[n2][i2].length; s2++) t2.set(e2[n2][i2][s2], r2), r2 += \
e2[n2][i2][s2].length;\n        }, flattenTo(e2, t2) {\n          \
l.isArray(e2[0]) ? l.isArray(e2[0][0]) ? l.isArray(e2[0][0][0]) ? \
l.flatten4dArrayTo(e2, t2) : l.flatten3dArrayTo(e2, t2) : \
l.flatten2dArrayTo(e2, t2) : t2.set(e2);\n        }, splitArray(e2, t2) {\n   \
       const r2 = [];\n          for (let n2 = 0; n2 < e2.length; n2 += t2) \
r2.push(new e2.constructor(e2.buffer, 4 * n2 + e2.byteOffset, t2));\n         \
 return r2;\n        }, getAstString(e2, t2) {\n          const r2 = \
Array.isArray(e2) ? e2 : e2.split(/\\r?\\n/g), n2 = t2.loc.start, i2 = \
t2.loc.end, s2 = [];\n          if (n2.line === i2.line) s2.push(r2[n2.line - \
1].substring(n2.column, i2.column));\n          else {\n            \
s2.push(r2[n2.line - 1].slice(n2.column));\n            for (let e3 = \
n2.line; e3 < i2.line; e3++) s2.push(r2[e3]);\n            s2.push(r2[i2.line \
- 1].slice(0, i2.column));\n          }\n          return s2.join(\"\\n\");\n \
       }, allPropertiesOf(e2) {\n          const t2 = [];\n          do {\n   \
         t2.push.apply(t2, Object.getOwnPropertyNames(e2));\n          } \
while (e2 = Object.getPrototypeOf(e2));\n          return t2;\n        }, \
linesToString: (e2) => e2.length > 0 ? e2.join(\";\\n\") + \";\\n\" : \
\"\\n\", warnDeprecated(e2, t2, r2) {\n          r2 ? console.warn(`You are \
using a deprecated ${e2} \"${t2}\". It has been replaced with \"${r2}\". \
Fixing, but please upgrade as it will soon be removed.`) : console.warn(`You \
are using a deprecated ${e2} \"${t2}\". It has been removed. Fixing, but \
please upgrade as it will soon be removed.`);\n        }, flipPixels: (e2, \
t2, r2) => {\n          const n2 = r2 / 2 | 0, i2 = 4 * t2, s2 = new \
Uint8ClampedArray(4 * t2), a2 = e2.slice(0);\n          for (let e3 = 0; e3 < \
n2; ++e3) {\n            const t3 = e3 * i2, n3 = (r2 - e3 - 1) * i2;\n       \
     s2.set(a2.subarray(t3, t3 + i2)), a2.copyWithin(t3, n3, n3 + i2), \
a2.set(s2, n3);\n          }\n          return a2;\n        }, \
erectPackedFloat: (e2, t2) => e2.subarray(0, t2), erect2DPackedFloat: (e2, \
t2, r2) => {\n          const n2 = new Array(r2);\n          for (let i2 = 0; \
i2 < r2; i2++) {\n            const r3 = i2 * t2, s2 = r3 + t2;\n            \
n2[i2] = e2.subarray(r3, s2);\n          }\n          return n2;\n        }, \
erect3DPackedFloat: (e2, t2, r2, n2) => {\n          const i2 = new \
Array(n2);\n          for (let s2 = 0; s2 < n2; s2++) {\n            const n3 \
= new Array(r2);\n            for (let i3 = 0; i3 < r2; i3++) {\n             \
 const a2 = s2 * r2 * t2 + i3 * t2, o2 = a2 + t2;\n              n3[i3] = \
e2.subarray(a2, o2);\n            }\n            i2[s2] = n3;\n          }\n  \
        return i2;\n        }, erectMemoryOptimizedFloat: (e2, t2) => \
e2.subarray(0, t2), erectMemoryOptimized2DFloat: (e2, t2, r2) => {\n          \
const n2 = new Array(r2);\n          for (let i2 = 0; i2 < r2; i2++) {\n      \
      const r3 = i2 * t2;\n            n2[i2] = e2.subarray(r3, r3 + t2);\n   \
       }\n          return n2;\n        }, erectMemoryOptimized3DFloat: (e2, \
t2, r2, n2) => {\n          const i2 = new Array(n2);\n          for (let s2 \
= 0; s2 < n2; s2++) {\n            const n3 = new Array(r2);\n            for \
(let i3 = 0; i3 < r2; i3++) {\n              const a2 = s2 * r2 * t2 + i3 * \
t2;\n              n3[i3] = e2.subarray(a2, a2 + t2);\n            }\n        \
    i2[s2] = n3;\n          }\n          return i2;\n        }, erectFloat: \
(e2, t2) => {\n          const r2 = new Float32Array(t2);\n          let n2 = \
0;\n          for (let i2 = 0; i2 < t2; i2++) r2[i2] = e2[n2], n2 += 4;\n     \
     return r2;\n        }, erect2DFloat: (e2, t2, r2) => {\n          const \
n2 = new Array(r2);\n          let i2 = 0;\n          for (let s2 = 0; s2 < \
r2; s2++) {\n            const r3 = new Float32Array(t2);\n            for \
(let n3 = 0; n3 < t2; n3++) r3[n3] = e2[i2], i2 += 4;\n            n2[s2] = \
r3;\n          }\n          return n2;\n        }, erect3DFloat: (e2, t2, r2, \
n2) => {\n          const i2 = new Array(n2);\n          let s2 = 0;\n        \
  for (let a2 = 0; a2 < n2; a2++) {\n            const n3 = new Array(r2);\n  \
          for (let i3 = 0; i3 < r2; i3++) {\n              const r3 = new \
Float32Array(t2);\n              for (let n4 = 0; n4 < t2; n4++) r3[n4] = \
e2[s2], s2 += 4;\n              n3[i3] = r3;\n            }\n            \
i2[a2] = n3;\n          }\n          return i2;\n        }, erectArray2: (e2, \
t2) => {\n          const r2 = new Array(t2), n2 = 4 * t2;\n          let i2 \
= 0;\n          for (let t3 = 0; t3 < n2; t3 += 4) r2[i2++] = e2.subarray(t3, \
t3 + 2);\n          return r2;\n        }, erect2DArray2: (e2, t2, r2) => {\n \
         const n2 = new Array(r2), i2 = 4 * t2;\n          for (let s2 = 0; \
s2 < r2; s2++) {\n            const r3 = new Array(t2), a2 = s2 * i2;\n       \
     let o2 = 0;\n            for (let t3 = 0; t3 < i2; t3 += 4) r3[o2++] = \
e2.subarray(t3 + a2, t3 + a2 + 2);\n            n2[s2] = r3;\n          }\n   \
       return n2;\n        }, erect3DArray2: (e2, t2, r2, n2) => {\n          \
const i2 = 4 * t2, s2 = new Array(n2);\n          for (let a2 = 0; a2 < n2; \
a2++) {\n            const n3 = new Array(r2);\n            for (let s3 = 0; \
s3 < r2; s3++) {\n              const o2 = new Array(t2), u2 = a2 * i2 * r2 + \
s3 * i2;\n              let l2 = 0;\n              for (let t3 = 0; t3 < i2; \
t3 += 4) o2[l2++] = e2.subarray(t3 + u2, t3 + u2 + 2);\n              n3[s3] \
= o2;\n            }\n            s2[a2] = n3;\n          }\n          return \
s2;\n        }, erectArray3: (e2, t2) => {\n          const r2 = new \
Array(t2), n2 = 4 * t2;\n          let i2 = 0;\n          for (let t3 = 0; t3 \
< n2; t3 += 4) r2[i2++] = e2.subarray(t3, t3 + 3);\n          return r2;\n    \
    }, erect2DArray3: (e2, t2, r2) => {\n          const n2 = 4 * t2, i2 = \
new Array(r2);\n          for (let s2 = 0; s2 < r2; s2++) {\n            \
const r3 = new Array(t2), a2 = s2 * n2;\n            let o2 = 0;\n            \
for (let t3 = 0; t3 < n2; t3 += 4) r3[o2++] = e2.subarray(t3 + a2, t3 + a2 + \
3);\n            i2[s2] = r3;\n          }\n          return i2;\n        }, \
erect3DArray3: (e2, t2, r2, n2) => {\n          const i2 = 4 * t2, s2 = new \
Array(n2);\n          for (let a2 = 0; a2 < n2; a2++) {\n            const n3 \
= new Array(r2);\n            for (let s3 = 0; s3 < r2; s3++) {\n             \
 const o2 = new Array(t2), u2 = a2 * i2 * r2 + s3 * i2;\n              let l2 \
= 0;\n              for (let t3 = 0; t3 < i2; t3 += 4) o2[l2++] = \
e2.subarray(t3 + u2, t3 + u2 + 3);\n              n3[s3] = o2;\n            \
}\n            s2[a2] = n3;\n          }\n          return s2;\n        }, \
erectArray4: (e2, t2) => {\n          const r2 = new Array(e2), n2 = 4 * \
t2;\n          let i2 = 0;\n          for (let t3 = 0; t3 < n2; t3 += 4) \
r2[i2++] = e2.subarray(t3, t3 + 4);\n          return r2;\n        }, \
erect2DArray4: (e2, t2, r2) => {\n          const n2 = 4 * t2, i2 = new \
Array(r2);\n          for (let s2 = 0; s2 < r2; s2++) {\n            const r3 \
= new Array(t2), a2 = s2 * n2;\n            let o2 = 0;\n            for (let \
t3 = 0; t3 < n2; t3 += 4) r3[o2++] = e2.subarray(t3 + a2, t3 + a2 + 4);\n     \
       i2[s2] = r3;\n          }\n          return i2;\n        }, \
erect3DArray4: (e2, t2, r2, n2) => {\n          const i2 = 4 * t2, s2 = new \
Array(n2);\n          for (let a2 = 0; a2 < n2; a2++) {\n            const n3 \
= new Array(r2);\n            for (let s3 = 0; s3 < r2; s3++) {\n             \
 const o2 = new Array(t2), u2 = a2 * i2 * r2 + s3 * i2;\n              let l2 \
= 0;\n              for (let t3 = 0; t3 < i2; t3 += 4) o2[l2++] = \
e2.subarray(t3 + u2, t3 + u2 + 4);\n              n3[s3] = o2;\n            \
}\n            s2[a2] = n3;\n          }\n          return s2;\n        }, \
flattenFunctionToString: (e2, t2) => {\n          const { findDependency: r2, \
thisLookup: i2, doNotDefine: s2 } = t2;\n          let a2 = t2.flattened;\n   \
       a2 || (a2 = t2.flattened = {});\n          const o2 = n.parse(e2), u2 \
= [];\n          let h2 = 0;\n          const c2 = function e3(t3) {\n        \
    if (Array.isArray(t3)) {\n              const r3 = [];\n              for \
(let n2 = 0; n2 < t3.length; n2++) r3.push(e3(t3[n2]));\n              return \
r3.join(\"\");\n            }\n            switch (t3.type) {\n              \
case \"Program\":\n                return e3(t3.body) + \
(\"VariableDeclaration\" === t3.body[0].type ? \";\" : \"\");\n              \
case \"FunctionDeclaration\":\n                return `function \
${t3.id.name}(${t3.params.map(e3).join(\", \")}) ${e3(t3.body)}`;\n           \
   case \"BlockStatement\": {\n                const r3 = [];\n               \
 h2 += 2;\n                for (let n3 = 0; n3 < t3.body.length; n3++) {\n    \
              const i3 = e3(t3.body[n3]);\n                  i3 && r3.push(\" \
\".repeat(h2) + i3, \";\\n\");\n                }\n                return h2 \
-= 2, `{\n${r3.join(\"\")}}`;\n              }\n              case \
\"VariableDeclaration\":\n                const n2 = \
l.normalizeDeclarations(t3).map(e3).filter((e4) => null !== e4);\n            \
    return n2.length < 1 ? \"\" : `${t3.kind} ${n2.join(\",\")}`;\n           \
   case \"VariableDeclarator\":\n                if (t3.init.object && \
\"ThisExpression\" === t3.init.object.type) {\n                  return \
i2(t3.init.property.name, true) ? `${t3.id.name} = ${e3(t3.init)}` : null;\n  \
              }\n                return `${t3.id.name} = ${e3(t3.init)}`;\n   \
           case \"CallExpression\":\n                if (\"subarray\" === \
t3.callee.property.name) return \
`${e3(t3.callee.object)}.${e3(t3.callee.property)}(${t3.arguments.map((t4) => \
e3(t4)).join(\", \")})`;\n                if (\"gl\" === \
t3.callee.object.name || \"context\" === t3.callee.object.name) return \
`${e3(t3.callee.object)}.${e3(t3.callee.property)}(${t3.arguments.map((t4) => \
e3(t4)).join(\", \")})`;\n                if (\"ThisExpression\" === \
t3.callee.object.type) return u2.push(r2(\"this\", t3.callee.property.name)), \
`${t3.callee.property.name}(${t3.arguments.map((t4) => e3(t4)).join(\", \
\")})`;\n                if (t3.callee.object.name) {\n                  \
const n3 = r2(t3.callee.object.name, t3.callee.property.name);\n              \
    return null === n3 ? \
`${t3.callee.object.name}.${t3.callee.property.name}(${t3.arguments.map((t4) \
=> e3(t4)).join(\", \")})` : (u2.push(n3), \
`${t3.callee.property.name}(${t3.arguments.map((t4) => e3(t4)).join(\", \
\")})`);\n                }\n                if (\"MemberExpression\" === \
t3.callee.object.type) return \
`${e3(t3.callee.object)}.${t3.callee.property.name}(${t3.arguments.map((t4) \
=> e3(t4)).join(\", \")})`;\n                throw new Error(\"unknown \
ast.callee\");\n              case \"ReturnStatement\":\n                \
return `return ${e3(t3.argument)}`;\n              case \
\"BinaryExpression\":\n                return \
`(${e3(t3.left)}${t3.operator}${e3(t3.right)})`;\n              case \
\"UnaryExpression\":\n                return t3.prefix ? `${t3.operator} \
${e3(t3.argument)}` : `${e3(t3.argument)} ${t3.operator}`;\n              \
case \"ExpressionStatement\":\n                return \
`${e3(t3.expression)}`;\n              case \"SequenceExpression\":\n         \
       return `(${e3(t3.expressions)})`;\n              case \
\"ArrowFunctionExpression\":\n                return \
`(${t3.params.map(e3).join(\", \")}) => ${e3(t3.body)}`;\n              case \
\"Literal\":\n                return t3.raw;\n              case \
\"Identifier\":\n                return t3.name;\n              case \
\"MemberExpression\":\n                return \"ThisExpression\" === \
t3.object.type ? i2(t3.property.name) : t3.computed ? \
`${e3(t3.object)}[${e3(t3.property)}]` : e3(t3.object) + \".\" + \
e3(t3.property);\n              case \"ThisExpression\":\n                \
return \"this\";\n              case \"NewExpression\":\n                \
return `new ${e3(t3.callee)}(${t3.arguments.map((t4) => e3(t4)).join(\", \
\")})`;\n              case \"ForStatement\":\n                return `for \
(${e3(t3.init)};${e3(t3.test)};${e3(t3.update)}) ${e3(t3.body)}`;\n           \
   case \"AssignmentExpression\":\n                return \
`${e3(t3.left)}${t3.operator}${e3(t3.right)}`;\n              case \
\"UpdateExpression\":\n                return \
`${e3(t3.argument)}${t3.operator}`;\n              case \"IfStatement\":\n    \
            return `if (${e3(t3.test)}) ${e3(t3.consequent)}`;\n              \
case \"ThrowStatement\":\n                return `throw \
${e3(t3.argument)}`;\n              case \"ObjectPattern\":\n                \
return t3.properties.map(e3).join(\", \");\n              case \
\"ArrayPattern\":\n                return t3.elements.map(e3).join(\", \");\n \
             case \"DebuggerStatement\":\n                return \
\"debugger;\";\n              case \"ConditionalExpression\":\n               \
 return `${e3(t3.test)}?${e3(t3.consequent)}:${e3(t3.alternate)}`;\n          \
    case \"Property\":\n                if (\"init\" === t3.kind) return \
e3(t3.key);\n            }\n            throw new Error(`unhandled ast.type \
of ${t3.type}`);\n          }(o2);\n          if (u2.length > 0) {\n          \
  const e3 = [];\n            for (let r3 = 0; r3 < u2.length; r3++) {\n      \
        const n2 = u2[r3];\n              a2[n2] || (a2[n2] = true), n2 && \
e3.push(l.flattenFunctionToString(n2, t2) + \"\\n\");\n            }\n        \
    return e3.join(\"\") + c2;\n          }\n          return c2;\n        }, \
normalizeDeclarations: (e2) => {\n          if (\"VariableDeclaration\" !== \
e2.type) throw new Error('Ast is not of type \"VariableDeclaration\"');\n     \
     const t2 = [];\n          for (let r2 = 0; r2 < e2.declarations.length; \
r2++) {\n            const n2 = e2.declarations[r2];\n            if (n2.id \
&& \"ObjectPattern\" === n2.id.type && n2.id.properties) {\n              \
const { properties: e3 } = n2.id;\n              for (let r3 = 0; r3 < \
e3.length; r3++) {\n                const i2 = e3[r3];\n                if \
(\"ObjectPattern\" === i2.value.type && i2.value.properties) for (let e4 = 0; \
e4 < i2.value.properties.length; e4++) {\n                  const r4 = \
i2.value.properties[e4];\n                  if (\"Property\" !== r4.type) \
throw new Error(\"unexpected state\");\n                  t2.push({ type: \
\"VariableDeclarator\", id: { type: \"Identifier\", name: r4.key.name }, \
init: { type: \"MemberExpression\", object: { type: \"MemberExpression\", \
object: n2.init, property: { type: \"Identifier\", name: i2.key.name }, \
computed: false }, property: { type: \"Identifier\", name: r4.key.name }, \
computed: false } });\n                }\n                else {\n            \
      if (\"Identifier\" !== i2.value.type) throw new Error(\"unexpected \
state\");\n                  t2.push({ type: \"VariableDeclarator\", id: { \
type: \"Identifier\", name: i2.value && i2.value.name ? i2.value.name : \
i2.key.name }, init: { type: \"MemberExpression\", object: n2.init, property: \
{ type: \"Identifier\", name: i2.key.name }, computed: false } });\n          \
      }\n              }\n            } else if (n2.id && \"ArrayPattern\" \
=== n2.id.type && n2.id.elements) {\n              const { elements: e3 } = \
n2.id;\n              for (let r3 = 0; r3 < e3.length; r3++) {\n              \
  const i2 = e3[r3];\n                if (\"Identifier\" !== i2.type) throw \
new Error(\"unexpected state\");\n                t2.push({ type: \
\"VariableDeclarator\", id: { type: \"Identifier\", name: i2.name }, init: { \
type: \"MemberExpression\", object: n2.init, property: { type: \"Literal\", \
value: r3, raw: r3.toString(), start: i2.start, end: i2.end }, computed: true \
} });\n              }\n            } else t2.push(n2);\n          }\n        \
  return t2;\n        }, splitHTMLImageToRGB: (e2, t2) => {\n          const \
r2 = e2.createKernel(function(e3) {\n            return 255 * \
e3[this.thread.y][this.thread.x].r;\n          }, { output: [t2.width, \
t2.height], precision: \"unsigned\", argumentTypes: { a: \"HTMLImage\" } }), \
n2 = e2.createKernel(function(e3) {\n            return 255 * \
e3[this.thread.y][this.thread.x].g;\n          }, { output: [t2.width, \
t2.height], precision: \"unsigned\", argumentTypes: { a: \"HTMLImage\" } }), \
i2 = e2.createKernel(function(e3) {\n            return 255 * \
e3[this.thread.y][this.thread.x].b;\n          }, { output: [t2.width, \
t2.height], precision: \"unsigned\", argumentTypes: { a: \"HTMLImage\" } }), \
s2 = e2.createKernel(function(e3) {\n            return 255 * \
e3[this.thread.y][this.thread.x].a;\n          }, { output: [t2.width, \
t2.height], precision: \"unsigned\", argumentTypes: { a: \"HTMLImage\" } }), \
a2 = [r2(t2), n2(t2), i2(t2), s2(t2)];\n          return a2.rKernel = r2, \
a2.gKernel = n2, a2.bKernel = i2, a2.aKernel = s2, a2.gpu = e2, a2;\n        \
}, splitRGBAToCanvases: (e2, t2, r2, n2) => {\n          const i2 = \
e2.createKernel(function(e3) {\n            const t3 = \
e3[this.thread.y][this.thread.x];\n            this.color(t3.r / 255, 0, 0, \
255);\n          }, { output: [r2, n2], graphical: true, argumentTypes: { v: \
\"Array2D(4)\" } });\n          i2(t2);\n          const s2 = \
e2.createKernel(function(e3) {\n            const t3 = \
e3[this.thread.y][this.thread.x];\n            this.color(0, t3.g / 255, 0, \
255);\n          }, { output: [r2, n2], graphical: true, argumentTypes: { v: \
\"Array2D(4)\" } });\n          s2(t2);\n          const a2 = \
e2.createKernel(function(e3) {\n            const t3 = \
e3[this.thread.y][this.thread.x];\n            this.color(0, 0, t3.b / 255, \
255);\n          }, { output: [r2, n2], graphical: true, argumentTypes: { v: \
\"Array2D(4)\" } });\n          a2(t2);\n          const o2 = \
e2.createKernel(function(e3) {\n            const t3 = \
e3[this.thread.y][this.thread.x];\n            this.color(255, 255, 255, t3.a \
/ 255);\n          }, { output: [r2, n2], graphical: true, argumentTypes: { \
v: \"Array2D(4)\" } });\n          return o2(t2), [i2.canvas, s2.canvas, \
a2.canvas, o2.canvas];\n        }, getMinifySafeName: (e2) => {\n          \
try {\n            const t2 = n.parse(`const value = ${e2.toString()}`), { \
init: r2 } = t2.body[0].declarations[0];\n            return r2.body.name || \
r2.body.body[0].argument.name;\n          } catch (e3) {\n            throw \
new Error(\"Unrecognized function type.  Please use `() => \
yourFunctionVariableHere` or function() { return yourFunctionVariableHere; \
}\");\n          }\n        }, sanitizeName: function(e2) {\n          return \
h.test(e2) && (e2 = e2.replace(h, \"S_S\")), c.test(e2) ? e2 = e2.replace(c, \
\"U_U\") : p.test(e2) && (e2 = e2.replace(p, \"u_u\")), e2;\n        } }, h = \
/\\$/, c = /__/, p = /_/, d = l.getSystemEndianness();\n        t.exports = { \
utils: l };\n      }, { \"./input\": 110, \"./texture\": 113, acorn: 1 }] }, \
{}, [107])(107);\n    });\n  }\n});\n\n// <stdin>\nwindow.gpuJS = \
require_gpu();\n/**\n * gpu.js\n * http://gpu.rocks/\n *\n * GPU Accelerated \
JavaScript\n *\n * @version 2.16.0\n * @date Thu Feb 13 2025 11:46:50 \
GMT-0800 (Pacific Standard Time)\n *\n * @license MIT\n * The MIT License\n \
*\n * Copyright (c) 2025 gpu.js Team\n */\n/**\n* gpu.js\n* \
http://gpu.rocks/\n*\n* GPU Accelerated JavaScript\n*\n* @version 2.16.0\n* \
@date Thu Feb 13 2025 11:46:48 GMT-0800 (Pacific Standard Time)\n*\n* \
@license MIT\n* The MIT License\n*\n* Copyright (c) 2025 gpu.js Team\n*/\n", 
    "Display" -> "esm", "Hash" -> "eae80126-2e78-4e62-96c8-9e7cc97db469", 
    "Invisible" -> False, "MetaOnly" -> False, "Props" -> <||>, 
    "PublicFields" -> {"Properties"}, "State" -> "Idle", "Type" -> "Output", 
    "UID" -> Null, "Notebook" -> "f8a44bd9-03ea-4642-979c-20bee7c21c41"|>, 
   <|"Data" -> ".md\nNow we have an easy access to this framework.\n\n## \
Compute shaders\nHere we use GPU.js to write a compute shader in Javascript, \
which use privded array of 2D points and renders their density to a canvas. \
We shall support the possibillity to update the image in real-time and use \
`PlotRange`, `ImageSize` parameters similar to `Plot` function", 
    "Display" -> "codemirror", "Hash" -> 
     "00b69cda-fb1f-457f-b5d2-26ac17ec24ed", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <|"Hidden" -> True|>, 
    "PublicFields" -> {"Properties"}, "State" -> "Idle", "Type" -> "Input", 
    "UID" -> Null, "Notebook" -> "f8a44bd9-03ea-4642-979c-20bee7c21c41"|>, 
   <|"Data" -> "Now we have an easy access to this framework.\n\n## Compute \
shaders\nHere we use GPU.js to write a compute shader in Javascript, which \
use privded array of 2D points and renders their density to a canvas. We \
shall support the possibillity to update the image in real-time and use \
`PlotRange`, `ImageSize` parameters similar to `Plot` function", 
    "Display" -> "markdown", "Hash" -> 
     "b2faba0b-e847-45d3-a4fd-5ffc76c6383b", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "PublicFields" -> {"Properties"}, 
    "State" -> "Idle", "Type" -> "Output", "UID" -> Null, 
    "Notebook" -> "f8a44bd9-03ea-4642-979c-20bee7c21c41"|>, 
   <|"Data" -> ".js\nfunction getColor(t) {     \n    if (t >= 0 && t <= \
0.25)       \n        return [255.0 + (- 255.0) * t / 0.25, 255.0 + (- 255.0) \
* t / 0.25, 255.0];     \n    if (t >= 0.25 && t <= 0.55)       \n        \
return [0.0, 255.0 * (t - 0.25) / 0.3, 255.0 + (- 255.0) * (t - 0.25) / 0.3]; \
    \n    if (t >= 0.55 && t <= 0.85)       \n        return [255.0 * (t - \
0.55) / 0.3, 255.0, 0.0];     \n    if (t >= 0.85 && t <= 1)       \n        \
return [255.0, 255.0 + (- 255.0) * (t - 0.85) / 0.15, 0.0];     \n    return \
[255.0,255.0,255.0];   \n}\n\ncore.HeatMap = async (args, env) => {\n  const \
gpu = new window.gpuJS.GPU();\n  const options = await core._getRules(args, \
env);\n\n  env.local.gpu = gpu;\n  \n  let [width, height] = [320, 240];\n  \
let plotRange = [[-1,1], [-1,1]];\n  \n  if (options.ImageSize) {\n    if \
(Array.isArray(options.ImageSize))\n      [width, height] = \
options.ImageSize;\n    else\n      [width, height] = \
[Math.round(options.ImageSize), Math.round(options.ImageSize/1.6180339)];\n  \
}\n\n  if (options.PlotRange) {\n    plotRange = options.PlotRange;\n  }\n\n  \
plotRange = [\n    plotRange[0][0],\n    width / (plotRange[0][1] - \
plotRange[0][0]),\n\n    plotRange[1][0],\n    height / (plotRange[1][1] - \
plotRange[1][0])\n  ];\n\n\n  const points = await interpretate(args[0], \
env);\n  let alpha = 10000.0;\n  if (args.length - \
Object.keys(options).length > 1) {\n    alpha = await interpretate(args[1], \
env);\n    env.local.alpha_has = true;\n  }\n\n  env.local.alpha = alpha;\n\n \
 env.local.kernel = gpu.createKernel(function(points, pointCount, alpha) {\n  \
  let intensity = 0;\n    for (let i = 0; i < pointCount; i++) {\n        \
const pointX = (points[i * 2] - this.constants.plotRange[0]) * \
this.constants.plotRange[1];\n        const pointY = (points[i * 2 + 1] - \
this.constants.plotRange[2]) * this.constants.plotRange[3];\n        const dx \
= (this.thread.x - pointX)/this.constants.width;\n        const dy = \
(this.thread.y - pointY)/this.constants.height;\n        const dist = dx * dx \
+ dy * dy;\n        intensity += 1.0/(dist * alpha + 1.0); // Blurry effect\n \
   }\n    \n    intensity = Math.min(intensity, 1); // Cap intensity\n    \
const baseColor = getColor(intensity);\n\n    let blendedColor = [\n        \
baseColor[0] * intensity + (1.0 - intensity)*255,\n        baseColor[1] * \
intensity + (1.0 - intensity)*255,\n        baseColor[2] * intensity + (1.0 - \
intensity)*255\n    ];\n    this.color(blendedColor[0] / 255, blendedColor[1] \
/ 255, blendedColor[2] / 255);\n  }, {\n    dynamicArguments: true,\n    \
constants: {\n      plotRange: plotRange,\n      width: width,\n      height: \
height\n    }\n  })\n  .setOutput([width, height])\n  .setGraphical(true)\n  \
.setFunctions([getColor]);  \n\n  \
env.element.appendChild(env.local.kernel.canvas);\n\n  if (points instanceof \
NumericArrayObject) {\n    env.local.kernel(new Float32Array(points.buffer), \
points.dims[0], alpha);\n    return;\n  }\n  \n  \
env.local.kernel(points.flat(), points.length, \
alpha);\n}\n\ncore.HeatMap.virtual = true\n\ncore.HeatMap.destroy = (args, \
env) => {\n  env.local.kernel.destroy();\n  env.local.gpu.destroy();\n  \
delete env.local.gpu;\n  delete env.local.kernel;\n}\n\ncore.HeatMap.update = \
async (args, env) => {\n  let alpha = env.local.alpha;\n  if \
(env.local.alpha_has) {\n    alpha = await interpretate(args[1], env);\n  }\n \
 \n  const data = await interpretate(args[0], env);\n  if (data instanceof \
NumericArrayObject) {\n    env.local.kernel(new Float32Array(data.buffer), \
data.dims[0], alpha);\n    return;\n  }\n\n  env.local.kernel(data.flat(), \
data.length, alpha);\n}\n\nthis.ondestroy(() => {\n  \
gpu.destroy();\n});\n\nreturn 'If you see it, it works'", 
    "Display" -> "codemirror", "Hash" -> 
     "d3a5dc1b-b1f4-4014-bfdc-66b7bd2d9c94", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <|"Fade" -> True|>, 
    "PublicFields" -> {"Properties"}, "State" -> "Idle", "Type" -> "Input", 
    "UID" -> Null, "Notebook" -> "f8a44bd9-03ea-4642-979c-20bee7c21c41"|>, 
   <|"Data" -> "function getColor(t) {     \n    if (t >= 0 && t <= 0.25)     \
  \n        return [255.0 + (- 255.0) * t / 0.25, 255.0 + (- 255.0) * t / \
0.25, 255.0];     \n    if (t >= 0.25 && t <= 0.55)       \n        return \
[0.0, 255.0 * (t - 0.25) / 0.3, 255.0 + (- 255.0) * (t - 0.25) / 0.3];     \n \
   if (t >= 0.55 && t <= 0.85)       \n        return [255.0 * (t - 0.55) / \
0.3, 255.0, 0.0];     \n    if (t >= 0.85 && t <= 1)       \n        return \
[255.0, 255.0 + (- 255.0) * (t - 0.85) / 0.15, 0.0];     \n    return \
[255.0,255.0,255.0];   \n}\n\ncore.HeatMap = async (args, env) => {\n  const \
gpu = new window.gpuJS.GPU();\n  const options = await core._getRules(args, \
env);\n\n  env.local.gpu = gpu;\n  \n  let [width, height] = [320, 240];\n  \
let plotRange = [[-1,1], [-1,1]];\n  \n  if (options.ImageSize) {\n    if \
(Array.isArray(options.ImageSize))\n      [width, height] = \
options.ImageSize;\n    else\n      [width, height] = \
[Math.round(options.ImageSize), Math.round(options.ImageSize/1.6180339)];\n  \
}\n\n  if (options.PlotRange) {\n    plotRange = options.PlotRange;\n  }\n\n  \
plotRange = [\n    plotRange[0][0],\n    width / (plotRange[0][1] - \
plotRange[0][0]),\n\n    plotRange[1][0],\n    height / (plotRange[1][1] - \
plotRange[1][0])\n  ];\n\n\n  const points = await interpretate(args[0], \
env);\n  let alpha = 10000.0;\n  if (args.length - \
Object.keys(options).length > 1) {\n    alpha = await interpretate(args[1], \
env);\n    env.local.alpha_has = true;\n  }\n\n  env.local.alpha = alpha;\n\n \
 env.local.kernel = gpu.createKernel(function(points, pointCount, alpha) {\n  \
  let intensity = 0;\n    for (let i = 0; i < pointCount; i++) {\n        \
const pointX = (points[i * 2] - this.constants.plotRange[0]) * \
this.constants.plotRange[1];\n        const pointY = (points[i * 2 + 1] - \
this.constants.plotRange[2]) * this.constants.plotRange[3];\n        const dx \
= (this.thread.x - pointX)/this.constants.width;\n        const dy = \
(this.thread.y - pointY)/this.constants.height;\n        const dist = dx * dx \
+ dy * dy;\n        intensity += 1.0/(dist * alpha + 1.0); // Blurry effect\n \
   }\n    \n    intensity = Math.min(intensity, 1); // Cap intensity\n    \
const baseColor = getColor(intensity);\n\n    let blendedColor = [\n        \
baseColor[0] * intensity + (1.0 - intensity)*255,\n        baseColor[1] * \
intensity + (1.0 - intensity)*255,\n        baseColor[2] * intensity + (1.0 - \
intensity)*255\n    ];\n    this.color(blendedColor[0] / 255, blendedColor[1] \
/ 255, blendedColor[2] / 255);\n  }, {\n    dynamicArguments: true,\n    \
constants: {\n      plotRange: plotRange,\n      width: width,\n      height: \
height\n    }\n  })\n  .setOutput([width, height])\n  .setGraphical(true)\n  \
.setFunctions([getColor]);  \n\n  \
env.element.appendChild(env.local.kernel.canvas);\n\n  if (points instanceof \
NumericArrayObject) {\n    env.local.kernel(new Float32Array(points.buffer), \
points.dims[0], alpha);\n    return;\n  }\n  \n  \
env.local.kernel(points.flat(), points.length, \
alpha);\n}\n\ncore.HeatMap.virtual = true\n\ncore.HeatMap.destroy = (args, \
env) => {\n  env.local.kernel.destroy();\n  env.local.gpu.destroy();\n  \
delete env.local.gpu;\n  delete env.local.kernel;\n}\n\ncore.HeatMap.update = \
async (args, env) => {\n  let alpha = env.local.alpha;\n  if \
(env.local.alpha_has) {\n    alpha = await interpretate(args[1], env);\n  }\n \
 \n  const data = await interpretate(args[0], env);\n  if (data instanceof \
NumericArrayObject) {\n    env.local.kernel(new Float32Array(data.buffer), \
data.dims[0], alpha);\n    return;\n  }\n\n  env.local.kernel(data.flat(), \
data.length, alpha);\n}\n\nthis.ondestroy(() => {\n  \
gpu.destroy();\n});\n\nreturn 'If you see it, it works'", "Display" -> "js", 
    "Hash" -> "c8a165e6-afe4-47a8-95d7-a474ae1aa9ac", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "PublicFields" -> {"Properties"}, 
    "State" -> "Idle", "Type" -> "Output", "UID" -> Null, 
    "Notebook" -> "f8a44bd9-03ea-4642-979c-20bee7c21c41"|>, 
   <|"Data" -> ".md\n## Output form\nTo display the heatmap, we need to \
define an output form in Wolfram Language, that will use Javascript to render \
the widget", "Display" -> "codemirror", 
    "Hash" -> "4189220d-8019-4e70-86cf-5d2068dcb83c", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <|"Hidden" -> True|>, 
    "PublicFields" -> {"Properties"}, "State" -> "Idle", "Type" -> "Input", 
    "UID" -> Null, "Notebook" -> "f8a44bd9-03ea-4642-979c-20bee7c21c41"|>, 
   <|"Data" -> "## Output form\nTo display the heatmap, we need to define an \
output form in Wolfram Language, that will use Javascript to render the \
widget", "Display" -> "markdown", "Hash" -> 
     "428f9932-f032-42bf-896e-c028b514714d", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "PublicFields" -> {"Properties"}, 
    "State" -> "Idle", "Type" -> "Output", "UID" -> Null, 
    "Notebook" -> "f8a44bd9-03ea-4642-979c-20bee7c21c41"|>, 
   <|"Data" -> "HeatMap /: MakeBoxes[h_HeatMap, StandardForm] := With[{},\n  \
ViewBox[h, h]\n]\n\nHeatMap /: MakeBoxes[h_HeatMap, StandardForm] := With[{\n \
 o = CreateFrontEndObject[h]\n},\n  MakeBoxes[o, StandardForm]\n] /; \
ByteCount[h] > 1024\n\nOptions[HeatMap] = {ImageSize->{320, 240}, \
PlotRange->{{-1,1}, {-1,1}}};", "Display" -> "codemirror", 
    "Hash" -> "c9297f23-83fd-4ba4-a7f2-d61cb4ae8f95", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <|"Fade" -> True|>, 
    "PublicFields" -> {"Properties"}, "State" -> "Idle", "Type" -> "Input", 
    "UID" -> Null, "Notebook" -> "f8a44bd9-03ea-4642-979c-20bee7c21c41"|>, 
   <|"Data" -> ".md\n## Test\nCreate a bunch of points and render it", 
    "Display" -> "codemirror", "Hash" -> 
     "85029271-f6e2-4c3e-8e17-017cc712d57a", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <|"Hidden" -> True|>, 
    "PublicFields" -> {"Properties"}, "State" -> "Idle", "Type" -> "Input", 
    "UID" -> Null, "Notebook" -> "f8a44bd9-03ea-4642-979c-20bee7c21c41"|>, 
   <|"Data" -> "## Test\nCreate a bunch of points and render it", 
    "Display" -> "markdown", "Hash" -> 
     "0600bbfa-57a3-44f8-8525-cc27bf30a99a", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "PublicFields" -> {"Properties"}, 
    "State" -> "Idle", "Type" -> "Output", "UID" -> Null, 
    "Notebook" -> "f8a44bd9-03ea-4642-979c-20bee7c21c41"|>, 
   <|"Data" -> "HeatMap[Exp[-Norm[#]]# &/@ RandomReal[{-Pi,Pi}, {30,2}]]", 
    "Display" -> "codemirror", "Hash" -> 
     "82bafdaa-44a7-4469-9f05-97c120e2a1c4", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "PublicFields" -> {"Properties"}, 
    "State" -> "Idle", "Type" -> "Input", "UID" -> Null, 
    "Notebook" -> "f8a44bd9-03ea-4642-979c-20bee7c21c41"|>, 
   <|"Data" -> "(*VB[*)(FrontEndRef[\"ee52e033-8e00-49d5-9427-91a42d3e707e\"]\
)(*,*)(*\"1:eJxTTMoPSmNkYGAoZgESHvk5KRCeEJBwK8rPK3HNS3GtSE0uLUlMykkNVgEKp6aaG\
qUaGBvrWqQaGOiaWKaY6lqaGJnrWhommhilGKeaG5inAgB7rhUY\"*)(*]VB*)", 
    "Display" -> "codemirror", "Hash" -> 
     "031bcbbb-3120-4eb6-94d4-85e2a86b855b", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "PublicFields" -> {"Properties"}, 
    "State" -> "Idle", "Type" -> "Output", "UID" -> Null, 
    "Notebook" -> "f8a44bd9-03ea-4642-979c-20bee7c21c41"|>, 
   <|"Data" -> ".md\n## Integration with Graphics\nUsing basic `Inset` we can \
place it under any graphics", "Display" -> "codemirror", 
    "Hash" -> "19e08bc4-9ed3-4573-bb4f-6d26d1787bc7", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <|"Hidden" -> True|>, 
    "PublicFields" -> {"Properties"}, "State" -> "Idle", "Type" -> "Input", 
    "UID" -> Null, "Notebook" -> "f8a44bd9-03ea-4642-979c-20bee7c21c41"|>, 
   <|"Data" -> "## Integration with Graphics\nUsing basic `Inset` we can \
place it under any graphics", "Display" -> "markdown", 
    "Hash" -> "d0156ea6-c051-4e83-acd3-298f60b028c4", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "PublicFields" -> {"Properties"}, 
    "State" -> "Idle", "Type" -> "Output", "UID" -> Null, 
    "Notebook" -> "f8a44bd9-03ea-4642-979c-20bee7c21c41"|>, 
   <|"Data" -> "range = {{-1,1}, {-1,1}}/2.0;\ndataset = Exp[-Norm[#]]# &/@ \
RandomReal[{-Pi,Pi}, {50,2}];\n\n\nGraphics[{\n  ColorData[97][4], \
PointSize[0.03], \n  Inset[\n    HeatMap[dataset, 4000, PlotRange->range, \
ImageSize->{420,320}],\n    (range[[All,1]]+range[[All,2]])/2.0\n  ],\n  \
Black, Point[dataset]\n}, \n  PlotRange->range, ImageSizeRaw->({420,320} \
Graphics`DPR[]), ImagePadding->30,\n  Frame->True, Axes->True\n]", 
    "Display" -> "codemirror", "Hash" -> 
     "2fd1b3c2-caab-488b-937b-8369a4a650c6", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "PublicFields" -> {"Properties"}, 
    "State" -> "Idle", "Type" -> "Input", "UID" -> Null, 
    "Notebook" -> "f8a44bd9-03ea-4642-979c-20bee7c21c41"|>, 
   <|"Data" -> "(*VB[*)(FrontEndRef[\"cb4192e4-0c84-4904-9642-d1ff509ba599\"]\
)(*,*)(*\"1:eJxTTMoPSmNkYGAoZgESHvk5KRCeEJBwK8rPK3HNS3GtSE0uLUlMykkNVgEKJyeZG\
FoapZroGiRbmOiaWBqY6FqamRjpphimpZkaWCYlmlpaAgB6qhUf\"*)(*]VB*)", 
    "Display" -> "codemirror", "Hash" -> 
     "3d5569b8-a2d6-46ae-8bcc-38c1fad21f78", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "PublicFields" -> {"Properties"}, 
    "State" -> "Idle", "Type" -> "Output", "UID" -> Null, 
    "Notebook" -> "f8a44bd9-03ea-4642-979c-20bee7c21c41"|>, 
   <|"Data" -> ".md\n## Make it dynamic\nWe should take a full advantage of \
the WebGL and perform smooth animation of the data points. For this we define \
helper function to guide our points though the calculated path ", 
    "Display" -> "codemirror", "Hash" -> 
     "26ea8513-72dd-42da-9ba9-cb313083f1a5", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <|"Hidden" -> True|>, 
    "PublicFields" -> {"Properties"}, "State" -> "Idle", "Type" -> "Input", 
    "UID" -> Null, "Notebook" -> "f8a44bd9-03ea-4642-979c-20bee7c21c41"|>, 
   <|"Data" -> "## Make it dynamic\nWe should take a full advantage of the \
WebGL and perform smooth animation of the data points. For this we define \
helper function to guide our points though the calculated path ", 
    "Display" -> "markdown", "Hash" -> 
     "3da221c1-9e03-41bd-b933-40e85c963bf8", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "PublicFields" -> {"Properties"}, 
    "State" -> "Idle", "Type" -> "Output", "UID" -> Null, 
    "Notebook" -> "f8a44bd9-03ea-4642-979c-20bee7c21c41"|>, 
   <|"Data" -> "fixedPoint[args__, maxN_:Infinity] := \
NestWhile[Function[input,\n  With[{\n    pos = input[[1]], \n    target = \
input[[2]], \n    velocity = input[[3]], \n    iteration = input[[4]]\n  }, \
{\n    pos + 0.01 velocity,\n    target,\n    velocity 0.9 + 0.1 (Normalize \
/@ ( target - pos)),\n    iteration + 1\n  }]\n], {args}, \
(Max[Abs[#[[1]]-#[[2]]]]>0.1 && #[[4]] <= maxN)&][[{1,4}]]", 
    "Display" -> "codemirror", "Hash" -> 
     "2392da34-6003-4943-872b-6eef6c41c8f6", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "PublicFields" -> {"Properties"}, 
    "State" -> "Idle", "Type" -> "Input", "UID" -> Null, 
    "Notebook" -> "f8a44bd9-03ea-4642-979c-20bee7c21c41"|>, 
   <|"Data" -> ".md\nNow we generate the data, find the number of interations \
steps until all points converge the target positions and assign a slider to \
control the process", "Display" -> "codemirror", 
    "Hash" -> "801a0206-fa9d-439b-b229-e544e8b294cd", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <|"Hidden" -> True|>, 
    "PublicFields" -> {"Properties"}, "State" -> "Idle", "Type" -> "Input", 
    "UID" -> Null, "Notebook" -> "f8a44bd9-03ea-4642-979c-20bee7c21c41"|>, 
   <|"Data" -> "Now we generate the data, find the number of interations \
steps until all points converge the target positions and assign a slider to \
control the process", "Display" -> "markdown", 
    "Hash" -> "1f2b9399-135c-499d-bb46-b26ea57820de", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "PublicFields" -> {"Properties"}, 
    "State" -> "Idle", "Type" -> "Output", "UID" -> Null, 
    "Notebook" -> "f8a44bd9-03ea-4642-979c-20bee7c21c41"|>, 
   <|"Data" -> "(* input data *)\nrange = {{-1,1}, {-1,1}};\npoints = \
RandomPoint[RegionDifference[Disk[{0,0}, 0.6], Disk[{0,0}, 0.5]], 100];\n\n(* \
place points outside the viewport *)\noffscreenPos = With[{corners = range // \
Transpose}, \n  RandomPoint[\n    RegionDifference[\n      Rectangle @@ (2 \
corners),\n      Rectangle @@ corners\n    ], Length[points]\n  ]\n];\n\n(* \
procedurally animate each particle *)\nWith[{\n  vel = 0.1 RandomReal[{-1,1}, \
{Length[points], 2}],\n  target = points\n},\n  points = offscreenPos;\n  \n  \
With[{\n    maxIterations = fixedPoint[offscreenPos, target, vel, 0, \
Infinity][[2]]\n  },\n    EventHandler[InputRange[0, maxIterations, 1, 0], \
Function[i,\n      points = fixedPoint[offscreenPos, target, vel, 0, \
i][[1]]\n    ]]\n  ]\n]\n\n(* render *)\nGraphics[{\n  ColorData[97][4], \
PointSize[0.03], \n  Inset[\n    HeatMap[points // Offload, 4000, \
PlotRange->range, ImageSize->{420,320}],\n    \
(range[[All,1]]+range[[All,2]])/2.0\n  ],\n  Black, Point[points // \
Offload]\n}, \n  PlotRange->range, ImageSizeRaw->({420,320} Graphics`DPR[]), \
ImagePadding->30,\n  Frame->True, Axes->True, TransitionType->None, \
\"Control\"->False\n]", "Display" -> "codemirror", 
    "Hash" -> "b4040c15-88dc-4759-9230-cdaa3922dcb8", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <|"Fade" -> True|>, 
    "PublicFields" -> {"Properties"}, "State" -> "Idle", "Type" -> "Input", 
    "UID" -> Null, "Notebook" -> "f8a44bd9-03ea-4642-979c-20bee7c21c41"|>, 
   <|"Data" -> "(*VB[*)(EventObject[<|\"Id\" -> \
\"89e759c0-69d5-42d9-b9a2-ff5858d553eb\", \"Initial\" -> 0, \"View\" -> \
\"be35c15b-4091-4c24-b269-8dbfceccd6af\"|>])(*,*)(*\"1:eJxTTMoPSmNkYGAoZgESHv\
k5KRCeEJBwK8rPK3HNS3GtSE0uLUlMykkNVgEKJ6UamyYbmibpmhhYGuqaJBuZ6CYZmVnqWqQkpSW\
nJienmCWmAQCGExZe\"*)(*]VB*)", "Display" -> "codemirror", 
    "Hash" -> "81a10ead-7a37-49b5-ae32-fd96f74ec3c0", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "PublicFields" -> {"Properties"}, 
    "State" -> "Idle", "Type" -> "Output", "UID" -> Null, 
    "Notebook" -> "f8a44bd9-03ea-4642-979c-20bee7c21c41"|>, 
   <|"Data" -> "(*VB[*)(Graphics[{RGBColor[0.922526, 0.385626, 0.209179], \
PointSize[0.03], Inset[HeatMap[Offload[points], 4000, PlotRange -> {{-1, 1}, \
{-1, 1}}, ImageSize -> {420, 320}], {0., 0.}], GrayLevel[0], \
Point[Offload[points]]}, PlotRange -> {{-1, 1}, {-1, 1}}, ImageSizeRaw -> \
{420, 320}, ImagePadding -> 30, Frame -> True, Axes -> True, TransitionType \
-> None, \"Control\" -> \
False])(*,*)(*\"1:eJxTTMoPSmNkYGAoZgESHvk5KWkcIB6IcC9KLMjITC5OY4XJ+2QWl6Qxw+S\
D3J2c83Pyi4qubP1mF9r61r7ojv78NRLrbtgXabgzLko4dsoeYjQnkAjIz8wrCc6sSi3aIdf6OnDH\
PPs0JpAcyGzPvOLUkjSQBcXsIFekJpb4JhZA9IIE/NPScvITU4rZgOwCkDnFmQv4GRggBoC0BZXmp\
EJsyckvCUrMS09FyIHdjMLL/A8EmSDTCYvDTfbMTUxPBbkfTc8SoPpMB0Z0s4oYoADOQAQFMFwrfV\
LLUnMyEeKssCDC52u6eZgH2cNBieWE/YyqLSAxJSUzLz1TDtNokEfdihJzU8FCIUWlqWgKQAzHitR\
iXPJ8YOHEvOLMksz8vJDKAogWv/w8NJXBoEB0zs8rKcrPgVibmFOcCgB+QbLF\"*)(*]VB*)", 
    "Display" -> "codemirror", "Hash" -> 
     "2f8be402-9235-4a17-b344-659546a6ebb0", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "PublicFields" -> {"Properties"}, 
    "State" -> "Idle", "Type" -> "Output", "UID" -> Null, 
    "Notebook" -> "f8a44bd9-03ea-4642-979c-20bee7c21c41"|>, 
   <|"Data" -> ".md\n*Try to drag. Its alive!*", "Display" -> "codemirror", 
    "Hash" -> "dcc11515-8ea3-40a6-9e75-20dbfcb4dcb2", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <|"Hidden" -> True|>, 
    "PublicFields" -> {"Properties"}, "State" -> "Idle", "Type" -> "Input", 
    "UID" -> Null, "Notebook" -> "f8a44bd9-03ea-4642-979c-20bee7c21c41"|>, 
   <|"Data" -> "*Try to drag. Its alive!*", "Display" -> "markdown", 
    "Hash" -> "3e0bfb90-9ec8-4f12-803f-b94ed710043a", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "PublicFields" -> {"Properties"}, 
    "State" -> "Idle", "Type" -> "Output", "UID" -> Null, 
    "Notebook" -> "f8a44bd9-03ea-4642-979c-20bee7c21c41"|>}, 
 "serializer" -> "jsfn4"|>
