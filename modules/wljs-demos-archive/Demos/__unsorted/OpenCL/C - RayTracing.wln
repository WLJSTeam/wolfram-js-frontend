<|"Notebook" -> <|"Controller" -> "e9d646f8-7d1b-494c-b7ee-c7337ce2980c", 
   "FocusedCell" -> CoffeeLiqueur`Notebook`Cells`CellObj[
     CoffeeLiqueur`Notebook`Cells`CellObj`$1483], 
   "MessangerChannel" -> Messanger, "ModalsChannel" -> 
    "d2855dd1-82ba-43ad-8198-0b113656d946", "Objects" -> <||>, 
   "Path" -> 
    "/users/kirill/Github/wljs-demos-archive/Demos/OpenCL/C - RayTracing.wln"\
, "PublicFields" -> {"Properties"}, "Symbols" -> <||>, 
   "TOC" -> {CoffeeLiqueur`Extensions`TOC`Private`heading[1, 
      "RayTracing Demo 1", CoffeeLiqueur`Notebook`Cells`CellObj[
       CoffeeLiqueur`Notebook`Cells`CellObj`$1460]], 
     CoffeeLiqueur`Extensions`TOC`Private`heading[2, 
      "Compute shader program", CoffeeLiqueur`Notebook`Cells`CellObj[
       CoffeeLiqueur`Notebook`Cells`CellObj`$1468]], 
     CoffeeLiqueur`Extensions`TOC`Private`heading[2, "Supporting code", 
      CoffeeLiqueur`Notebook`Cells`CellObj[
       CoffeeLiqueur`Notebook`Cells`CellObj`$1474]], 
     CoffeeLiqueur`Extensions`TOC`Private`heading[2, "Animation cycle", 
      CoffeeLiqueur`Notebook`Cells`CellObj[
       CoffeeLiqueur`Notebook`Cells`CellObj`$1482]]}|>, 
 "Cells" -> {<|"Data" -> ".md\n# RayTracing Demo 1\nA short demonstration of \
a simple raytracing program runnning on GPU and controlled by Wolfram Kernel. \
This compute shader is fully based on Sam Lapere work [OpenCL path tracing \
tutorial](https://raytracey.blogspot.com/2016/11/opencl-path-tracing-tutorial\
-2-path.html)", "Display" -> "codemirror", 
    "Hash" -> "7df12303-7ad6-48a8-87a5-80a13f7a54f3", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <|"Hidden" -> True|>, 
    "PublicFields" -> {"Properties"}, "State" -> "Idle", "Type" -> "Input", 
    "UID" -> Null, "Notebook" -> "89f9259e-5a6f-406f-8e50-1ceef8058533"|>, 
   <|"Data" -> "# RayTracing Demo 1\nA short demonstration of a simple \
raytracing program runnning on GPU and controlled by Wolfram Kernel. This \
compute shader is fully based on Sam Lapere work [OpenCL path tracing \
tutorial](https://raytracey.blogspot.com/2016/11/opencl-path-tracing-tutorial\
-2-path.html)", "Display" -> "markdown", 
    "Hash" -> "f0df95a0-537d-4aca-8edf-d926af7cab48", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "PublicFields" -> {"Properties"}, 
    "State" -> "Idle", "Type" -> "Output", "UID" -> Null, 
    "Notebook" -> "89f9259e-5a6f-406f-8e50-1ceef8058533"|>, 
   <|"Data" -> ".md\nImport libraries", "Display" -> "codemirror", 
    "Hash" -> "47ff59f7-f38a-4420-8790-1be417365f06", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <|"Hidden" -> True|>, 
    "PublicFields" -> {"Properties"}, "State" -> "Idle", "Type" -> "Input", 
    "UID" -> Null, "Notebook" -> "89f9259e-5a6f-406f-8e50-1ceef8058533"|>, 
   <|"Data" -> "Import libraries", "Display" -> "markdown", 
    "Hash" -> "c2a3d844-a67f-4e00-9629-1fbd1f5008b1", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "PublicFields" -> {"Properties"}, 
    "State" -> "Idle", "Type" -> "Output", "UID" -> Null, 
    "Notebook" -> "89f9259e-5a6f-406f-8e50-1ceef8058533"|>, 
   <|"Data" -> "Needs[\"OpenCLLink`\"]", "Display" -> "codemirror", 
    "Hash" -> "261d50f7-6cc3-44b9-a90c-f7f7228adf4b", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <|"InitGroup" -> True|>, 
    "PublicFields" -> {"Properties"}, "State" -> "Idle", "Type" -> "Input", 
    "UID" -> Null, "Notebook" -> "89f9259e-5a6f-406f-8e50-1ceef8058533"|>, 
   <|"Data" -> 
     ".md\nIf something went wrong, please check if `OpenCL` is supported", 
    "Display" -> "codemirror", "Hash" -> 
     "12e950e9-4593-4388-bfbf-d1cc4086452a", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <|"Hidden" -> True|>, 
    "PublicFields" -> {"Properties"}, "State" -> "Idle", "Type" -> "Input", 
    "UID" -> Null, "Notebook" -> "89f9259e-5a6f-406f-8e50-1ceef8058533"|>, 
   <|"Data" -> 
     "If something went wrong, please check if `OpenCL` is supported", 
    "Display" -> "markdown", "Hash" -> 
     "245142b9-a18d-43ea-bcdc-d8aa64c562c5", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "PublicFields" -> {"Properties"}, 
    "State" -> "Idle", "Type" -> "Output", "UID" -> Null, 
    "Notebook" -> "89f9259e-5a6f-406f-8e50-1ceef8058533"|>, 
   <|"Data" -> "OpenCLQ[]", "Display" -> "codemirror", 
    "Hash" -> "5c99afb0-e770-4dd2-9fc3-09363b01d0e3", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "PublicFields" -> {"Properties"}, 
    "State" -> "Idle", "Type" -> "Input", "UID" -> Null, 
    "Notebook" -> "89f9259e-5a6f-406f-8e50-1ceef8058533"|>, 
   <|"Data" -> "True", "Display" -> "codemirror", 
    "Hash" -> "06c605fe-e13e-4d54-b6f7-92cf7461b73a", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "PublicFields" -> {"Properties"}, 
    "State" -> "Idle", "Type" -> "Output", "UID" -> Null, 
    "Notebook" -> "89f9259e-5a6f-406f-8e50-1ceef8058533"|>, 
   <|"Data" -> ".md\n## Compute shader program\nSee \
[more](https://raytracey.blogspot.com/2016/11/opencl-path-tracing-tutorial-2-\
path.html) in Sam's blog. Here we just only use it with some modifications", 
    "Display" -> "codemirror", "Hash" -> 
     "0e86bc64-96bc-474f-b29a-c1839e8fb9ef", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <|"Hidden" -> True|>, 
    "PublicFields" -> {"Properties"}, "State" -> "Idle", "Type" -> "Input", 
    "UID" -> Null, "Notebook" -> "89f9259e-5a6f-406f-8e50-1ceef8058533"|>, 
   <|"Data" -> "## Compute shader program\nSee \
[more](https://raytracey.blogspot.com/2016/11/opencl-path-tracing-tutorial-2-\
path.html) in Sam's blog. Here we just only use it with some modifications", 
    "Display" -> "markdown", "Hash" -> 
     "c8e5795f-f050-4e96-9bbb-c717f9accecc", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "PublicFields" -> {"Properties"}, 
    "State" -> "Idle", "Type" -> "Output", "UID" -> Null, 
    "Notebook" -> "89f9259e-5a6f-406f-8e50-1ceef8058533"|>, 
   <|"Data" -> "ray.cl\n__constant float EPSILON = 0.00003f;\n__constant \
float PI = 3.14159265359f;\n__constant int SAMPLES = 8;\n__constant float \
INV_SAMPLES = 1.0f / SAMPLES;\n\ntypedef struct Ray {\n    float3 origin;\n   \
 float3 dir;\n} Ray;\n\ntypedef struct Sphere {\n    float radius;\n    \
float3 pos;\n    float3 color;\n    float3 emission;\n} Sphere;\n\nstatic \
inline float get_random(unsigned int *seed0, unsigned int *seed1) {\n    \
*seed0 = 36969 * ((*seed0) & 65535) + ((*seed0) >> 16);\n    *seed1 = 18000 * \
((*seed1) & 65535) + ((*seed1) >> 16);\n\n    unsigned int ires = ((*seed0) \
<< 16) + (*seed1);\n    union {\n        float f;\n        unsigned int ui;\n \
   } res;\n\n    res.ui = (ires & 0x007fffff) | 0x40000000;\n    return \
(res.f - 2.0f) / 2.0f;\n}\n\nRay createCamRay(const int x_coord, const int \
y_coord, const int width, const int height, float zoom) {\n    float \
aspect_ratio = (float)width / (float)height;\n    float fx = ((float)x_coord \
/ width - 0.5f) * aspect_ratio * zoom;\n    float fy = ((float)y_coord / \
height - 0.5f) * zoom;\n\n    float3 pixel_pos = (float3)(fx, -fy, 0.0f);\n   \
 Ray ray;\n    ray.origin = (float3)(0.0f, 0.1f, 2.0f);\n    ray.dir = \
normalize(pixel_pos - ray.origin);\n\n    return ray;\n}\n\ninline float \
intersect_sphere(const Sphere* sphere, const Ray* ray) {\n    float3 \
rayToCenter = sphere->pos - ray->origin;\n    float b = dot(rayToCenter, \
ray->dir);\n    float c = dot(rayToCenter, rayToCenter) - sphere->radius * \
sphere->radius;\n    float disc = b * b - c;\n\n    if (disc < 0.0f) return \
0.0f;\n    disc = sqrt(disc);\n\n    if ((b - disc) > EPSILON) return b - \
disc;\n    if ((b + disc) > EPSILON) return b + disc;\n\n    return \
0.0f;\n}\n\nbool intersect_scene(const Sphere* spheres, const Ray* ray, \
float* t, int* sphere_id, const int sphere_count) {\n    float inf = 1e20f;\n \
   *t = inf;\n\n    for (int i = 0; i < sphere_count; i++) {\n        float \
hitdistance = intersect_sphere(&spheres[i], ray);\n        if (hitdistance != \
0.0f && hitdistance < *t) {\n            *t = hitdistance;\n            \
*sphere_id = i;\n        }\n    }\n    return *t < inf;\n}\n\nfloat3 \
trace(const Sphere* spheres, const Ray* camray, const int sphere_count, \
unsigned int* seed0, unsigned int* seed1, float zoom) {\n    Ray ray = \
*camray;\n    float3 accum_color = (float3)(0.0f, 0.0f, 0.0f);\n    float3 \
mask = (float3)(1.0f, 1.0f, 1.0f);\n\n    for (int bounces = 0; bounces < 3; \
bounces++) {\n        float t;\n        int hitsphere_id = 0;\n\n        if \
(!intersect_scene(spheres, &ray, &t, &hitsphere_id, sphere_count))\n          \
  return accum_color += mask * (float3)(0.15f, 0.15f, 0.25f);\n\n        \
const Sphere* hitsphere = &spheres[hitsphere_id];\n\n        float3 hitpoint \
= ray.origin + ray.dir * t;\n        float3 normal = normalize(hitpoint - \
hitsphere->pos);\n        float3 normal_facing = dot(normal, ray.dir) < 0.0f \
? normal : -normal;\n\n        float rand1 = 2.0f * PI * get_random(seed0, \
seed1);\n        float rand2 = get_random(seed0, seed1);\n        float \
rand2s = sqrt(rand2);\n\n        float3 w = normal_facing;\n        float3 u \
= normalize(cross((fabs(w.x) > 0.1f ? (float3)(0.0f, 1.0f, 0.0f) : \
(float3)(1.0f, 0.0f, 0.0f)), w));\n        float3 v = cross(w, u);\n\n        \
float3 newdir = normalize(u * cos(rand1) * rand2s + v * sin(rand1) * rand2s + \
w * sqrt(1.0f - rand2));\n\n        ray.origin = hitpoint + normal_facing * \
EPSILON;\n        ray.dir = newdir;\n\n        accum_color += mask * \
hitsphere->emission;\n        mask *= hitsphere->color;\n        mask *= \
dot(newdir, normal_facing);\n    }\n\n    return accum_color;\n}\n\n__kernel \
void render_kernel(__global uchar4* output, const int width, const int \
height, float zoom, float r, float ox, float oy) {\n    unsigned int \
work_item_id = get_global_id(0);\n    unsigned int x_coord = work_item_id % \
width;\n    unsigned int y_coord = work_item_id / width;\n\n    unsigned int \
seed0 = x_coord;\n    unsigned int seed1 = y_coord;\n\n    Sphere \
cpu_spheres[10];\n    int sphere_count = 10;\n\n\t// left \
wall\n\tcpu_spheres[0].radius\t= 200.0f;\n\tcpu_spheres[0].pos = \
(float3)(-200.6f, 0.0f, 0.0f);\n\tcpu_spheres[0].color    = (float3)(0.75f, \
0.25f, 0.25f);\n\tcpu_spheres[0].emission = (float3)(0.0f, 0.0f, \
0.0f);\n\n\t// right wall\n\tcpu_spheres[1].radius\t= \
200.0f;\n\tcpu_spheres[1].pos = (float3)(200.6f, 0.0f, \
0.0f);\n\tcpu_spheres[1].color    = (float3)(0.25f, 0.25f, \
0.75f);\n\tcpu_spheres[1].emission = (float3)(0.0f, 0.0f, 0.0f);\n\n\t// \
floor\n\tcpu_spheres[2].radius\t= 200.0f;\n\tcpu_spheres[2].pos = \
(float3)(0.0f, -200.4f, 0.0f);\n\tcpu_spheres[2].color\t= (float3)(0.9f, \
0.8f, 0.7f);\n\tcpu_spheres[2].emission = (float3)(0.0f, 0.0f, 0.0f);\n\n\t// \
ceiling\n\tcpu_spheres[3].radius\t= 200.0f;\n\tcpu_spheres[3].pos = \
(float3)(0.0f, 200.4f, 0.0f);\n\tcpu_spheres[3].color\t= (float3)(0.9f, 0.8f, \
0.7f);\n\tcpu_spheres[3].emission = (float3)(0.0f, 0.0f, 0.0f);\n\n\t// back \
wall\n\tcpu_spheres[4].radius   = 200.0f;\n\tcpu_spheres[4].pos = \
(float3)(0.0f, 0.0f, -200.4f);\n\tcpu_spheres[4].color    = (float3)(0.9f, \
0.8f, 0.7f);\n\tcpu_spheres[4].emission = (float3)(0.0f, 0.0f, 0.0f);\n\n\t// \
front wall \n\tcpu_spheres[5].radius   = 200.0f;\n\tcpu_spheres[5].pos = \
(float3)(0.0f, 0.0f, 202.0f);\n\tcpu_spheres[5].color    = (float3)(0.9f, \
0.8f, 0.7f);\n\tcpu_spheres[5].emission = (float3)(0.0f, 0.0f, 0.0f);\n\n\t// \
left sphere\n\tcpu_spheres[6].radius   = 0.16f;\n\tcpu_spheres[6].pos = \
(float3)(-0.25f, -0.24f, -0.1f);\n\tcpu_spheres[6].color    = (float3)(0.9f, \
0.8f, 0.7f);\n\tcpu_spheres[6].emission = (float3)(0.0f, 0.0f, 0.0f);\n\n\t// \
right sphere\n\tcpu_spheres[7].radius   = 0.16f;\n\tcpu_spheres[7].pos = \
(float3)(0.25f, -0.24f, 0.1f);\n\tcpu_spheres[7].color    = (float3)(0.9f, \
0.8f, 0.7f);\n\tcpu_spheres[7].emission = (float3)(0.0f, 0.0f, 0.0f);\n\n\t// \
lightsource\n\tcpu_spheres[8].radius   = 1.0f;\n\tcpu_spheres[8].pos = \
(float3)(0.0f, 1.36f, 0.0f);\n\tcpu_spheres[8].color    = (float3)(0.0f, \
0.0f, 0.0f);\n\tcpu_spheres[8].emission = (float3)(6.0f, 5.0f, 3.0f);\n\n \
cpu_spheres[9].radius   = r;\n\tcpu_spheres[9].pos = (float3)(ox, oy, \
0.1f);\n\tcpu_spheres[9].color    = (float3)(0.9f, 0.8f, \
0.7f);\n\tcpu_spheres[9].emission = (float3)(1.0f, 2.0f, 2.0f);\n\n    \n\n\n \
   // Define all spheres similarly as before ...\n\n    Ray camray = \
createCamRay(x_coord, y_coord, width, height, zoom);\n\n    float3 finalcolor \
= (float3)(0.0f, 0.0f, 0.0f);\n    \n    for (int i = 0; i < SAMPLES; i++)\n  \
      finalcolor += trace(cpu_spheres, &camray, 10, &seed0, &seed1, zoom) * \
INV_SAMPLES;\n\n    uchar4 rgba;\n\n    rgba.x=(uchar)(finalcolor.x*255.0);\n \
   rgba.y=(uchar)(finalcolor.y*255.0);\n    \
rgba.z=(uchar)(finalcolor.z*255.0);\n    rgba.w=255;\n\n    \
output[work_item_id] = rgba;\n}", "Display" -> "codemirror", 
    "Hash" -> "4a137d05-3573-4b91-957f-1963660f34ae", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <|"Fade" -> True, "InitGroup" -> True|>, 
    "PublicFields" -> {"Properties"}, "State" -> "Idle", "Type" -> "Input", 
    "UID" -> Null, "Notebook" -> "89f9259e-5a6f-406f-8e50-1ceef8058533"|>, 
   <|"Data" -> ".md\nTune the number of bounces or samples, if you experience \
performance issues", "Display" -> "codemirror", 
    "Hash" -> "cb963ed3-db41-4ac3-a0fa-f8f6b1189a2f", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <|"Hidden" -> True|>, 
    "PublicFields" -> {"Properties"}, "State" -> "Idle", "Type" -> "Input", 
    "UID" -> Null, "Notebook" -> "89f9259e-5a6f-406f-8e50-1ceef8058533"|>, 
   <|"Data" -> "Tune the number of bounces or samples, if you experience \
performance issues", "Display" -> "markdown", 
    "Hash" -> "0b53502c-1fac-415d-be55-1b8e4d5ecf1a", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "PublicFields" -> {"Properties"}, 
    "State" -> "Idle", "Type" -> "Output", "UID" -> Null, 
    "Notebook" -> "89f9259e-5a6f-406f-8e50-1ceef8058533"|>, 
   <|"Data" -> ".md\n## Supporting code\nCompile our program", 
    "Display" -> "codemirror", "Hash" -> 
     "d7e552fd-571b-45ea-a460-36eb7d263af8", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <|"Hidden" -> True|>, 
    "PublicFields" -> {"Properties"}, "State" -> "Idle", "Type" -> "Input", 
    "UID" -> Null, "Notebook" -> "89f9259e-5a6f-406f-8e50-1ceef8058533"|>, 
   <|"Data" -> "## Supporting code\nCompile our program", 
    "Display" -> "markdown", "Hash" -> 
     "051c436b-4105-4cc1-828b-85376468c92c", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "PublicFields" -> {"Properties"}, 
    "State" -> "Idle", "Type" -> "Output", "UID" -> Null, 
    "Notebook" -> "89f9259e-5a6f-406f-8e50-1ceef8058533"|>, 
   <|"Data" -> "render = OpenCLFunctionLoad[File[\"ray.cl\"], \n  \
\"render_kernel\", {{\"UnsignedByte[4]\", _, \"Output\"}, _Integer, _Integer, \
\"Float\", \"Float\", \"Float\", \"Float\"}, 256, \
\"ShellOutputFunction\"->Print]", "Display" -> "codemirror", 
    "Hash" -> "6961f5df-d2cd-4bc3-80fb-7ff00d8e13ba", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <|"InitGroup" -> True|>, 
    "PublicFields" -> {"Properties"}, "State" -> "Idle", "Type" -> "Input", 
    "UID" -> Null, "Notebook" -> "89f9259e-5a6f-406f-8e50-1ceef8058533"|>, 
   <|"Data" -> "OpenCLLink`Private`cGetProgramBuildLog[238834719,\"ray.cl\",\
\"-DUSING_OPENCL_FUNCTION=1 -DOPENCLLINK_USING_GENERIC -Dmint=int \
-DReal_t=double -DUSING_DOUBLE_PRECISIONQ=1\"]", "Display" -> "print", 
    "Hash" -> "5a453d1b-4e07-4913-99bb-f9e2b1f6c33e", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "PublicFields" -> {"Properties"}, 
    "State" -> "Idle", "Type" -> "Output", "UID" -> Null, 
    "Notebook" -> "89f9259e-5a6f-406f-8e50-1ceef8058533"|>, 
   <|"Data" -> "OpenCLFunction[\"<>\",\"render_kernel\",{{\"UnsignedByte[4]\"\
,_,\"Output\"},\"Integer64\",\"Integer64\",\"Float\",\"Float\",\"Float\",\"Fl\
oat\"}]", "Display" -> "codemirror", 
    "Hash" -> "18abef20-d548-43e2-816b-9be355a127c4", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "PublicFields" -> {"Properties"}, 
    "State" -> "Idle", "Type" -> "Output", "UID" -> Null, 
    "Notebook" -> "89f9259e-5a6f-406f-8e50-1ceef8058533"|>, 
   <|"Data" -> ".md\nAllocate memory for a image buffer", 
    "Display" -> "codemirror", "Hash" -> 
     "04f75375-7ab5-422b-930e-0ec0d8d15bd7", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <|"Hidden" -> True|>, 
    "PublicFields" -> {"Properties"}, "State" -> "Idle", "Type" -> "Input", 
    "UID" -> Null, "Notebook" -> "89f9259e-5a6f-406f-8e50-1ceef8058533"|>, 
   <|"Data" -> "Allocate memory for a image buffer", "Display" -> "markdown", 
    "Hash" -> "208ec146-89a0-4d5f-b4c6-8a47ffc8a5e4", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "PublicFields" -> {"Properties"}, 
    "State" -> "Idle", "Type" -> "Output", "UID" -> Null, 
    "Notebook" -> "89f9259e-5a6f-406f-8e50-1ceef8058533"|>, 
   <|"Data" -> "{width, height} = {512, 512};\n\nout = \
OpenCLMemoryLoad[Table[{0,0,0,0}, {i, width}, {j, height}], \
\"UnsignedByte[4]\"];", "Display" -> "codemirror", 
    "Hash" -> "de90ac3d-ac1e-4408-9419-9fd5acd1b5da", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <|"InitGroup" -> True|>, 
    "PublicFields" -> {"Properties"}, "State" -> "Idle", "Type" -> "Input", 
    "UID" -> Null, "Notebook" -> "89f9259e-5a6f-406f-8e50-1ceef8058533"|>, 
   <|"Data" -> ".md\n## Animation cycle\nIt renders in sync with browser's \
repaint cycle. We also add a new listeners for the *mouse position*, *zoom* \
and a single slider (just to try)", "Display" -> "codemirror", 
    "Hash" -> "57831d78-3154-470e-b384-0bc9c3103faf", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <|"Hidden" -> True|>, 
    "PublicFields" -> {"Properties"}, "State" -> "Idle", "Type" -> "Input", 
    "UID" -> Null, "Notebook" -> "89f9259e-5a6f-406f-8e50-1ceef8058533"|>, 
   <|"Data" -> "## Animation cycle\nIt renders in sync with browser's repaint \
cycle. We also add a new listeners for the *mouse position*, *zoom* and a \
single slider (just to try)", "Display" -> "markdown", 
    "Hash" -> "14ccd1d7-f1b9-4aaa-bab0-ba967664f5fa", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "PublicFields" -> {"Properties"}, 
    "State" -> "Idle", "Type" -> "Output", "UID" -> Null, 
    "Notebook" -> "89f9259e-5a6f-406f-8e50-1ceef8058533"|>, 
   <|"Data" -> "zoom = 2.5;\npos = {0.,0.};\nr = 0.1;\n\ntime = \
AbsoluteTime[];\nfps = 1;\n\nEventHandler[\"render\", Function[Null,\n  \
render[out, width, height, zoom, r, pos[[1]], pos[[2]], width height ];\n  \
frame = NumericArray[out // OpenCLMemoryGet, \"UnsignedInteger8\"];\n  \
With[{t = AbsoluteTime[]},\n    fps = (fps + (*FB[*)((1)(*,*)/(*,*)(t - \
time))(*]FB*))/2 // Round;\n    time = t;\n  ];\n]];\n\nEventFire[\"render\", \
True]; (* just to initialize variables *)\n\ndpr = \
1/FrontFetch[Graphics`DPR[]];\n\nGraphics[{\n  Inset[Image[frame // Offload, \
\"Byte\"], {0,0}],\n  EventHandler[Null, {\n    \"mousemove\" -> Function[xy, \
pos = xy], \n    \"zoom\" -> Function[k, zoom = k]}\n  ],\n  \
Directive[FontSize->18], Red, Text[fps // Offload, {0.25,0.25}],\n  \
AnimationFrameListener[fps//Offload, \"Event\"->\"render\"]\n}, \
PlotRange->{{-1,1}, {-1,1}}, ImageSize->(dpr{width, height}), \
ImagePadding->None]\n\nEventHandler[InputRange[0.01, 0.5, 0.01, 0.1], \
Function[val, r=val]]", "Display" -> "codemirror", 
    "Hash" -> "e5cd6a39-d335-4d0f-ae5f-309ddbd34c42", "Invisible" -> False, 
    "MetaOnly" -> False, "Props" -> <||>, "PublicFields" -> {"Properties"}, 
    "State" -> "Idle", "Type" -> "Input", "UID" -> Null, 
    "Notebook" -> "89f9259e-5a6f-406f-8e50-1ceef8058533"|>}, 
 "serializer" -> "jsfn4"|>
